感觉这部分很细节，我就总结下几个点吧。

### 大致过程总结
* 先是物理内存：
    申请内存先把物理页组织好。此时有几个页已经被占用了，需要处理对应PageInfo结构体。然后再封装物理内存的申请过程。此处就完成了。之后就进入虚拟内存操作过程。
* 然后是虚拟内存，即管理页表：
    插入和删除虚拟地址到物理地址映射，并在需要时创建页表页等组件函数。
* 然后利用这些组件要把虚拟内存初始化：
    按照inc /memlayout.h显示的布局。来设置适当的虚拟到物理映射。此时我们所规定的内核空间全都被映射占用。



### PageInfo结构体
其实在cs：app的书中讨论过空闲物理内存的组织方式，更好的办法应该是内嵌链表。
PageInfo结构体中有pp_ref记录虚拟页引用数。


### Linux如何屏蔽段。
先讲下怎么访问段：
全局描述符表GDT只有一张(一个处理器对应一个GDT)，GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址。GDT表中有段描述符。段寄存器CS SS等存段选择子，根据段选择子可以访问段描述符。段描述符中有起始地址和size。

现在再讲如何屏蔽就很简单了。每个段基址0，size4G即可。


**当前页目录的物理地址存储在CPU寄存器CR3中，也称为页目录基寄存器(PDBR)。**
