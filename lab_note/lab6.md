# lab6

## 介绍
既然你已经有了一个文件系统，那么任何操作系统都不应该没有网络堆栈。在本实验中，您将为网络接口卡编写一个驱动程序。该卡基于英特尔82540EM芯片，也称为E1000。

### 开始
获取lab6
```
git add .
git pull
git checkout -b lab6 origin/lab6
git merge lab5
```

然而，网卡驱动程序将不足以使您的操作系统连接到互联网。在新的lab6代码中，我们为您提供了一个网络栈和一个网络服务器。与之前的实验室一样，使用git获取此实验室的代码，合并到您自己的代码中，并探索新的net/目录中的内容，以及kern/中的新文件。

除了编写驱动程序，您还需要创建一个系统调用接口来访问您的驱动程序。您将实现缺失的网络服务器代码，以在网络堆栈和驱动程序之间传输数据包。您还将通过完成web服务器将所有内容捆绑在一起。使用新的web服务器，您将能够从您的文件系统提供文件。

大部分内核设备驱动程序代码都必须从头编写。这个实验提供的指导比以前的实验室少得多:没有框架文件，没有写在石头(？？)上的系统调用接口，许多设计决策都留给您。出于这个原因，我们建议你在开始任何单独的练习之前阅读整个作业。很多学生觉得这个实验比以前的实验更难，所以请合理地安排时间。

## QEMU的虚拟网络
我们将使用QEMU的用户模式网络堆栈，因为它不需要管理权限即可运行。QEMU的文档在这里有关于user-net的更多信息。我们已经更新了makefile，以启用QEMU的用户模式网络堆栈和虚拟E1000网卡。

默认情况下，QEMU提供了一个运行在IP 10.0.2.2上的虚拟路由器，并将为JOS分配IP地址10.0.2.15。为了简单起见，我们将这些默认值硬编码到net/ns.h的网络服务器中。

虽然QEMU的虚拟网络允许JOS对Internet进行任意连接，但JOS的10.0.2.15地址在QEMU内部运行的虚拟网络之外没有任何意义(也就是说，QEMU充当NAT：NAT网络地址转换)，因此我们不能直接连接到JOS内部运行的服务器，甚至从运行QEMU的主机上也不能。为了解决这个问题，我们配置QEMU，使其在主机上的某个端口上运行服务器，该端口只需连接到JOS中的某个端口，并在真实主机和虚拟网络之间来回传输数据。

您将在端口7 (echo)和端口80 (http)上运行JOS服务器。要查明QEMU转发到开发主机上的哪些端口，请运行`make which-ports`。为了方便起见，makefile还提供了`make nc-7`和`make nc-80`，它们允许您直接与在终端中这些端口上运行的服务器交互。(这些目标只连接到正在运行的QEMU实例;QEMU必须单独启动。)

### 数据包检测
makefile还配置了QEMU的网络堆栈，以记录lab目录中qemu.pcap的所有入/出数据包。

要获取捕获数据包的十六进制/ASCII转储，请使用tcpdump，如下所示:
`tcpdump -XXnr qemu.pcap`

或者，你可以使用Wireshark来图形化地检查pcap文件。Wireshark还知道如何解码和检查数百种网络协议。

### 调试E1000
我们很幸运能够使用模拟硬件。由于E1000是运行在软件上的，模拟的E1000可以以一个用户可读的格式向我们报告其内部状态和它遇到的任何问题。通常，使用裸板编写的驱动程序开发人员无法获得这样的特权。

E1000可以产生大量调试输出，因此必须启用特定的日志记录通道。你可能会发现一些有用的通道:

|  标志位 | 含义  |
|  ----  | ----  |
| tx     | 日志包传输操作 |
| txerr  | 日志传输环路错误 |
| rx | 将更改记录到RCTL |
| rxfilter | 入包日志过滤 |
| rxerr | 记录接收环路错误 |
| unknown | 记录未知寄存器的读写 |
| eeprom | 日志从EEPROM读取数据 |
| interrupt | 记录中断和对中断寄存器的更改 |

例如，要启用“tx”和“txerr”日志记录，可以使用`make E1000_DEBUG=tx,txerr ..`

您可以进一步使用软件模拟硬件进行调试。如果你遇到了问题，不明白为什么E1000没有按照预期的方式响应，你可以在hw/net/e1000.c中查看QEMU的E1000实现。

## 网络服务器

