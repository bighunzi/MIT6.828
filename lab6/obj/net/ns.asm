
obj/net/ns：     文件格式 elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain//调用lib/libmain.c中的libmain()
  80002c:	e8 45 e4 00 00       	call   80e476 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 13 a5 00 00       	call   80a55b <thread_wakeup>
}
  800048:	83 c4 10             	add    $0x10,%esp
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 59 a5 00 00       	call   80a5c6 <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	78 05                	js     800079 <start_timer+0x2c>
}
  800074:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800077:	c9                   	leave  
  800078:	c3                   	ret    
		panic("cannot create timer thread: %s", e2s(r));
  800079:	83 ec 0c             	sub    $0xc,%esp
  80007c:	50                   	push   %eax
  80007d:	e8 77 a8 00 00       	call   80a8f9 <e2s>
  800082:	50                   	push   %eax
  800083:	68 00 0c 81 00       	push   $0x810c00
  800088:	6a 7a                	push   $0x7a
  80008a:	68 35 0d 81 00       	push   $0x810d35
  80008f:	e8 42 e4 00 00       	call   80e4d6 <_panic>

00800094 <net_timer>:
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
  800099:	8b 75 08             	mov    0x8(%ebp),%esi
		uint32_t cur = sys_time_msec();
  80009c:	e8 d7 f0 00 00       	call   80f178 <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx
		lwip_core_lock();
  8000a3:	e8 8a a4 00 00       	call   80a532 <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 83 a4 00 00       	call   80a533 <lwip_core_unlock>
		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 ad a6 00 00       	call   80a76c <thread_wait>
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 7b 08             	mov    0x8(%ebx),%edi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 4f 01 00 00    	ja     80022b <serve_thread+0x167>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 e0 0d 81 00 	jmp    *0x810de0(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 47 04             	mov    0x4(%edi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 37                	push   (%edi)
  8000f8:	e8 bc 0d 00 00       	call   800eb9 <lwip_accept>
  8000fd:	89 c6                	mov    %eax,%esi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	57                   	push   %edi
  800109:	e8 13 ec 00 00       	call   80ed21 <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800111:	83 fe ff             	cmp    $0xffffffff,%esi
  800114:	0f 84 2f 01 00 00    	je     800249 <serve_thread+0x185>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
		perror(buf);
	}

	if (args->reqno != NSREQ_INPUT)
  80011a:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80011d:	0f 85 48 01 00 00    	jne    80026b <serve_thread+0x1a7>
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
  800123:	8b 53 08             	mov    0x8(%ebx),%edx
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800126:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  80012c:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80012f:	c6 80 38 50 81 00 00 	movb   $0x0,0x815038(%eax)
	sys_page_unmap(0, (void*) args->req);
  800136:	83 ec 08             	sub    $0x8,%esp
  800139:	52                   	push   %edx
  80013a:	6a 00                	push   $0x0
  80013c:	e8 cb ee 00 00       	call   80f00c <sys_page_unmap>
	free(args);
  800141:	89 1c 24             	mov    %ebx,(%esp)
  800144:	e8 52 00 01 00       	call   81019b <free>
}
  800149:	83 c4 10             	add    $0x10,%esp
  80014c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80014f:	5b                   	pop    %ebx
  800150:	5e                   	pop    %esi
  800151:	5f                   	pop    %edi
  800152:	5d                   	pop    %ebp
  800153:	c3                   	ret    
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800154:	83 ec 04             	sub    $0x4,%esp
  800157:	ff 77 14             	push   0x14(%edi)
  80015a:	8d 47 04             	lea    0x4(%edi),%eax
  80015d:	50                   	push   %eax
  80015e:	ff 37                	push   (%edi)
  800160:	e8 0e 0f 00 00       	call   801073 <lwip_bind>
  800165:	89 c6                	mov    %eax,%esi
		break;
  800167:	83 c4 10             	add    $0x10,%esp
  80016a:	eb a5                	jmp    800111 <serve_thread+0x4d>
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  80016c:	83 ec 08             	sub    $0x8,%esp
  80016f:	ff 77 04             	push   0x4(%edi)
  800172:	ff 37                	push   (%edi)
  800174:	e8 25 1a 00 00       	call   801b9e <lwip_shutdown>
  800179:	89 c6                	mov    %eax,%esi
		break;
  80017b:	83 c4 10             	add    $0x10,%esp
  80017e:	eb 91                	jmp    800111 <serve_thread+0x4d>
		r = lwip_close(req->close.req_s);
  800180:	83 ec 0c             	sub    $0xc,%esp
  800183:	ff 37                	push   (%edi)
  800185:	e8 9f 0f 00 00       	call   801129 <lwip_close>
  80018a:	89 c6                	mov    %eax,%esi
		break;
  80018c:	83 c4 10             	add    $0x10,%esp
  80018f:	eb 80                	jmp    800111 <serve_thread+0x4d>
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800191:	83 ec 04             	sub    $0x4,%esp
  800194:	ff 77 14             	push   0x14(%edi)
  800197:	8d 47 04             	lea    0x4(%edi),%eax
  80019a:	50                   	push   %eax
  80019b:	ff 37                	push   (%edi)
  80019d:	e8 10 10 00 00       	call   8011b2 <lwip_connect>
  8001a2:	89 c6                	mov    %eax,%esi
		break;
  8001a4:	83 c4 10             	add    $0x10,%esp
  8001a7:	e9 65 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001ac:	83 ec 08             	sub    $0x8,%esp
  8001af:	ff 77 04             	push   0x4(%edi)
  8001b2:	ff 37                	push   (%edi)
  8001b4:	e8 af 10 00 00       	call   801268 <lwip_listen>
  8001b9:	89 c6                	mov    %eax,%esi
		break;
  8001bb:	83 c4 10             	add    $0x10,%esp
  8001be:	e9 4e ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001c3:	ff 77 08             	push   0x8(%edi)
  8001c6:	ff 77 04             	push   0x4(%edi)
  8001c9:	57                   	push   %edi
  8001ca:	ff 37                	push   (%edi)
  8001cc:	e8 7c 13 00 00       	call   80154d <lwip_recv>
  8001d1:	89 c6                	mov    %eax,%esi
		break;
  8001d3:	83 c4 10             	add    $0x10,%esp
  8001d6:	e9 36 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001db:	ff 77 08             	push   0x8(%edi)
  8001de:	ff 77 04             	push   0x4(%edi)
  8001e1:	8d 47 0c             	lea    0xc(%edi),%eax
  8001e4:	50                   	push   %eax
  8001e5:	ff 37                	push   (%edi)
  8001e7:	e8 eb 14 00 00       	call   8016d7 <lwip_send>
  8001ec:	89 c6                	mov    %eax,%esi
		break;
  8001ee:	83 c4 10             	add    $0x10,%esp
  8001f1:	e9 1b ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8001f6:	83 ec 04             	sub    $0x4,%esp
  8001f9:	ff 77 08             	push   0x8(%edi)
  8001fc:	ff 77 04             	push   0x4(%edi)
  8001ff:	ff 37                	push   (%edi)
  800201:	e8 5f 15 00 00       	call   801765 <lwip_socket>
  800206:	89 c6                	mov    %eax,%esi
		break;
  800208:	83 c4 10             	add    $0x10,%esp
  80020b:	e9 01 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		jif_input(&nif, (void *)&req->pkt);
  800210:	83 ec 08             	sub    $0x8,%esp
  800213:	57                   	push   %edi
  800214:	68 00 50 81 00       	push   $0x815000
  800219:	e8 c2 a7 00 00       	call   80a9e0 <jif_input>
  80021e:	83 c4 10             	add    $0x10,%esp
		r = 0;
  800221:	be 00 00 00 00       	mov    $0x0,%esi
  800226:	e9 ef fe ff ff       	jmp    80011a <serve_thread+0x56>
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80022b:	83 ec 04             	sub    $0x4,%esp
  80022e:	57                   	push   %edi
  80022f:	ff 73 04             	push   0x4(%ebx)
  800232:	68 20 0c 81 00       	push   $0x810c20
  800237:	e8 75 e3 00 00       	call   80e5b1 <cprintf>
  80023c:	83 c4 10             	add    $0x10,%esp
		r = -E_INVAL;
  80023f:	be fd ff ff ff       	mov    $0xfffffffd,%esi
  800244:	e9 d1 fe ff ff       	jmp    80011a <serve_thread+0x56>
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800249:	ff 33                	push   (%ebx)
  80024b:	68 40 0d 81 00       	push   $0x810d40
  800250:	6a 64                	push   $0x64
  800252:	8d 7d 84             	lea    -0x7c(%ebp),%edi
  800255:	57                   	push   %edi
  800256:	e8 db e8 00 00       	call   80eb36 <snprintf>
		perror(buf);
  80025b:	89 3c 24             	mov    %edi,(%esp)
  80025e:	e8 72 a6 00 00       	call   80a8d5 <perror>
  800263:	83 c4 10             	add    $0x10,%esp
  800266:	e9 af fe ff ff       	jmp    80011a <serve_thread+0x56>
		ipc_send(args->whom, r, 0, 0);
  80026b:	6a 00                	push   $0x0
  80026d:	6a 00                	push   $0x0
  80026f:	56                   	push   %esi
  800270:	ff 73 04             	push   0x4(%ebx)
  800273:	e8 46 f2 00 00       	call   80f4be <ipc_send>
  800278:	83 c4 10             	add    $0x10,%esp
  80027b:	e9 a3 fe ff ff       	jmp    800123 <serve_thread+0x5f>

00800280 <serve_init>:
{
  800280:	55                   	push   %ebp
  800281:	89 e5                	mov    %esp,%ebp
  800283:	56                   	push   %esi
  800284:	53                   	push   %ebx
  800285:	83 ec 10             	sub    $0x10,%esp
  800288:	8b 75 08             	mov    0x8(%ebp),%esi
	lwip_core_lock();
  80028b:	e8 a2 a2 00 00       	call   80a532 <lwip_core_lock>
	uint32_t done = 0;
  800290:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800297:	83 ec 08             	sub    $0x8,%esp
  80029a:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80029d:	53                   	push   %ebx
  80029e:	68 33 00 80 00       	push   $0x800033
  8002a3:	e8 7b 21 00 00       	call   802423 <tcpip_init>
	lwip_core_unlock();
  8002a8:	e8 86 a2 00 00       	call   80a533 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8002ad:	83 c4 0c             	add    $0xc,%esp
  8002b0:	6a ff                	push   $0xffffffff
  8002b2:	6a 00                	push   $0x0
  8002b4:	53                   	push   %ebx
  8002b5:	e8 b2 a4 00 00       	call   80a76c <thread_wait>
	lwip_core_lock();
  8002ba:	e8 73 a2 00 00       	call   80a532 <lwip_core_lock>
	ipaddr.addr  = init_addr;
  8002bf:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002c8:	8b 45 10             	mov    0x10(%ebp),%eax
  8002cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002ce:	83 c4 0c             	add    $0xc,%esp
  8002d1:	68 ec 64 80 00       	push   $0x8064ec
  8002d6:	68 ce aa 80 00       	push   $0x80aace
  8002db:	68 4c 50 81 00       	push   $0x81504c
  8002e0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002e3:	50                   	push   %eax
  8002e4:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002e7:	50                   	push   %eax
  8002e8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002eb:	50                   	push   %eax
  8002ec:	68 00 50 81 00       	push   $0x815000
  8002f1:	e8 70 43 00 00       	call   804666 <netif_add>
  8002f6:	83 c4 20             	add    $0x20,%esp
  8002f9:	85 c0                	test   %eax,%eax
  8002fb:	0f 84 cc 00 00 00    	je     8003cd <serve_init+0x14d>
	netif_set_default(nif);
  800301:	83 ec 0c             	sub    $0xc,%esp
  800304:	68 00 50 81 00       	push   $0x815000
  800309:	e8 0a 44 00 00       	call   804718 <netif_set_default>
	netif_set_up(nif);
  80030e:	c7 04 24 00 50 81 00 	movl   $0x815000,(%esp)
  800315:	e8 0b 44 00 00       	call   804725 <netif_set_up>
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80031a:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800321:	b9 4f 0d 81 00       	mov    $0x810d4f,%ecx
  800326:	ba 6e 94 80 00       	mov    $0x80946e,%edx
  80032b:	b8 6c 50 81 00       	mov    $0x81506c,%eax
  800330:	e8 18 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800335:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80033c:	b9 59 0d 81 00       	mov    $0x810d59,%ecx
  800341:	ba b8 56 80 00       	mov    $0x8056b8,%edx
  800346:	b8 60 50 81 00       	mov    $0x815060,%eax
  80034b:	e8 fd fc ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800350:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800357:	b9 65 0d 81 00       	mov    $0x810d65,%ecx
  80035c:	ba 4b 5c 80 00       	mov    $0x805c4b,%edx
  800361:	b8 54 50 81 00       	mov    $0x815054,%eax
  800366:	e8 e2 fc ff ff       	call   80004d <start_timer>
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80036b:	89 34 24             	mov    %esi,(%esp)
  80036e:	e8 71 72 00 00       	call   8075e4 <inet_ntoa>
  800373:	50                   	push   %eax
  800374:	0f b6 05 2a 50 81 00 	movzbl 0x81502a,%eax
  80037b:	50                   	push   %eax
  80037c:	0f b6 05 29 50 81 00 	movzbl 0x815029,%eax
  800383:	50                   	push   %eax
  800384:	0f b6 05 28 50 81 00 	movzbl 0x815028,%eax
  80038b:	50                   	push   %eax
  80038c:	0f b6 05 27 50 81 00 	movzbl 0x815027,%eax
  800393:	50                   	push   %eax
  800394:	0f b6 05 26 50 81 00 	movzbl 0x815026,%eax
  80039b:	50                   	push   %eax
  80039c:	0f b6 05 25 50 81 00 	movzbl 0x815025,%eax
  8003a3:	50                   	push   %eax
  8003a4:	68 64 0c 81 00       	push   $0x810c64
  8003a9:	e8 03 e2 00 00       	call   80e5b1 <cprintf>
	lwip_core_unlock();
  8003ae:	83 c4 30             	add    $0x30,%esp
  8003b1:	e8 7d a1 00 00       	call   80a533 <lwip_core_unlock>
	cprintf("NS: TCP/IP initialized.\n");
  8003b6:	83 ec 0c             	sub    $0xc,%esp
  8003b9:	68 71 0d 81 00       	push   $0x810d71
  8003be:	e8 ee e1 00 00       	call   80e5b1 <cprintf>
}
  8003c3:	83 c4 10             	add    $0x10,%esp
  8003c6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c9:	5b                   	pop    %ebx
  8003ca:	5e                   	pop    %esi
  8003cb:	5d                   	pop    %ebp
  8003cc:	c3                   	ret    
		panic("lwip_init: error in netif_add\n");
  8003cd:	83 ec 04             	sub    $0x4,%esp
  8003d0:	68 44 0c 81 00       	push   $0x810c44
  8003d5:	6a 5c                	push   $0x5c
  8003d7:	68 35 0d 81 00       	push   $0x810d35
  8003dc:	e8 f5 e0 00 00       	call   80e4d6 <_panic>

008003e1 <serve>:

void
serve(void) {
  8003e1:	55                   	push   %ebp
  8003e2:	89 e5                	mov    %esp,%ebp
  8003e4:	57                   	push   %edi
  8003e5:	56                   	push   %esi
  8003e6:	53                   	push   %ebx
  8003e7:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003ea:	8d 7d e0             	lea    -0x20(%ebp),%edi
  8003ed:	e9 b3 00 00 00       	jmp    8004a5 <serve+0xc4>
			thread_yield();
  8003f2:	e8 f2 a2 00 00       	call   80a6e9 <thread_yield>
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003f7:	83 c3 01             	add    $0x1,%ebx
  8003fa:	e8 7d a1 00 00       	call   80a57c <thread_wakeups_pending>
  8003ff:	85 c0                	test   %eax,%eax
  800401:	74 05                	je     800408 <serve+0x27>
  800403:	83 fb 1f             	cmp    $0x1f,%ebx
  800406:	7e ea                	jle    8003f2 <serve+0x11>
		perm = 0;
  800408:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	for (i = 0; i < QUEUE_SIZE; i++)
  80040f:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  800414:	80 b8 38 50 81 00 00 	cmpb   $0x0,0x815038(%eax)
  80041b:	74 1c                	je     800439 <serve+0x58>
	for (i = 0; i < QUEUE_SIZE; i++)
  80041d:	83 c0 01             	add    $0x1,%eax
  800420:	83 f8 14             	cmp    $0x14,%eax
  800423:	75 ef                	jne    800414 <serve+0x33>
		panic("NS: buffer overflow");
  800425:	83 ec 04             	sub    $0x4,%esp
  800428:	68 8a 0d 81 00       	push   $0x810d8a
  80042d:	6a 3f                	push   $0x3f
  80042f:	68 35 0d 81 00       	push   $0x810d35
  800434:	e8 9d e0 00 00       	call   80e4d6 <_panic>
	va = (void *)(REQVA + i * PGSIZE);
  800439:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  80043f:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  800442:	c6 80 38 50 81 00 01 	movb   $0x1,0x815038(%eax)
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800449:	83 ec 04             	sub    $0x4,%esp
  80044c:	57                   	push   %edi
  80044d:	53                   	push   %ebx
  80044e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800451:	50                   	push   %eax
  800452:	e8 00 f0 00 00       	call   80f457 <ipc_recv>
  800457:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800459:	83 c4 10             	add    $0x10,%esp
  80045c:	83 f8 0c             	cmp    $0xc,%eax
  80045f:	74 4e                	je     8004af <serve+0xce>
			put_buffer(va);
			continue;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800461:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800465:	0f 84 a0 00 00 00    	je     80050b <serve+0x12a>
			continue; // just leave it hanging...
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  80046b:	83 ec 0c             	sub    $0xc,%esp
  80046e:	6a 0c                	push   $0xc
  800470:	e8 d2 fd 00 00       	call   810247 <malloc>
		if (!args)
  800475:	83 c4 10             	add    $0x10,%esp
  800478:	85 c0                	test   %eax,%eax
  80047a:	0f 84 a0 00 00 00    	je     800520 <serve+0x13f>
			panic("could not allocate thread args structure");

		args->reqno = reqno;
  800480:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  800482:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800485:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  800488:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  80048b:	50                   	push   %eax
  80048c:	68 c4 00 80 00       	push   $0x8000c4
  800491:	68 9e 0d 81 00       	push   $0x810d9e
  800496:	6a 00                	push   $0x0
  800498:	e8 29 a1 00 00       	call   80a5c6 <thread_create>
		thread_yield(); // let the thread created run
  80049d:	e8 47 a2 00 00       	call   80a6e9 <thread_yield>
  8004a2:	83 c4 10             	add    $0x10,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004a5:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004aa:	e9 4b ff ff ff       	jmp    8003fa <serve+0x19>
			process_timer(whom);
  8004af:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (envid != timer_envid) {
  8004b2:	3b 35 50 50 81 00    	cmp    0x815050,%esi
  8004b8:	74 23                	je     8004dd <serve+0xfc>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  8004ba:	83 ec 08             	sub    $0x8,%esp
  8004bd:	56                   	push   %esi
  8004be:	68 a0 0c 81 00       	push   $0x810ca0
  8004c3:	e8 e9 e0 00 00       	call   80e5b1 <cprintf>
		return;
  8004c8:	83 c4 10             	add    $0x10,%esp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8004cb:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  8004d1:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  8004d4:	c6 83 38 50 81 00 00 	movb   $0x0,0x815038(%ebx)
			continue;
  8004db:	eb c8                	jmp    8004a5 <serve+0xc4>
	start = sys_time_msec();
  8004dd:	e8 96 ec 00 00       	call   80f178 <sys_time_msec>
  8004e2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  8004e5:	e8 ff a1 00 00       	call   80a6e9 <thread_yield>
	now = sys_time_msec();
  8004ea:	e8 89 ec 00 00       	call   80f178 <sys_time_msec>
  8004ef:	89 c2                	mov    %eax,%edx
	ipc_send(envid, to, 0, 0);
  8004f1:	6a 00                	push   $0x0
  8004f3:	6a 00                	push   $0x0
	to = TIMER_INTERVAL - (now - start);
  8004f5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8004f8:	05 fa 00 00 00       	add    $0xfa,%eax
  8004fd:	29 d0                	sub    %edx,%eax
	ipc_send(envid, to, 0, 0);
  8004ff:	50                   	push   %eax
  800500:	56                   	push   %esi
  800501:	e8 b8 ef 00 00       	call   80f4be <ipc_send>
  800506:	83 c4 10             	add    $0x10,%esp
  800509:	eb c0                	jmp    8004cb <serve+0xea>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  80050b:	83 ec 08             	sub    $0x8,%esp
  80050e:	ff 75 e4             	push   -0x1c(%ebp)
  800511:	68 dc 0c 81 00       	push   $0x810cdc
  800516:	e8 96 e0 00 00       	call   80e5b1 <cprintf>
			continue; // just leave it hanging...
  80051b:	83 c4 10             	add    $0x10,%esp
  80051e:	eb 85                	jmp    8004a5 <serve+0xc4>
			panic("could not allocate thread args structure");
  800520:	83 ec 04             	sub    $0x4,%esp
  800523:	68 0c 0d 81 00       	push   $0x810d0c
  800528:	68 27 01 00 00       	push   $0x127
  80052d:	68 35 0d 81 00       	push   $0x810d35
  800532:	e8 9f df 00 00       	call   80e4d6 <_panic>

00800537 <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  800537:	55                   	push   %ebp
  800538:	89 e5                	mov    %esp,%ebp
  80053a:	56                   	push   %esi
  80053b:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  80053c:	83 ec 0c             	sub    $0xc,%esp
  80053f:	68 ab 0d 81 00       	push   $0x810dab
  800544:	e8 5d 73 00 00       	call   8078a6 <inet_addr>
  800549:	89 c6                	mov    %eax,%esi
  80054b:	c7 04 24 b4 0d 81 00 	movl   $0x810db4,(%esp)
  800552:	e8 4f 73 00 00       	call   8078a6 <inet_addr>
  800557:	89 c3                	mov    %eax,%ebx
  800559:	c7 04 24 c2 0d 81 00 	movl   $0x810dc2,(%esp)
  800560:	e8 41 73 00 00       	call   8078a6 <inet_addr>
  800565:	83 c4 0c             	add    $0xc,%esp
  800568:	56                   	push   %esi
  800569:	53                   	push   %ebx
  80056a:	50                   	push   %eax
  80056b:	e8 10 fd ff ff       	call   800280 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800570:	e8 6c fe ff ff       	call   8003e1 <serve>

00800575 <umain>:
}

void
umain(int argc, char **argv)
{
  800575:	55                   	push   %ebp
  800576:	89 e5                	mov    %esp,%ebp
  800578:	53                   	push   %ebx
  800579:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  80057c:	e8 c8 e9 00 00       	call   80ef49 <sys_getenvid>
  800581:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800583:	c7 05 e8 42 81 00 3b 	movl   $0x81373b,0x8142e8
  80058a:	37 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  80058d:	e8 45 ed 00 00       	call   80f2d7 <fork>
  800592:	a3 50 50 81 00       	mov    %eax,0x815050
	if (timer_envid < 0)
  800597:	85 c0                	test   %eax,%eax
  800599:	78 43                	js     8005de <umain+0x69>
		panic("error forking");
	else if (timer_envid == 0) {
  80059b:	74 58                	je     8005f5 <umain+0x80>
		return;
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  80059d:	e8 35 ed 00 00       	call   80f2d7 <fork>
	if (input_envid < 0)
  8005a2:	85 c0                	test   %eax,%eax
  8005a4:	78 65                	js     80060b <umain+0x96>
		panic("error forking");
	else if (input_envid == 0) {
  8005a6:	74 7a                	je     800622 <umain+0xad>
		return;
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005a8:	e8 2a ed 00 00       	call   80f2d7 <fork>
  8005ad:	a3 4c 50 81 00       	mov    %eax,0x81504c
	if (output_envid < 0)
  8005b2:	85 c0                	test   %eax,%eax
  8005b4:	78 7a                	js     800630 <umain+0xbb>
		panic("error forking");
	else if (output_envid == 0) {
  8005b6:	0f 84 8b 00 00 00    	je     800647 <umain+0xd2>
		return;
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  8005bc:	e8 73 9f 00 00       	call   80a534 <thread_init>
	thread_create(0, "main", tmain, 0);
  8005c1:	6a 00                	push   $0x0
  8005c3:	68 37 05 80 00       	push   $0x800537
  8005c8:	68 da 0d 81 00       	push   $0x810dda
  8005cd:	6a 00                	push   $0x0
  8005cf:	e8 f2 9f 00 00       	call   80a5c6 <thread_create>
	thread_yield();
  8005d4:	e8 10 a1 00 00       	call   80a6e9 <thread_yield>
  8005d9:	83 c4 10             	add    $0x10,%esp
  8005dc:	eb 28                	jmp    800606 <umain+0x91>
		panic("error forking");
  8005de:	83 ec 04             	sub    $0x4,%esp
  8005e1:	68 cc 0d 81 00       	push   $0x810dcc
  8005e6:	68 44 01 00 00       	push   $0x144
  8005eb:	68 35 0d 81 00       	push   $0x810d35
  8005f0:	e8 e1 de 00 00       	call   80e4d6 <_panic>
		timer(ns_envid, TIMER_INTERVAL);
  8005f5:	83 ec 08             	sub    $0x8,%esp
  8005f8:	68 fa 00 00 00       	push   $0xfa
  8005fd:	53                   	push   %ebx
  8005fe:	e8 52 00 00 00       	call   800655 <timer>
		return;
  800603:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  800606:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800609:	c9                   	leave  
  80060a:	c3                   	ret    
		panic("error forking");
  80060b:	83 ec 04             	sub    $0x4,%esp
  80060e:	68 cc 0d 81 00       	push   $0x810dcc
  800613:	68 4e 01 00 00       	push   $0x14e
  800618:	68 35 0d 81 00       	push   $0x810d35
  80061d:	e8 b4 de 00 00       	call   80e4d6 <_panic>
		input(ns_envid);
  800622:	83 ec 0c             	sub    $0xc,%esp
  800625:	53                   	push   %ebx
  800626:	e8 e0 00 00 00       	call   80070b <input>
		return;
  80062b:	83 c4 10             	add    $0x10,%esp
  80062e:	eb d6                	jmp    800606 <umain+0x91>
		panic("error forking");
  800630:	83 ec 04             	sub    $0x4,%esp
  800633:	68 cc 0d 81 00       	push   $0x810dcc
  800638:	68 58 01 00 00       	push   $0x158
  80063d:	68 35 0d 81 00       	push   $0x810d35
  800642:	e8 8f de 00 00       	call   80e4d6 <_panic>
		output(ns_envid);
  800647:	83 ec 0c             	sub    $0xc,%esp
  80064a:	53                   	push   %ebx
  80064b:	e8 2c 01 00 00       	call   80077c <output>
		return;
  800650:	83 c4 10             	add    $0x10,%esp
  800653:	eb b1                	jmp    800606 <umain+0x91>

00800655 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800655:	55                   	push   %ebp
  800656:	89 e5                	mov    %esp,%ebp
  800658:	57                   	push   %edi
  800659:	56                   	push   %esi
  80065a:	53                   	push   %ebx
  80065b:	83 ec 1c             	sub    $0x1c,%esp
  80065e:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  800661:	e8 12 eb 00 00       	call   80f178 <sys_time_msec>
  800666:	03 45 0c             	add    0xc(%ebp),%eax
  800669:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  80066b:	c7 05 e8 42 81 00 0c 	movl   $0x810e0c,0x8142e8
  800672:	0e 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800675:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  800678:	eb 33                	jmp    8006ad <timer+0x58>
		if (r < 0)
  80067a:	85 c0                	test   %eax,%eax
  80067c:	78 43                	js     8006c1 <timer+0x6c>
		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  80067e:	6a 00                	push   $0x0
  800680:	6a 00                	push   $0x0
  800682:	6a 0c                	push   $0xc
  800684:	56                   	push   %esi
  800685:	e8 34 ee 00 00       	call   80f4be <ipc_send>
  80068a:	83 c4 10             	add    $0x10,%esp
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80068d:	83 ec 04             	sub    $0x4,%esp
  800690:	6a 00                	push   $0x0
  800692:	6a 00                	push   $0x0
  800694:	57                   	push   %edi
  800695:	e8 bd ed 00 00       	call   80f457 <ipc_recv>
  80069a:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  80069c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80069f:	83 c4 10             	add    $0x10,%esp
  8006a2:	39 f0                	cmp    %esi,%eax
  8006a4:	75 2d                	jne    8006d3 <timer+0x7e>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8006a6:	e8 cd ea 00 00       	call   80f178 <sys_time_msec>
  8006ab:	01 c3                	add    %eax,%ebx
		while((r = sys_time_msec()) < stop && r >= 0) {
  8006ad:	e8 c6 ea 00 00       	call   80f178 <sys_time_msec>
  8006b2:	85 c0                	test   %eax,%eax
  8006b4:	78 c4                	js     80067a <timer+0x25>
  8006b6:	39 d8                	cmp    %ebx,%eax
  8006b8:	73 c0                	jae    80067a <timer+0x25>
			sys_yield();
  8006ba:	e8 a9 e8 00 00       	call   80ef68 <sys_yield>
  8006bf:	eb ec                	jmp    8006ad <timer+0x58>
			panic("sys_time_msec: %e", r);
  8006c1:	50                   	push   %eax
  8006c2:	68 15 0e 81 00       	push   $0x810e15
  8006c7:	6a 0f                	push   $0xf
  8006c9:	68 27 0e 81 00       	push   $0x810e27
  8006ce:	e8 03 de 00 00       	call   80e4d6 <_panic>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006d3:	83 ec 08             	sub    $0x8,%esp
  8006d6:	50                   	push   %eax
  8006d7:	68 34 0e 81 00       	push   $0x810e34
  8006dc:	e8 d0 de 00 00       	call   80e5b1 <cprintf>
				continue;
  8006e1:	83 c4 10             	add    $0x10,%esp
  8006e4:	eb a7                	jmp    80068d <timer+0x38>

008006e6 <sleep>:

extern union Nsipc nsipcbuf;

void
sleep(int msec)
{
  8006e6:	55                   	push   %ebp
  8006e7:	89 e5                	mov    %esp,%ebp
  8006e9:	56                   	push   %esi
  8006ea:	53                   	push   %ebx
  8006eb:	8b 75 08             	mov    0x8(%ebp),%esi
    unsigned now = sys_time_msec();
  8006ee:	e8 85 ea 00 00       	call   80f178 <sys_time_msec>
  8006f3:	89 c3                	mov    %eax,%ebx

    while (msec > sys_time_msec()-now){
  8006f5:	eb 05                	jmp    8006fc <sleep+0x16>
    	sys_yield();
  8006f7:	e8 6c e8 00 00       	call   80ef68 <sys_yield>
    while (msec > sys_time_msec()-now){
  8006fc:	e8 77 ea 00 00       	call   80f178 <sys_time_msec>
  800701:	29 d8                	sub    %ebx,%eax
  800703:	39 f0                	cmp    %esi,%eax
  800705:	72 f0                	jb     8006f7 <sleep+0x11>
    }    
}
  800707:	5b                   	pop    %ebx
  800708:	5e                   	pop    %esi
  800709:	5d                   	pop    %ebp
  80070a:	c3                   	ret    

0080070b <input>:

void
input(envid_t ns_envid)
{
  80070b:	55                   	push   %ebp
  80070c:	89 e5                	mov    %esp,%ebp
  80070e:	57                   	push   %edi
  80070f:	56                   	push   %esi
  800710:	53                   	push   %ebx
  800711:	81 ec 1c 08 00 00    	sub    $0x81c,%esp
  800717:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_input";
  80071a:	c7 05 e8 42 81 00 6f 	movl   $0x810e6f,0x8142e8
  800721:	0e 81 00 
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
	size_t len;
	char rev_buf[RX_PACKET_SIZE];
	while(1){
		while ( sys_e1000_recv(rev_buf, &len)  < 0) {
  800724:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  800727:	8d 9d e4 f7 ff ff    	lea    -0x81c(%ebp),%ebx
  80072d:	eb 05                	jmp    800734 <input+0x29>
			sys_yield();//没东西读，就阻塞，切换别的环境。    
  80072f:	e8 34 e8 00 00       	call   80ef68 <sys_yield>
		while ( sys_e1000_recv(rev_buf, &len)  < 0) {
  800734:	83 ec 08             	sub    $0x8,%esp
  800737:	56                   	push   %esi
  800738:	53                   	push   %ebx
  800739:	e8 7a ea 00 00       	call   80f1b8 <sys_e1000_recv>
  80073e:	83 c4 10             	add    $0x10,%esp
  800741:	85 c0                	test   %eax,%eax
  800743:	78 ea                	js     80072f <input+0x24>
		}
		memcpy(nsipcbuf.pkt.jp_data, rev_buf, len);
  800745:	83 ec 04             	sub    $0x4,%esp
  800748:	ff 75 e4             	push   -0x1c(%ebp)
  80074b:	53                   	push   %ebx
  80074c:	68 04 e0 b3 00       	push   $0xb3e004
  800751:	e8 2d e6 00 00       	call   80ed83 <memcpy>
		nsipcbuf.pkt.jp_len = len;
  800756:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800759:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
		
		ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_P|PTE_U);
  80075e:	6a 05                	push   $0x5
  800760:	68 00 e0 b3 00       	push   $0xb3e000
  800765:	6a 0a                	push   $0xa
  800767:	57                   	push   %edi
  800768:	e8 51 ed 00 00       	call   80f4be <ipc_send>
		
		sleep(30);//停留一段时间，不停留的话，测试不会通过，会丢包。
  80076d:	83 c4 14             	add    $0x14,%esp
  800770:	6a 1e                	push   $0x1e
  800772:	e8 6f ff ff ff       	call   8006e6 <sleep>
		while ( sys_e1000_recv(rev_buf, &len)  < 0) {
  800777:	83 c4 10             	add    $0x10,%esp
  80077a:	eb b8                	jmp    800734 <input+0x29>

0080077c <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  80077c:	55                   	push   %ebp
  80077d:	89 e5                	mov    %esp,%ebp
  80077f:	56                   	push   %esi
  800780:	53                   	push   %ebx
  800781:	83 ec 10             	sub    $0x10,%esp
  800784:	8b 75 08             	mov    0x8(%ebp),%esi
	binaryname = "ns_output";
  800787:	c7 05 e8 42 81 00 78 	movl   $0x810e78,0x8142e8
  80078e:	0e 81 00 
	// 	- read a packet from the network server
	//	- send the packet to the device driver
	int r, perm;
	envid_t from_env;
	while(1){
		r=ipc_recv( &from_env , &nsipcbuf, NULL);
  800791:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800794:	eb 1f                	jmp    8007b5 <output+0x39>
		if(r!=NSREQ_OUTPUT || from_env!=ns_envid){
			continue;
		} 
		while( sys_e1000_try_send( nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len ) < 0 ){
			sys_yield();//发送失败，切换进程，让出控制器。
  800796:	e8 cd e7 00 00       	call   80ef68 <sys_yield>
		while( sys_e1000_try_send( nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len ) < 0 ){
  80079b:	83 ec 08             	sub    $0x8,%esp
  80079e:	ff 35 00 e0 b3 00    	push   0xb3e000
  8007a4:	68 04 e0 b3 00       	push   $0xb3e004
  8007a9:	e8 e9 e9 00 00       	call   80f197 <sys_e1000_try_send>
  8007ae:	83 c4 10             	add    $0x10,%esp
  8007b1:	85 c0                	test   %eax,%eax
  8007b3:	78 e1                	js     800796 <output+0x1a>
		r=ipc_recv( &from_env , &nsipcbuf, NULL);
  8007b5:	83 ec 04             	sub    $0x4,%esp
  8007b8:	6a 00                	push   $0x0
  8007ba:	68 00 e0 b3 00       	push   $0xb3e000
  8007bf:	53                   	push   %ebx
  8007c0:	e8 92 ec 00 00       	call   80f457 <ipc_recv>
		if(r!=NSREQ_OUTPUT || from_env!=ns_envid){
  8007c5:	83 c4 10             	add    $0x10,%esp
  8007c8:	83 f8 0b             	cmp    $0xb,%eax
  8007cb:	75 e8                	jne    8007b5 <output+0x39>
  8007cd:	39 75 f4             	cmp    %esi,-0xc(%ebp)
  8007d0:	75 e3                	jne    8007b5 <output+0x39>
  8007d2:	eb c7                	jmp    80079b <output+0x1f>

008007d4 <get_socket>:
static struct lwip_socket *
get_socket(int s)
{
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  8007d4:	83 f8 1f             	cmp    $0x1f,%eax
  8007d7:	77 1b                	ja     8007f4 <get_socket+0x20>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
  8007d9:	8d 14 80             	lea    (%eax,%eax,4),%edx
  8007dc:	8d 14 95 a0 50 81 00 	lea    0x8150a0(,%edx,4),%edx

  if (!sock->conn) {
  8007e3:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8007e6:	8b 04 85 a0 50 81 00 	mov    0x8150a0(,%eax,4),%eax
  8007ed:	85 c0                	test   %eax,%eax
  8007ef:	74 14                	je     800805 <get_socket+0x31>
    set_errno(EBADF);
    return NULL;
  }

  return sock;
}
  8007f1:	89 d0                	mov    %edx,%eax
  8007f3:	c3                   	ret    
    set_errno(EBADF);
  8007f4:	c7 05 34 50 81 00 09 	movl   $0x9,0x815034
  8007fb:	00 00 00 
    return NULL;
  8007fe:	ba 00 00 00 00       	mov    $0x0,%edx
  800803:	eb ec                	jmp    8007f1 <get_socket+0x1d>
    set_errno(EBADF);
  800805:	c7 05 34 50 81 00 09 	movl   $0x9,0x815034
  80080c:	00 00 00 
    return NULL;
  80080f:	89 c2                	mov    %eax,%edx
  800811:	eb de                	jmp    8007f1 <get_socket+0x1d>

00800813 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  800813:	55                   	push   %ebp
  800814:	89 e5                	mov    %esp,%ebp
  800816:	57                   	push   %edi
  800817:	56                   	push   %esi
  800818:	53                   	push   %ebx
  800819:	83 ec 30             	sub    $0x30,%esp
  80081c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80081f:	89 55 d0             	mov    %edx,-0x30(%ebp)
  800822:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800825:	6a 04                	push   $0x4
  800827:	6a 00                	push   $0x0
  800829:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80082c:	50                   	push   %eax
  80082d:	e8 a9 e4 00 00       	call   80ecdb <memset>
  FD_ZERO(&lwriteset);
  800832:	83 c4 0c             	add    $0xc,%esp
  800835:	6a 04                	push   $0x4
  800837:	6a 00                	push   $0x0
  800839:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80083c:	50                   	push   %eax
  80083d:	e8 99 e4 00 00       	call   80ecdb <memset>
  FD_ZERO(&lexceptset);
  800842:	83 c4 0c             	add    $0xc,%esp
  800845:	6a 04                	push   $0x4
  800847:	6a 00                	push   $0x0
  800849:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80084c:	50                   	push   %eax
  80084d:	e8 89 e4 00 00       	call   80ecdb <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800852:	83 c4 10             	add    $0x10,%esp
  int i, nready = 0;
  800855:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  for(i = 0; i < maxfdp1; i++) {
  80085c:	bb 00 00 00 00       	mov    $0x0,%ebx
  800861:	eb 20                	jmp    800883 <lwip_selscan+0x70>
    if (FD_ISSET(i, readset)) {
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
        FD_SET(i, &lreadset);
  800863:	b8 01 00 00 00       	mov    $0x1,%eax
  800868:	89 f9                	mov    %edi,%ecx
  80086a:	d3 e0                	shl    %cl,%eax
  80086c:	08 44 35 e4          	or     %al,-0x1c(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  800870:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  800874:	8b 45 cc             	mov    -0x34(%ebp),%eax
  800877:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  80087b:	0f a3 f8             	bt     %edi,%eax
  80087e:	72 3e                	jb     8008be <lwip_selscan+0xab>
  for(i = 0; i < maxfdp1; i++) {
  800880:	83 c3 01             	add    $0x1,%ebx
  800883:	3b 5d d4             	cmp    -0x2c(%ebp),%ebx
  800886:	7d 5b                	jge    8008e3 <lwip_selscan+0xd0>
    if (FD_ISSET(i, readset)) {
  800888:	8d 73 07             	lea    0x7(%ebx),%esi
  80088b:	85 db                	test   %ebx,%ebx
  80088d:	0f 49 f3             	cmovns %ebx,%esi
  800890:	c1 fe 03             	sar    $0x3,%esi
  800893:	89 df                	mov    %ebx,%edi
  800895:	83 e7 07             	and    $0x7,%edi
  800898:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80089b:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  80089f:	0f a3 f8             	bt     %edi,%eax
  8008a2:	73 d0                	jae    800874 <lwip_selscan+0x61>
      p_sock = get_socket(i);
  8008a4:	89 d8                	mov    %ebx,%eax
  8008a6:	e8 29 ff ff ff       	call   8007d4 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8008ab:	85 c0                	test   %eax,%eax
  8008ad:	74 c5                	je     800874 <lwip_selscan+0x61>
  8008af:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8008b3:	75 ae                	jne    800863 <lwip_selscan+0x50>
  8008b5:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8008ba:	74 b8                	je     800874 <lwip_selscan+0x61>
  8008bc:	eb a5                	jmp    800863 <lwip_selscan+0x50>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  8008be:	89 d8                	mov    %ebx,%eax
  8008c0:	e8 0f ff ff ff       	call   8007d4 <get_socket>
      if (p_sock && p_sock->sendevent) {
  8008c5:	85 c0                	test   %eax,%eax
  8008c7:	74 b7                	je     800880 <lwip_selscan+0x6d>
  8008c9:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  8008ce:	74 b0                	je     800880 <lwip_selscan+0x6d>
        FD_SET(i, &lwriteset);
  8008d0:	b8 01 00 00 00       	mov    $0x1,%eax
  8008d5:	89 f9                	mov    %edi,%ecx
  8008d7:	d3 e0                	shl    %cl,%eax
  8008d9:	08 44 35 e0          	or     %al,-0x20(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  8008dd:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
  8008e1:	eb 9d                	jmp    800880 <lwip_selscan+0x6d>
      }
    }
  }
  *readset = lreadset;
  8008e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8008e6:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8008e9:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  8008eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8008ee:	8b 55 cc             	mov    -0x34(%ebp),%edx
  8008f1:	89 02                	mov    %eax,(%edx)
  FD_ZERO(exceptset);
  8008f3:	83 ec 04             	sub    $0x4,%esp
  8008f6:	6a 04                	push   $0x4
  8008f8:	6a 00                	push   $0x0
  8008fa:	ff 75 08             	push   0x8(%ebp)
  8008fd:	e8 d9 e3 00 00       	call   80ecdb <memset>
  
  return nready;
}
  800902:	8b 45 c8             	mov    -0x38(%ebp),%eax
  800905:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800908:	5b                   	pop    %ebx
  800909:	5e                   	pop    %esi
  80090a:	5f                   	pop    %edi
  80090b:	5d                   	pop    %ebp
  80090c:	c3                   	ret    

0080090d <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  80090d:	55                   	push   %ebp
  80090e:	89 e5                	mov    %esp,%ebp
  800910:	57                   	push   %edi
  800911:	56                   	push   %esi
  800912:	53                   	push   %ebx
  800913:	83 ec 3c             	sub    $0x3c,%esp
  800916:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  800919:	89 ce                	mov    %ecx,%esi
  80091b:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  80091e:	e8 b1 fe ff ff       	call   8007d4 <get_socket>
  if (!sock)
  800923:	85 c0                	test   %eax,%eax
  800925:	0f 84 86 00 00 00    	je     8009b1 <lwip_getaddrname+0xa4>
  80092b:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  80092d:	83 ec 04             	sub    $0x4,%esp
  800930:	6a 10                	push   $0x10
  800932:	6a 00                	push   $0x0
  800934:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800937:	50                   	push   %eax
  800938:	e8 9e e3 00 00       	call   80ecdb <memset>
  sin.sin_len = sizeof(sin);
  80093d:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800941:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800945:	89 f8                	mov    %edi,%eax
  800947:	0f b6 f8             	movzbl %al,%edi
  80094a:	57                   	push   %edi
  80094b:	8d 45 da             	lea    -0x26(%ebp),%eax
  80094e:	50                   	push   %eax
  80094f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800952:	50                   	push   %eax
  800953:	ff 33                	push   (%ebx)
  800955:	e8 63 a3 00 00       	call   80acbd <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  80095a:	83 c4 14             	add    $0x14,%esp
  80095d:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  800961:	50                   	push   %eax
  800962:	e8 1f 6d 00 00       	call   807686 <htons>
  800967:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  80096b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80096e:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  800971:	83 c4 10             	add    $0x10,%esp
  800974:	83 3e 10             	cmpl   $0x10,(%esi)
  800977:	76 06                	jbe    80097f <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  800979:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  80097f:	83 ec 04             	sub    $0x4,%esp
  800982:	ff 36                	push   (%esi)
  800984:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800987:	50                   	push   %eax
  800988:	ff 75 c4             	push   -0x3c(%ebp)
  80098b:	e8 f3 e3 00 00       	call   80ed83 <memcpy>
  sock_set_errno(sock, 0);
  800990:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  800997:	c7 05 34 50 81 00 00 	movl   $0x0,0x815034
  80099e:	00 00 00 
  return 0;
  8009a1:	83 c4 10             	add    $0x10,%esp
  8009a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8009a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8009ac:	5b                   	pop    %ebx
  8009ad:	5e                   	pop    %esi
  8009ae:	5f                   	pop    %edi
  8009af:	5d                   	pop    %ebp
  8009b0:	c3                   	ret    
    return -1;
  8009b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8009b6:	eb f1                	jmp    8009a9 <lwip_getaddrname+0x9c>

008009b8 <event_callback>:
{
  8009b8:	55                   	push   %ebp
  8009b9:	89 e5                	mov    %esp,%ebp
  8009bb:	57                   	push   %edi
  8009bc:	56                   	push   %esi
  8009bd:	53                   	push   %ebx
  8009be:	83 ec 1c             	sub    $0x1c,%esp
  8009c1:	8b 7d 08             	mov    0x8(%ebp),%edi
  8009c4:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (conn) {
  8009c7:	85 ff                	test   %edi,%edi
  8009c9:	0f 84 80 01 00 00    	je     800b4f <event_callback+0x197>
    s = conn->socket;
  8009cf:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  8009d2:	85 db                	test   %ebx,%ebx
  8009d4:	78 3c                	js     800a12 <event_callback+0x5a>
    sock = get_socket(s);
  8009d6:	89 d8                	mov    %ebx,%eax
  8009d8:	e8 f7 fd ff ff       	call   8007d4 <get_socket>
  8009dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  8009e0:	85 c0                	test   %eax,%eax
  8009e2:	0f 84 67 01 00 00    	je     800b4f <event_callback+0x197>
  sys_sem_wait(selectsem);
  8009e8:	83 ec 0c             	sub    $0xc,%esp
  8009eb:	ff 35 80 50 81 00    	push   0x815080
  8009f1:	e8 12 47 00 00       	call   805108 <sys_sem_wait>
  switch (evt) {
  8009f6:	83 c4 10             	add    $0x10,%esp
  8009f9:	83 fe 02             	cmp    $0x2,%esi
  8009fc:	0f 84 a0 00 00 00    	je     800aa2 <event_callback+0xea>
  800a02:	77 59                	ja     800a5d <event_callback+0xa5>
  800a04:	85 f6                	test   %esi,%esi
  800a06:	74 65                	je     800a6d <event_callback+0xb5>
      sock->rcvevent--;
  800a08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a0b:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800a10:	eb 63                	jmp    800a75 <event_callback+0xbd>
      sys_sem_wait(socksem);
  800a12:	83 ec 0c             	sub    $0xc,%esp
  800a15:	ff 35 84 50 81 00    	push   0x815084
  800a1b:	e8 e8 46 00 00       	call   805108 <sys_sem_wait>
      if (conn->socket < 0) {
  800a20:	8b 47 1c             	mov    0x1c(%edi),%eax
  800a23:	83 c4 10             	add    $0x10,%esp
  800a26:	85 c0                	test   %eax,%eax
  800a28:	78 13                	js     800a3d <event_callback+0x85>
      sys_sem_signal(socksem);
  800a2a:	83 ec 0c             	sub    $0xc,%esp
  800a2d:	ff 35 84 50 81 00    	push   0x815084
  800a33:	e8 e9 95 00 00       	call   80a021 <sys_sem_signal>
  800a38:	83 c4 10             	add    $0x10,%esp
  800a3b:	eb 99                	jmp    8009d6 <event_callback+0x1e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800a3d:	85 f6                	test   %esi,%esi
  800a3f:	75 06                	jne    800a47 <event_callback+0x8f>
          conn->socket--;
  800a41:	83 e8 01             	sub    $0x1,%eax
  800a44:	89 47 1c             	mov    %eax,0x1c(%edi)
        sys_sem_signal(socksem);
  800a47:	83 ec 0c             	sub    $0xc,%esp
  800a4a:	ff 35 84 50 81 00    	push   0x815084
  800a50:	e8 cc 95 00 00       	call   80a021 <sys_sem_signal>
        return;
  800a55:	83 c4 10             	add    $0x10,%esp
  800a58:	e9 f2 00 00 00       	jmp    800b4f <event_callback+0x197>
  switch (evt) {
  800a5d:	83 fe 03             	cmp    $0x3,%esi
  800a60:	75 4b                	jne    800aad <event_callback+0xf5>
      sock->sendevent = 0;
  800a62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a65:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800a6b:	eb 08                	jmp    800a75 <event_callback+0xbd>
      sock->rcvevent++;
  800a6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a70:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
  sys_sem_signal(selectsem);
  800a75:	83 ec 0c             	sub    $0xc,%esp
  800a78:	ff 35 80 50 81 00    	push   0x815080
  800a7e:	e8 9e 95 00 00       	call   80a021 <sys_sem_signal>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800a83:	8d 73 07             	lea    0x7(%ebx),%esi
  800a86:	83 c4 10             	add    $0x10,%esp
  800a89:	85 db                	test   %ebx,%ebx
  800a8b:	0f 49 f3             	cmovns %ebx,%esi
  800a8e:	c1 fe 03             	sar    $0x3,%esi
  800a91:	89 d9                	mov    %ebx,%ecx
  800a93:	83 e1 07             	and    $0x7,%ecx
  800a96:	bf 01 00 00 00       	mov    $0x1,%edi
  800a9b:	d3 e7                	shl    %cl,%edi
  800a9d:	e9 83 00 00 00       	jmp    800b25 <event_callback+0x16d>
      sock->sendevent = 1;
  800aa2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800aa5:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800aab:	eb c8                	jmp    800a75 <event_callback+0xbd>
      LWIP_ASSERT("unknown event", 0);
  800aad:	83 ec 04             	sub    $0x4,%esp
  800ab0:	68 82 0e 81 00       	push   $0x810e82
  800ab5:	68 17 04 00 00       	push   $0x417
  800aba:	68 90 0e 81 00       	push   $0x810e90
  800abf:	e8 12 da 00 00       	call   80e4d6 <_panic>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800ac4:	8b 1b                	mov    (%ebx),%ebx
  800ac6:	85 db                	test   %ebx,%ebx
  800ac8:	74 74                	je     800b3e <event_callback+0x186>
      if (scb->sem_signalled == 0) {
  800aca:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800ace:	75 f4                	jne    800ac4 <event_callback+0x10c>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800ad0:	8b 43 04             	mov    0x4(%ebx),%eax
  800ad3:	85 c0                	test   %eax,%eax
  800ad5:	74 12                	je     800ae9 <event_callback+0x131>
  800ad7:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800adb:	85 f8                	test   %edi,%eax
  800add:	74 0a                	je     800ae9 <event_callback+0x131>
          if (sock->rcvevent)
  800adf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800ae2:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800ae7:	75 19                	jne    800b02 <event_callback+0x14a>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800ae9:	8b 43 08             	mov    0x8(%ebx),%eax
  800aec:	85 c0                	test   %eax,%eax
  800aee:	74 d4                	je     800ac4 <event_callback+0x10c>
  800af0:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800af4:	85 f8                	test   %edi,%eax
  800af6:	74 cc                	je     800ac4 <event_callback+0x10c>
          if (sock->sendevent)
  800af8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800afb:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800b00:	74 c2                	je     800ac4 <event_callback+0x10c>
      scb->sem_signalled = 1;
  800b02:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800b09:	83 ec 0c             	sub    $0xc,%esp
  800b0c:	ff 35 80 50 81 00    	push   0x815080
  800b12:	e8 0a 95 00 00       	call   80a021 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800b17:	83 c4 04             	add    $0x4,%esp
  800b1a:	ff 73 14             	push   0x14(%ebx)
  800b1d:	e8 ff 94 00 00       	call   80a021 <sys_sem_signal>
    sys_sem_wait(selectsem);
  800b22:	83 c4 10             	add    $0x10,%esp
  800b25:	83 ec 0c             	sub    $0xc,%esp
  800b28:	ff 35 80 50 81 00    	push   0x815080
  800b2e:	e8 d5 45 00 00       	call   805108 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b33:	8b 1d 88 50 81 00    	mov    0x815088,%ebx
  800b39:	83 c4 10             	add    $0x10,%esp
  800b3c:	eb 88                	jmp    800ac6 <event_callback+0x10e>
      sys_sem_signal(selectsem);
  800b3e:	83 ec 0c             	sub    $0xc,%esp
  800b41:	ff 35 80 50 81 00    	push   0x815080
  800b47:	e8 d5 94 00 00       	call   80a021 <sys_sem_signal>
      break;
  800b4c:	83 c4 10             	add    $0x10,%esp
}
  800b4f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800b52:	5b                   	pop    %ebx
  800b53:	5e                   	pop    %esi
  800b54:	5f                   	pop    %edi
  800b55:	5d                   	pop    %ebp
  800b56:	c3                   	ret    

00800b57 <alloc_socket>:
{
  800b57:	55                   	push   %ebp
  800b58:	89 e5                	mov    %esp,%ebp
  800b5a:	56                   	push   %esi
  800b5b:	53                   	push   %ebx
  800b5c:	89 c6                	mov    %eax,%esi
  sys_sem_wait(socksem);
  800b5e:	83 ec 0c             	sub    $0xc,%esp
  800b61:	ff 35 84 50 81 00    	push   0x815084
  800b67:	e8 9c 45 00 00       	call   805108 <sys_sem_wait>
  800b6c:	b8 a0 50 81 00       	mov    $0x8150a0,%eax
  800b71:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800b74:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800b79:	83 38 00             	cmpl   $0x0,(%eax)
  800b7c:	74 23                	je     800ba1 <alloc_socket+0x4a>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800b7e:	83 c3 01             	add    $0x1,%ebx
  800b81:	83 c0 14             	add    $0x14,%eax
  800b84:	83 fb 20             	cmp    $0x20,%ebx
  800b87:	75 f0                	jne    800b79 <alloc_socket+0x22>
  sys_sem_signal(socksem);
  800b89:	83 ec 0c             	sub    $0xc,%esp
  800b8c:	ff 35 84 50 81 00    	push   0x815084
  800b92:	e8 8a 94 00 00       	call   80a021 <sys_sem_signal>
  return -1;
  800b97:	83 c4 10             	add    $0x10,%esp
  800b9a:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  800b9f:	eb 55                	jmp    800bf6 <alloc_socket+0x9f>
      sockets[i].conn       = newconn;
  800ba1:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800ba4:	c1 e2 02             	shl    $0x2,%edx
  800ba7:	89 b2 a0 50 81 00    	mov    %esi,0x8150a0(%edx)
      sockets[i].lastdata   = NULL;
  800bad:	c7 82 a4 50 81 00 00 	movl   $0x0,0x8150a4(%edx)
  800bb4:	00 00 00 
      sockets[i].lastoffset = 0;
  800bb7:	66 c7 82 a8 50 81 00 	movw   $0x0,0x8150a8(%edx)
  800bbe:	00 00 
      sockets[i].rcvevent   = 0;
  800bc0:	66 c7 82 aa 50 81 00 	movw   $0x0,0x8150aa(%edx)
  800bc7:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800bc9:	66 c7 82 ac 50 81 00 	movw   $0x1,0x8150ac(%edx)
  800bd0:	01 00 
      sockets[i].flags      = 0;
  800bd2:	66 c7 82 ae 50 81 00 	movw   $0x0,0x8150ae(%edx)
  800bd9:	00 00 
      sockets[i].err        = 0;
  800bdb:	c7 82 b0 50 81 00 00 	movl   $0x0,0x8150b0(%edx)
  800be2:	00 00 00 
      sys_sem_signal(socksem);
  800be5:	83 ec 0c             	sub    $0xc,%esp
  800be8:	ff 35 84 50 81 00    	push   0x815084
  800bee:	e8 2e 94 00 00       	call   80a021 <sys_sem_signal>
      return i;
  800bf3:	83 c4 10             	add    $0x10,%esp
}
  800bf6:	89 d8                	mov    %ebx,%eax
  800bf8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800bfb:	5b                   	pop    %ebx
  800bfc:	5e                   	pop    %esi
  800bfd:	5d                   	pop    %ebp
  800bfe:	c3                   	ret    

00800bff <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800bff:	55                   	push   %ebp
  800c00:	89 e5                	mov    %esp,%ebp
  800c02:	56                   	push   %esi
  800c03:	53                   	push   %ebx
  800c04:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800c07:	85 c0                	test   %eax,%eax
  800c09:	74 3b                	je     800c46 <lwip_getsockopt_internal+0x47>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800c0b:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800c0d:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800c10:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800c13:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800c16:	83 fa 06             	cmp    $0x6,%edx
  800c19:	0f 84 32 01 00 00    	je     800d51 <lwip_getsockopt_internal+0x152>
  800c1f:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800c25:	74 36                	je     800c5d <lwip_getsockopt_internal+0x5e>
  800c27:	85 d2                	test   %edx,%edx
  800c29:	0f 84 f4 00 00 00    	je     800d23 <lwip_getsockopt_internal+0x124>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800c2f:	83 ec 0c             	sub    $0xc,%esp
  800c32:	8b 03                	mov    (%ebx),%eax
  800c34:	ff 70 10             	push   0x10(%eax)
  800c37:	e8 e5 93 00 00       	call   80a021 <sys_sem_signal>
}
  800c3c:	83 c4 10             	add    $0x10,%esp
  800c3f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800c42:	5b                   	pop    %ebx
  800c43:	5e                   	pop    %esi
  800c44:	5d                   	pop    %ebp
  800c45:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800c46:	83 ec 04             	sub    $0x4,%esp
  800c49:	68 a7 0e 81 00       	push   $0x810ea7
  800c4e:	68 38 05 00 00       	push   $0x538
  800c53:	68 90 0e 81 00       	push   $0x810e90
  800c58:	e8 79 d8 00 00       	call   80e4d6 <_panic>
  800c5d:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  800c63:	0f 84 81 00 00 00    	je     800cea <lwip_getsockopt_internal+0xeb>
  800c69:	7e 20                	jle    800c8b <lwip_getsockopt_internal+0x8c>
  800c6b:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  800c71:	74 39                	je     800cac <lwip_getsockopt_internal+0xad>
  800c73:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800c79:	75 b4                	jne    800c2f <lwip_getsockopt_internal+0x30>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800c7b:	8b 13                	mov    (%ebx),%edx
  800c7d:	8b 52 08             	mov    0x8(%edx),%edx
  800c80:	0f b6 52 10          	movzbl 0x10(%edx),%edx
  800c84:	83 e2 01             	and    $0x1,%edx
  800c87:	89 10                	mov    %edx,(%eax)
      break;
  800c89:	eb a4                	jmp    800c2f <lwip_getsockopt_internal+0x30>
  800c8b:	8d 51 fe             	lea    -0x2(%ecx),%edx
  800c8e:	83 fa 1e             	cmp    $0x1e,%edx
  800c91:	77 9c                	ja     800c2f <lwip_getsockopt_internal+0x30>
  800c93:	be 41 00 00 40       	mov    $0x40000041,%esi
  800c98:	0f a3 d6             	bt     %edx,%esi
  800c9b:	73 92                	jae    800c2f <lwip_getsockopt_internal+0x30>
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800c9d:	8b 13                	mov    (%ebx),%edx
  800c9f:	8b 52 08             	mov    0x8(%edx),%edx
  800ca2:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  800ca6:	21 ca                	and    %ecx,%edx
  800ca8:	89 10                	mov    %edx,(%eax)
      break;
  800caa:	eb 83                	jmp    800c2f <lwip_getsockopt_internal+0x30>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800cac:	8b 13                	mov    (%ebx),%edx
  800cae:	8b 12                	mov    (%edx),%edx
  800cb0:	89 d1                	mov    %edx,%ecx
  800cb2:	81 e1 f0 00 00 00    	and    $0xf0,%ecx
  800cb8:	83 f9 20             	cmp    $0x20,%ecx
  800cbb:	74 22                	je     800cdf <lwip_getsockopt_internal+0xe0>
  800cbd:	83 f9 40             	cmp    $0x40,%ecx
  800cc0:	74 12                	je     800cd4 <lwip_getsockopt_internal+0xd5>
        *(int*)optval = sock->conn->type;
  800cc2:	83 f9 10             	cmp    $0x10,%ecx
  800cc5:	b9 01 00 00 00       	mov    $0x1,%ecx
  800cca:	0f 44 d1             	cmove  %ecx,%edx
  800ccd:	89 10                	mov    %edx,(%eax)
  800ccf:	e9 5b ff ff ff       	jmp    800c2f <lwip_getsockopt_internal+0x30>
        *(int*)optval = SOCK_RAW;
  800cd4:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        break;
  800cda:	e9 50 ff ff ff       	jmp    800c2f <lwip_getsockopt_internal+0x30>
        *(int*)optval = SOCK_DGRAM;
  800cdf:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
  800ce5:	e9 45 ff ff ff       	jmp    800c2f <lwip_getsockopt_internal+0x30>
      if (sock->err == 0) {
  800cea:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800cee:	75 22                	jne    800d12 <lwip_getsockopt_internal+0x113>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800cf0:	8b 13                	mov    (%ebx),%edx
  800cf2:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  800cf6:	f7 da                	neg    %edx
  800cf8:	b9 05 00 00 00       	mov    $0x5,%ecx
  800cfd:	83 fa 0e             	cmp    $0xe,%edx
  800d00:	77 07                	ja     800d09 <lwip_getsockopt_internal+0x10a>
  800d02:	8b 0c 95 60 0f 81 00 	mov    0x810f60(,%edx,4),%ecx
  800d09:	89 4b 10             	mov    %ecx,0x10(%ebx)
  800d0c:	89 0d 34 50 81 00    	mov    %ecx,0x815034
      *(int *)optval = sock->err;
  800d12:	8b 53 10             	mov    0x10(%ebx),%edx
  800d15:	89 10                	mov    %edx,(%eax)
      sock->err = 0;
  800d17:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
      break;
  800d1e:	e9 0c ff ff ff       	jmp    800c2f <lwip_getsockopt_internal+0x30>
  800d23:	83 f9 01             	cmp    $0x1,%ecx
  800d26:	74 19                	je     800d41 <lwip_getsockopt_internal+0x142>
  800d28:	83 f9 02             	cmp    $0x2,%ecx
  800d2b:	0f 85 fe fe ff ff    	jne    800c2f <lwip_getsockopt_internal+0x30>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800d31:	8b 13                	mov    (%ebx),%edx
  800d33:	8b 52 08             	mov    0x8(%edx),%edx
  800d36:	0f b6 52 0b          	movzbl 0xb(%edx),%edx
  800d3a:	89 10                	mov    %edx,(%eax)
      break;
  800d3c:	e9 ee fe ff ff       	jmp    800c2f <lwip_getsockopt_internal+0x30>
      *(int*)optval = sock->conn->pcb.ip->tos;
  800d41:	8b 13                	mov    (%ebx),%edx
  800d43:	8b 52 08             	mov    0x8(%edx),%edx
  800d46:	0f b6 52 0a          	movzbl 0xa(%edx),%edx
  800d4a:	89 10                	mov    %edx,(%eax)
      break;
  800d4c:	e9 de fe ff ff       	jmp    800c2f <lwip_getsockopt_internal+0x30>
  800d51:	83 f9 01             	cmp    $0x1,%ecx
  800d54:	74 1b                	je     800d71 <lwip_getsockopt_internal+0x172>
  800d56:	83 f9 02             	cmp    $0x2,%ecx
  800d59:	0f 85 d0 fe ff ff    	jne    800c2f <lwip_getsockopt_internal+0x30>
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800d5f:	8b 13                	mov    (%ebx),%edx
  800d61:	8b 52 08             	mov    0x8(%edx),%edx
  800d64:	8b 92 9c 00 00 00    	mov    0x9c(%edx),%edx
  800d6a:	89 10                	mov    %edx,(%eax)
      break;
  800d6c:	e9 be fe ff ff       	jmp    800c2f <lwip_getsockopt_internal+0x30>
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800d71:	8b 13                	mov    (%ebx),%edx
  800d73:	8b 52 08             	mov    0x8(%edx),%edx
  800d76:	0f b6 52 20          	movzbl 0x20(%edx),%edx
  800d7a:	83 e2 40             	and    $0x40,%edx
  800d7d:	89 10                	mov    %edx,(%eax)
      break;
  800d7f:	e9 ab fe ff ff       	jmp    800c2f <lwip_getsockopt_internal+0x30>

00800d84 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800d84:	55                   	push   %ebp
  800d85:	89 e5                	mov    %esp,%ebp
  800d87:	53                   	push   %ebx
  800d88:	83 ec 04             	sub    $0x4,%esp
  800d8b:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d8e:	85 c0                	test   %eax,%eax
  800d90:	74 35                	je     800dc7 <lwip_setsockopt_internal+0x43>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800d92:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800d94:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800d97:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800d9a:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800d9d:	83 fa 06             	cmp    $0x6,%edx
  800da0:	0f 84 aa 00 00 00    	je     800e50 <lwip_setsockopt_internal+0xcc>
  800da6:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800dac:	74 30                	je     800dde <lwip_setsockopt_internal+0x5a>
  800dae:	85 d2                	test   %edx,%edx
  800db0:	74 76                	je     800e28 <lwip_setsockopt_internal+0xa4>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800db2:	83 ec 0c             	sub    $0xc,%esp
  800db5:	8b 03                	mov    (%ebx),%eax
  800db7:	ff 70 10             	push   0x10(%eax)
  800dba:	e8 62 92 00 00       	call   80a021 <sys_sem_signal>
}
  800dbf:	83 c4 10             	add    $0x10,%esp
  800dc2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800dc5:	c9                   	leave  
  800dc6:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800dc7:	83 ec 04             	sub    $0x4,%esp
  800dca:	68 a7 0e 81 00       	push   $0x810ea7
  800dcf:	68 ae 06 00 00       	push   $0x6ae
  800dd4:	68 90 0e 81 00       	push   $0x810e90
  800dd9:	e8 f8 d6 00 00       	call   80e4d6 <_panic>
  800dde:	83 f9 20             	cmp    $0x20,%ecx
  800de1:	74 0d                	je     800df0 <lwip_setsockopt_internal+0x6c>
  800de3:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800de9:	74 22                	je     800e0d <lwip_setsockopt_internal+0x89>
  800deb:	83 f9 08             	cmp    $0x8,%ecx
  800dee:	75 c2                	jne    800db2 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800df0:	83 38 00             	cmpl   $0x0,(%eax)
  800df3:	74 0b                	je     800e00 <lwip_setsockopt_internal+0x7c>
        sock->conn->pcb.ip->so_options |= optname;
  800df5:	8b 03                	mov    (%ebx),%eax
  800df7:	8b 40 08             	mov    0x8(%eax),%eax
  800dfa:	66 09 48 08          	or     %cx,0x8(%eax)
  800dfe:	eb b2                	jmp    800db2 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.ip->so_options &= ~optname;
  800e00:	8b 03                	mov    (%ebx),%eax
  800e02:	8b 40 08             	mov    0x8(%eax),%eax
  800e05:	f7 d1                	not    %ecx
  800e07:	66 21 48 08          	and    %cx,0x8(%eax)
  800e0b:	eb a5                	jmp    800db2 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800e0d:	83 38 00             	cmpl   $0x0,(%eax)
  800e10:	74 0b                	je     800e1d <lwip_setsockopt_internal+0x99>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800e12:	8b 03                	mov    (%ebx),%eax
  800e14:	8b 40 08             	mov    0x8(%eax),%eax
  800e17:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800e1b:	eb 95                	jmp    800db2 <lwip_setsockopt_internal+0x2e>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800e1d:	8b 03                	mov    (%ebx),%eax
  800e1f:	8b 40 08             	mov    0x8(%eax),%eax
  800e22:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800e26:	eb 8a                	jmp    800db2 <lwip_setsockopt_internal+0x2e>
  800e28:	83 f9 01             	cmp    $0x1,%ecx
  800e2b:	74 14                	je     800e41 <lwip_setsockopt_internal+0xbd>
  800e2d:	83 f9 02             	cmp    $0x2,%ecx
  800e30:	75 80                	jne    800db2 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800e32:	8b 13                	mov    (%ebx),%edx
  800e34:	8b 52 08             	mov    0x8(%edx),%edx
  800e37:	8b 00                	mov    (%eax),%eax
  800e39:	88 42 0b             	mov    %al,0xb(%edx)
      break;
  800e3c:	e9 71 ff ff ff       	jmp    800db2 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800e41:	8b 13                	mov    (%ebx),%edx
  800e43:	8b 52 08             	mov    0x8(%edx),%edx
  800e46:	8b 00                	mov    (%eax),%eax
  800e48:	88 42 0a             	mov    %al,0xa(%edx)
      break;
  800e4b:	e9 62 ff ff ff       	jmp    800db2 <lwip_setsockopt_internal+0x2e>
  800e50:	83 f9 01             	cmp    $0x1,%ecx
  800e53:	74 1b                	je     800e70 <lwip_setsockopt_internal+0xec>
  800e55:	83 f9 02             	cmp    $0x2,%ecx
  800e58:	0f 85 54 ff ff ff    	jne    800db2 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800e5e:	8b 13                	mov    (%ebx),%edx
  800e60:	8b 52 08             	mov    0x8(%edx),%edx
  800e63:	8b 00                	mov    (%eax),%eax
  800e65:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
      break;
  800e6b:	e9 42 ff ff ff       	jmp    800db2 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800e70:	83 38 00             	cmpl   $0x0,(%eax)
  800e73:	74 0e                	je     800e83 <lwip_setsockopt_internal+0xff>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800e75:	8b 03                	mov    (%ebx),%eax
  800e77:	8b 40 08             	mov    0x8(%eax),%eax
  800e7a:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800e7e:	e9 2f ff ff ff       	jmp    800db2 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800e83:	8b 03                	mov    (%ebx),%eax
  800e85:	8b 40 08             	mov    0x8(%eax),%eax
  800e88:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800e8c:	e9 21 ff ff ff       	jmp    800db2 <lwip_setsockopt_internal+0x2e>

00800e91 <lwip_socket_init>:
{
  800e91:	55                   	push   %ebp
  800e92:	89 e5                	mov    %esp,%ebp
  800e94:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800e97:	6a 01                	push   $0x1
  800e99:	e8 c6 8e 00 00       	call   809d64 <sys_sem_new>
  800e9e:	a3 84 50 81 00       	mov    %eax,0x815084
  selectsem = sys_sem_new(1);
  800ea3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800eaa:	e8 b5 8e 00 00       	call   809d64 <sys_sem_new>
  800eaf:	a3 80 50 81 00       	mov    %eax,0x815080
}
  800eb4:	83 c4 10             	add    $0x10,%esp
  800eb7:	c9                   	leave  
  800eb8:	c3                   	ret    

00800eb9 <lwip_accept>:
{
  800eb9:	55                   	push   %ebp
  800eba:	89 e5                	mov    %esp,%ebp
  800ebc:	57                   	push   %edi
  800ebd:	56                   	push   %esi
  800ebe:	53                   	push   %ebx
  800ebf:	83 ec 3c             	sub    $0x3c,%esp
  800ec2:	8b 7d 10             	mov    0x10(%ebp),%edi
  sock = get_socket(s);
  800ec5:	8b 45 08             	mov    0x8(%ebp),%eax
  800ec8:	e8 07 f9 ff ff       	call   8007d4 <get_socket>
  if (!sock)
  800ecd:	85 c0                	test   %eax,%eax
  800ecf:	0f 84 94 01 00 00    	je     801069 <lwip_accept+0x1b0>
  800ed5:	89 c6                	mov    %eax,%esi
  newconn = netconn_accept(sock->conn);
  800ed7:	83 ec 0c             	sub    $0xc,%esp
  800eda:	ff 30                	push   (%eax)
  800edc:	e8 92 9f 00 00       	call   80ae73 <netconn_accept>
  800ee1:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800ee3:	83 c4 10             	add    $0x10,%esp
  800ee6:	85 c0                	test   %eax,%eax
  800ee8:	0f 84 e6 00 00 00    	je     800fd4 <lwip_accept+0x11b>
  err = netconn_peer(newconn, &naddr, &port);
  800eee:	6a 00                	push   $0x0
  800ef0:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800ef3:	50                   	push   %eax
  800ef4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800ef7:	50                   	push   %eax
  800ef8:	53                   	push   %ebx
  800ef9:	e8 bf 9d 00 00       	call   80acbd <netconn_getaddr>
  800efe:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800f01:	83 c4 10             	add    $0x10,%esp
  800f04:	84 c0                	test   %al,%al
  800f06:	0f 85 f1 00 00 00    	jne    800ffd <lwip_accept+0x144>
  memset(&sin, 0, sizeof(sin));
  800f0c:	83 ec 04             	sub    $0x4,%esp
  800f0f:	6a 10                	push   $0x10
  800f11:	6a 00                	push   $0x0
  800f13:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f16:	50                   	push   %eax
  800f17:	e8 bf dd 00 00       	call   80ecdb <memset>
  sin.sin_len = sizeof(sin);
  800f1c:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800f20:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800f24:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800f28:	89 04 24             	mov    %eax,(%esp)
  800f2b:	e8 56 67 00 00       	call   807686 <htons>
  800f30:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800f34:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800f37:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (*addrlen > sizeof(sin))
  800f3a:	83 c4 10             	add    $0x10,%esp
  800f3d:	83 3f 10             	cmpl   $0x10,(%edi)
  800f40:	76 06                	jbe    800f48 <lwip_accept+0x8f>
    *addrlen = sizeof(sin);
  800f42:	c7 07 10 00 00 00    	movl   $0x10,(%edi)
  SMEMCPY(addr, &sin, *addrlen);
  800f48:	83 ec 04             	sub    $0x4,%esp
  800f4b:	ff 37                	push   (%edi)
  800f4d:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f50:	50                   	push   %eax
  800f51:	ff 75 0c             	push   0xc(%ebp)
  800f54:	e8 2a de 00 00       	call   80ed83 <memcpy>
  newsock = alloc_socket(newconn);
  800f59:	89 d8                	mov    %ebx,%eax
  800f5b:	e8 f7 fb ff ff       	call   800b57 <alloc_socket>
  800f60:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800f62:	83 c4 10             	add    $0x10,%esp
  800f65:	83 f8 ff             	cmp    $0xffffffff,%eax
  800f68:	0f 84 c2 00 00 00    	je     801030 <lwip_accept+0x177>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800f6e:	83 f8 1f             	cmp    $0x1f,%eax
  800f71:	0f 87 db 00 00 00    	ja     801052 <lwip_accept+0x199>
  newconn->callback = event_callback;
  800f77:	c7 43 2c b8 09 80 00 	movl   $0x8009b8,0x2c(%ebx)
  sys_sem_wait(socksem);
  800f7e:	83 ec 0c             	sub    $0xc,%esp
  800f81:	ff 35 84 50 81 00    	push   0x815084
  800f87:	e8 7c 41 00 00       	call   805108 <sys_sem_wait>
  nsock->rcvevent += -1 - newconn->socket;
  800f8c:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  800f8f:	8d 14 85 a0 50 81 00 	lea    0x8150a0(,%eax,4),%edx
  800f96:	0f b7 42 0a          	movzwl 0xa(%edx),%eax
  800f9a:	66 2b 43 1c          	sub    0x1c(%ebx),%ax
  800f9e:	83 e8 01             	sub    $0x1,%eax
  800fa1:	66 89 42 0a          	mov    %ax,0xa(%edx)
  newconn->socket = newsock;
  800fa5:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  800fa8:	83 c4 04             	add    $0x4,%esp
  800fab:	ff 35 84 50 81 00    	push   0x815084
  800fb1:	e8 6b 90 00 00       	call   80a021 <sys_sem_signal>
  sock_set_errno(sock, 0);
  800fb6:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  800fbd:	c7 05 34 50 81 00 00 	movl   $0x0,0x815034
  800fc4:	00 00 00 
  return newsock;
  800fc7:	83 c4 10             	add    $0x10,%esp
}
  800fca:	89 f8                	mov    %edi,%eax
  800fcc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800fcf:	5b                   	pop    %ebx
  800fd0:	5e                   	pop    %esi
  800fd1:	5f                   	pop    %edi
  800fd2:	5d                   	pop    %ebp
  800fd3:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  800fd4:	8b 06                	mov    (%esi),%eax
  800fd6:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800fda:	f7 d8                	neg    %eax
  800fdc:	ba 05 00 00 00       	mov    $0x5,%edx
  800fe1:	83 f8 0e             	cmp    $0xe,%eax
  800fe4:	77 07                	ja     800fed <lwip_accept+0x134>
  800fe6:	8b 14 85 60 0f 81 00 	mov    0x810f60(,%eax,4),%edx
  800fed:	89 56 10             	mov    %edx,0x10(%esi)
  800ff0:	89 15 34 50 81 00    	mov    %edx,0x815034
    return -1;
  800ff6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800ffb:	eb cd                	jmp    800fca <lwip_accept+0x111>
    netconn_delete(newconn);
  800ffd:	83 ec 0c             	sub    $0xc,%esp
  801000:	53                   	push   %ebx
  801001:	e8 4f 9c 00 00       	call   80ac55 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  801006:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  80100a:	f7 d8                	neg    %eax
  80100c:	83 c4 10             	add    $0x10,%esp
  80100f:	ba 05 00 00 00       	mov    $0x5,%edx
  801014:	83 f8 0e             	cmp    $0xe,%eax
  801017:	77 07                	ja     801020 <lwip_accept+0x167>
  801019:	8b 14 85 60 0f 81 00 	mov    0x810f60(,%eax,4),%edx
  801020:	89 56 10             	mov    %edx,0x10(%esi)
  801023:	89 15 34 50 81 00    	mov    %edx,0x815034
    return -1;
  801029:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80102e:	eb 9a                	jmp    800fca <lwip_accept+0x111>
    netconn_delete(newconn);
  801030:	83 ec 0c             	sub    $0xc,%esp
  801033:	53                   	push   %ebx
  801034:	e8 1c 9c 00 00       	call   80ac55 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  801039:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  801040:	c7 05 34 50 81 00 17 	movl   $0x17,0x815034
  801047:	00 00 00 
    return -1;
  80104a:	83 c4 10             	add    $0x10,%esp
  80104d:	e9 78 ff ff ff       	jmp    800fca <lwip_accept+0x111>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  801052:	83 ec 04             	sub    $0x4,%esp
  801055:	68 b3 0e 81 00       	push   $0x810eb3
  80105a:	68 25 01 00 00       	push   $0x125
  80105f:	68 90 0e 81 00       	push   $0x810e90
  801064:	e8 6d d4 00 00       	call   80e4d6 <_panic>
    return -1;
  801069:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80106e:	e9 57 ff ff ff       	jmp    800fca <lwip_accept+0x111>

00801073 <lwip_bind>:
{
  801073:	55                   	push   %ebp
  801074:	89 e5                	mov    %esp,%ebp
  801076:	56                   	push   %esi
  801077:	53                   	push   %ebx
  801078:	83 ec 10             	sub    $0x10,%esp
  80107b:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  80107e:	8b 45 08             	mov    0x8(%ebp),%eax
  801081:	e8 4e f7 ff ff       	call   8007d4 <get_socket>
  if (!sock)
  801086:	85 c0                	test   %eax,%eax
  801088:	0f 84 94 00 00 00    	je     801122 <lwip_bind+0xaf>
  80108e:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801090:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801094:	75 4f                	jne    8010e5 <lwip_bind+0x72>
  801096:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  80109a:	75 49                	jne    8010e5 <lwip_bind+0x72>
  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80109c:	8b 46 04             	mov    0x4(%esi),%eax
  80109f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  8010a2:	83 ec 0c             	sub    $0xc,%esp
  8010a5:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8010a9:	50                   	push   %eax
  8010aa:	e8 e4 65 00 00       	call   807693 <ntohs>
  8010af:	83 c4 0c             	add    $0xc,%esp
  8010b2:	0f b7 c0             	movzwl %ax,%eax
  8010b5:	50                   	push   %eax
  8010b6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8010b9:	50                   	push   %eax
  8010ba:	ff 33                	push   (%ebx)
  8010bc:	e8 88 9c 00 00       	call   80ad49 <netconn_bind>
  if (err != ERR_OK) {
  8010c1:	83 c4 10             	add    $0x10,%esp
  8010c4:	84 c0                	test   %al,%al
  8010c6:	75 34                	jne    8010fc <lwip_bind+0x89>
  sock_set_errno(sock, 0);
  8010c8:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8010cf:	c7 05 34 50 81 00 00 	movl   $0x0,0x815034
  8010d6:	00 00 00 
  return 0;
  8010d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8010de:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8010e1:	5b                   	pop    %ebx
  8010e2:	5e                   	pop    %esi
  8010e3:	5d                   	pop    %ebp
  8010e4:	c3                   	ret    
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8010e5:	83 ec 04             	sub    $0x4,%esp
  8010e8:	68 c8 0e 81 00       	push   $0x810ec8
  8010ed:	68 48 01 00 00       	push   $0x148
  8010f2:	68 90 0e 81 00       	push   $0x810e90
  8010f7:	e8 da d3 00 00       	call   80e4d6 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  8010fc:	0f be c0             	movsbl %al,%eax
  8010ff:	f7 d8                	neg    %eax
  801101:	ba 05 00 00 00       	mov    $0x5,%edx
  801106:	83 f8 0e             	cmp    $0xe,%eax
  801109:	77 07                	ja     801112 <lwip_bind+0x9f>
  80110b:	8b 14 85 60 0f 81 00 	mov    0x810f60(,%eax,4),%edx
  801112:	89 53 10             	mov    %edx,0x10(%ebx)
  801115:	89 15 34 50 81 00    	mov    %edx,0x815034
    return -1;
  80111b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801120:	eb bc                	jmp    8010de <lwip_bind+0x6b>
    return -1;
  801122:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801127:	eb b5                	jmp    8010de <lwip_bind+0x6b>

00801129 <lwip_close>:
{
  801129:	55                   	push   %ebp
  80112a:	89 e5                	mov    %esp,%ebp
  80112c:	53                   	push   %ebx
  80112d:	83 ec 04             	sub    $0x4,%esp
  sock = get_socket(s);
  801130:	8b 45 08             	mov    0x8(%ebp),%eax
  801133:	e8 9c f6 ff ff       	call   8007d4 <get_socket>
  if (!sock) {
  801138:	85 c0                	test   %eax,%eax
  80113a:	74 6f                	je     8011ab <lwip_close+0x82>
  80113c:	89 c3                	mov    %eax,%ebx
  netconn_delete(sock->conn);
  80113e:	83 ec 0c             	sub    $0xc,%esp
  801141:	ff 30                	push   (%eax)
  801143:	e8 0d 9b 00 00       	call   80ac55 <netconn_delete>
  sys_sem_wait(socksem);
  801148:	83 c4 04             	add    $0x4,%esp
  80114b:	ff 35 84 50 81 00    	push   0x815084
  801151:	e8 b2 3f 00 00       	call   805108 <sys_sem_wait>
  if (sock->lastdata) {
  801156:	8b 43 04             	mov    0x4(%ebx),%eax
  801159:	83 c4 10             	add    $0x10,%esp
  80115c:	85 c0                	test   %eax,%eax
  80115e:	74 0c                	je     80116c <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  801160:	83 ec 0c             	sub    $0xc,%esp
  801163:	50                   	push   %eax
  801164:	e8 5b 13 00 00       	call   8024c4 <netbuf_delete>
  801169:	83 c4 10             	add    $0x10,%esp
  sock->lastdata   = NULL;
  80116c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  801173:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  801179:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  80117f:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801186:	c7 05 34 50 81 00 00 	movl   $0x0,0x815034
  80118d:	00 00 00 
  sys_sem_signal(socksem);
  801190:	83 ec 0c             	sub    $0xc,%esp
  801193:	ff 35 84 50 81 00    	push   0x815084
  801199:	e8 83 8e 00 00       	call   80a021 <sys_sem_signal>
  return 0;
  80119e:	83 c4 10             	add    $0x10,%esp
  8011a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8011a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8011a9:	c9                   	leave  
  8011aa:	c3                   	ret    
    return -1;
  8011ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011b0:	eb f4                	jmp    8011a6 <lwip_close+0x7d>

008011b2 <lwip_connect>:
{
  8011b2:	55                   	push   %ebp
  8011b3:	89 e5                	mov    %esp,%ebp
  8011b5:	56                   	push   %esi
  8011b6:	53                   	push   %ebx
  8011b7:	83 ec 10             	sub    $0x10,%esp
  8011ba:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  8011bd:	8b 45 08             	mov    0x8(%ebp),%eax
  8011c0:	e8 0f f6 ff ff       	call   8007d4 <get_socket>
  if (!sock)
  8011c5:	85 c0                	test   %eax,%eax
  8011c7:	0f 84 94 00 00 00    	je     801261 <lwip_connect+0xaf>
  8011cd:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8011cf:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  8011d3:	75 4f                	jne    801224 <lwip_connect+0x72>
  8011d5:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8011d9:	75 49                	jne    801224 <lwip_connect+0x72>
    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8011db:	8b 46 04             	mov    0x4(%esi),%eax
  8011de:	89 45 f4             	mov    %eax,-0xc(%ebp)
    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8011e1:	83 ec 0c             	sub    $0xc,%esp
  8011e4:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8011e8:	50                   	push   %eax
  8011e9:	e8 a5 64 00 00       	call   807693 <ntohs>
  8011ee:	83 c4 0c             	add    $0xc,%esp
  8011f1:	0f b7 c0             	movzwl %ax,%eax
  8011f4:	50                   	push   %eax
  8011f5:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8011f8:	50                   	push   %eax
  8011f9:	ff 33                	push   (%ebx)
  8011fb:	e8 9a 9b 00 00       	call   80ad9a <netconn_connect>
  if (err != ERR_OK) {
  801200:	83 c4 10             	add    $0x10,%esp
  801203:	84 c0                	test   %al,%al
  801205:	75 34                	jne    80123b <lwip_connect+0x89>
  sock_set_errno(sock, 0);
  801207:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80120e:	c7 05 34 50 81 00 00 	movl   $0x0,0x815034
  801215:	00 00 00 
  return 0;
  801218:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80121d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801220:	5b                   	pop    %ebx
  801221:	5e                   	pop    %esi
  801222:	5d                   	pop    %ebp
  801223:	c3                   	ret    
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801224:	83 ec 04             	sub    $0x4,%esp
  801227:	68 e3 0e 81 00       	push   $0x810ee3
  80122c:	68 84 01 00 00       	push   $0x184
  801231:	68 90 0e 81 00       	push   $0x810e90
  801236:	e8 9b d2 00 00       	call   80e4d6 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  80123b:	0f be c0             	movsbl %al,%eax
  80123e:	f7 d8                	neg    %eax
  801240:	ba 05 00 00 00       	mov    $0x5,%edx
  801245:	83 f8 0e             	cmp    $0xe,%eax
  801248:	77 07                	ja     801251 <lwip_connect+0x9f>
  80124a:	8b 14 85 60 0f 81 00 	mov    0x810f60(,%eax,4),%edx
  801251:	89 53 10             	mov    %edx,0x10(%ebx)
  801254:	89 15 34 50 81 00    	mov    %edx,0x815034
    return -1;
  80125a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80125f:	eb bc                	jmp    80121d <lwip_connect+0x6b>
    return -1;
  801261:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801266:	eb b5                	jmp    80121d <lwip_connect+0x6b>

00801268 <lwip_listen>:
{
  801268:	55                   	push   %ebp
  801269:	89 e5                	mov    %esp,%ebp
  80126b:	56                   	push   %esi
  80126c:	53                   	push   %ebx
  80126d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  sock = get_socket(s);
  801270:	8b 45 08             	mov    0x8(%ebp),%eax
  801273:	e8 5c f5 ff ff       	call   8007d4 <get_socket>
  if (!sock)
  801278:	85 c0                	test   %eax,%eax
  80127a:	74 6b                	je     8012e7 <lwip_listen+0x7f>
  80127c:	89 c6                	mov    %eax,%esi
  err = netconn_listen_with_backlog(sock->conn, backlog);
  80127e:	83 ec 08             	sub    $0x8,%esp
  801281:	b8 ff 00 00 00       	mov    $0xff,%eax
  801286:	39 c3                	cmp    %eax,%ebx
  801288:	0f 4e c3             	cmovle %ebx,%eax
  80128b:	85 c0                	test   %eax,%eax
  80128d:	ba 00 00 00 00       	mov    $0x0,%edx
  801292:	0f 48 c2             	cmovs  %edx,%eax
  801295:	50                   	push   %eax
  801296:	ff 36                	push   (%esi)
  801298:	e8 92 9b 00 00       	call   80ae2f <netconn_listen_with_backlog>
  if (err != ERR_OK) {
  80129d:	83 c4 10             	add    $0x10,%esp
  8012a0:	84 c0                	test   %al,%al
  8012a2:	75 1d                	jne    8012c1 <lwip_listen+0x59>
  sock_set_errno(sock, 0);
  8012a4:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8012ab:	c7 05 34 50 81 00 00 	movl   $0x0,0x815034
  8012b2:	00 00 00 
  return 0;
  8012b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8012ba:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8012bd:	5b                   	pop    %ebx
  8012be:	5e                   	pop    %esi
  8012bf:	5d                   	pop    %ebp
  8012c0:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(err));
  8012c1:	0f be c0             	movsbl %al,%eax
  8012c4:	f7 d8                	neg    %eax
  8012c6:	ba 05 00 00 00       	mov    $0x5,%edx
  8012cb:	83 f8 0e             	cmp    $0xe,%eax
  8012ce:	77 07                	ja     8012d7 <lwip_listen+0x6f>
  8012d0:	8b 14 85 60 0f 81 00 	mov    0x810f60(,%eax,4),%edx
  8012d7:	89 56 10             	mov    %edx,0x10(%esi)
  8012da:	89 15 34 50 81 00    	mov    %edx,0x815034
    return -1;
  8012e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012e5:	eb d3                	jmp    8012ba <lwip_listen+0x52>
    return -1;
  8012e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012ec:	eb cc                	jmp    8012ba <lwip_listen+0x52>

008012ee <lwip_recvfrom>:
{
  8012ee:	55                   	push   %ebp
  8012ef:	89 e5                	mov    %esp,%ebp
  8012f1:	57                   	push   %edi
  8012f2:	56                   	push   %esi
  8012f3:	53                   	push   %ebx
  8012f4:	83 ec 3c             	sub    $0x3c,%esp
  sock = get_socket(s);
  8012f7:	8b 45 08             	mov    0x8(%ebp),%eax
  8012fa:	e8 d5 f4 ff ff       	call   8007d4 <get_socket>
  if (!sock)
  8012ff:	85 c0                	test   %eax,%eax
  801301:	0f 84 20 02 00 00    	je     801527 <lwip_recvfrom+0x239>
  801307:	89 c7                	mov    %eax,%edi
  u16_t               buflen, copylen, off = 0;
  801309:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80130f:	8b 45 14             	mov    0x14(%ebp),%eax
  801312:	83 e0 08             	and    $0x8,%eax
  801315:	89 45 b8             	mov    %eax,-0x48(%ebp)
  801318:	e9 a7 00 00 00       	jmp    8013c4 <lwip_recvfrom+0xd6>
  80131d:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  801321:	75 06                	jne    801329 <lwip_recvfrom+0x3b>
  801323:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  801327:	74 07                	je     801330 <lwip_recvfrom+0x42>
  801329:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  80132e:	74 56                	je     801386 <lwip_recvfrom+0x98>
      sock->lastdata = buf = netconn_recv(sock->conn);
  801330:	83 ec 0c             	sub    $0xc,%esp
  801333:	ff 37                	push   (%edi)
  801335:	e8 ab 9b 00 00       	call   80aee5 <netconn_recv>
  80133a:	89 c6                	mov    %eax,%esi
  80133c:	89 47 04             	mov    %eax,0x4(%edi)
      if (!buf) {
  80133f:	83 c4 10             	add    $0x10,%esp
  801342:	85 c0                	test   %eax,%eax
  801344:	0f 85 85 00 00 00    	jne    8013cf <lwip_recvfrom+0xe1>
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  80134a:	8b 17                	mov    (%edi),%edx
  80134c:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  801350:	74 0b                	je     80135d <lwip_recvfrom+0x6f>
  801352:	b8 6e 00 00 00       	mov    $0x6e,%eax
  801357:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  80135b:	74 17                	je     801374 <lwip_recvfrom+0x86>
  80135d:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  801361:	f7 da                	neg    %edx
  801363:	b8 05 00 00 00       	mov    $0x5,%eax
  801368:	83 fa 0e             	cmp    $0xe,%edx
  80136b:	77 07                	ja     801374 <lwip_recvfrom+0x86>
  80136d:	8b 04 95 60 0f 81 00 	mov    0x810f60(,%edx,4),%eax
  801374:	89 47 10             	mov    %eax,0x10(%edi)
  801377:	a3 34 50 81 00       	mov    %eax,0x815034
        return 0;
  80137c:	b8 00 00 00 00       	mov    $0x0,%eax
  801381:	e9 09 01 00 00       	jmp    80148f <lwip_recvfrom+0x1a1>
        sock_set_errno(sock, EWOULDBLOCK);
  801386:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  80138d:	c7 05 34 50 81 00 0b 	movl   $0xb,0x815034
  801394:	00 00 00 
        return -1;
  801397:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80139c:	e9 ee 00 00 00       	jmp    80148f <lwip_recvfrom+0x1a1>
        sock->lastdata = NULL;
  8013a1:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  8013a8:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        netbuf_delete(buf);
  8013ae:	83 ec 0c             	sub    $0xc,%esp
  8013b1:	56                   	push   %esi
  8013b2:	e8 0d 11 00 00       	call   8024c4 <netbuf_delete>
  8013b7:	83 c4 10             	add    $0x10,%esp
  } while (!done);
  8013ba:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  8013be:	0f 85 aa 00 00 00    	jne    80146e <lwip_recvfrom+0x180>
    if (sock->lastdata) {
  8013c4:	8b 77 04             	mov    0x4(%edi),%esi
  8013c7:	85 f6                	test   %esi,%esi
  8013c9:	0f 84 4e ff ff ff    	je     80131d <lwip_recvfrom+0x2f>
    buflen = netbuf_len(buf);
  8013cf:	8b 16                	mov    (%esi),%edx
  8013d1:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
    buflen -= sock->lastoffset;
  8013d5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8013d9:	89 cb                	mov    %ecx,%ebx
  8013db:	29 c3                	sub    %eax,%ebx
    if (len > buflen) {
  8013dd:	0f b7 db             	movzwl %bx,%ebx
  8013e0:	89 5d bc             	mov    %ebx,-0x44(%ebp)
      copylen = len;
  8013e3:	29 c1                	sub    %eax,%ecx
  8013e5:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  8013e8:	66 0f 4d 4d 10       	cmovge 0x10(%ebp),%cx
  8013ed:	89 cb                	mov    %ecx,%ebx
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  8013ef:	0f b7 c9             	movzwl %cx,%ecx
  8013f2:	0f b7 c0             	movzwl %ax,%eax
  8013f5:	50                   	push   %eax
  8013f6:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  8013f9:	51                   	push   %ecx
  8013fa:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8013fe:	03 45 0c             	add    0xc(%ebp),%eax
  801401:	50                   	push   %eax
  801402:	52                   	push   %edx
  801403:	e8 94 3b 00 00       	call   804f9c <pbuf_copy_partial>
    off += copylen;
  801408:	66 01 5d c4          	add    %bx,-0x3c(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80140c:	83 c4 04             	add    $0x4,%esp
  80140f:	ff 37                	push   (%edi)
  801411:	e8 7f 98 00 00       	call   80ac95 <netconn_type>
  801416:	83 c4 10             	add    $0x10,%esp
      done = 1;
  801419:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80141d:	83 f8 10             	cmp    $0x10,%eax
  801420:	75 23                	jne    801445 <lwip_recvfrom+0x157>
      len -= copylen;
  801422:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  801425:	29 4d 10             	sub    %ecx,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  801428:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80142c:	7e 17                	jle    801445 <lwip_recvfrom+0x157>
  80142e:	8b 06                	mov    (%esi),%eax
  801430:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
  801434:	83 e0 01             	and    $0x1,%eax
  801437:	88 45 c7             	mov    %al,-0x39(%ebp)
  80143a:	75 09                	jne    801445 <lwip_recvfrom+0x157>
  80143c:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801441:	0f 94 45 c7          	sete   -0x39(%ebp)
    if ((flags & MSG_PEEK)==0) {
  801445:	f6 45 14 01          	testb  $0x1,0x14(%ebp)
  801449:	75 23                	jne    80146e <lwip_recvfrom+0x180>
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  80144b:	8b 07                	mov    (%edi),%eax
  80144d:	83 38 10             	cmpl   $0x10,(%eax)
  801450:	0f 85 4b ff ff ff    	jne    8013a1 <lwip_recvfrom+0xb3>
  801456:	8b 55 c0             	mov    -0x40(%ebp),%edx
  801459:	39 55 bc             	cmp    %edx,-0x44(%ebp)
  80145c:	0f 8e 3f ff ff ff    	jle    8013a1 <lwip_recvfrom+0xb3>
        sock->lastdata = buf;
  801462:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  801465:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  801469:	e9 4c ff ff ff       	jmp    8013ba <lwip_recvfrom+0xcc>
  if (from && fromlen) {
  80146e:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801472:	74 06                	je     80147a <lwip_recvfrom+0x18c>
  801474:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801478:	75 1d                	jne    801497 <lwip_recvfrom+0x1a9>
  sock_set_errno(sock, 0);
  80147a:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  801481:	c7 05 34 50 81 00 00 	movl   $0x0,0x815034
  801488:	00 00 00 
  return off;
  80148b:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
}
  80148f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801492:	5b                   	pop    %ebx
  801493:	5e                   	pop    %esi
  801494:	5f                   	pop    %edi
  801495:	5d                   	pop    %ebp
  801496:	c3                   	ret    
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801497:	83 ec 0c             	sub    $0xc,%esp
  80149a:	ff 37                	push   (%edi)
  80149c:	e8 f4 97 00 00       	call   80ac95 <netconn_type>
  8014a1:	83 c4 10             	add    $0x10,%esp
  8014a4:	83 f8 10             	cmp    $0x10,%eax
  8014a7:	74 65                	je     80150e <lwip_recvfrom+0x220>
      addr = netbuf_fromaddr(buf);
  8014a9:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  8014ac:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8014b0:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    memset(&sin, 0, sizeof(sin));
  8014b4:	83 ec 04             	sub    $0x4,%esp
  8014b7:	6a 10                	push   $0x10
  8014b9:	6a 00                	push   $0x0
  8014bb:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8014be:	50                   	push   %eax
  8014bf:	e8 17 d8 00 00       	call   80ecdb <memset>
    sin.sin_len = sizeof(sin);
  8014c4:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  8014c8:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  8014cc:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8014d0:	89 04 24             	mov    %eax,(%esp)
  8014d3:	e8 ae 61 00 00       	call   807686 <htons>
  8014d8:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8014dc:	8b 03                	mov    (%ebx),%eax
  8014de:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (*fromlen > sizeof(sin))
  8014e1:	83 c4 10             	add    $0x10,%esp
  8014e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8014e7:	83 38 10             	cmpl   $0x10,(%eax)
  8014ea:	76 06                	jbe    8014f2 <lwip_recvfrom+0x204>
      *fromlen = sizeof(sin);
  8014ec:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
    SMEMCPY(from, &sin, *fromlen);
  8014f2:	83 ec 04             	sub    $0x4,%esp
  8014f5:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8014f8:	ff 30                	push   (%eax)
  8014fa:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8014fd:	50                   	push   %eax
  8014fe:	ff 75 18             	push   0x18(%ebp)
  801501:	e8 7d d8 00 00       	call   80ed83 <memcpy>
  801506:	83 c4 10             	add    $0x10,%esp
  801509:	e9 6c ff ff ff       	jmp    80147a <lwip_recvfrom+0x18c>
      netconn_getaddr(sock->conn, addr, &port, 0);
  80150e:	6a 00                	push   $0x0
  801510:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  801513:	50                   	push   %eax
  801514:	8d 45 d8             	lea    -0x28(%ebp),%eax
  801517:	50                   	push   %eax
  801518:	ff 37                	push   (%edi)
  80151a:	e8 9e 97 00 00       	call   80acbd <netconn_getaddr>
  80151f:	83 c4 10             	add    $0x10,%esp
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  801522:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  801525:	eb 8d                	jmp    8014b4 <lwip_recvfrom+0x1c6>
    return -1;
  801527:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80152c:	e9 5e ff ff ff       	jmp    80148f <lwip_recvfrom+0x1a1>

00801531 <lwip_read>:
{
  801531:	55                   	push   %ebp
  801532:	89 e5                	mov    %esp,%ebp
  801534:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  801537:	6a 00                	push   $0x0
  801539:	6a 00                	push   $0x0
  80153b:	6a 00                	push   $0x0
  80153d:	ff 75 10             	push   0x10(%ebp)
  801540:	ff 75 0c             	push   0xc(%ebp)
  801543:	ff 75 08             	push   0x8(%ebp)
  801546:	e8 a3 fd ff ff       	call   8012ee <lwip_recvfrom>
}
  80154b:	c9                   	leave  
  80154c:	c3                   	ret    

0080154d <lwip_recv>:
{
  80154d:	55                   	push   %ebp
  80154e:	89 e5                	mov    %esp,%ebp
  801550:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  801553:	6a 00                	push   $0x0
  801555:	6a 00                	push   $0x0
  801557:	ff 75 14             	push   0x14(%ebp)
  80155a:	ff 75 10             	push   0x10(%ebp)
  80155d:	ff 75 0c             	push   0xc(%ebp)
  801560:	ff 75 08             	push   0x8(%ebp)
  801563:	e8 86 fd ff ff       	call   8012ee <lwip_recvfrom>
}
  801568:	c9                   	leave  
  801569:	c3                   	ret    

0080156a <lwip_sendto>:
{
  80156a:	55                   	push   %ebp
  80156b:	89 e5                	mov    %esp,%ebp
  80156d:	57                   	push   %edi
  80156e:	56                   	push   %esi
  80156f:	53                   	push   %ebx
  801570:	83 ec 2c             	sub    $0x2c,%esp
  801573:	8b 7d 10             	mov    0x10(%ebp),%edi
  801576:	8b 75 18             	mov    0x18(%ebp),%esi
  sock = get_socket(s);
  801579:	8b 45 08             	mov    0x8(%ebp),%eax
  80157c:	e8 53 f2 ff ff       	call   8007d4 <get_socket>
  if (!sock)
  801581:	85 c0                	test   %eax,%eax
  801583:	0f 84 28 01 00 00    	je     8016b1 <lwip_sendto+0x147>
  801589:	89 c3                	mov    %eax,%ebx
  if (sock->conn->type==NETCONN_TCP) {
  80158b:	8b 00                	mov    (%eax),%eax
  80158d:	83 38 10             	cmpl   $0x10,(%eax)
  801590:	0f 84 be 00 00 00    	je     801654 <lwip_sendto+0xea>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  801596:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  80159c:	0f 87 c8 00 00 00    	ja     80166a <lwip_sendto+0x100>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8015a2:	89 f2                	mov    %esi,%edx
  8015a4:	0b 55 1c             	or     0x1c(%ebp),%edx
  8015a7:	0f 84 0b 01 00 00    	je     8016b8 <lwip_sendto+0x14e>
  8015ad:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8015b1:	0f 85 ca 00 00 00    	jne    801681 <lwip_sendto+0x117>
  8015b7:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8015bb:	0f 85 c0 00 00 00    	jne    801681 <lwip_sendto+0x117>
  buf.p = buf.ptr = NULL;
  8015c1:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8015c8:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  8015cf:	8b 46 04             	mov    0x4(%esi),%eax
  8015d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  8015d5:	83 ec 0c             	sub    $0xc,%esp
  8015d8:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8015dc:	50                   	push   %eax
  8015dd:	e8 b1 60 00 00       	call   807693 <ntohs>
  8015e2:	83 c4 10             	add    $0x10,%esp
  8015e5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    buf.addr         = &remote_addr;
  8015e8:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  8015eb:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  8015ef:	83 ec 04             	sub    $0x4,%esp
  8015f2:	0f b7 c7             	movzwl %di,%eax
  8015f5:	50                   	push   %eax
  8015f6:	ff 75 0c             	push   0xc(%ebp)
  8015f9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8015fc:	50                   	push   %eax
  8015fd:	e8 bd 0f 00 00       	call   8025bf <netbuf_ref>
  801602:	0f be f0             	movsbl %al,%esi
  801605:	83 c4 10             	add    $0x10,%esp
  801608:	85 f6                	test   %esi,%esi
  80160a:	0f 84 88 00 00 00    	je     801698 <lwip_sendto+0x12e>
  if (buf.p != NULL) {
  801610:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  801613:	85 c0                	test   %eax,%eax
  801615:	74 0c                	je     801623 <lwip_sendto+0xb9>
    pbuf_free(buf.p);
  801617:	83 ec 0c             	sub    $0xc,%esp
  80161a:	50                   	push   %eax
  80161b:	e8 2c 32 00 00       	call   80484c <pbuf_free>
  801620:	83 c4 10             	add    $0x10,%esp
  sock_set_errno(sock, err_to_errno(err));
  801623:	89 f2                	mov    %esi,%edx
  801625:	f7 da                	neg    %edx
  801627:	b8 05 00 00 00       	mov    $0x5,%eax
  80162c:	83 fa 0e             	cmp    $0xe,%edx
  80162f:	77 07                	ja     801638 <lwip_sendto+0xce>
  801631:	8b 04 95 60 0f 81 00 	mov    0x810f60(,%edx,4),%eax
  801638:	89 43 10             	mov    %eax,0x10(%ebx)
  80163b:	a3 34 50 81 00       	mov    %eax,0x815034
  return (err==ERR_OK?size:-1);
  801640:	85 f6                	test   %esi,%esi
  801642:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801647:	0f 45 f8             	cmovne %eax,%edi
}
  80164a:	89 f8                	mov    %edi,%eax
  80164c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80164f:	5b                   	pop    %ebx
  801650:	5e                   	pop    %esi
  801651:	5f                   	pop    %edi
  801652:	5d                   	pop    %ebp
  801653:	c3                   	ret    
    return lwip_send(s, data, size, flags);
  801654:	ff 75 14             	push   0x14(%ebp)
  801657:	57                   	push   %edi
  801658:	ff 75 0c             	push   0xc(%ebp)
  80165b:	ff 75 08             	push   0x8(%ebp)
  80165e:	e8 74 00 00 00       	call   8016d7 <lwip_send>
  801663:	89 c7                	mov    %eax,%edi
  801665:	83 c4 10             	add    $0x10,%esp
  801668:	eb e0                	jmp    80164a <lwip_sendto+0xe0>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  80166a:	83 ec 04             	sub    $0x4,%esp
  80166d:	68 20 0f 81 00       	push   $0x810f20
  801672:	68 96 02 00 00       	push   $0x296
  801677:	68 90 0e 81 00       	push   $0x810e90
  80167c:	e8 55 ce 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801681:	83 ec 04             	sub    $0x4,%esp
  801684:	68 01 0f 81 00       	push   $0x810f01
  801689:	68 98 02 00 00       	push   $0x298
  80168e:	68 90 0e 81 00       	push   $0x810e90
  801693:	e8 3e ce 00 00       	call   80e4d6 <_panic>
    err = netconn_send(sock->conn, &buf);
  801698:	83 ec 08             	sub    $0x8,%esp
  80169b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80169e:	50                   	push   %eax
  80169f:	ff 33                	push   (%ebx)
  8016a1:	e8 d4 99 00 00       	call   80b07a <netconn_send>
  8016a6:	0f be f0             	movsbl %al,%esi
  8016a9:	83 c4 10             	add    $0x10,%esp
  8016ac:	e9 5f ff ff ff       	jmp    801610 <lwip_sendto+0xa6>
    return -1;
  8016b1:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  8016b6:	eb 92                	jmp    80164a <lwip_sendto+0xe0>
  buf.p = buf.ptr = NULL;
  8016b8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8016bf:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = 0;
  8016c6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8016cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8016d2:	e9 11 ff ff ff       	jmp    8015e8 <lwip_sendto+0x7e>

008016d7 <lwip_send>:
{
  8016d7:	55                   	push   %ebp
  8016d8:	89 e5                	mov    %esp,%ebp
  8016da:	57                   	push   %edi
  8016db:	56                   	push   %esi
  8016dc:	53                   	push   %ebx
  8016dd:	83 ec 0c             	sub    $0xc,%esp
  8016e0:	8b 7d 08             	mov    0x8(%ebp),%edi
  8016e3:	8b 75 10             	mov    0x10(%ebp),%esi
  sock = get_socket(s);
  8016e6:	89 f8                	mov    %edi,%eax
  8016e8:	e8 e7 f0 ff ff       	call   8007d4 <get_socket>
  if (!sock)
  8016ed:	85 c0                	test   %eax,%eax
  8016ef:	74 6d                	je     80175e <lwip_send+0x87>
  8016f1:	89 c3                	mov    %eax,%ebx
  if (sock->conn->type!=NETCONN_TCP) {
  8016f3:	8b 10                	mov    (%eax),%edx
  8016f5:	83 3a 10             	cmpl   $0x10,(%edx)
  8016f8:	74 1f                	je     801719 <lwip_send+0x42>
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8016fa:	83 ec 08             	sub    $0x8,%esp
  8016fd:	6a 00                	push   $0x0
  8016ff:	6a 00                	push   $0x0
  801701:	ff 75 14             	push   0x14(%ebp)
  801704:	56                   	push   %esi
  801705:	ff 75 0c             	push   0xc(%ebp)
  801708:	57                   	push   %edi
  801709:	e8 5c fe ff ff       	call   80156a <lwip_sendto>
  80170e:	83 c4 20             	add    $0x20,%esp
}
  801711:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801714:	5b                   	pop    %ebx
  801715:	5e                   	pop    %esi
  801716:	5f                   	pop    %edi
  801717:	5d                   	pop    %ebp
  801718:	c3                   	ret    
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801719:	8b 45 14             	mov    0x14(%ebp),%eax
  80171c:	c1 e8 03             	shr    $0x3,%eax
  80171f:	83 e0 02             	and    $0x2,%eax
  801722:	83 c8 01             	or     $0x1,%eax
  801725:	50                   	push   %eax
  801726:	56                   	push   %esi
  801727:	ff 75 0c             	push   0xc(%ebp)
  80172a:	52                   	push   %edx
  80172b:	e8 c6 99 00 00       	call   80b0f6 <netconn_write>
  sock_set_errno(sock, err_to_errno(err));
  801730:	0f be d0             	movsbl %al,%edx
  801733:	f7 da                	neg    %edx
  801735:	83 c4 10             	add    $0x10,%esp
  801738:	b9 05 00 00 00       	mov    $0x5,%ecx
  80173d:	83 fa 0e             	cmp    $0xe,%edx
  801740:	77 07                	ja     801749 <lwip_send+0x72>
  801742:	8b 0c 95 60 0f 81 00 	mov    0x810f60(,%edx,4),%ecx
  801749:	89 4b 10             	mov    %ecx,0x10(%ebx)
  80174c:	89 0d 34 50 81 00    	mov    %ecx,0x815034
  return (err==ERR_OK?size:-1);
  801752:	84 c0                	test   %al,%al
  801754:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801759:	0f 44 c6             	cmove  %esi,%eax
  80175c:	eb b3                	jmp    801711 <lwip_send+0x3a>
    return -1;
  80175e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801763:	eb ac                	jmp    801711 <lwip_send+0x3a>

00801765 <lwip_socket>:
{
  801765:	55                   	push   %ebp
  801766:	89 e5                	mov    %esp,%ebp
  801768:	56                   	push   %esi
  801769:	53                   	push   %ebx
  80176a:	8b 45 0c             	mov    0xc(%ebp),%eax
  switch (type) {
  80176d:	83 f8 02             	cmp    $0x2,%eax
  801770:	74 57                	je     8017c9 <lwip_socket+0x64>
  801772:	83 f8 03             	cmp    $0x3,%eax
  801775:	74 11                	je     801788 <lwip_socket+0x23>
  801777:	83 f8 01             	cmp    $0x1,%eax
  80177a:	74 74                	je     8017f0 <lwip_socket+0x8b>
  80177c:	b8 16 00 00 00       	mov    $0x16,%eax
  801781:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801786:	eb 33                	jmp    8017bb <lwip_socket+0x56>
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  801788:	83 ec 04             	sub    $0x4,%esp
  80178b:	68 b8 09 80 00       	push   $0x8009b8
  801790:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  801794:	50                   	push   %eax
  801795:	6a 40                	push   $0x40
  801797:	e8 de 93 00 00       	call   80ab7a <netconn_new_with_proto_and_callback>
  80179c:	89 c6                	mov    %eax,%esi
    break;
  80179e:	83 c4 10             	add    $0x10,%esp
  if (!conn) {
  8017a1:	85 f6                	test   %esi,%esi
  8017a3:	74 76                	je     80181b <lwip_socket+0xb6>
  i = alloc_socket(conn);
  8017a5:	89 f0                	mov    %esi,%eax
  8017a7:	e8 ab f3 ff ff       	call   800b57 <alloc_socket>
  8017ac:	89 c3                	mov    %eax,%ebx
  if (i == -1) {
  8017ae:	83 f8 ff             	cmp    $0xffffffff,%eax
  8017b1:	74 55                	je     801808 <lwip_socket+0xa3>
  conn->socket = i;
  8017b3:	89 46 1c             	mov    %eax,0x1c(%esi)
  return i;
  8017b6:	b8 00 00 00 00       	mov    $0x0,%eax
    set_errno(EINVAL);
  8017bb:	a3 34 50 81 00       	mov    %eax,0x815034
}
  8017c0:	89 d8                	mov    %ebx,%eax
  8017c2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8017c5:	5b                   	pop    %ebx
  8017c6:	5e                   	pop    %esi
  8017c7:	5d                   	pop    %ebp
  8017c8:	c3                   	ret    
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  8017c9:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  8017d0:	0f 94 c0             	sete   %al
  8017d3:	0f b6 c0             	movzbl %al,%eax
  8017d6:	83 c0 20             	add    $0x20,%eax
  8017d9:	83 ec 04             	sub    $0x4,%esp
  8017dc:	68 b8 09 80 00       	push   $0x8009b8
  8017e1:	6a 00                	push   $0x0
  8017e3:	50                   	push   %eax
  8017e4:	e8 91 93 00 00       	call   80ab7a <netconn_new_with_proto_and_callback>
  8017e9:	89 c6                	mov    %eax,%esi
    break;
  8017eb:	83 c4 10             	add    $0x10,%esp
  8017ee:	eb b1                	jmp    8017a1 <lwip_socket+0x3c>
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8017f0:	83 ec 04             	sub    $0x4,%esp
  8017f3:	68 b8 09 80 00       	push   $0x8009b8
  8017f8:	6a 00                	push   $0x0
  8017fa:	6a 10                	push   $0x10
  8017fc:	e8 79 93 00 00       	call   80ab7a <netconn_new_with_proto_and_callback>
  801801:	89 c6                	mov    %eax,%esi
    break;
  801803:	83 c4 10             	add    $0x10,%esp
  801806:	eb 99                	jmp    8017a1 <lwip_socket+0x3c>
    netconn_delete(conn);
  801808:	83 ec 0c             	sub    $0xc,%esp
  80180b:	56                   	push   %esi
  80180c:	e8 44 94 00 00       	call   80ac55 <netconn_delete>
    return -1;
  801811:	83 c4 10             	add    $0x10,%esp
  801814:	b8 17 00 00 00       	mov    $0x17,%eax
  801819:	eb a0                	jmp    8017bb <lwip_socket+0x56>
  80181b:	b8 69 00 00 00       	mov    $0x69,%eax
    return -1;
  801820:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801825:	eb 94                	jmp    8017bb <lwip_socket+0x56>

00801827 <lwip_write>:
{
  801827:	55                   	push   %ebp
  801828:	89 e5                	mov    %esp,%ebp
  80182a:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  80182d:	6a 00                	push   $0x0
  80182f:	ff 75 10             	push   0x10(%ebp)
  801832:	ff 75 0c             	push   0xc(%ebp)
  801835:	ff 75 08             	push   0x8(%ebp)
  801838:	e8 9a fe ff ff       	call   8016d7 <lwip_send>
}
  80183d:	c9                   	leave  
  80183e:	c3                   	ret    

0080183f <lwip_select>:
{
  80183f:	55                   	push   %ebp
  801840:	89 e5                	mov    %esp,%ebp
  801842:	57                   	push   %edi
  801843:	56                   	push   %esi
  801844:	53                   	push   %ebx
  801845:	83 ec 58             	sub    $0x58,%esp
  801848:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80184b:	8b 75 10             	mov    0x10(%ebp),%esi
  80184e:	8b 7d 14             	mov    0x14(%ebp),%edi
  select_cb.next = 0;
  801851:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801858:	89 5d c8             	mov    %ebx,-0x38(%ebp)
  select_cb.writeset = writeset;
  80185b:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  80185e:	89 7d d0             	mov    %edi,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801861:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  sys_sem_wait(selectsem);
  801868:	ff 35 80 50 81 00    	push   0x815080
  80186e:	e8 95 38 00 00       	call   805108 <sys_sem_wait>
  if (readset)
  801873:	83 c4 10             	add    $0x10,%esp
  801876:	85 db                	test   %ebx,%ebx
  801878:	0f 84 0b 01 00 00    	je     801989 <lwip_select+0x14a>
    lreadset = *readset;
  80187e:	8b 03                	mov    (%ebx),%eax
  801880:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (writeset)
  801883:	85 f6                	test   %esi,%esi
  801885:	0f 84 16 01 00 00    	je     8019a1 <lwip_select+0x162>
    lwriteset = *writeset;
  80188b:	8b 06                	mov    (%esi),%eax
  80188d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (exceptset)
  801890:	85 ff                	test   %edi,%edi
  801892:	0f 84 21 01 00 00    	je     8019b9 <lwip_select+0x17a>
    lexceptset = *exceptset;
  801898:	8b 07                	mov    (%edi),%eax
  80189a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  80189d:	83 ec 0c             	sub    $0xc,%esp
  8018a0:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8018a3:	50                   	push   %eax
  8018a4:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8018a7:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8018aa:	8b 45 08             	mov    0x8(%ebp),%eax
  8018ad:	e8 61 ef ff ff       	call   800813 <lwip_selscan>
  8018b2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if (!nready) {
  8018b5:	83 c4 10             	add    $0x10,%esp
  8018b8:	85 c0                	test   %eax,%eax
  8018ba:	0f 85 90 02 00 00    	jne    801b50 <lwip_select+0x311>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  8018c0:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8018c4:	0f 84 9c 02 00 00    	je     801b66 <lwip_select+0x327>
  8018ca:	8b 45 18             	mov    0x18(%ebp),%eax
  8018cd:	83 38 00             	cmpl   $0x0,(%eax)
  8018d0:	75 0e                	jne    8018e0 <lwip_select+0xa1>
  8018d2:	8b 40 04             	mov    0x4(%eax),%eax
  8018d5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  8018d8:	85 c0                	test   %eax,%eax
  8018da:	0f 84 f1 00 00 00    	je     8019d1 <lwip_select+0x192>
    select_cb.sem = sys_sem_new(0);
  8018e0:	83 ec 0c             	sub    $0xc,%esp
  8018e3:	6a 00                	push   $0x0
  8018e5:	e8 7a 84 00 00       	call   809d64 <sys_sem_new>
  8018ea:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  8018ed:	a1 88 50 81 00       	mov    0x815088,%eax
  8018f2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  8018f5:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  8018f8:	a3 88 50 81 00       	mov    %eax,0x815088
    sys_sem_signal(selectsem);
  8018fd:	83 c4 04             	add    $0x4,%esp
  801900:	ff 35 80 50 81 00    	push   0x815080
  801906:	e8 16 87 00 00       	call   80a021 <sys_sem_signal>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  80190b:	8b 45 18             	mov    0x18(%ebp),%eax
  80190e:	8b 40 04             	mov    0x4(%eax),%eax
  801911:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801914:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  80191a:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80191f:	89 c8                	mov    %ecx,%eax
  801921:	f7 ea                	imul   %edx
  801923:	c1 fa 06             	sar    $0x6,%edx
  801926:	c1 f9 1f             	sar    $0x1f,%ecx
  801929:	29 ca                	sub    %ecx,%edx
  80192b:	8b 45 18             	mov    0x18(%ebp),%eax
  80192e:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
  801934:	01 c2                	add    %eax,%edx
  801936:	b8 01 00 00 00       	mov    $0x1,%eax
  80193b:	0f 44 d0             	cmove  %eax,%edx
  80193e:	83 c4 10             	add    $0x10,%esp
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  801941:	83 ec 08             	sub    $0x8,%esp
  801944:	52                   	push   %edx
  801945:	ff 75 d8             	push   -0x28(%ebp)
  801948:	e8 87 39 00 00       	call   8052d4 <sys_sem_wait_timeout>
  80194d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    sys_sem_wait(selectsem);
  801950:	83 c4 04             	add    $0x4,%esp
  801953:	ff 35 80 50 81 00    	push   0x815080
  801959:	e8 aa 37 00 00       	call   805108 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  80195e:	a1 88 50 81 00       	mov    0x815088,%eax
  801963:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  801966:	83 c4 10             	add    $0x10,%esp
        if (p_selcb->next == &select_cb) {
  801969:	89 d1                	mov    %edx,%ecx
    if (select_cb_list == &select_cb)
  80196b:	39 d0                	cmp    %edx,%eax
  80196d:	0f 84 b4 00 00 00    	je     801a27 <lwip_select+0x1e8>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801973:	85 c0                	test   %eax,%eax
  801975:	0f 84 bb 00 00 00    	je     801a36 <lwip_select+0x1f7>
        if (p_selcb->next == &select_cb) {
  80197b:	8b 10                	mov    (%eax),%edx
  80197d:	39 ca                	cmp    %ecx,%edx
  80197f:	0f 84 ac 00 00 00    	je     801a31 <lwip_select+0x1f2>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801985:	89 d0                	mov    %edx,%eax
  801987:	eb ea                	jmp    801973 <lwip_select+0x134>
    FD_ZERO(&lreadset);
  801989:	83 ec 04             	sub    $0x4,%esp
  80198c:	6a 04                	push   $0x4
  80198e:	6a 00                	push   $0x0
  801990:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801993:	50                   	push   %eax
  801994:	e8 42 d3 00 00       	call   80ecdb <memset>
  801999:	83 c4 10             	add    $0x10,%esp
  80199c:	e9 e2 fe ff ff       	jmp    801883 <lwip_select+0x44>
    FD_ZERO(&lwriteset);
  8019a1:	83 ec 04             	sub    $0x4,%esp
  8019a4:	6a 04                	push   $0x4
  8019a6:	6a 00                	push   $0x0
  8019a8:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8019ab:	50                   	push   %eax
  8019ac:	e8 2a d3 00 00       	call   80ecdb <memset>
  8019b1:	83 c4 10             	add    $0x10,%esp
  8019b4:	e9 d7 fe ff ff       	jmp    801890 <lwip_select+0x51>
    FD_ZERO(&lexceptset);
  8019b9:	83 ec 04             	sub    $0x4,%esp
  8019bc:	6a 04                	push   $0x4
  8019be:	6a 00                	push   $0x0
  8019c0:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8019c3:	50                   	push   %eax
  8019c4:	e8 12 d3 00 00       	call   80ecdb <memset>
  8019c9:	83 c4 10             	add    $0x10,%esp
  8019cc:	e9 cc fe ff ff       	jmp    80189d <lwip_select+0x5e>
      sys_sem_signal(selectsem);
  8019d1:	83 ec 0c             	sub    $0xc,%esp
  8019d4:	ff 35 80 50 81 00    	push   0x815080
  8019da:	e8 42 86 00 00       	call   80a021 <sys_sem_signal>
      if (readset)
  8019df:	83 c4 10             	add    $0x10,%esp
  8019e2:	85 db                	test   %ebx,%ebx
  8019e4:	74 10                	je     8019f6 <lwip_select+0x1b7>
        FD_ZERO(readset);
  8019e6:	83 ec 04             	sub    $0x4,%esp
  8019e9:	6a 04                	push   $0x4
  8019eb:	6a 00                	push   $0x0
  8019ed:	53                   	push   %ebx
  8019ee:	e8 e8 d2 00 00       	call   80ecdb <memset>
  8019f3:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  8019f6:	85 f6                	test   %esi,%esi
  8019f8:	74 10                	je     801a0a <lwip_select+0x1cb>
        FD_ZERO(writeset);
  8019fa:	83 ec 04             	sub    $0x4,%esp
  8019fd:	6a 04                	push   $0x4
  8019ff:	6a 00                	push   $0x0
  801a01:	56                   	push   %esi
  801a02:	e8 d4 d2 00 00       	call   80ecdb <memset>
  801a07:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801a0a:	85 ff                	test   %edi,%edi
  801a0c:	0f 84 a3 00 00 00    	je     801ab5 <lwip_select+0x276>
        FD_ZERO(exceptset);
  801a12:	83 ec 04             	sub    $0x4,%esp
  801a15:	6a 04                	push   $0x4
  801a17:	6a 00                	push   $0x0
  801a19:	57                   	push   %edi
  801a1a:	e8 bc d2 00 00       	call   80ecdb <memset>
  801a1f:	83 c4 10             	add    $0x10,%esp
      return 0;
  801a22:	e9 8e 00 00 00       	jmp    801ab5 <lwip_select+0x276>
      select_cb_list = select_cb.next;
  801a27:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801a2a:	a3 88 50 81 00       	mov    %eax,0x815088
  801a2f:	eb 05                	jmp    801a36 <lwip_select+0x1f7>
          p_selcb->next = select_cb.next;
  801a31:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801a34:	89 10                	mov    %edx,(%eax)
    sys_sem_signal(selectsem);
  801a36:	83 ec 0c             	sub    $0xc,%esp
  801a39:	ff 35 80 50 81 00    	push   0x815080
  801a3f:	e8 dd 85 00 00       	call   80a021 <sys_sem_signal>
    sys_sem_free(select_cb.sem);
  801a44:	83 c4 04             	add    $0x4,%esp
  801a47:	ff 75 d8             	push   -0x28(%ebp)
  801a4a:	e8 96 83 00 00       	call   809de5 <sys_sem_free>
    if (i == 0)  {
  801a4f:	83 c4 10             	add    $0x10,%esp
  801a52:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801a56:	74 72                	je     801aca <lwip_select+0x28b>
    if (readset)
  801a58:	85 db                	test   %ebx,%ebx
  801a5a:	0f 84 a8 00 00 00    	je     801b08 <lwip_select+0x2c9>
      lreadset = *readset;
  801a60:	8b 03                	mov    (%ebx),%eax
  801a62:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (writeset)
  801a65:	85 f6                	test   %esi,%esi
  801a67:	0f 84 b3 00 00 00    	je     801b20 <lwip_select+0x2e1>
      lwriteset = *writeset;
  801a6d:	8b 06                	mov    (%esi),%eax
  801a6f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (exceptset)
  801a72:	85 ff                	test   %edi,%edi
  801a74:	0f 84 be 00 00 00    	je     801b38 <lwip_select+0x2f9>
      lexceptset = *exceptset;
  801a7a:	8b 07                	mov    (%edi),%eax
  801a7c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801a7f:	83 ec 0c             	sub    $0xc,%esp
  801a82:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a85:	50                   	push   %eax
  801a86:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801a89:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801a8c:	8b 45 08             	mov    0x8(%ebp),%eax
  801a8f:	e8 7f ed ff ff       	call   800813 <lwip_selscan>
  801a94:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801a97:	83 c4 10             	add    $0x10,%esp
  if (readset)
  801a9a:	85 db                	test   %ebx,%ebx
  801a9c:	74 05                	je     801aa3 <lwip_select+0x264>
    *readset = lreadset;
  801a9e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801aa1:	89 03                	mov    %eax,(%ebx)
  if (writeset)
  801aa3:	85 f6                	test   %esi,%esi
  801aa5:	74 05                	je     801aac <lwip_select+0x26d>
    *writeset = lwriteset;
  801aa7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801aaa:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801aac:	85 ff                	test   %edi,%edi
  801aae:	74 05                	je     801ab5 <lwip_select+0x276>
    *exceptset = lexceptset;
  801ab0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801ab3:	89 07                	mov    %eax,(%edi)
      set_errno(0);
  801ab5:	c7 05 34 50 81 00 00 	movl   $0x0,0x815034
  801abc:	00 00 00 
}
  801abf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801ac2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801ac5:	5b                   	pop    %ebx
  801ac6:	5e                   	pop    %esi
  801ac7:	5f                   	pop    %edi
  801ac8:	5d                   	pop    %ebp
  801ac9:	c3                   	ret    
      if (readset)
  801aca:	85 db                	test   %ebx,%ebx
  801acc:	74 10                	je     801ade <lwip_select+0x29f>
        FD_ZERO(readset);
  801ace:	83 ec 04             	sub    $0x4,%esp
  801ad1:	6a 04                	push   $0x4
  801ad3:	6a 00                	push   $0x0
  801ad5:	53                   	push   %ebx
  801ad6:	e8 00 d2 00 00       	call   80ecdb <memset>
  801adb:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801ade:	85 f6                	test   %esi,%esi
  801ae0:	74 10                	je     801af2 <lwip_select+0x2b3>
        FD_ZERO(writeset);
  801ae2:	83 ec 04             	sub    $0x4,%esp
  801ae5:	6a 04                	push   $0x4
  801ae7:	6a 00                	push   $0x0
  801ae9:	56                   	push   %esi
  801aea:	e8 ec d1 00 00       	call   80ecdb <memset>
  801aef:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801af2:	85 ff                	test   %edi,%edi
  801af4:	74 bf                	je     801ab5 <lwip_select+0x276>
        FD_ZERO(exceptset);
  801af6:	83 ec 04             	sub    $0x4,%esp
  801af9:	6a 04                	push   $0x4
  801afb:	6a 00                	push   $0x0
  801afd:	57                   	push   %edi
  801afe:	e8 d8 d1 00 00       	call   80ecdb <memset>
  801b03:	83 c4 10             	add    $0x10,%esp
      return 0;
  801b06:	eb ad                	jmp    801ab5 <lwip_select+0x276>
      FD_ZERO(&lreadset);
  801b08:	83 ec 04             	sub    $0x4,%esp
  801b0b:	6a 04                	push   $0x4
  801b0d:	6a 00                	push   $0x0
  801b0f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801b12:	50                   	push   %eax
  801b13:	e8 c3 d1 00 00       	call   80ecdb <memset>
  801b18:	83 c4 10             	add    $0x10,%esp
  801b1b:	e9 45 ff ff ff       	jmp    801a65 <lwip_select+0x226>
      FD_ZERO(&lwriteset);
  801b20:	83 ec 04             	sub    $0x4,%esp
  801b23:	6a 04                	push   $0x4
  801b25:	6a 00                	push   $0x0
  801b27:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801b2a:	50                   	push   %eax
  801b2b:	e8 ab d1 00 00       	call   80ecdb <memset>
  801b30:	83 c4 10             	add    $0x10,%esp
  801b33:	e9 3a ff ff ff       	jmp    801a72 <lwip_select+0x233>
      FD_ZERO(&lexceptset);
  801b38:	83 ec 04             	sub    $0x4,%esp
  801b3b:	6a 04                	push   $0x4
  801b3d:	6a 00                	push   $0x0
  801b3f:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b42:	50                   	push   %eax
  801b43:	e8 93 d1 00 00       	call   80ecdb <memset>
  801b48:	83 c4 10             	add    $0x10,%esp
  801b4b:	e9 2f ff ff ff       	jmp    801a7f <lwip_select+0x240>
    sys_sem_signal(selectsem);
  801b50:	83 ec 0c             	sub    $0xc,%esp
  801b53:	ff 35 80 50 81 00    	push   0x815080
  801b59:	e8 c3 84 00 00       	call   80a021 <sys_sem_signal>
  801b5e:	83 c4 10             	add    $0x10,%esp
  801b61:	e9 34 ff ff ff       	jmp    801a9a <lwip_select+0x25b>
    select_cb.sem = sys_sem_new(0);
  801b66:	83 ec 0c             	sub    $0xc,%esp
  801b69:	6a 00                	push   $0x0
  801b6b:	e8 f4 81 00 00       	call   809d64 <sys_sem_new>
  801b70:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801b73:	a1 88 50 81 00       	mov    0x815088,%eax
  801b78:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801b7b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801b7e:	a3 88 50 81 00       	mov    %eax,0x815088
    sys_sem_signal(selectsem);
  801b83:	83 c4 04             	add    $0x4,%esp
  801b86:	ff 35 80 50 81 00    	push   0x815080
  801b8c:	e8 90 84 00 00       	call   80a021 <sys_sem_signal>
  801b91:	83 c4 10             	add    $0x10,%esp
      msectimeout = 0;
  801b94:	ba 00 00 00 00       	mov    $0x0,%edx
  801b99:	e9 a3 fd ff ff       	jmp    801941 <lwip_select+0x102>

00801b9e <lwip_shutdown>:
{
  801b9e:	55                   	push   %ebp
  801b9f:	89 e5                	mov    %esp,%ebp
  801ba1:	83 ec 14             	sub    $0x14,%esp
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801ba4:	ff 75 08             	push   0x8(%ebp)
  801ba7:	e8 7d f5 ff ff       	call   801129 <lwip_close>
}
  801bac:	c9                   	leave  
  801bad:	c3                   	ret    

00801bae <lwip_getpeername>:
{
  801bae:	55                   	push   %ebp
  801baf:	89 e5                	mov    %esp,%ebp
  801bb1:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801bb4:	6a 00                	push   $0x0
  801bb6:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801bb9:	8b 55 0c             	mov    0xc(%ebp),%edx
  801bbc:	8b 45 08             	mov    0x8(%ebp),%eax
  801bbf:	e8 49 ed ff ff       	call   80090d <lwip_getaddrname>
}
  801bc4:	c9                   	leave  
  801bc5:	c3                   	ret    

00801bc6 <lwip_getsockname>:
{
  801bc6:	55                   	push   %ebp
  801bc7:	89 e5                	mov    %esp,%ebp
  801bc9:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801bcc:	6a 01                	push   $0x1
  801bce:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801bd1:	8b 55 0c             	mov    0xc(%ebp),%edx
  801bd4:	8b 45 08             	mov    0x8(%ebp),%eax
  801bd7:	e8 31 ed ff ff       	call   80090d <lwip_getaddrname>
}
  801bdc:	c9                   	leave  
  801bdd:	c3                   	ret    

00801bde <lwip_getsockopt>:
{
  801bde:	55                   	push   %ebp
  801bdf:	89 e5                	mov    %esp,%ebp
  801be1:	57                   	push   %edi
  801be2:	56                   	push   %esi
  801be3:	53                   	push   %ebx
  801be4:	83 ec 2c             	sub    $0x2c,%esp
  801be7:	8b 75 0c             	mov    0xc(%ebp),%esi
  801bea:	8b 7d 18             	mov    0x18(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801bed:	8b 45 08             	mov    0x8(%ebp),%eax
  801bf0:	e8 df eb ff ff       	call   8007d4 <get_socket>
  if (!sock)
  801bf5:	85 c0                	test   %eax,%eax
  801bf7:	0f 84 a6 01 00 00    	je     801da3 <lwip_getsockopt+0x1c5>
  801bfd:	89 c3                	mov    %eax,%ebx
  if ((NULL == optval) || (NULL == optlen)) {
  801bff:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801c03:	74 37                	je     801c3c <lwip_getsockopt+0x5e>
  801c05:	85 ff                	test   %edi,%edi
  801c07:	74 33                	je     801c3c <lwip_getsockopt+0x5e>
  switch (level) {
  801c09:	83 fe 06             	cmp    $0x6,%esi
  801c0c:	0f 84 2f 01 00 00    	je     801d41 <lwip_getsockopt+0x163>
  801c12:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801c18:	74 3d                	je     801c57 <lwip_getsockopt+0x79>
  801c1a:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801c1f:	85 f6                	test   %esi,%esi
  801c21:	0f 84 a8 00 00 00    	je     801ccf <lwip_getsockopt+0xf1>
    sock_set_errno(sock, err);
  801c27:	0f be c0             	movsbl %al,%eax
  801c2a:	89 43 10             	mov    %eax,0x10(%ebx)
  801c2d:	a3 34 50 81 00       	mov    %eax,0x815034
    return -1;
  801c32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c37:	e9 fd 00 00 00       	jmp    801d39 <lwip_getsockopt+0x15b>
    sock_set_errno(sock, EFAULT);
  801c3c:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801c43:	c7 05 34 50 81 00 0e 	movl   $0xe,0x815034
  801c4a:	00 00 00 
    return -1;
  801c4d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c52:	e9 e2 00 00 00       	jmp    801d39 <lwip_getsockopt+0x15b>
  801c57:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801c5e:	7e 34                	jle    801c94 <lwip_getsockopt+0xb6>
  801c60:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801c65:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801c6c:	75 b9                	jne    801c27 <lwip_getsockopt+0x49>
        err = EINVAL;
  801c6e:	83 3f 04             	cmpl   $0x4,(%edi)
  801c71:	19 c0                	sbb    %eax,%eax
  801c73:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801c76:	8b 13                	mov    (%ebx),%edx
  801c78:	83 3a 20             	cmpl   $0x20,(%edx)
  801c7b:	0f 85 f0 00 00 00    	jne    801d71 <lwip_getsockopt+0x193>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801c81:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801c84:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801c88:	0f 85 ed 00 00 00    	jne    801d7b <lwip_getsockopt+0x19d>
  if (err != ERR_OK) {
  801c8e:	84 c0                	test   %al,%al
  801c90:	74 55                	je     801ce7 <lwip_getsockopt+0x109>
  801c92:	eb 93                	jmp    801c27 <lwip_getsockopt+0x49>
  801c94:	81 7d 10 06 10 00 00 	cmpl   $0x1006,0x10(%ebp)
  801c9b:	7f 23                	jg     801cc0 <lwip_getsockopt+0xe2>
  801c9d:	8b 45 10             	mov    0x10(%ebp),%eax
  801ca0:	83 e8 02             	sub    $0x2,%eax
  801ca3:	83 f8 1e             	cmp    $0x1e,%eax
  801ca6:	0f 87 bb 00 00 00    	ja     801d67 <lwip_getsockopt+0x189>
  801cac:	ba 41 00 00 40       	mov    $0x40000041,%edx
  801cb1:	0f a3 c2             	bt     %eax,%edx
  801cb4:	72 0a                	jb     801cc0 <lwip_getsockopt+0xe2>
  801cb6:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cbb:	e9 67 ff ff ff       	jmp    801c27 <lwip_getsockopt+0x49>
      if (*optlen < sizeof(int)) {
  801cc0:	83 3f 03             	cmpl   $0x3,(%edi)
  801cc3:	77 22                	ja     801ce7 <lwip_getsockopt+0x109>
        err = EINVAL;
  801cc5:	b8 16 00 00 00       	mov    $0x16,%eax
  801cca:	e9 58 ff ff ff       	jmp    801c27 <lwip_getsockopt+0x49>
  801ccf:	8b 45 10             	mov    0x10(%ebp),%eax
  801cd2:	83 e8 01             	sub    $0x1,%eax
  801cd5:	83 f8 01             	cmp    $0x1,%eax
  801cd8:	0f 87 a7 00 00 00    	ja     801d85 <lwip_getsockopt+0x1a7>
      if (*optlen < sizeof(int)) {
  801cde:	83 3f 03             	cmpl   $0x3,(%edi)
  801ce1:	0f 86 a8 00 00 00    	jbe    801d8f <lwip_getsockopt+0x1b1>
  data.sock = sock;
  801ce7:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801cea:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801ced:	8b 45 10             	mov    0x10(%ebp),%eax
  801cf0:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801cf3:	8b 45 14             	mov    0x14(%ebp),%eax
  801cf6:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801cf9:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801cfc:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801d00:	83 ec 04             	sub    $0x4,%esp
  801d03:	6a 01                	push   $0x1
  801d05:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801d08:	50                   	push   %eax
  801d09:	68 ff 0b 80 00       	push   $0x800bff
  801d0e:	e8 d1 05 00 00       	call   8022e4 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801d13:	83 c4 08             	add    $0x8,%esp
  801d16:	6a 00                	push   $0x0
  801d18:	8b 03                	mov    (%ebx),%eax
  801d1a:	ff 70 10             	push   0x10(%eax)
  801d1d:	e8 6f 83 00 00       	call   80a091 <sys_arch_sem_wait>
  err = data.err;
  801d22:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801d26:	0f be d0             	movsbl %al,%edx
  801d29:	89 53 10             	mov    %edx,0x10(%ebx)
  801d2c:	89 15 34 50 81 00    	mov    %edx,0x815034
  return err ? -1 : 0;
  801d32:	83 c4 10             	add    $0x10,%esp
  801d35:	f6 d8                	neg    %al
  801d37:	19 c0                	sbb    %eax,%eax
}
  801d39:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801d3c:	5b                   	pop    %ebx
  801d3d:	5e                   	pop    %esi
  801d3e:	5f                   	pop    %edi
  801d3f:	5d                   	pop    %ebp
  801d40:	c3                   	ret    
    if (*optlen < sizeof(int)) {
  801d41:	83 3f 03             	cmpl   $0x3,(%edi)
  801d44:	76 53                	jbe    801d99 <lwip_getsockopt+0x1bb>
    if (sock->conn->type != NETCONN_TCP)
  801d46:	8b 10                	mov    (%eax),%edx
      return 0;
  801d48:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801d4d:	83 3a 10             	cmpl   $0x10,(%edx)
  801d50:	75 e7                	jne    801d39 <lwip_getsockopt+0x15b>
  801d52:	8b 45 10             	mov    0x10(%ebp),%eax
  801d55:	83 e8 01             	sub    $0x1,%eax
  801d58:	83 f8 01             	cmp    $0x1,%eax
  801d5b:	76 8a                	jbe    801ce7 <lwip_getsockopt+0x109>
      err = ENOPROTOOPT;
  801d5d:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d62:	e9 c0 fe ff ff       	jmp    801c27 <lwip_getsockopt+0x49>
  801d67:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d6c:	e9 b6 fe ff ff       	jmp    801c27 <lwip_getsockopt+0x49>
        err = EAFNOSUPPORT;
  801d71:	b8 61 00 00 00       	mov    $0x61,%eax
  801d76:	e9 ac fe ff ff       	jmp    801c27 <lwip_getsockopt+0x49>
  801d7b:	b8 61 00 00 00       	mov    $0x61,%eax
  801d80:	e9 a2 fe ff ff       	jmp    801c27 <lwip_getsockopt+0x49>
      err = ENOPROTOOPT;
  801d85:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d8a:	e9 98 fe ff ff       	jmp    801c27 <lwip_getsockopt+0x49>
        err = EINVAL;
  801d8f:	b8 16 00 00 00       	mov    $0x16,%eax
  801d94:	e9 8e fe ff ff       	jmp    801c27 <lwip_getsockopt+0x49>
      err = EINVAL;
  801d99:	b8 16 00 00 00       	mov    $0x16,%eax
  801d9e:	e9 84 fe ff ff       	jmp    801c27 <lwip_getsockopt+0x49>
    return -1;
  801da3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801da8:	eb 8f                	jmp    801d39 <lwip_getsockopt+0x15b>

00801daa <lwip_setsockopt>:
{
  801daa:	55                   	push   %ebp
  801dab:	89 e5                	mov    %esp,%ebp
  801dad:	57                   	push   %edi
  801dae:	56                   	push   %esi
  801daf:	53                   	push   %ebx
  801db0:	83 ec 2c             	sub    $0x2c,%esp
  801db3:	8b 75 0c             	mov    0xc(%ebp),%esi
  801db6:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801db9:	8b 45 08             	mov    0x8(%ebp),%eax
  801dbc:	e8 13 ea ff ff       	call   8007d4 <get_socket>
  if (!sock)
  801dc1:	85 c0                	test   %eax,%eax
  801dc3:	0f 84 63 01 00 00    	je     801f2c <lwip_setsockopt+0x182>
  801dc9:	89 c3                	mov    %eax,%ebx
  if (NULL == optval) {
  801dcb:	85 ff                	test   %edi,%edi
  801dcd:	74 2c                	je     801dfb <lwip_setsockopt+0x51>
  switch (level) {
  801dcf:	83 fe 06             	cmp    $0x6,%esi
  801dd2:	0f 84 fb 00 00 00    	je     801ed3 <lwip_setsockopt+0x129>
  801dd8:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801dde:	74 36                	je     801e16 <lwip_setsockopt+0x6c>
  801de0:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801de5:	85 f6                	test   %esi,%esi
  801de7:	74 7b                	je     801e64 <lwip_setsockopt+0xba>
    sock_set_errno(sock, err);
  801de9:	89 43 10             	mov    %eax,0x10(%ebx)
  801dec:	a3 34 50 81 00       	mov    %eax,0x815034
    return -1;
  801df1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801df6:	e9 d0 00 00 00       	jmp    801ecb <lwip_setsockopt+0x121>
    sock_set_errno(sock, EFAULT);
  801dfb:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801e02:	c7 05 34 50 81 00 0e 	movl   $0xe,0x815034
  801e09:	00 00 00 
    return -1;
  801e0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e11:	e9 b5 00 00 00       	jmp    801ecb <lwip_setsockopt+0x121>
  801e16:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801e1a:	74 14                	je     801e30 <lwip_setsockopt+0x86>
  801e1c:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801e23:	74 18                	je     801e3d <lwip_setsockopt+0x93>
  801e25:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e2a:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801e2e:	75 b9                	jne    801de9 <lwip_setsockopt+0x3f>
      if (optlen < sizeof(int)) {
  801e30:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e34:	77 47                	ja     801e7d <lwip_setsockopt+0xd3>
        err = EINVAL;
  801e36:	b8 16 00 00 00       	mov    $0x16,%eax
  801e3b:	eb ac                	jmp    801de9 <lwip_setsockopt+0x3f>
        err = EINVAL;
  801e3d:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801e41:	19 c0                	sbb    %eax,%eax
  801e43:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801e46:	8b 13                	mov    (%ebx),%edx
  801e48:	83 3a 20             	cmpl   $0x20,(%edx)
  801e4b:	0f 85 a9 00 00 00    	jne    801efa <lwip_setsockopt+0x150>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801e51:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801e54:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801e58:	0f 85 a6 00 00 00    	jne    801f04 <lwip_setsockopt+0x15a>
  if (err != ERR_OK) {
  801e5e:	85 c0                	test   %eax,%eax
  801e60:	74 1b                	je     801e7d <lwip_setsockopt+0xd3>
  801e62:	eb 85                	jmp    801de9 <lwip_setsockopt+0x3f>
  801e64:	8b 45 10             	mov    0x10(%ebp),%eax
  801e67:	83 e8 01             	sub    $0x1,%eax
  801e6a:	83 f8 01             	cmp    $0x1,%eax
  801e6d:	0f 87 9b 00 00 00    	ja     801f0e <lwip_setsockopt+0x164>
      if (optlen < sizeof(int)) {
  801e73:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e77:	0f 86 9b 00 00 00    	jbe    801f18 <lwip_setsockopt+0x16e>
  data.sock = sock;
  801e7d:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801e80:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801e83:	8b 45 10             	mov    0x10(%ebp),%eax
  801e86:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801e89:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801e8c:	8d 45 18             	lea    0x18(%ebp),%eax
  801e8f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801e92:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801e96:	83 ec 04             	sub    $0x4,%esp
  801e99:	6a 01                	push   $0x1
  801e9b:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801e9e:	50                   	push   %eax
  801e9f:	68 84 0d 80 00       	push   $0x800d84
  801ea4:	e8 3b 04 00 00       	call   8022e4 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801ea9:	83 c4 08             	add    $0x8,%esp
  801eac:	6a 00                	push   $0x0
  801eae:	8b 03                	mov    (%ebx),%eax
  801eb0:	ff 70 10             	push   0x10(%eax)
  801eb3:	e8 d9 81 00 00       	call   80a091 <sys_arch_sem_wait>
  err = data.err;
  801eb8:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801ebc:	89 43 10             	mov    %eax,0x10(%ebx)
  801ebf:	a3 34 50 81 00       	mov    %eax,0x815034
  return err ? -1 : 0;
  801ec4:	83 c4 10             	add    $0x10,%esp
  801ec7:	f7 d8                	neg    %eax
  801ec9:	19 c0                	sbb    %eax,%eax
}
  801ecb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801ece:	5b                   	pop    %ebx
  801ecf:	5e                   	pop    %esi
  801ed0:	5f                   	pop    %edi
  801ed1:	5d                   	pop    %ebp
  801ed2:	c3                   	ret    
    if (optlen < sizeof(int)) {
  801ed3:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801ed7:	76 49                	jbe    801f22 <lwip_setsockopt+0x178>
    if (sock->conn->type != NETCONN_TCP)
  801ed9:	8b 10                	mov    (%eax),%edx
      return 0;
  801edb:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801ee0:	83 3a 10             	cmpl   $0x10,(%edx)
  801ee3:	75 e6                	jne    801ecb <lwip_setsockopt+0x121>
  801ee5:	8b 45 10             	mov    0x10(%ebp),%eax
  801ee8:	83 e8 01             	sub    $0x1,%eax
  801eeb:	83 f8 01             	cmp    $0x1,%eax
  801eee:	76 8d                	jbe    801e7d <lwip_setsockopt+0xd3>
      err = ENOPROTOOPT;
  801ef0:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ef5:	e9 ef fe ff ff       	jmp    801de9 <lwip_setsockopt+0x3f>
        err = EAFNOSUPPORT;
  801efa:	b8 61 00 00 00       	mov    $0x61,%eax
  801eff:	e9 e5 fe ff ff       	jmp    801de9 <lwip_setsockopt+0x3f>
  801f04:	b8 61 00 00 00       	mov    $0x61,%eax
  801f09:	e9 db fe ff ff       	jmp    801de9 <lwip_setsockopt+0x3f>
        err = ENOPROTOOPT;
  801f0e:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f13:	e9 d1 fe ff ff       	jmp    801de9 <lwip_setsockopt+0x3f>
        err = EINVAL;
  801f18:	b8 16 00 00 00       	mov    $0x16,%eax
  801f1d:	e9 c7 fe ff ff       	jmp    801de9 <lwip_setsockopt+0x3f>
      err = EINVAL;
  801f22:	b8 16 00 00 00       	mov    $0x16,%eax
  801f27:	e9 bd fe ff ff       	jmp    801de9 <lwip_setsockopt+0x3f>
    return -1;
  801f2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f31:	eb 98                	jmp    801ecb <lwip_setsockopt+0x121>

00801f33 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801f33:	55                   	push   %ebp
  801f34:	89 e5                	mov    %esp,%ebp
  801f36:	56                   	push   %esi
  801f37:	53                   	push   %ebx
  801f38:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801f3b:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801f3e:	8b 45 08             	mov    0x8(%ebp),%eax
  801f41:	e8 8e e8 ff ff       	call   8007d4 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801f46:	85 c0                	test   %eax,%eax
  801f48:	0f 84 b4 00 00 00    	je     802002 <lwip_ioctl+0xcf>
    return -1;

  switch (cmd) {
  801f4e:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801f54:	74 5d                	je     801fb3 <lwip_ioctl+0x80>
  801f56:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  801f5c:	0f 85 88 00 00 00    	jne    801fea <lwip_ioctl+0xb7>
  case FIONREAD:
    if (!argp) {
  801f62:	85 f6                	test   %esi,%esi
  801f64:	74 35                	je     801f9b <lwip_ioctl+0x68>
      sock_set_errno(sock, EINVAL);
      return -1;
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  801f66:	8b 10                	mov    (%eax),%edx
  801f68:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  801f6c:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  801f6f:	8b 48 04             	mov    0x4(%eax),%ecx
  801f72:	85 c9                	test   %ecx,%ecx
  801f74:	74 0d                	je     801f83 <lwip_ioctl+0x50>
      buflen = netbuf_len(sock->lastdata);
  801f76:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  801f78:	66 2b 50 08          	sub    0x8(%eax),%dx
  801f7c:	66 03 51 08          	add    0x8(%ecx),%dx
  801f80:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  801f83:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801f8a:	c7 05 34 50 81 00 00 	movl   $0x0,0x815034
  801f91:	00 00 00 
    return 0;
  801f94:	b8 00 00 00 00       	mov    $0x0,%eax
  801f99:	eb 4b                	jmp    801fe6 <lwip_ioctl+0xb3>
      sock_set_errno(sock, EINVAL);
  801f9b:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  801fa2:	c7 05 34 50 81 00 16 	movl   $0x16,0x815034
  801fa9:	00 00 00 
      return -1;
  801fac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fb1:	eb 33                	jmp    801fe6 <lwip_ioctl+0xb3>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  801fb3:	85 f6                	test   %esi,%esi
  801fb5:	74 0e                	je     801fc5 <lwip_ioctl+0x92>
  801fb7:	83 3e 00             	cmpl   $0x0,(%esi)
  801fba:	74 09                	je     801fc5 <lwip_ioctl+0x92>
      sock->flags |= O_NONBLOCK;
  801fbc:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  801fc0:	80 ce 08             	or     $0x8,%dh
  801fc3:	eb 07                	jmp    801fcc <lwip_ioctl+0x99>
    else
      sock->flags &= ~O_NONBLOCK;
  801fc5:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  801fc9:	80 e6 f7             	and    $0xf7,%dh
  801fcc:	66 89 50 0e          	mov    %dx,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  801fd0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801fd7:	c7 05 34 50 81 00 00 	movl   $0x0,0x815034
  801fde:	00 00 00 
    return 0;
  801fe1:	b8 00 00 00 00       	mov    $0x0,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  801fe6:	5b                   	pop    %ebx
  801fe7:	5e                   	pop    %esi
  801fe8:	5d                   	pop    %ebp
  801fe9:	c3                   	ret    
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  801fea:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  801ff1:	c7 05 34 50 81 00 26 	movl   $0x26,0x815034
  801ff8:	00 00 00 
    return -1;
  801ffb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802000:	eb e4                	jmp    801fe6 <lwip_ioctl+0xb3>
    return -1;
  802002:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802007:	eb dd                	jmp    801fe6 <lwip_ioctl+0xb3>

00802009 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  802009:	55                   	push   %ebp
  80200a:	89 e5                	mov    %esp,%ebp
  80200c:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  80200f:	e8 ab 40 00 00       	call   8060bf <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  802014:	83 3d 4c 44 b3 00 00 	cmpl   $0x0,0xb3444c
  80201b:	74 19                	je     802036 <tcpip_tcp_timer+0x2d>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80201d:	83 ec 04             	sub    $0x4,%esp
  802020:	6a 00                	push   $0x0
  802022:	68 09 20 80 00       	push   $0x802009
  802027:	68 fa 00 00 00       	push   $0xfa
  80202c:	e8 64 31 00 00       	call   805195 <sys_timeout>
  802031:	83 c4 10             	add    $0x10,%esp
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
  802034:	c9                   	leave  
  802035:	c3                   	ret    
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  802036:	83 3d 48 44 b3 00 00 	cmpl   $0x0,0xb34448
  80203d:	75 de                	jne    80201d <tcpip_tcp_timer+0x14>
    tcpip_tcp_timer_active = 0;
  80203f:	c7 05 20 53 81 00 00 	movl   $0x0,0x815320
  802046:	00 00 00 
}
  802049:	eb e9                	jmp    802034 <tcpip_tcp_timer+0x2b>

0080204b <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  80204b:	55                   	push   %ebp
  80204c:	89 e5                	mov    %esp,%ebp
  80204e:	53                   	push   %ebx
  80204f:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802052:	6a 00                	push   $0x0
  802054:	68 fc 21 80 00       	push   $0x8021fc
  802059:	68 e8 03 00 00       	push   $0x3e8
  80205e:	e8 32 31 00 00       	call   805195 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802063:	83 c4 0c             	add    $0xc,%esp
  802066:	6a 00                	push   $0x0
  802068:	68 d8 21 80 00       	push   $0x8021d8
  80206d:	68 88 13 00 00       	push   $0x1388
  802072:	e8 1e 31 00 00       	call   805195 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802077:	83 c4 0c             	add    $0xc,%esp
  80207a:	6a 00                	push   $0x0
  80207c:	68 b4 21 80 00       	push   $0x8021b4
  802081:	68 60 ea 00 00       	push   $0xea60
  802086:	e8 0a 31 00 00       	call   805195 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80208b:	83 c4 0c             	add    $0xc,%esp
  80208e:	6a 00                	push   $0x0
  802090:	68 90 21 80 00       	push   $0x802190
  802095:	68 f4 01 00 00       	push   $0x1f4
  80209a:	e8 f6 30 00 00       	call   805195 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  80209f:	a1 28 53 81 00       	mov    0x815328,%eax
  8020a4:	83 c4 10             	add    $0x10,%esp
  8020a7:	85 c0                	test   %eax,%eax
  8020a9:	74 0e                	je     8020b9 <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  8020ab:	83 ec 0c             	sub    $0xc,%esp
  8020ae:	ff 35 24 53 81 00    	push   0x815324
  8020b4:	ff d0                	call   *%eax
  8020b6:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8020b9:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8020bc:	eb 44                	jmp    802102 <tcpip_thread+0xb7>
    switch (msg->type) {
  8020be:	83 f8 03             	cmp    $0x3,%eax
  8020c1:	75 3f                	jne    802102 <tcpip_thread+0xb7>
      break;

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8020c3:	8b 42 08             	mov    0x8(%edx),%eax
  8020c6:	83 f8 ff             	cmp    $0xffffffff,%eax
  8020c9:	0f 84 ab 00 00 00    	je     80217a <tcpip_thread+0x12f>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8020cf:	83 ec 04             	sub    $0x4,%esp
  8020d2:	ff 72 10             	push   0x10(%edx)
  8020d5:	ff 72 0c             	push   0xc(%edx)
  8020d8:	50                   	push   %eax
  8020d9:	e8 b7 30 00 00       	call   805195 <sys_timeout>
  8020de:	83 c4 10             	add    $0x10,%esp
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8020e1:	83 ec 08             	sub    $0x8,%esp
  8020e4:	ff 75 f4             	push   -0xc(%ebp)
  8020e7:	6a 08                	push   $0x8
  8020e9:	e8 0d 24 00 00       	call   8044fb <memp_free>
      break;
  8020ee:	83 c4 10             	add    $0x10,%esp
  8020f1:	eb 0f                	jmp    802102 <tcpip_thread+0xb7>
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  8020f3:	8b 42 08             	mov    0x8(%edx),%eax
  8020f6:	83 ec 0c             	sub    $0xc,%esp
  8020f9:	8d 50 04             	lea    0x4(%eax),%edx
  8020fc:	52                   	push   %edx
  8020fd:	ff 10                	call   *(%eax)
      break;
  8020ff:	83 c4 10             	add    $0x10,%esp
    sys_mbox_fetch(mbox, (void *)&msg);
  802102:	83 ec 08             	sub    $0x8,%esp
  802105:	53                   	push   %ebx
  802106:	ff 35 00 40 81 00    	push   0x814000
  80210c:	e8 64 2f 00 00       	call   805075 <sys_mbox_fetch>
    switch (msg->type) {
  802111:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802114:	8b 02                	mov    (%edx),%eax
  802116:	83 c4 10             	add    $0x10,%esp
  802119:	83 f8 02             	cmp    $0x2,%eax
  80211c:	74 41                	je     80215f <tcpip_thread+0x114>
  80211e:	77 9e                	ja     8020be <tcpip_thread+0x73>
  802120:	85 c0                	test   %eax,%eax
  802122:	74 cf                	je     8020f3 <tcpip_thread+0xa8>
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  802124:	8b 42 0c             	mov    0xc(%edx),%eax
  802127:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  80212b:	74 21                	je     80214e <tcpip_thread+0x103>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80212d:	83 ec 08             	sub    $0x8,%esp
  802130:	50                   	push   %eax
  802131:	ff 72 08             	push   0x8(%edx)
  802134:	e8 6e 7a 00 00       	call   809ba7 <ethernet_input>
  802139:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  80213c:	83 ec 08             	sub    $0x8,%esp
  80213f:	ff 75 f4             	push   -0xc(%ebp)
  802142:	6a 09                	push   $0x9
  802144:	e8 b2 23 00 00       	call   8044fb <memp_free>
      break;
  802149:	83 c4 10             	add    $0x10,%esp
  80214c:	eb b4                	jmp    802102 <tcpip_thread+0xb7>
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  80214e:	83 ec 08             	sub    $0x8,%esp
  802151:	50                   	push   %eax
  802152:	ff 72 08             	push   0x8(%edx)
  802155:	e8 92 43 00 00       	call   8064ec <ip_input>
  80215a:	83 c4 10             	add    $0x10,%esp
  80215d:	eb dd                	jmp    80213c <tcpip_thread+0xf1>
      msg->msg.cb.f(msg->msg.cb.ctx);
  80215f:	83 ec 0c             	sub    $0xc,%esp
  802162:	ff 72 0c             	push   0xc(%edx)
  802165:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802168:	83 c4 08             	add    $0x8,%esp
  80216b:	ff 75 f4             	push   -0xc(%ebp)
  80216e:	6a 08                	push   $0x8
  802170:	e8 86 23 00 00       	call   8044fb <memp_free>
      break;
  802175:	83 c4 10             	add    $0x10,%esp
  802178:	eb 88                	jmp    802102 <tcpip_thread+0xb7>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  80217a:	83 ec 08             	sub    $0x8,%esp
  80217d:	ff 72 10             	push   0x10(%edx)
  802180:	ff 72 0c             	push   0xc(%edx)
  802183:	e8 ca 30 00 00       	call   805252 <sys_untimeout>
  802188:	83 c4 10             	add    $0x10,%esp
  80218b:	e9 51 ff ff ff       	jmp    8020e1 <tcpip_thread+0x96>

00802190 <dhcp_timer_fine>:
{
  802190:	55                   	push   %ebp
  802191:	89 e5                	mov    %esp,%ebp
  802193:	83 ec 08             	sub    $0x8,%esp
  dhcp_fine_tmr();
  802196:	e8 30 1b 00 00       	call   803ccb <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80219b:	83 ec 04             	sub    $0x4,%esp
  80219e:	6a 00                	push   $0x0
  8021a0:	68 90 21 80 00       	push   $0x802190
  8021a5:	68 f4 01 00 00       	push   $0x1f4
  8021aa:	e8 e6 2f 00 00       	call   805195 <sys_timeout>
}
  8021af:	83 c4 10             	add    $0x10,%esp
  8021b2:	c9                   	leave  
  8021b3:	c3                   	ret    

008021b4 <dhcp_timer_coarse>:
{
  8021b4:	55                   	push   %ebp
  8021b5:	89 e5                	mov    %esp,%ebp
  8021b7:	83 ec 08             	sub    $0x8,%esp
  dhcp_coarse_tmr();
  8021ba:	e8 41 19 00 00       	call   803b00 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8021bf:	83 ec 04             	sub    $0x4,%esp
  8021c2:	6a 00                	push   $0x0
  8021c4:	68 b4 21 80 00       	push   $0x8021b4
  8021c9:	68 60 ea 00 00       	push   $0xea60
  8021ce:	e8 c2 2f 00 00       	call   805195 <sys_timeout>
}
  8021d3:	83 c4 10             	add    $0x10,%esp
  8021d6:	c9                   	leave  
  8021d7:	c3                   	ret    

008021d8 <arp_timer>:
{
  8021d8:	55                   	push   %ebp
  8021d9:	89 e5                	mov    %esp,%ebp
  8021db:	83 ec 08             	sub    $0x8,%esp
  etharp_tmr();
  8021de:	e8 8b 72 00 00       	call   80946e <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8021e3:	83 ec 04             	sub    $0x4,%esp
  8021e6:	6a 00                	push   $0x0
  8021e8:	68 d8 21 80 00       	push   $0x8021d8
  8021ed:	68 88 13 00 00       	push   $0x1388
  8021f2:	e8 9e 2f 00 00       	call   805195 <sys_timeout>
}
  8021f7:	83 c4 10             	add    $0x10,%esp
  8021fa:	c9                   	leave  
  8021fb:	c3                   	ret    

008021fc <ip_reass_timer>:
{
  8021fc:	55                   	push   %ebp
  8021fd:	89 e5                	mov    %esp,%ebp
  8021ff:	83 ec 08             	sub    $0x8,%esp
  ip_reass_tmr();
  802202:	e8 be 49 00 00       	call   806bc5 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802207:	83 ec 04             	sub    $0x4,%esp
  80220a:	6a 00                	push   $0x0
  80220c:	68 fc 21 80 00       	push   $0x8021fc
  802211:	68 e8 03 00 00       	push   $0x3e8
  802216:	e8 7a 2f 00 00       	call   805195 <sys_timeout>
}
  80221b:	83 c4 10             	add    $0x10,%esp
  80221e:	c9                   	leave  
  80221f:	c3                   	ret    

00802220 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  802220:	55                   	push   %ebp
  802221:	89 e5                	mov    %esp,%ebp
  802223:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  802226:	ff 75 08             	push   0x8(%ebp)
  802229:	e8 1e 26 00 00       	call   80484c <pbuf_free>
}
  80222e:	83 c4 10             	add    $0x10,%esp
  802231:	c9                   	leave  
  802232:	c3                   	ret    

00802233 <tcp_timer_needed>:
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802233:	83 3d 20 53 81 00 00 	cmpl   $0x0,0x815320
  80223a:	75 38                	jne    802274 <tcp_timer_needed+0x41>
  80223c:	83 3d 4c 44 b3 00 00 	cmpl   $0x0,0xb3444c
  802243:	74 26                	je     80226b <tcp_timer_needed+0x38>
{
  802245:	55                   	push   %ebp
  802246:	89 e5                	mov    %esp,%ebp
  802248:	83 ec 0c             	sub    $0xc,%esp
    tcpip_tcp_timer_active = 1;
  80224b:	c7 05 20 53 81 00 01 	movl   $0x1,0x815320
  802252:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802255:	6a 00                	push   $0x0
  802257:	68 09 20 80 00       	push   $0x802009
  80225c:	68 fa 00 00 00       	push   $0xfa
  802261:	e8 2f 2f 00 00       	call   805195 <sys_timeout>
  802266:	83 c4 10             	add    $0x10,%esp
}
  802269:	c9                   	leave  
  80226a:	c3                   	ret    
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  80226b:	83 3d 48 44 b3 00 00 	cmpl   $0x0,0xb34448
  802272:	75 d1                	jne    802245 <tcp_timer_needed+0x12>
  802274:	c3                   	ret    

00802275 <tcpip_input>:
  if (mbox != SYS_MBOX_NULL) {
  802275:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  80227c:	74 59                	je     8022d7 <tcpip_input+0x62>
{
  80227e:	55                   	push   %ebp
  80227f:	89 e5                	mov    %esp,%ebp
  802281:	53                   	push   %ebx
  802282:	83 ec 10             	sub    $0x10,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  802285:	6a 09                	push   $0x9
  802287:	e8 19 22 00 00       	call   8044a5 <memp_malloc>
  80228c:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  80228e:	83 c4 10             	add    $0x10,%esp
  802291:	85 c0                	test   %eax,%eax
  802293:	74 48                	je     8022dd <tcpip_input+0x68>
    msg->type = TCPIP_MSG_INPKT;
  802295:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  80229b:	8b 45 08             	mov    0x8(%ebp),%eax
  80229e:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8022a1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8022a4:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8022a7:	83 ec 08             	sub    $0x8,%esp
  8022aa:	53                   	push   %ebx
  8022ab:	ff 35 00 40 81 00    	push   0x814000
  8022b1:	e8 15 7f 00 00       	call   80a1cb <sys_mbox_trypost>
  8022b6:	83 c4 10             	add    $0x10,%esp
  8022b9:	84 c0                	test   %al,%al
  8022bb:	75 05                	jne    8022c2 <tcpip_input+0x4d>
}
  8022bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8022c0:	c9                   	leave  
  8022c1:	c3                   	ret    
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8022c2:	83 ec 08             	sub    $0x8,%esp
  8022c5:	53                   	push   %ebx
  8022c6:	6a 09                	push   $0x9
  8022c8:	e8 2e 22 00 00       	call   8044fb <memp_free>
      return ERR_MEM;
  8022cd:	83 c4 10             	add    $0x10,%esp
  8022d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022d5:	eb e6                	jmp    8022bd <tcpip_input+0x48>
  return ERR_VAL;
  8022d7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8022dc:	c3                   	ret    
      return ERR_MEM;
  8022dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022e2:	eb d9                	jmp    8022bd <tcpip_input+0x48>

008022e4 <tcpip_callback_with_block>:
{
  8022e4:	55                   	push   %ebp
  8022e5:	89 e5                	mov    %esp,%ebp
  8022e7:	56                   	push   %esi
  8022e8:	53                   	push   %ebx
  8022e9:	8b 75 10             	mov    0x10(%ebp),%esi
  if (mbox != SYS_MBOX_NULL) {
  8022ec:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8022f3:	74 76                	je     80236b <tcpip_callback_with_block+0x87>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8022f5:	83 ec 0c             	sub    $0xc,%esp
  8022f8:	6a 08                	push   $0x8
  8022fa:	e8 a6 21 00 00       	call   8044a5 <memp_malloc>
  8022ff:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802301:	83 c4 10             	add    $0x10,%esp
  802304:	85 c0                	test   %eax,%eax
  802306:	74 6a                	je     802372 <tcpip_callback_with_block+0x8e>
    msg->type = TCPIP_MSG_CALLBACK;
  802308:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  80230e:	8b 45 08             	mov    0x8(%ebp),%eax
  802311:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802314:	8b 45 0c             	mov    0xc(%ebp),%eax
  802317:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  80231a:	89 f0                	mov    %esi,%eax
  80231c:	84 c0                	test   %al,%al
  80231e:	75 1d                	jne    80233d <tcpip_callback_with_block+0x59>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  802320:	83 ec 08             	sub    $0x8,%esp
  802323:	53                   	push   %ebx
  802324:	ff 35 00 40 81 00    	push   0x814000
  80232a:	e8 9c 7e 00 00       	call   80a1cb <sys_mbox_trypost>
  80232f:	83 c4 10             	add    $0x10,%esp
  802332:	84 c0                	test   %al,%al
  802334:	75 20                	jne    802356 <tcpip_callback_with_block+0x72>
}
  802336:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802339:	5b                   	pop    %ebx
  80233a:	5e                   	pop    %esi
  80233b:	5d                   	pop    %ebp
  80233c:	c3                   	ret    
      sys_mbox_post(mbox, msg);
  80233d:	83 ec 08             	sub    $0x8,%esp
  802340:	53                   	push   %ebx
  802341:	ff 35 00 40 81 00    	push   0x814000
  802347:	e8 3d 7f 00 00       	call   80a289 <sys_mbox_post>
  80234c:	83 c4 10             	add    $0x10,%esp
    return ERR_OK;
  80234f:	b8 00 00 00 00       	mov    $0x0,%eax
  802354:	eb e0                	jmp    802336 <tcpip_callback_with_block+0x52>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  802356:	83 ec 08             	sub    $0x8,%esp
  802359:	53                   	push   %ebx
  80235a:	6a 08                	push   $0x8
  80235c:	e8 9a 21 00 00       	call   8044fb <memp_free>
        return ERR_MEM;
  802361:	83 c4 10             	add    $0x10,%esp
  802364:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802369:	eb cb                	jmp    802336 <tcpip_callback_with_block+0x52>
  return ERR_VAL;
  80236b:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  802370:	eb c4                	jmp    802336 <tcpip_callback_with_block+0x52>
      return ERR_MEM;
  802372:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802377:	eb bd                	jmp    802336 <tcpip_callback_with_block+0x52>

00802379 <tcpip_timeout>:
  if (mbox != SYS_MBOX_NULL) {
  802379:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802380:	74 45                	je     8023c7 <tcpip_timeout+0x4e>
{
  802382:	55                   	push   %ebp
  802383:	89 e5                	mov    %esp,%ebp
  802385:	83 ec 14             	sub    $0x14,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802388:	6a 08                	push   $0x8
  80238a:	e8 16 21 00 00       	call   8044a5 <memp_malloc>
    if (msg == NULL) {
  80238f:	83 c4 10             	add    $0x10,%esp
  802392:	85 c0                	test   %eax,%eax
  802394:	74 37                	je     8023cd <tcpip_timeout+0x54>
    msg->type = TCPIP_MSG_TIMEOUT;
  802396:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  80239c:	8b 55 08             	mov    0x8(%ebp),%edx
  80239f:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8023a2:	8b 55 0c             	mov    0xc(%ebp),%edx
  8023a5:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8023a8:	8b 55 10             	mov    0x10(%ebp),%edx
  8023ab:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8023ae:	83 ec 08             	sub    $0x8,%esp
  8023b1:	50                   	push   %eax
  8023b2:	ff 35 00 40 81 00    	push   0x814000
  8023b8:	e8 cc 7e 00 00       	call   80a289 <sys_mbox_post>
    return ERR_OK;
  8023bd:	83 c4 10             	add    $0x10,%esp
  8023c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8023c5:	c9                   	leave  
  8023c6:	c3                   	ret    
  return ERR_VAL;
  8023c7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8023cc:	c3                   	ret    
      return ERR_MEM;
  8023cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8023d2:	eb f1                	jmp    8023c5 <tcpip_timeout+0x4c>

008023d4 <tcpip_apimsg>:
{
  8023d4:	55                   	push   %ebp
  8023d5:	89 e5                	mov    %esp,%ebp
  8023d7:	53                   	push   %ebx
  8023d8:	83 ec 24             	sub    $0x24,%esp
  8023db:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (mbox != SYS_MBOX_NULL) {
  8023de:	a1 00 40 81 00       	mov    0x814000,%eax
  8023e3:	83 f8 ff             	cmp    $0xffffffff,%eax
  8023e6:	74 34                	je     80241c <tcpip_apimsg+0x48>
    msg.type = TCPIP_MSG_API;
  8023e8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  8023ef:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  8023f2:	83 ec 08             	sub    $0x8,%esp
  8023f5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8023f8:	52                   	push   %edx
  8023f9:	50                   	push   %eax
  8023fa:	e8 8a 7e 00 00       	call   80a289 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  8023ff:	83 c4 08             	add    $0x8,%esp
  802402:	6a 00                	push   $0x0
  802404:	8b 43 04             	mov    0x4(%ebx),%eax
  802407:	ff 70 10             	push   0x10(%eax)
  80240a:	e8 82 7c 00 00       	call   80a091 <sys_arch_sem_wait>
    return ERR_OK;
  80240f:	83 c4 10             	add    $0x10,%esp
  802412:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802417:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80241a:	c9                   	leave  
  80241b:	c3                   	ret    
  return ERR_VAL;
  80241c:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  802421:	eb f4                	jmp    802417 <tcpip_apimsg+0x43>

00802423 <tcpip_init>:
{
  802423:	55                   	push   %ebp
  802424:	89 e5                	mov    %esp,%ebp
  802426:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  802429:	e8 65 03 00 00       	call   802793 <lwip_init>
  tcpip_init_done = initfunc;
  80242e:	8b 45 08             	mov    0x8(%ebp),%eax
  802431:	a3 28 53 81 00       	mov    %eax,0x815328
  tcpip_init_done_arg = arg;
  802436:	8b 45 0c             	mov    0xc(%ebp),%eax
  802439:	a3 24 53 81 00       	mov    %eax,0x815324
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  80243e:	83 ec 0c             	sub    $0xc,%esp
  802441:	6a 00                	push   $0x0
  802443:	e8 c5 7a 00 00       	call   809f0d <sys_mbox_new>
  802448:	a3 00 40 81 00       	mov    %eax,0x814000
  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  80244d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  802454:	6a 00                	push   $0x0
  802456:	6a 00                	push   $0x0
  802458:	68 4b 20 80 00       	push   $0x80204b
  80245d:	68 9c 0f 81 00       	push   $0x810f9c
  802462:	e8 5e 7f 00 00       	call   80a3c5 <sys_thread_new>
}
  802467:	83 c4 20             	add    $0x20,%esp
  80246a:	c9                   	leave  
  80246b:	c3                   	ret    

0080246c <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  80246c:	55                   	push   %ebp
  80246d:	89 e5                	mov    %esp,%ebp
  80246f:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  802472:	6a 00                	push   $0x0
  802474:	ff 75 08             	push   0x8(%ebp)
  802477:	68 20 22 80 00       	push   $0x802220
  80247c:	e8 63 fe ff ff       	call   8022e4 <tcpip_callback_with_block>
}
  802481:	c9                   	leave  
  802482:	c3                   	ret    

00802483 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  802483:	55                   	push   %ebp
  802484:	89 e5                	mov    %esp,%ebp
  802486:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  802489:	6a 00                	push   $0x0
  80248b:	ff 75 08             	push   0x8(%ebp)
  80248e:	68 62 3f 80 00       	push   $0x803f62
  802493:	e8 4c fe ff ff       	call   8022e4 <tcpip_callback_with_block>
}
  802498:	c9                   	leave  
  802499:	c3                   	ret    

0080249a <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  80249a:	55                   	push   %ebp
  80249b:	89 e5                	mov    %esp,%ebp
  80249d:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8024a0:	6a 06                	push   $0x6
  8024a2:	e8 fe 1f 00 00       	call   8044a5 <memp_malloc>
  if (buf != NULL) {
  8024a7:	83 c4 10             	add    $0x10,%esp
  8024aa:	85 c0                	test   %eax,%eax
  8024ac:	74 14                	je     8024c2 <netbuf_new+0x28>
    buf->p = NULL;
  8024ae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8024b4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  8024bb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  8024c2:	c9                   	leave  
  8024c3:	c3                   	ret    

008024c4 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8024c4:	55                   	push   %ebp
  8024c5:	89 e5                	mov    %esp,%ebp
  8024c7:	53                   	push   %ebx
  8024c8:	83 ec 04             	sub    $0x4,%esp
  8024cb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  8024ce:	85 db                	test   %ebx,%ebx
  8024d0:	74 2d                	je     8024ff <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  8024d2:	8b 03                	mov    (%ebx),%eax
  8024d4:	85 c0                	test   %eax,%eax
  8024d6:	74 19                	je     8024f1 <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  8024d8:	83 ec 0c             	sub    $0xc,%esp
  8024db:	50                   	push   %eax
  8024dc:	e8 6b 23 00 00       	call   80484c <pbuf_free>
      buf->p = buf->ptr = NULL;
  8024e1:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8024e8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  8024ee:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  8024f1:	83 ec 08             	sub    $0x8,%esp
  8024f4:	53                   	push   %ebx
  8024f5:	6a 06                	push   $0x6
  8024f7:	e8 ff 1f 00 00       	call   8044fb <memp_free>
  8024fc:	83 c4 10             	add    $0x10,%esp
  }
}
  8024ff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802502:	c9                   	leave  
  802503:	c3                   	ret    

00802504 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802504:	55                   	push   %ebp
  802505:	89 e5                	mov    %esp,%ebp
  802507:	56                   	push   %esi
  802508:	53                   	push   %ebx
  802509:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80250c:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80250f:	85 db                	test   %ebx,%ebx
  802511:	74 3e                	je     802551 <netbuf_alloc+0x4d>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802513:	8b 03                	mov    (%ebx),%eax
  802515:	85 c0                	test   %eax,%eax
  802517:	74 0c                	je     802525 <netbuf_alloc+0x21>
    pbuf_free(buf->p);
  802519:	83 ec 0c             	sub    $0xc,%esp
  80251c:	50                   	push   %eax
  80251d:	e8 2a 23 00 00       	call   80484c <pbuf_free>
  802522:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  802525:	83 ec 04             	sub    $0x4,%esp
  802528:	6a 00                	push   $0x0
  80252a:	0f b7 c6             	movzwl %si,%eax
  80252d:	50                   	push   %eax
  80252e:	6a 00                	push   $0x0
  802530:	e8 dd 23 00 00       	call   804912 <pbuf_alloc>
  802535:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802537:	83 c4 10             	add    $0x10,%esp
  80253a:	85 c0                	test   %eax,%eax
  80253c:	74 0c                	je     80254a <netbuf_alloc+0x46>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  80253e:	66 39 70 0a          	cmp    %si,0xa(%eax)
  802542:	72 21                	jb     802565 <netbuf_alloc+0x61>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  802544:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  802547:	8b 40 04             	mov    0x4(%eax),%eax
}
  80254a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80254d:	5b                   	pop    %ebx
  80254e:	5e                   	pop    %esi
  80254f:	5d                   	pop    %ebp
  802550:	c3                   	ret    
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802551:	83 ec 04             	sub    $0x4,%esp
  802554:	68 a9 0f 81 00       	push   $0x810fa9
  802559:	6a 63                	push   $0x63
  80255b:	68 c3 0f 81 00       	push   $0x810fc3
  802560:	e8 71 bf 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("check that first pbuf can hold size",
  802565:	83 ec 04             	sub    $0x4,%esp
  802568:	68 90 10 81 00       	push   $0x811090
  80256d:	6a 6d                	push   $0x6d
  80256f:	68 c3 0f 81 00       	push   $0x810fc3
  802574:	e8 5d bf 00 00       	call   80e4d6 <_panic>

00802579 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  802579:	55                   	push   %ebp
  80257a:	89 e5                	mov    %esp,%ebp
  80257c:	53                   	push   %ebx
  80257d:	83 ec 04             	sub    $0x4,%esp
  802580:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802583:	85 db                	test   %ebx,%ebx
  802585:	74 24                	je     8025ab <netbuf_free+0x32>
  if (buf->p != NULL) {
  802587:	8b 03                	mov    (%ebx),%eax
  802589:	85 c0                	test   %eax,%eax
  80258b:	74 0c                	je     802599 <netbuf_free+0x20>
    pbuf_free(buf->p);
  80258d:	83 ec 0c             	sub    $0xc,%esp
  802590:	50                   	push   %eax
  802591:	e8 b6 22 00 00       	call   80484c <pbuf_free>
  802596:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  802599:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8025a0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8025a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8025a9:	c9                   	leave  
  8025aa:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8025ab:	83 ec 04             	sub    $0x4,%esp
  8025ae:	68 d9 0f 81 00       	push   $0x810fd9
  8025b3:	6a 7b                	push   $0x7b
  8025b5:	68 c3 0f 81 00       	push   $0x810fc3
  8025ba:	e8 17 bf 00 00       	call   80e4d6 <_panic>

008025bf <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8025bf:	55                   	push   %ebp
  8025c0:	89 e5                	mov    %esp,%ebp
  8025c2:	56                   	push   %esi
  8025c3:	53                   	push   %ebx
  8025c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8025c7:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8025ca:	85 db                	test   %ebx,%ebx
  8025cc:	74 4e                	je     80261c <netbuf_ref+0x5d>
  if (buf->p != NULL) {
  8025ce:	8b 03                	mov    (%ebx),%eax
  8025d0:	85 c0                	test   %eax,%eax
  8025d2:	74 0c                	je     8025e0 <netbuf_ref+0x21>
    pbuf_free(buf->p);
  8025d4:	83 ec 0c             	sub    $0xc,%esp
  8025d7:	50                   	push   %eax
  8025d8:	e8 6f 22 00 00       	call   80484c <pbuf_free>
  8025dd:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  8025e0:	83 ec 04             	sub    $0x4,%esp
  8025e3:	6a 02                	push   $0x2
  8025e5:	6a 00                	push   $0x0
  8025e7:	6a 00                	push   $0x0
  8025e9:	e8 24 23 00 00       	call   804912 <pbuf_alloc>
  8025ee:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8025f0:	83 c4 10             	add    $0x10,%esp
  8025f3:	85 c0                	test   %eax,%eax
  8025f5:	74 3c                	je     802633 <netbuf_ref+0x74>
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  8025f7:	8b 55 0c             	mov    0xc(%ebp),%edx
  8025fa:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  8025fd:	8b 03                	mov    (%ebx),%eax
  8025ff:	66 89 70 08          	mov    %si,0x8(%eax)
  802603:	8b 03                	mov    (%ebx),%eax
  802605:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  802609:	8b 03                	mov    (%ebx),%eax
  return ERR_OK;
  80260b:	ba 00 00 00 00       	mov    $0x0,%edx
  buf->ptr = buf->p;
  802610:	89 43 04             	mov    %eax,0x4(%ebx)
}
  802613:	89 d0                	mov    %edx,%eax
  802615:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802618:	5b                   	pop    %ebx
  802619:	5e                   	pop    %esi
  80261a:	5d                   	pop    %ebp
  80261b:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  80261c:	83 ec 04             	sub    $0x4,%esp
  80261f:	68 f2 0f 81 00       	push   $0x810ff2
  802624:	68 8e 00 00 00       	push   $0x8e
  802629:	68 c3 0f 81 00       	push   $0x810fc3
  80262e:	e8 a3 be 00 00       	call   80e4d6 <_panic>
    return ERR_MEM;
  802633:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  802638:	eb d6                	jmp    802610 <netbuf_ref+0x51>

0080263a <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  80263a:	55                   	push   %ebp
  80263b:	89 e5                	mov    %esp,%ebp
  80263d:	56                   	push   %esi
  80263e:	53                   	push   %ebx
  80263f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802642:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  802645:	85 db                	test   %ebx,%ebx
  802647:	74 2a                	je     802673 <netbuf_chain+0x39>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  802649:	85 f6                	test   %esi,%esi
  80264b:	74 3d                	je     80268a <netbuf_chain+0x50>
  pbuf_chain(head->p, tail->p);
  80264d:	83 ec 08             	sub    $0x8,%esp
  802650:	ff 36                	push   (%esi)
  802652:	ff 33                	push   (%ebx)
  802654:	e8 c1 26 00 00       	call   804d1a <pbuf_chain>
  head->ptr = head->p;
  802659:	8b 03                	mov    (%ebx),%eax
  80265b:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  80265e:	83 c4 08             	add    $0x8,%esp
  802661:	56                   	push   %esi
  802662:	6a 06                	push   $0x6
  802664:	e8 92 1e 00 00       	call   8044fb <memp_free>
  802669:	83 c4 10             	add    $0x10,%esp
}
  80266c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80266f:	5b                   	pop    %ebx
  802670:	5e                   	pop    %esi
  802671:	5d                   	pop    %ebp
  802672:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  802673:	83 ec 04             	sub    $0x4,%esp
  802676:	68 0a 10 81 00       	push   $0x81100a
  80267b:	68 a6 00 00 00       	push   $0xa6
  802680:	68 c3 0f 81 00       	push   $0x810fc3
  802685:	e8 4c be 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  80268a:	83 ec 04             	sub    $0x4,%esp
  80268d:	68 23 10 81 00       	push   $0x811023
  802692:	68 a7 00 00 00       	push   $0xa7
  802697:	68 c3 0f 81 00       	push   $0x810fc3
  80269c:	e8 35 be 00 00       	call   80e4d6 <_panic>

008026a1 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  8026a1:	55                   	push   %ebp
  8026a2:	89 e5                	mov    %esp,%ebp
  8026a4:	53                   	push   %ebx
  8026a5:	83 ec 04             	sub    $0x4,%esp
  8026a8:	8b 45 08             	mov    0x8(%ebp),%eax
  8026ab:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8026ae:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  8026b1:	85 c0                	test   %eax,%eax
  8026b3:	74 28                	je     8026dd <netbuf_data+0x3c>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  8026b5:	85 c9                	test   %ecx,%ecx
  8026b7:	74 3b                	je     8026f4 <netbuf_data+0x53>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  8026b9:	85 d2                	test   %edx,%edx
  8026bb:	74 4e                	je     80270b <netbuf_data+0x6a>

  if (buf->ptr == NULL) {
  8026bd:	8b 58 04             	mov    0x4(%eax),%ebx
  8026c0:	85 db                	test   %ebx,%ebx
  8026c2:	74 5e                	je     802722 <netbuf_data+0x81>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  8026c4:	8b 5b 04             	mov    0x4(%ebx),%ebx
  8026c7:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  8026c9:	8b 40 04             	mov    0x4(%eax),%eax
  8026cc:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  8026d0:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  8026d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8026d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8026db:	c9                   	leave  
  8026dc:	c3                   	ret    
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  8026dd:	83 ec 04             	sub    $0x4,%esp
  8026e0:	68 3e 10 81 00       	push   $0x81103e
  8026e5:	68 b9 00 00 00       	push   $0xb9
  8026ea:	68 c3 0f 81 00       	push   $0x810fc3
  8026ef:	e8 e2 bd 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  8026f4:	83 ec 04             	sub    $0x4,%esp
  8026f7:	68 57 10 81 00       	push   $0x811057
  8026fc:	68 ba 00 00 00       	push   $0xba
  802701:	68 c3 0f 81 00       	push   $0x810fc3
  802706:	e8 cb bd 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80270b:	83 ec 04             	sub    $0x4,%esp
  80270e:	68 74 10 81 00       	push   $0x811074
  802713:	68 bb 00 00 00       	push   $0xbb
  802718:	68 c3 0f 81 00       	push   $0x810fc3
  80271d:	e8 b4 bd 00 00       	call   80e4d6 <_panic>
    return ERR_BUF;
  802722:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  802727:	eb af                	jmp    8026d8 <netbuf_data+0x37>

00802729 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802729:	55                   	push   %ebp
  80272a:	89 e5                	mov    %esp,%ebp
  80272c:	83 ec 08             	sub    $0x8,%esp
  80272f:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802732:	85 c0                	test   %eax,%eax
  802734:	74 14                	je     80274a <netbuf_next+0x21>
  if (buf->ptr->next == NULL) {
  802736:	8b 50 04             	mov    0x4(%eax),%edx
  802739:	8b 12                	mov    (%edx),%edx
  80273b:	85 d2                	test   %edx,%edx
  80273d:	74 22                	je     802761 <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  80273f:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  802742:	83 3a 00             	cmpl   $0x0,(%edx)
  802745:	0f 94 c0             	sete   %al
    return 1;
  }
  return 0;
}
  802748:	c9                   	leave  
  802749:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  80274a:	83 ec 04             	sub    $0x4,%esp
  80274d:	68 d9 0f 81 00       	push   $0x810fd9
  802752:	68 d2 00 00 00       	push   $0xd2
  802757:	68 c3 0f 81 00       	push   $0x810fc3
  80275c:	e8 75 bd 00 00       	call   80e4d6 <_panic>
    return -1;
  802761:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802766:	eb e0                	jmp    802748 <netbuf_next+0x1f>

00802768 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  802768:	55                   	push   %ebp
  802769:	89 e5                	mov    %esp,%ebp
  80276b:	83 ec 08             	sub    $0x8,%esp
  80276e:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802771:	85 c0                	test   %eax,%eax
  802773:	74 07                	je     80277c <netbuf_first+0x14>
  buf->ptr = buf->p;
  802775:	8b 10                	mov    (%eax),%edx
  802777:	89 50 04             	mov    %edx,0x4(%eax)
}
  80277a:	c9                   	leave  
  80277b:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80277c:	83 ec 04             	sub    $0x4,%esp
  80277f:	68 d9 0f 81 00       	push   $0x810fd9
  802784:	68 e7 00 00 00       	push   $0xe7
  802789:	68 c3 0f 81 00       	push   $0x810fc3
  80278e:	e8 43 bd 00 00       	call   80e4d6 <_panic>

00802793 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  802793:	55                   	push   %ebp
  802794:	89 e5                	mov    %esp,%ebp
  802796:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802799:	e8 15 75 00 00       	call   809cb3 <sys_init>
  mem_init();
  80279e:	e8 59 17 00 00       	call   803efc <mem_init>
  memp_init();
  8027a3:	e8 a1 1c 00 00       	call   804449 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  8027a8:	e8 e4 e6 ff ff       	call   800e91 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  8027ad:	c9                   	leave  
  8027ae:	c3                   	ret    

008027af <dhcp_set_state>:
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
  8027af:	38 10                	cmp    %dl,(%eax)
  8027b1:	74 06                	je     8027b9 <dhcp_set_state+0xa>
    dhcp->state = new_state;
  8027b3:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  8027b5:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  8027b9:	c3                   	ret    

008027ba <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  8027ba:	55                   	push   %ebp
  8027bb:	89 e5                	mov    %esp,%ebp
  8027bd:	57                   	push   %edi
  8027be:	56                   	push   %esi
  8027bf:	53                   	push   %ebx
  8027c0:	83 ec 0c             	sub    $0xc,%esp
  8027c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  8027c6:	89 d6                	mov    %edx,%esi
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  8027c8:	8b 50 14             	mov    0x14(%eax),%edx
  8027cb:	85 d2                	test   %edx,%edx
  8027cd:	74 17                	je     8027e6 <dhcp_get_option_ptr+0x2c>
  8027cf:	0f b7 78 18          	movzwl 0x18(%eax),%edi
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  8027d3:	b8 00 00 00 00       	mov    $0x0,%eax
  u8_t overload = DHCP_OVERLOAD_NONE;
  8027d8:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  8027dc:	66 85 ff             	test   %di,%di
  8027df:	75 24                	jne    802805 <dhcp_get_option_ptr+0x4b>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  8027e1:	ba 00 00 00 00       	mov    $0x0,%edx
}
  8027e6:	89 d0                	mov    %edx,%eax
  8027e8:	83 c4 0c             	add    $0xc,%esp
  8027eb:	5b                   	pop    %ebx
  8027ec:	5e                   	pop    %esi
  8027ed:	5f                   	pop    %edi
  8027ee:	5d                   	pop    %ebp
  8027ef:	c3                   	ret    
        offset += 2;
  8027f0:	8d 48 02             	lea    0x2(%eax),%ecx
        overload = options[offset++];
  8027f3:	83 c0 03             	add    $0x3,%eax
  8027f6:	0f b7 c9             	movzwl %cx,%ecx
  8027f9:	0f b6 1c 0a          	movzbl (%edx,%ecx,1),%ebx
  8027fd:	88 5d ef             	mov    %bl,-0x11(%ebp)
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802800:	66 39 c7             	cmp    %ax,%di
  802803:	76 30                	jbe    802835 <dhcp_get_option_ptr+0x7b>
  802805:	0f b7 c8             	movzwl %ax,%ecx
  802808:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
  80280b:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  80280e:	0f b6 1b             	movzbl (%ebx),%ebx
  802811:	80 fb ff             	cmp    $0xff,%bl
  802814:	74 1f                	je     802835 <dhcp_get_option_ptr+0x7b>
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802816:	80 fb 34             	cmp    $0x34,%bl
  802819:	74 d5                	je     8027f0 <dhcp_get_option_ptr+0x36>
      else if (options[offset] == option_type) {
  80281b:	89 f1                	mov    %esi,%ecx
  80281d:	38 cb                	cmp    %cl,%bl
  80281f:	0f 84 9f 00 00 00    	je     8028c4 <dhcp_get_option_ptr+0x10a>
        offset++;
  802825:	8d 48 01             	lea    0x1(%eax),%ecx
        offset += 1 + options[offset];
  802828:	0f b7 c9             	movzwl %cx,%ecx
  80282b:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  80282f:	8d 44 01 02          	lea    0x2(%ecx,%eax,1),%eax
  802833:	eb cb                	jmp    802800 <dhcp_get_option_ptr+0x46>
  return NULL;
  802835:	ba 00 00 00 00       	mov    $0x0,%edx
    if (overload != DHCP_OVERLOAD_NONE) {
  80283a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
  80283e:	84 c0                	test   %al,%al
  802840:	74 a4                	je     8027e6 <dhcp_get_option_ptr+0x2c>
      if (overload == DHCP_OVERLOAD_FILE) {
  802842:	3c 01                	cmp    $0x1,%al
  802844:	74 54                	je     80289a <dhcp_get_option_ptr+0xe0>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  802846:	80 7d ef 02          	cmpb   $0x2,-0x11(%ebp)
  80284a:	74 5e                	je     8028aa <dhcp_get_option_ptr+0xf0>
        options = (u8_t *)&dhcp->msg_in->sname;
  80284c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80284f:	8b 58 10             	mov    0x10(%eax),%ebx
  802852:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  802855:	bf c0 00 00 00       	mov    $0xc0,%edi
      offset = 0;
  80285a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80285f:	89 f0                	mov    %esi,%eax
  802861:	88 45 f0             	mov    %al,-0x10(%ebp)
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802864:	0f b7 d1             	movzwl %cx,%edx
  802867:	01 da                	add    %ebx,%edx
  802869:	0f b6 32             	movzbl (%edx),%esi
  80286c:	89 f0                	mov    %esi,%eax
  80286e:	3c ff                	cmp    $0xff,%al
  802870:	74 48                	je     8028ba <dhcp_get_option_ptr+0x100>
        if (options[offset] == option_type) {
  802872:	89 f0                	mov    %esi,%eax
  802874:	3a 45 f0             	cmp    -0x10(%ebp),%al
  802877:	0f 84 69 ff ff ff    	je     8027e6 <dhcp_get_option_ptr+0x2c>
          offset++;
  80287d:	8d 51 01             	lea    0x1(%ecx),%edx
          offset += 1 + options[offset];
  802880:	0f b7 d2             	movzwl %dx,%edx
  802883:	0f b6 14 13          	movzbl (%ebx,%edx,1),%edx
  802887:	8d 4c 11 02          	lea    0x2(%ecx,%edx,1),%ecx
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80288b:	66 39 cf             	cmp    %cx,%di
  80288e:	77 d4                	ja     802864 <dhcp_get_option_ptr+0xaa>
  return NULL;
  802890:	ba 00 00 00 00       	mov    $0x0,%edx
  802895:	e9 4c ff ff ff       	jmp    8027e6 <dhcp_get_option_ptr+0x2c>
        options = (u8_t *)&dhcp->msg_in->file;
  80289a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80289d:	8b 58 10             	mov    0x10(%eax),%ebx
  8028a0:	83 c3 6c             	add    $0x6c,%ebx
        field_len = DHCP_FILE_LEN;
  8028a3:	bf 80 00 00 00       	mov    $0x80,%edi
  8028a8:	eb b0                	jmp    80285a <dhcp_get_option_ptr+0xa0>
        options = (u8_t *)&dhcp->msg_in->sname;
  8028aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8028ad:	8b 58 10             	mov    0x10(%eax),%ebx
  8028b0:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_SNAME_LEN;
  8028b3:	bf 40 00 00 00       	mov    $0x40,%edi
  8028b8:	eb a0                	jmp    80285a <dhcp_get_option_ptr+0xa0>
  return NULL;
  8028ba:	ba 00 00 00 00       	mov    $0x0,%edx
  8028bf:	e9 22 ff ff ff       	jmp    8027e6 <dhcp_get_option_ptr+0x2c>
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8028c4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  8028c7:	89 ca                	mov    %ecx,%edx
  8028c9:	e9 18 ff ff ff       	jmp    8027e6 <dhcp_get_option_ptr+0x2c>

008028ce <dhcp_get_option_long>:
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  8028ce:	0f b6 08             	movzbl (%eax),%ecx
  8028d1:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  8028d4:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  8028d8:	c1 e2 10             	shl    $0x10,%edx
  8028db:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  8028dd:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  8028e1:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  8028e3:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  8028e7:	c1 e0 08             	shl    $0x8,%eax
  value |= (u32_t)(*ptr++);
  8028ea:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  8028ec:	c3                   	ret    

008028ed <dhcp_option_byte>:
{
  8028ed:	55                   	push   %ebp
  8028ee:	89 e5                	mov    %esp,%ebp
  8028f0:	56                   	push   %esi
  8028f1:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8028f2:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8028f6:	66 83 f9 43          	cmp    $0x43,%cx
  8028fa:	77 1b                	ja     802917 <dhcp_option_byte+0x2a>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  8028fc:	8b 58 20             	mov    0x20(%eax),%ebx
  8028ff:	8d 71 01             	lea    0x1(%ecx),%esi
  802902:	66 89 70 24          	mov    %si,0x24(%eax)
  802906:	0f b7 c9             	movzwl %cx,%ecx
  802909:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802910:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802913:	5b                   	pop    %ebx
  802914:	5e                   	pop    %esi
  802915:	5d                   	pop    %ebp
  802916:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802917:	83 ec 04             	sub    $0x4,%esp
  80291a:	68 b4 10 81 00       	push   $0x8110b4
  80291f:	68 65 04 00 00       	push   $0x465
  802924:	68 02 14 81 00       	push   $0x811402
  802929:	e8 a8 bb 00 00       	call   80e4d6 <_panic>

0080292e <dhcp_option>:
{
  80292e:	55                   	push   %ebp
  80292f:	89 e5                	mov    %esp,%ebp
  802931:	57                   	push   %edi
  802932:	56                   	push   %esi
  802933:	53                   	push   %ebx
  802934:	83 ec 0c             	sub    $0xc,%esp
  802937:	89 d3                	mov    %edx,%ebx
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802939:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  80293d:	0f b6 f9             	movzbl %cl,%edi
  802940:	0f b7 f2             	movzwl %dx,%esi
  802943:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  802947:	83 fe 44             	cmp    $0x44,%esi
  80294a:	77 34                	ja     802980 <dhcp_option+0x52>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80294c:	8b 70 20             	mov    0x20(%eax),%esi
  80294f:	8d 7a 01             	lea    0x1(%edx),%edi
  802952:	66 89 78 24          	mov    %di,0x24(%eax)
  802956:	0f b7 d2             	movzwl %dx,%edx
  802959:	88 9c 16 f0 00 00 00 	mov    %bl,0xf0(%esi,%edx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802960:	8b 58 20             	mov    0x20(%eax),%ebx
  802963:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802967:	8d 72 01             	lea    0x1(%edx),%esi
  80296a:	66 89 70 24          	mov    %si,0x24(%eax)
  80296e:	0f b7 d2             	movzwl %dx,%edx
  802971:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  802978:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80297b:	5b                   	pop    %ebx
  80297c:	5e                   	pop    %esi
  80297d:	5f                   	pop    %edi
  80297e:	5d                   	pop    %ebp
  80297f:	c3                   	ret    
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802980:	83 ec 04             	sub    $0x4,%esp
  802983:	68 f0 10 81 00       	push   $0x8110f0
  802988:	68 5a 04 00 00       	push   $0x45a
  80298d:	68 02 14 81 00       	push   $0x811402
  802992:	e8 3f bb 00 00       	call   80e4d6 <_panic>

00802997 <dhcp_option_short>:
{
  802997:	55                   	push   %ebp
  802998:	89 e5                	mov    %esp,%ebp
  80299a:	56                   	push   %esi
  80299b:	53                   	push   %ebx
  80299c:	89 d1                	mov    %edx,%ecx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80299e:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8029a2:	0f b7 da             	movzwl %dx,%ebx
  8029a5:	83 c3 02             	add    $0x2,%ebx
  8029a8:	83 fb 44             	cmp    $0x44,%ebx
  8029ab:	77 33                	ja     8029e0 <dhcp_option_short+0x49>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  8029ad:	8b 58 20             	mov    0x20(%eax),%ebx
  8029b0:	8d 72 01             	lea    0x1(%edx),%esi
  8029b3:	66 89 70 24          	mov    %si,0x24(%eax)
  8029b7:	0f b7 d2             	movzwl %dx,%edx
  8029ba:	88 ac 13 f0 00 00 00 	mov    %ch,0xf0(%ebx,%edx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  8029c1:	8b 58 20             	mov    0x20(%eax),%ebx
  8029c4:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8029c8:	8d 72 01             	lea    0x1(%edx),%esi
  8029cb:	66 89 70 24          	mov    %si,0x24(%eax)
  8029cf:	0f b7 d2             	movzwl %dx,%edx
  8029d2:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  8029d9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8029dc:	5b                   	pop    %ebx
  8029dd:	5e                   	pop    %esi
  8029de:	5d                   	pop    %ebp
  8029df:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  8029e0:	83 ec 04             	sub    $0x4,%esp
  8029e3:	68 38 11 81 00       	push   $0x811138
  8029e8:	68 6c 04 00 00       	push   $0x46c
  8029ed:	68 02 14 81 00       	push   $0x811402
  8029f2:	e8 df ba 00 00       	call   80e4d6 <_panic>

008029f7 <dhcp_option_trailer>:
{
  8029f7:	55                   	push   %ebp
  8029f8:	89 e5                	mov    %esp,%ebp
  8029fa:	53                   	push   %ebx
  8029fb:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  8029fe:	85 c0                	test   %eax,%eax
  802a00:	74 27                	je     802a29 <dhcp_option_trailer+0x32>
  802a02:	89 c2                	mov    %eax,%edx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802a04:	8b 48 20             	mov    0x20(%eax),%ecx
  802a07:	85 c9                	test   %ecx,%ecx
  802a09:	74 35                	je     802a40 <dhcp_option_trailer+0x49>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a0b:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  802a0f:	66 83 f8 43          	cmp    $0x43,%ax
  802a13:	77 42                	ja     802a57 <dhcp_option_trailer+0x60>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802a15:	8d 58 01             	lea    0x1(%eax),%ebx
  802a18:	66 89 5a 24          	mov    %bx,0x24(%edx)
  802a1c:	0f b7 c0             	movzwl %ax,%eax
  802a1f:	c6 84 01 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%eax,1)
  802a26:	ff 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802a27:	eb 5a                	jmp    802a83 <dhcp_option_trailer+0x8c>
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802a29:	83 ec 04             	sub    $0x4,%esp
  802a2c:	68 7c 11 81 00       	push   $0x81117c
  802a31:	68 80 05 00 00       	push   $0x580
  802a36:	68 02 14 81 00       	push   $0x811402
  802a3b:	e8 96 ba 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802a40:	83 ec 04             	sub    $0x4,%esp
  802a43:	68 a0 11 81 00       	push   $0x8111a0
  802a48:	68 81 05 00 00       	push   $0x581
  802a4d:	68 02 14 81 00       	push   $0x811402
  802a52:	e8 7f ba 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a57:	83 ec 04             	sub    $0x4,%esp
  802a5a:	68 cc 11 81 00       	push   $0x8111cc
  802a5f:	68 82 05 00 00       	push   $0x582
  802a64:	68 02 14 81 00       	push   $0x811402
  802a69:	e8 68 ba 00 00       	call   80e4d6 <_panic>
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802a6e:	8b 4a 20             	mov    0x20(%edx),%ecx
  802a71:	8d 58 01             	lea    0x1(%eax),%ebx
  802a74:	66 89 5a 24          	mov    %bx,0x24(%edx)
  802a78:	0f b7 c0             	movzwl %ax,%eax
  802a7b:	c6 84 01 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%eax,1)
  802a82:	00 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802a83:	0f b7 42 24          	movzwl 0x24(%edx),%eax
  802a87:	66 83 f8 43          	cmp    $0x43,%ax
  802a8b:	76 e1                	jbe    802a6e <dhcp_option_trailer+0x77>
  802a8d:	a8 03                	test   $0x3,%al
  802a8f:	74 17                	je     802aa8 <dhcp_option_trailer+0xb1>
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a91:	83 ec 04             	sub    $0x4,%esp
  802a94:	68 cc 11 81 00       	push   $0x8111cc
  802a99:	68 87 05 00 00       	push   $0x587
  802a9e:	68 02 14 81 00       	push   $0x811402
  802aa3:	e8 2e ba 00 00       	call   80e4d6 <_panic>
}
  802aa8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802aab:	c9                   	leave  
  802aac:	c3                   	ret    

00802aad <dhcp_option_long>:
{
  802aad:	55                   	push   %ebp
  802aae:	89 e5                	mov    %esp,%ebp
  802ab0:	56                   	push   %esi
  802ab1:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802ab2:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802ab6:	0f b7 d9             	movzwl %cx,%ebx
  802ab9:	83 c3 04             	add    $0x4,%ebx
  802abc:	83 fb 44             	cmp    $0x44,%ebx
  802abf:	77 6d                	ja     802b2e <dhcp_option_long+0x81>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802ac1:	8d 71 01             	lea    0x1(%ecx),%esi
  802ac4:	66 89 70 24          	mov    %si,0x24(%eax)
  802ac8:	0f b7 c9             	movzwl %cx,%ecx
  802acb:	89 d3                	mov    %edx,%ebx
  802acd:	c1 eb 18             	shr    $0x18,%ebx
  802ad0:	8b 70 20             	mov    0x20(%eax),%esi
  802ad3:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802ada:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802ade:	8d 71 01             	lea    0x1(%ecx),%esi
  802ae1:	66 89 70 24          	mov    %si,0x24(%eax)
  802ae5:	0f b7 c9             	movzwl %cx,%ecx
  802ae8:	89 d3                	mov    %edx,%ebx
  802aea:	c1 eb 10             	shr    $0x10,%ebx
  802aed:	8b 70 20             	mov    0x20(%eax),%esi
  802af0:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802af7:	8b 58 20             	mov    0x20(%eax),%ebx
  802afa:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802afe:	8d 71 01             	lea    0x1(%ecx),%esi
  802b01:	66 89 70 24          	mov    %si,0x24(%eax)
  802b05:	0f b7 c9             	movzwl %cx,%ecx
  802b08:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802b0f:	8b 58 20             	mov    0x20(%eax),%ebx
  802b12:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b16:	8d 71 01             	lea    0x1(%ecx),%esi
  802b19:	66 89 70 24          	mov    %si,0x24(%eax)
  802b1d:	0f b7 c9             	movzwl %cx,%ecx
  802b20:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802b27:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802b2a:	5b                   	pop    %ebx
  802b2b:	5e                   	pop    %esi
  802b2c:	5d                   	pop    %ebp
  802b2d:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802b2e:	83 ec 04             	sub    $0x4,%esp
  802b31:	68 0c 12 81 00       	push   $0x81120c
  802b36:	68 74 04 00 00       	push   $0x474
  802b3b:	68 02 14 81 00       	push   $0x811402
  802b40:	e8 91 b9 00 00       	call   80e4d6 <_panic>

00802b45 <dhcp_create_request>:
{
  802b45:	55                   	push   %ebp
  802b46:	89 e5                	mov    %esp,%ebp
  802b48:	57                   	push   %edi
  802b49:	56                   	push   %esi
  802b4a:	53                   	push   %ebx
  802b4b:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802b4e:	85 c0                	test   %eax,%eax
  802b50:	0f 84 d8 00 00 00    	je     802c2e <dhcp_create_request+0xe9>
  802b56:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  802b58:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802b5b:	85 db                	test   %ebx,%ebx
  802b5d:	0f 84 e2 00 00 00    	je     802c45 <dhcp_create_request+0x100>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802b63:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802b67:	0f 85 ef 00 00 00    	jne    802c5c <dhcp_create_request+0x117>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802b6d:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802b71:	0f 85 fc 00 00 00    	jne    802c73 <dhcp_create_request+0x12e>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802b77:	83 ec 04             	sub    $0x4,%esp
  802b7a:	6a 00                	push   $0x0
  802b7c:	68 34 01 00 00       	push   $0x134
  802b81:	6a 00                	push   $0x0
  802b83:	e8 8a 1d 00 00       	call   804912 <pbuf_alloc>
  802b88:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802b8b:	83 c4 10             	add    $0x10,%esp
  802b8e:	85 c0                	test   %eax,%eax
  802b90:	0f 84 9b 01 00 00    	je     802d31 <dhcp_create_request+0x1ec>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802b96:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802b9c:	0f 86 e8 00 00 00    	jbe    802c8a <dhcp_create_request+0x145>
  dhcp->xid = xid++;
  802ba2:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802ba8:	8d 4a 01             	lea    0x1(%edx),%ecx
  802bab:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802bb1:	89 53 04             	mov    %edx,0x4(%ebx)
  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802bb4:	8b 40 04             	mov    0x4(%eax),%eax
  802bb7:	89 43 20             	mov    %eax,0x20(%ebx)
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802bba:	c6 00 01             	movb   $0x1,(%eax)
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802bbd:	8b 43 20             	mov    0x20(%ebx),%eax
  802bc0:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802bc4:	8b 43 20             	mov    0x20(%ebx),%eax
  802bc7:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802bcb:	8b 43 20             	mov    0x20(%ebx),%eax
  802bce:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802bd2:	8b 7b 20             	mov    0x20(%ebx),%edi
  802bd5:	83 ec 0c             	sub    $0xc,%esp
  802bd8:	ff 73 04             	push   0x4(%ebx)
  802bdb:	e8 c0 4a 00 00       	call   8076a0 <htonl>
  802be0:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  802be3:	8b 43 20             	mov    0x20(%ebx),%eax
  802be6:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802bec:	8b 43 20             	mov    0x20(%ebx),%eax
  802bef:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802bf5:	8b 43 20             	mov    0x20(%ebx),%eax
  802bf8:	8b 56 04             	mov    0x4(%esi),%edx
  802bfb:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802bfe:	8b 43 20             	mov    0x20(%ebx),%eax
  802c01:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802c08:	8b 43 20             	mov    0x20(%ebx),%eax
  802c0b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802c12:	8b 43 20             	mov    0x20(%ebx),%eax
  802c15:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802c1c:	83 c4 10             	add    $0x10,%esp
  802c1f:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802c24:	bf 00 00 00 00       	mov    $0x0,%edi
  802c29:	e9 82 00 00 00       	jmp    802cb0 <dhcp_create_request+0x16b>
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802c2e:	83 ec 04             	sub    $0x4,%esp
  802c31:	68 4c 12 81 00       	push   $0x81124c
  802c36:	68 2d 05 00 00       	push   $0x52d
  802c3b:	68 02 14 81 00       	push   $0x811402
  802c40:	e8 91 b8 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802c45:	83 ec 04             	sub    $0x4,%esp
  802c48:	68 70 12 81 00       	push   $0x811270
  802c4d:	68 2f 05 00 00       	push   $0x52f
  802c52:	68 02 14 81 00       	push   $0x811402
  802c57:	e8 7a b8 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802c5c:	83 ec 04             	sub    $0x4,%esp
  802c5f:	68 94 12 81 00       	push   $0x811294
  802c64:	68 30 05 00 00       	push   $0x530
  802c69:	68 02 14 81 00       	push   $0x811402
  802c6e:	e8 63 b8 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802c73:	83 ec 04             	sub    $0x4,%esp
  802c76:	68 c0 12 81 00       	push   $0x8112c0
  802c7b:	68 31 05 00 00       	push   $0x531
  802c80:	68 02 14 81 00       	push   $0x811402
  802c85:	e8 4c b8 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802c8a:	83 ec 04             	sub    $0x4,%esp
  802c8d:	68 ec 12 81 00       	push   $0x8112ec
  802c92:	68 37 05 00 00       	push   $0x537
  802c97:	68 02 14 81 00       	push   $0x811402
  802c9c:	e8 35 b8 00 00       	call   80e4d6 <_panic>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802ca1:	8b 4b 20             	mov    0x20(%ebx),%ecx
  802ca4:	88 54 01 1c          	mov    %dl,0x1c(%ecx,%eax,1)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802ca8:	83 c0 01             	add    $0x1,%eax
  802cab:	83 f8 10             	cmp    $0x10,%eax
  802cae:	74 12                	je     802cc2 <dhcp_create_request+0x17d>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802cb0:	0f b6 4e 24          	movzbl 0x24(%esi),%ecx
  802cb4:	89 fa                	mov    %edi,%edx
  802cb6:	66 39 c1             	cmp    %ax,%cx
  802cb9:	76 e6                	jbe    802ca1 <dhcp_create_request+0x15c>
  802cbb:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  802cc0:	eb df                	jmp    802ca1 <dhcp_create_request+0x15c>
  802cc2:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  802cc7:	8b 53 20             	mov    0x20(%ebx),%edx
  802cca:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802ccf:	83 c0 01             	add    $0x1,%eax
  802cd2:	83 f8 40             	cmp    $0x40,%eax
  802cd5:	75 f0                	jne    802cc7 <dhcp_create_request+0x182>
  802cd7:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->file[i] = 0;
  802cdc:	8b 53 20             	mov    0x20(%ebx),%edx
  802cdf:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802ce4:	83 c0 01             	add    $0x1,%eax
  802ce7:	3d 80 00 00 00       	cmp    $0x80,%eax
  802cec:	75 ee                	jne    802cdc <dhcp_create_request+0x197>
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802cee:	8b 73 20             	mov    0x20(%ebx),%esi
  802cf1:	83 ec 0c             	sub    $0xc,%esp
  802cf4:	68 63 53 82 63       	push   $0x63825363
  802cf9:	e8 a2 49 00 00       	call   8076a0 <htonl>
  802cfe:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802d04:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802d0a:	83 c4 10             	add    $0x10,%esp
  802d0d:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802d12:	8b 53 20             	mov    0x20(%ebx),%edx
  802d15:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802d1c:	83 c0 01             	add    $0x1,%eax
  802d1f:	83 f8 44             	cmp    $0x44,%eax
  802d22:	75 ee                	jne    802d12 <dhcp_create_request+0x1cd>
  return ERR_OK;
  802d24:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802d29:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802d2c:	5b                   	pop    %ebx
  802d2d:	5e                   	pop    %esi
  802d2e:	5f                   	pop    %edi
  802d2f:	5d                   	pop    %ebp
  802d30:	c3                   	ret    
    return ERR_MEM;
  802d31:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802d36:	eb f1                	jmp    802d29 <dhcp_create_request+0x1e4>

00802d38 <dhcp_delete_request>:
{
  802d38:	55                   	push   %ebp
  802d39:	89 e5                	mov    %esp,%ebp
  802d3b:	53                   	push   %ebx
  802d3c:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802d3f:	85 c0                	test   %eax,%eax
  802d41:	74 33                	je     802d76 <dhcp_delete_request+0x3e>
  dhcp = netif->dhcp;
  802d43:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802d46:	85 db                	test   %ebx,%ebx
  802d48:	74 43                	je     802d8d <dhcp_delete_request+0x55>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802d4a:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802d4d:	85 c0                	test   %eax,%eax
  802d4f:	74 53                	je     802da4 <dhcp_delete_request+0x6c>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802d51:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802d55:	74 64                	je     802dbb <dhcp_delete_request+0x83>
    pbuf_free(dhcp->p_out);
  802d57:	83 ec 0c             	sub    $0xc,%esp
  802d5a:	50                   	push   %eax
  802d5b:	e8 ec 1a 00 00       	call   80484c <pbuf_free>
  dhcp->p_out = NULL;
  802d60:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802d67:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  802d6e:	83 c4 10             	add    $0x10,%esp
}
  802d71:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802d74:	c9                   	leave  
  802d75:	c3                   	ret    
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802d76:	83 ec 04             	sub    $0x4,%esp
  802d79:	68 30 13 81 00       	push   $0x811330
  802d7e:	68 69 05 00 00       	push   $0x569
  802d83:	68 02 14 81 00       	push   $0x811402
  802d88:	e8 49 b7 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802d8d:	83 ec 04             	sub    $0x4,%esp
  802d90:	68 54 13 81 00       	push   $0x811354
  802d95:	68 6b 05 00 00       	push   $0x56b
  802d9a:	68 02 14 81 00       	push   $0x811402
  802d9f:	e8 32 b7 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802da4:	83 ec 04             	sub    $0x4,%esp
  802da7:	68 78 13 81 00       	push   $0x811378
  802dac:	68 6c 05 00 00       	push   $0x56c
  802db1:	68 02 14 81 00       	push   $0x811402
  802db6:	e8 1b b7 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802dbb:	83 ec 04             	sub    $0x4,%esp
  802dbe:	68 a4 13 81 00       	push   $0x8113a4
  802dc3:	68 6d 05 00 00       	push   $0x56d
  802dc8:	68 02 14 81 00       	push   $0x811402
  802dcd:	e8 04 b7 00 00       	call   80e4d6 <_panic>

00802dd2 <dhcp_rebind>:
{
  802dd2:	55                   	push   %ebp
  802dd3:	89 e5                	mov    %esp,%ebp
  802dd5:	57                   	push   %edi
  802dd6:	56                   	push   %esi
  802dd7:	53                   	push   %ebx
  802dd8:	83 ec 0c             	sub    $0xc,%esp
  802ddb:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802ddd:	8b 58 20             	mov    0x20(%eax),%ebx
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802de0:	ba 04 00 00 00       	mov    $0x4,%edx
  802de5:	89 d8                	mov    %ebx,%eax
  802de7:	e8 c3 f9 ff ff       	call   8027af <dhcp_set_state>
  result = dhcp_create_request(netif);
  802dec:	89 f8                	mov    %edi,%eax
  802dee:	e8 52 fd ff ff       	call   802b45 <dhcp_create_request>
  802df3:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802df5:	84 c0                	test   %al,%al
  802df7:	74 3d                	je     802e36 <dhcp_rebind+0x64>
  dhcp->tries++;
  802df9:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802dfd:	83 c0 01             	add    $0x1,%eax
  802e00:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802e03:	ba 10 27 00 00       	mov    $0x2710,%edx
  802e08:	3c 09                	cmp    $0x9,%al
  802e0a:	77 08                	ja     802e14 <dhcp_rebind+0x42>
  802e0c:	0f b6 c0             	movzbl %al,%eax
  802e0f:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802e14:	66 81 c2 f3 01       	add    $0x1f3,%dx
  802e19:	0f b7 d2             	movzwl %dx,%edx
  802e1c:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802e21:	89 d0                	mov    %edx,%eax
  802e23:	f7 e9                	imul   %ecx
  802e25:	c1 fa 05             	sar    $0x5,%edx
  802e28:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802e2c:	89 f0                	mov    %esi,%eax
  802e2e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802e31:	5b                   	pop    %ebx
  802e32:	5e                   	pop    %esi
  802e33:	5f                   	pop    %edi
  802e34:	5d                   	pop    %ebp
  802e35:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802e36:	b9 01 00 00 00       	mov    $0x1,%ecx
  802e3b:	ba 35 00 00 00       	mov    $0x35,%edx
  802e40:	89 d8                	mov    %ebx,%eax
  802e42:	e8 e7 fa ff ff       	call   80292e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802e47:	ba 03 00 00 00       	mov    $0x3,%edx
  802e4c:	89 d8                	mov    %ebx,%eax
  802e4e:	e8 9a fa ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802e53:	b9 02 00 00 00       	mov    $0x2,%ecx
  802e58:	ba 39 00 00 00       	mov    $0x39,%edx
  802e5d:	89 d8                	mov    %ebx,%eax
  802e5f:	e8 ca fa ff ff       	call   80292e <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802e64:	ba 40 02 00 00       	mov    $0x240,%edx
  802e69:	89 d8                	mov    %ebx,%eax
  802e6b:	e8 27 fb ff ff       	call   802997 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  802e70:	89 d8                	mov    %ebx,%eax
  802e72:	e8 80 fb ff ff       	call   8029f7 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802e77:	83 ec 08             	sub    $0x8,%esp
  802e7a:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802e7e:	66 05 f0 00          	add    $0xf0,%ax
  802e82:	0f b7 c0             	movzwl %ax,%eax
  802e85:	50                   	push   %eax
  802e86:	ff 73 1c             	push   0x1c(%ebx)
  802e89:	e8 e3 1c 00 00       	call   804b71 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802e8e:	83 c4 0c             	add    $0xc,%esp
  802e91:	6a 43                	push   $0x43
  802e93:	68 a8 1c 81 00       	push   $0x811ca8
  802e98:	ff 73 08             	push   0x8(%ebx)
  802e9b:	e8 01 60 00 00       	call   808ea1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802ea0:	89 3c 24             	mov    %edi,(%esp)
  802ea3:	6a 43                	push   $0x43
  802ea5:	68 a4 1c 81 00       	push   $0x811ca4
  802eaa:	ff 73 1c             	push   0x1c(%ebx)
  802ead:	ff 73 08             	push   0x8(%ebx)
  802eb0:	e8 f7 5d 00 00       	call   808cac <udp_sendto_if>
    dhcp_delete_request(netif);
  802eb5:	83 c4 20             	add    $0x20,%esp
  802eb8:	89 f8                	mov    %edi,%eax
  802eba:	e8 79 fe ff ff       	call   802d38 <dhcp_delete_request>
  802ebf:	e9 35 ff ff ff       	jmp    802df9 <dhcp_rebind+0x27>

00802ec4 <dhcp_discover>:
{
  802ec4:	55                   	push   %ebp
  802ec5:	89 e5                	mov    %esp,%ebp
  802ec7:	57                   	push   %edi
  802ec8:	56                   	push   %esi
  802ec9:	53                   	push   %ebx
  802eca:	83 ec 0c             	sub    $0xc,%esp
  802ecd:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802ecf:	8b 58 20             	mov    0x20(%eax),%ebx
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802ed2:	a1 a8 1c 81 00       	mov    0x811ca8,%eax
  802ed7:	89 43 30             	mov    %eax,0x30(%ebx)
  result = dhcp_create_request(netif);
  802eda:	89 f8                	mov    %edi,%eax
  802edc:	e8 64 fc ff ff       	call   802b45 <dhcp_create_request>
  802ee1:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802ee3:	84 c0                	test   %al,%al
  802ee5:	74 40                	je     802f27 <dhcp_discover+0x63>
  dhcp->tries++;
  802ee7:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802eeb:	83 c0 01             	add    $0x1,%eax
  802eee:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802ef1:	ba 10 27 00 00       	mov    $0x2710,%edx
  802ef6:	3c 03                	cmp    $0x3,%al
  802ef8:	77 0b                	ja     802f05 <dhcp_discover+0x41>
  802efa:	0f b6 c0             	movzbl %al,%eax
  802efd:	83 c0 01             	add    $0x1,%eax
  802f00:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802f05:	66 81 c2 f3 01       	add    $0x1f3,%dx
  802f0a:	0f b7 d2             	movzwl %dx,%edx
  802f0d:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802f12:	89 d0                	mov    %edx,%eax
  802f14:	f7 e9                	imul   %ecx
  802f16:	c1 fa 05             	sar    $0x5,%edx
  802f19:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802f1d:	89 f0                	mov    %esi,%eax
  802f1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802f22:	5b                   	pop    %ebx
  802f23:	5e                   	pop    %esi
  802f24:	5f                   	pop    %edi
  802f25:	5d                   	pop    %ebp
  802f26:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802f27:	b9 01 00 00 00       	mov    $0x1,%ecx
  802f2c:	ba 35 00 00 00       	mov    $0x35,%edx
  802f31:	89 d8                	mov    %ebx,%eax
  802f33:	e8 f6 f9 ff ff       	call   80292e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802f38:	ba 01 00 00 00       	mov    $0x1,%edx
  802f3d:	89 d8                	mov    %ebx,%eax
  802f3f:	e8 a9 f9 ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802f44:	b9 02 00 00 00       	mov    $0x2,%ecx
  802f49:	ba 39 00 00 00       	mov    $0x39,%edx
  802f4e:	89 d8                	mov    %ebx,%eax
  802f50:	e8 d9 f9 ff ff       	call   80292e <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802f55:	ba 40 02 00 00       	mov    $0x240,%edx
  802f5a:	89 d8                	mov    %ebx,%eax
  802f5c:	e8 36 fa ff ff       	call   802997 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802f61:	b9 04 00 00 00       	mov    $0x4,%ecx
  802f66:	ba 37 00 00 00       	mov    $0x37,%edx
  802f6b:	89 d8                	mov    %ebx,%eax
  802f6d:	e8 bc f9 ff ff       	call   80292e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802f72:	ba 01 00 00 00       	mov    $0x1,%edx
  802f77:	89 d8                	mov    %ebx,%eax
  802f79:	e8 6f f9 ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802f7e:	ba 03 00 00 00       	mov    $0x3,%edx
  802f83:	89 d8                	mov    %ebx,%eax
  802f85:	e8 63 f9 ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802f8a:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802f8f:	89 d8                	mov    %ebx,%eax
  802f91:	e8 57 f9 ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802f96:	ba 06 00 00 00       	mov    $0x6,%edx
  802f9b:	89 d8                	mov    %ebx,%eax
  802f9d:	e8 4b f9 ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  802fa2:	89 d8                	mov    %ebx,%eax
  802fa4:	e8 4e fa ff ff       	call   8029f7 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802fa9:	83 ec 08             	sub    $0x8,%esp
  802fac:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802fb0:	66 05 f0 00          	add    $0xf0,%ax
  802fb4:	0f b7 c0             	movzwl %ax,%eax
  802fb7:	50                   	push   %eax
  802fb8:	ff 73 1c             	push   0x1c(%ebx)
  802fbb:	e8 b1 1b 00 00       	call   804b71 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802fc0:	83 c4 0c             	add    $0xc,%esp
  802fc3:	6a 43                	push   $0x43
  802fc5:	68 a8 1c 81 00       	push   $0x811ca8
  802fca:	ff 73 08             	push   0x8(%ebx)
  802fcd:	e8 cf 5e 00 00       	call   808ea1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802fd2:	89 3c 24             	mov    %edi,(%esp)
  802fd5:	6a 43                	push   $0x43
  802fd7:	68 a4 1c 81 00       	push   $0x811ca4
  802fdc:	ff 73 1c             	push   0x1c(%ebx)
  802fdf:	ff 73 08             	push   0x8(%ebx)
  802fe2:	e8 c5 5c 00 00       	call   808cac <udp_sendto_if>
    dhcp_delete_request(netif);
  802fe7:	83 c4 20             	add    $0x20,%esp
  802fea:	89 f8                	mov    %edi,%eax
  802fec:	e8 47 fd ff ff       	call   802d38 <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_SELECTING);
  802ff1:	ba 06 00 00 00       	mov    $0x6,%edx
  802ff6:	89 d8                	mov    %ebx,%eax
  802ff8:	e8 b2 f7 ff ff       	call   8027af <dhcp_set_state>
  802ffd:	e9 e5 fe ff ff       	jmp    802ee7 <dhcp_discover+0x23>

00803002 <dhcp_select>:
{
  803002:	55                   	push   %ebp
  803003:	89 e5                	mov    %esp,%ebp
  803005:	57                   	push   %edi
  803006:	56                   	push   %esi
  803007:	53                   	push   %ebx
  803008:	83 ec 0c             	sub    $0xc,%esp
  80300b:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80300d:	8b 58 20             	mov    0x20(%eax),%ebx
  result = dhcp_create_request(netif);
  803010:	e8 30 fb ff ff       	call   802b45 <dhcp_create_request>
  803015:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803017:	84 c0                	test   %al,%al
  803019:	74 3d                	je     803058 <dhcp_select+0x56>
  dhcp->tries++;
  80301b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  80301f:	83 c0 01             	add    $0x1,%eax
  803022:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  803025:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  80302a:	3c 03                	cmp    $0x3,%al
  80302c:	77 08                	ja     803036 <dhcp_select+0x34>
  80302e:	0f b6 c0             	movzbl %al,%eax
  803031:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803036:	66 81 c2 f3 01       	add    $0x1f3,%dx
  80303b:	0f b7 d2             	movzwl %dx,%edx
  80303e:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803043:	89 d0                	mov    %edx,%eax
  803045:	f7 e9                	imul   %ecx
  803047:	c1 fa 05             	sar    $0x5,%edx
  80304a:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  80304e:	89 f0                	mov    %esi,%eax
  803050:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803053:	5b                   	pop    %ebx
  803054:	5e                   	pop    %esi
  803055:	5f                   	pop    %edi
  803056:	5d                   	pop    %ebp
  803057:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803058:	b9 01 00 00 00       	mov    $0x1,%ecx
  80305d:	ba 35 00 00 00       	mov    $0x35,%edx
  803062:	89 d8                	mov    %ebx,%eax
  803064:	e8 c5 f8 ff ff       	call   80292e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803069:	ba 03 00 00 00       	mov    $0x3,%edx
  80306e:	89 d8                	mov    %ebx,%eax
  803070:	e8 78 f8 ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803075:	b9 02 00 00 00       	mov    $0x2,%ecx
  80307a:	ba 39 00 00 00       	mov    $0x39,%edx
  80307f:	89 d8                	mov    %ebx,%eax
  803081:	e8 a8 f8 ff ff       	call   80292e <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803086:	ba 40 02 00 00       	mov    $0x240,%edx
  80308b:	89 d8                	mov    %ebx,%eax
  80308d:	e8 05 f9 ff ff       	call   802997 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803092:	b9 04 00 00 00       	mov    $0x4,%ecx
  803097:	ba 32 00 00 00       	mov    $0x32,%edx
  80309c:	89 d8                	mov    %ebx,%eax
  80309e:	e8 8b f8 ff ff       	call   80292e <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8030a3:	83 ec 0c             	sub    $0xc,%esp
  8030a6:	ff 73 30             	push   0x30(%ebx)
  8030a9:	e8 1a 48 00 00       	call   8078c8 <ntohl>
  8030ae:	89 c2                	mov    %eax,%edx
  8030b0:	89 d8                	mov    %ebx,%eax
  8030b2:	e8 f6 f9 ff ff       	call   802aad <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8030b7:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030bc:	ba 36 00 00 00       	mov    $0x36,%edx
  8030c1:	89 d8                	mov    %ebx,%eax
  8030c3:	e8 66 f8 ff ff       	call   80292e <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8030c8:	83 c4 04             	add    $0x4,%esp
  8030cb:	ff 73 2c             	push   0x2c(%ebx)
  8030ce:	e8 f5 47 00 00       	call   8078c8 <ntohl>
  8030d3:	89 c2                	mov    %eax,%edx
  8030d5:	89 d8                	mov    %ebx,%eax
  8030d7:	e8 d1 f9 ff ff       	call   802aad <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8030dc:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030e1:	ba 37 00 00 00       	mov    $0x37,%edx
  8030e6:	89 d8                	mov    %ebx,%eax
  8030e8:	e8 41 f8 ff ff       	call   80292e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8030ed:	ba 01 00 00 00       	mov    $0x1,%edx
  8030f2:	89 d8                	mov    %ebx,%eax
  8030f4:	e8 f4 f7 ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8030f9:	ba 03 00 00 00       	mov    $0x3,%edx
  8030fe:	89 d8                	mov    %ebx,%eax
  803100:	e8 e8 f7 ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803105:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80310a:	89 d8                	mov    %ebx,%eax
  80310c:	e8 dc f7 ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803111:	ba 06 00 00 00       	mov    $0x6,%edx
  803116:	89 d8                	mov    %ebx,%eax
  803118:	e8 d0 f7 ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  80311d:	89 d8                	mov    %ebx,%eax
  80311f:	e8 d3 f8 ff ff       	call   8029f7 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803124:	83 c4 08             	add    $0x8,%esp
  803127:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80312b:	66 05 f0 00          	add    $0xf0,%ax
  80312f:	0f b7 c0             	movzwl %ax,%eax
  803132:	50                   	push   %eax
  803133:	ff 73 1c             	push   0x1c(%ebx)
  803136:	e8 36 1a 00 00       	call   804b71 <pbuf_realloc>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80313b:	89 3c 24             	mov    %edi,(%esp)
  80313e:	6a 43                	push   $0x43
  803140:	68 a4 1c 81 00       	push   $0x811ca4
  803145:	ff 73 1c             	push   0x1c(%ebx)
  803148:	ff 73 08             	push   0x8(%ebx)
  80314b:	e8 5c 5b 00 00       	call   808cac <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803150:	83 c4 1c             	add    $0x1c,%esp
  803153:	6a 43                	push   $0x43
  803155:	68 a8 1c 81 00       	push   $0x811ca8
  80315a:	ff 73 08             	push   0x8(%ebx)
  80315d:	e8 3f 5d 00 00       	call   808ea1 <udp_connect>
    dhcp_delete_request(netif);
  803162:	89 f8                	mov    %edi,%eax
  803164:	e8 cf fb ff ff       	call   802d38 <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  803169:	ba 01 00 00 00       	mov    $0x1,%edx
  80316e:	89 d8                	mov    %ebx,%eax
  803170:	e8 3a f6 ff ff       	call   8027af <dhcp_set_state>
  803175:	83 c4 10             	add    $0x10,%esp
  803178:	e9 9e fe ff ff       	jmp    80301b <dhcp_select+0x19>

0080317d <dhcp_check>:
{
  80317d:	55                   	push   %ebp
  80317e:	89 e5                	mov    %esp,%ebp
  803180:	53                   	push   %ebx
  803181:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  803184:	8b 58 20             	mov    0x20(%eax),%ebx
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  803187:	6a 00                	push   $0x0
  803189:	8d 53 30             	lea    0x30(%ebx),%edx
  80318c:	52                   	push   %edx
  80318d:	50                   	push   %eax
  80318e:	e8 ec 66 00 00       	call   80987f <etharp_query>
  dhcp->tries++;
  803193:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803197:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  dhcp_set_state(dhcp, DHCP_CHECKING);
  80319d:	ba 08 00 00 00       	mov    $0x8,%edx
  8031a2:	89 d8                	mov    %ebx,%eax
  8031a4:	e8 06 f6 ff ff       	call   8027af <dhcp_set_state>
}
  8031a9:	83 c4 10             	add    $0x10,%esp
  8031ac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8031af:	c9                   	leave  
  8031b0:	c3                   	ret    

008031b1 <dhcp_bind>:
{
  8031b1:	55                   	push   %ebp
  8031b2:	89 e5                	mov    %esp,%ebp
  8031b4:	56                   	push   %esi
  8031b5:	53                   	push   %ebx
  8031b6:	83 ec 10             	sub    $0x10,%esp
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8031b9:	85 c0                	test   %eax,%eax
  8031bb:	0f 84 d9 00 00 00    	je     80329a <dhcp_bind+0xe9>
  8031c1:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  8031c3:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  8031c6:	85 db                	test   %ebx,%ebx
  8031c8:	0f 84 e3 00 00 00    	je     8032b1 <dhcp_bind+0x100>
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  8031ce:	8b 53 50             	mov    0x50(%ebx),%edx
  8031d1:	83 fa ff             	cmp    $0xffffffff,%edx
  8031d4:	74 2f                	je     803205 <dhcp_bind+0x54>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8031d6:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  8031d9:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  8031df:	0f 87 7e 01 00 00    	ja     803363 <dhcp_bind+0x1b2>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8031e5:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  8031ea:	89 d0                	mov    %edx,%eax
  8031ec:	f7 e1                	mul    %ecx
  8031ee:	89 d0                	mov    %edx,%eax
  8031f0:	c1 e8 05             	shr    $0x5,%eax
    if (dhcp->t1_timeout == 0) {
  8031f3:	f7 c2 e0 ff 1f 00    	test   $0x1fffe0,%edx
  8031f9:	0f 85 c9 00 00 00    	jne    8032c8 <dhcp_bind+0x117>
      dhcp->t1_timeout = 1;
  8031ff:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  803205:	8b 53 54             	mov    0x54(%ebx),%edx
  803208:	83 fa ff             	cmp    $0xffffffff,%edx
  80320b:	74 2f                	je     80323c <dhcp_bind+0x8b>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80320d:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  803210:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  803216:	0f 87 3c 01 00 00    	ja     803358 <dhcp_bind+0x1a7>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80321c:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803221:	89 d0                	mov    %edx,%eax
  803223:	f7 e1                	mul    %ecx
  803225:	89 d0                	mov    %edx,%eax
  803227:	c1 e8 05             	shr    $0x5,%eax
    if (dhcp->t2_timeout == 0) {
  80322a:	f7 c2 e0 ff 1f 00    	test   $0x1fffe0,%edx
  803230:	0f 85 9b 00 00 00    	jne    8032d1 <dhcp_bind+0x120>
      dhcp->t2_timeout = 1;
  803236:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80323c:	8b 43 34             	mov    0x34(%ebx),%eax
  80323f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sn_mask.addr == 0) {
  803242:	85 c0                	test   %eax,%eax
  803244:	0f 84 90 00 00 00    	je     8032da <dhcp_bind+0x129>
  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80324a:	8b 43 38             	mov    0x38(%ebx),%eax
  80324d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (gw_addr.addr == 0) {
  803250:	85 c0                	test   %eax,%eax
  803252:	0f 84 e2 00 00 00    	je     80333a <dhcp_bind+0x189>
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  803258:	83 ec 08             	sub    $0x8,%esp
  80325b:	8d 43 30             	lea    0x30(%ebx),%eax
  80325e:	50                   	push   %eax
  80325f:	56                   	push   %esi
  803260:	e8 55 13 00 00       	call   8045ba <netif_set_ipaddr>
  netif_set_netmask(netif, &sn_mask);
  803265:	83 c4 08             	add    $0x8,%esp
  803268:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80326b:	50                   	push   %eax
  80326c:	56                   	push   %esi
  80326d:	e8 8d 14 00 00       	call   8046ff <netif_set_netmask>
  netif_set_gw(netif, &gw_addr);
  803272:	83 c4 08             	add    $0x8,%esp
  803275:	8d 45 f0             	lea    -0x10(%ebp),%eax
  803278:	50                   	push   %eax
  803279:	56                   	push   %esi
  80327a:	e8 67 14 00 00       	call   8046e6 <netif_set_gw>
  netif_set_up(netif);
  80327f:	89 34 24             	mov    %esi,(%esp)
  803282:	e8 9e 14 00 00       	call   804725 <netif_set_up>
  dhcp_set_state(dhcp, DHCP_BOUND);
  803287:	ba 0a 00 00 00       	mov    $0xa,%edx
  80328c:	89 d8                	mov    %ebx,%eax
  80328e:	e8 1c f5 ff ff       	call   8027af <dhcp_set_state>
}
  803293:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803296:	5b                   	pop    %ebx
  803297:	5e                   	pop    %esi
  803298:	5d                   	pop    %ebp
  803299:	c3                   	ret    
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80329a:	83 ec 04             	sub    $0x4,%esp
  80329d:	68 17 14 81 00       	push   $0x811417
  8032a2:	68 3d 03 00 00       	push   $0x33d
  8032a7:	68 02 14 81 00       	push   $0x811402
  8032ac:	e8 25 b2 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  8032b1:	83 ec 04             	sub    $0x4,%esp
  8032b4:	68 30 14 81 00       	push   $0x811430
  8032b9:	68 3f 03 00 00       	push   $0x33f
  8032be:	68 02 14 81 00       	push   $0x811402
  8032c3:	e8 0e b2 00 00       	call   80e4d6 <_panic>
    dhcp->t1_timeout = (u16_t)timeout;
  8032c8:	66 89 43 28          	mov    %ax,0x28(%ebx)
  8032cc:	e9 34 ff ff ff       	jmp    803205 <dhcp_bind+0x54>
    dhcp->t2_timeout = (u16_t)timeout;
  8032d1:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
  8032d5:	e9 62 ff ff ff       	jmp    80323c <dhcp_bind+0x8b>
    u8_t first_octet = ip4_addr1(&sn_mask);
  8032da:	83 ec 0c             	sub    $0xc,%esp
  8032dd:	6a 00                	push   $0x0
  8032df:	e8 e4 45 00 00       	call   8078c8 <ntohl>
  8032e4:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  8032e7:	83 c4 10             	add    $0x10,%esp
  8032ea:	84 c0                	test   %al,%al
  8032ec:	79 1c                	jns    80330a <dhcp_bind+0x159>
    } else if (first_octet >= 192) {
  8032ee:	3c bf                	cmp    $0xbf,%al
  8032f0:	76 30                	jbe    803322 <dhcp_bind+0x171>
      sn_mask.addr = htonl(0xffffff00);
  8032f2:	83 ec 0c             	sub    $0xc,%esp
  8032f5:	68 00 ff ff ff       	push   $0xffffff00
  8032fa:	e8 a1 43 00 00       	call   8076a0 <htonl>
  8032ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803302:	83 c4 10             	add    $0x10,%esp
  803305:	e9 40 ff ff ff       	jmp    80324a <dhcp_bind+0x99>
      sn_mask.addr = htonl(0xff000000);
  80330a:	83 ec 0c             	sub    $0xc,%esp
  80330d:	68 00 00 00 ff       	push   $0xff000000
  803312:	e8 89 43 00 00       	call   8076a0 <htonl>
  803317:	89 45 f4             	mov    %eax,-0xc(%ebp)
  80331a:	83 c4 10             	add    $0x10,%esp
  80331d:	e9 28 ff ff ff       	jmp    80324a <dhcp_bind+0x99>
      sn_mask.addr = htonl(0xffff0000);
  803322:	83 ec 0c             	sub    $0xc,%esp
  803325:	68 00 00 ff ff       	push   $0xffff0000
  80332a:	e8 71 43 00 00       	call   8076a0 <htonl>
  80332f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803332:	83 c4 10             	add    $0x10,%esp
  803335:	e9 10 ff ff ff       	jmp    80324a <dhcp_bind+0x99>
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80333a:	8b 43 30             	mov    0x30(%ebx),%eax
  80333d:	23 45 f4             	and    -0xc(%ebp),%eax
  803340:	89 45 f0             	mov    %eax,-0x10(%ebp)
    gw_addr.addr |= htonl(0x00000001);
  803343:	83 ec 0c             	sub    $0xc,%esp
  803346:	6a 01                	push   $0x1
  803348:	e8 53 43 00 00       	call   8076a0 <htonl>
  80334d:	09 45 f0             	or     %eax,-0x10(%ebp)
  803350:	83 c4 10             	add    $0x10,%esp
  803353:	e9 00 ff ff ff       	jmp    803258 <dhcp_bind+0xa7>
    dhcp->t2_timeout = (u16_t)timeout;
  803358:	66 c7 43 2a ff ff    	movw   $0xffff,0x2a(%ebx)
  80335e:	e9 d9 fe ff ff       	jmp    80323c <dhcp_bind+0x8b>
    dhcp->t1_timeout = (u16_t)timeout;
  803363:	66 c7 43 28 ff ff    	movw   $0xffff,0x28(%ebx)
  803369:	e9 97 fe ff ff       	jmp    803205 <dhcp_bind+0x54>

0080336e <dhcp_free_reply>:
{
  80336e:	55                   	push   %ebp
  80336f:	89 e5                	mov    %esp,%ebp
  803371:	53                   	push   %ebx
  803372:	83 ec 04             	sub    $0x4,%esp
  803375:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  803377:	8b 40 10             	mov    0x10(%eax),%eax
  80337a:	85 c0                	test   %eax,%eax
  80337c:	74 13                	je     803391 <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  80337e:	83 ec 0c             	sub    $0xc,%esp
  803381:	50                   	push   %eax
  803382:	e8 db 0b 00 00       	call   803f62 <mem_free>
    dhcp->msg_in = NULL;
  803387:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80338e:	83 c4 10             	add    $0x10,%esp
  if (dhcp->options_in) {
  803391:	8b 43 14             	mov    0x14(%ebx),%eax
  803394:	85 c0                	test   %eax,%eax
  803396:	74 19                	je     8033b1 <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  803398:	83 ec 0c             	sub    $0xc,%esp
  80339b:	50                   	push   %eax
  80339c:	e8 c1 0b 00 00       	call   803f62 <mem_free>
    dhcp->options_in = NULL;
  8033a1:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  8033a8:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  8033ae:	83 c4 10             	add    $0x10,%esp
}
  8033b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8033b4:	c9                   	leave  
  8033b5:	c3                   	ret    

008033b6 <dhcp_recv>:
{
  8033b6:	55                   	push   %ebp
  8033b7:	89 e5                	mov    %esp,%ebp
  8033b9:	57                   	push   %edi
  8033ba:	56                   	push   %esi
  8033bb:	53                   	push   %ebx
  8033bc:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp = netif->dhcp;
  8033bf:	8b 45 08             	mov    0x8(%ebp),%eax
  8033c2:	8b 78 20             	mov    0x20(%eax),%edi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  8033c5:	8b 45 10             	mov    0x10(%ebp),%eax
  8033c8:	8b 70 04             	mov    0x4(%eax),%esi
  8033cb:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  dhcp->p = p;
  8033ce:	89 47 0c             	mov    %eax,0xc(%edi)
  if (reply_msg->op != DHCP_BOOTREPLY) {
  8033d1:	80 3e 02             	cmpb   $0x2,(%esi)
  8033d4:	75 26                	jne    8033fc <dhcp_recv+0x46>
  8033d6:	8b 45 08             	mov    0x8(%ebp),%eax
  8033d9:	83 c0 25             	add    $0x25,%eax
  8033dc:	8d 56 1c             	lea    0x1c(%esi),%edx
  8033df:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8033e2:	0f b6 71 24          	movzbl 0x24(%ecx),%esi
  8033e6:	01 c6                	add    %eax,%esi
  for (i = 0; i < netif->hwaddr_len; i++) {
  8033e8:	39 f0                	cmp    %esi,%eax
  8033ea:	74 2a                	je     803416 <dhcp_recv+0x60>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  8033ec:	0f b6 18             	movzbl (%eax),%ebx
  8033ef:	0f b6 0a             	movzbl (%edx),%ecx
  8033f2:	83 c0 01             	add    $0x1,%eax
  8033f5:	83 c2 01             	add    $0x1,%edx
  8033f8:	38 cb                	cmp    %cl,%bl
  8033fa:	74 ec                	je     8033e8 <dhcp_recv+0x32>
  pbuf_free(p);
  8033fc:	83 ec 0c             	sub    $0xc,%esp
  8033ff:	ff 75 10             	push   0x10(%ebp)
  803402:	e8 45 14 00 00       	call   80484c <pbuf_free>
  dhcp->p = NULL;
  803407:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
}
  80340e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803411:	5b                   	pop    %ebx
  803412:	5e                   	pop    %esi
  803413:	5f                   	pop    %edi
  803414:	5d                   	pop    %ebp
  803415:	c3                   	ret    
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  803416:	83 ec 0c             	sub    $0xc,%esp
  803419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80341c:	ff 70 04             	push   0x4(%eax)
  80341f:	e8 a4 44 00 00       	call   8078c8 <ntohl>
  803424:	83 c4 10             	add    $0x10,%esp
  803427:	3b 47 04             	cmp    0x4(%edi),%eax
  80342a:	75 d0                	jne    8033fc <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80342c:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
  803430:	0f 84 17 01 00 00    	je     80354d <dhcp_recv+0x197>
  dhcp_free_reply(dhcp);
  803436:	89 f8                	mov    %edi,%eax
  803438:	e8 31 ff ff ff       	call   80336e <dhcp_free_reply>
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80343d:	8b 47 0c             	mov    0xc(%edi),%eax
  803440:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  803444:	66 3d f0 00          	cmp    $0xf0,%ax
  803448:	76 1e                	jbe    803468 <dhcp_recv+0xb2>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80344a:	66 2d f0 00          	sub    $0xf0,%ax
  80344e:	66 89 47 18          	mov    %ax,0x18(%edi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  803452:	83 ec 0c             	sub    $0xc,%esp
  803455:	0f b7 c0             	movzwl %ax,%eax
  803458:	50                   	push   %eax
  803459:	e8 f3 0d 00 00       	call   804251 <mem_malloc>
  80345e:	89 47 14             	mov    %eax,0x14(%edi)
    if (dhcp->options_in == NULL) {
  803461:	83 c4 10             	add    $0x10,%esp
  803464:	85 c0                	test   %eax,%eax
  803466:	74 94                	je     8033fc <dhcp_recv+0x46>
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803468:	83 ec 0c             	sub    $0xc,%esp
  80346b:	68 f0 00 00 00       	push   $0xf0
  803470:	e8 dc 0d 00 00       	call   804251 <mem_malloc>
  803475:	89 47 10             	mov    %eax,0x10(%edi)
  if (dhcp->msg_in == NULL) {
  803478:	83 c4 10             	add    $0x10,%esp
  80347b:	85 c0                	test   %eax,%eax
  80347d:	0f 84 e1 00 00 00    	je     803564 <dhcp_recv+0x1ae>
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  803483:	6a 00                	push   $0x0
  803485:	68 f0 00 00 00       	push   $0xf0
  80348a:	50                   	push   %eax
  80348b:	ff 77 0c             	push   0xc(%edi)
  80348e:	e8 09 1b 00 00       	call   804f9c <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803493:	83 c4 10             	add    $0x10,%esp
  803496:	66 3d f0 00          	cmp    $0xf0,%ax
  80349a:	0f 85 de 00 00 00    	jne    80357e <dhcp_recv+0x1c8>
  if (dhcp->options_in != NULL) {
  8034a0:	8b 47 14             	mov    0x14(%edi),%eax
  8034a3:	85 c0                	test   %eax,%eax
  8034a5:	74 20                	je     8034c7 <dhcp_recv+0x111>
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034a7:	68 f0 00 00 00       	push   $0xf0
  8034ac:	0f b7 57 18          	movzwl 0x18(%edi),%edx
  8034b0:	52                   	push   %edx
  8034b1:	50                   	push   %eax
  8034b2:	ff 77 0c             	push   0xc(%edi)
  8034b5:	e8 e2 1a 00 00       	call   804f9c <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8034ba:	83 c4 10             	add    $0x10,%esp
  8034bd:	66 3b 47 18          	cmp    0x18(%edi),%ax
  8034c1:	0f 85 ce 00 00 00    	jne    803595 <dhcp_recv+0x1df>
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  8034c7:	ba 35 00 00 00       	mov    $0x35,%edx
  8034cc:	89 f8                	mov    %edi,%eax
  8034ce:	e8 e7 f2 ff ff       	call   8027ba <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  8034d3:	85 c0                	test   %eax,%eax
  8034d5:	0f 84 21 ff ff ff    	je     8033fc <dhcp_recv+0x46>
  return *ptr;
  8034db:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  if (msg_type == DHCP_ACK) {
  8034df:	3c 05                	cmp    $0x5,%al
  8034e1:	0f 84 c5 00 00 00    	je     8035ac <dhcp_recv+0x1f6>
  else if ((msg_type == DHCP_NAK) &&
  8034e7:	3c 06                	cmp    $0x6,%al
  8034e9:	0f 84 5a 02 00 00    	je     803749 <dhcp_recv+0x393>
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  8034ef:	3c 02                	cmp    $0x2,%al
  8034f1:	0f 85 05 ff ff ff    	jne    8033fc <dhcp_recv+0x46>
  8034f7:	80 3f 06             	cmpb   $0x6,(%edi)
  8034fa:	0f 85 fc fe ff ff    	jne    8033fc <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  803500:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  803506:	8b 45 08             	mov    0x8(%ebp),%eax
  803509:	8b 58 20             	mov    0x20(%eax),%ebx
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  80350c:	ba 36 00 00 00       	mov    $0x36,%edx
  803511:	89 d8                	mov    %ebx,%eax
  803513:	e8 a2 f2 ff ff       	call   8027ba <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803518:	85 c0                	test   %eax,%eax
  80351a:	0f 84 dc fe ff ff    	je     8033fc <dhcp_recv+0x46>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803520:	83 c0 02             	add    $0x2,%eax
  803523:	e8 a6 f3 ff ff       	call   8028ce <dhcp_get_option_long>
  803528:	83 ec 0c             	sub    $0xc,%esp
  80352b:	50                   	push   %eax
  80352c:	e8 6f 41 00 00       	call   8076a0 <htonl>
  803531:	89 43 2c             	mov    %eax,0x2c(%ebx)
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803534:	8b 43 10             	mov    0x10(%ebx),%eax
  803537:	8b 40 10             	mov    0x10(%eax),%eax
  80353a:	89 43 30             	mov    %eax,0x30(%ebx)
    dhcp_select(netif);
  80353d:	8b 45 08             	mov    0x8(%ebp),%eax
  803540:	e8 bd fa ff ff       	call   803002 <dhcp_select>
  803545:	83 c4 10             	add    $0x10,%esp
  803548:	e9 af fe ff ff       	jmp    8033fc <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80354d:	83 ec 04             	sub    $0x4,%esp
  803550:	68 48 14 81 00       	push   $0x811448
  803555:	68 8a 04 00 00       	push   $0x48a
  80355a:	68 02 14 81 00       	push   $0x811402
  80355f:	e8 72 af 00 00       	call   80e4d6 <_panic>
    mem_free((void *)dhcp->options_in);
  803564:	83 ec 0c             	sub    $0xc,%esp
  803567:	ff 77 14             	push   0x14(%edi)
  80356a:	e8 f3 09 00 00       	call   803f62 <mem_free>
    dhcp->options_in = NULL;
  80356f:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
    return ERR_MEM;
  803576:	83 c4 10             	add    $0x10,%esp
  803579:	e9 7e fe ff ff       	jmp    8033fc <dhcp_recv+0x46>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80357e:	83 ec 04             	sub    $0x4,%esp
  803581:	68 d0 13 81 00       	push   $0x8113d0
  803586:	68 a0 04 00 00       	push   $0x4a0
  80358b:	68 02 14 81 00       	push   $0x811402
  803590:	e8 41 af 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803595:	83 ec 04             	sub    $0x4,%esp
  803598:	68 58 14 81 00       	push   $0x811458
  80359d:	68 a7 04 00 00       	push   $0x4a7
  8035a2:	68 02 14 81 00       	push   $0x811402
  8035a7:	e8 2a af 00 00       	call   80e4d6 <_panic>
    if (dhcp->state == DHCP_REQUESTING) {
  8035ac:	0f b6 07             	movzbl (%edi),%eax
  8035af:	3c 01                	cmp    $0x1,%al
  8035b1:	74 1e                	je     8035d1 <dhcp_recv+0x21b>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  8035b3:	83 e8 03             	sub    $0x3,%eax
  8035b6:	3c 02                	cmp    $0x2,%al
  8035b8:	0f 87 3e fe ff ff    	ja     8033fc <dhcp_recv+0x46>
      dhcp->request_timeout = 0;
  8035be:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_bind(netif);
  8035c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8035c7:	e8 e5 fb ff ff       	call   8031b1 <dhcp_bind>
  8035cc:	e9 2b fe ff ff       	jmp    8033fc <dhcp_recv+0x46>
  struct dhcp *dhcp = netif->dhcp;
  8035d1:	8b 45 08             	mov    0x8(%ebp),%eax
  8035d4:	8b 70 20             	mov    0x20(%eax),%esi
  dhcp->offered_sn_mask.addr = 0;
  8035d7:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  dhcp->offered_gw_addr.addr = 0;
  8035de:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_bc_addr.addr = 0;
  8035e5:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  8035ec:	ba 33 00 00 00       	mov    $0x33,%edx
  8035f1:	89 f0                	mov    %esi,%eax
  8035f3:	e8 c2 f1 ff ff       	call   8027ba <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035f8:	85 c0                	test   %eax,%eax
  8035fa:	74 0b                	je     803607 <dhcp_recv+0x251>
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  8035fc:	83 c0 02             	add    $0x2,%eax
  8035ff:	e8 ca f2 ff ff       	call   8028ce <dhcp_get_option_long>
  803604:	89 46 4c             	mov    %eax,0x4c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  803607:	ba 3a 00 00 00       	mov    $0x3a,%edx
  80360c:	89 f0                	mov    %esi,%eax
  80360e:	e8 a7 f1 ff ff       	call   8027ba <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803613:	85 c0                	test   %eax,%eax
  803615:	0f 84 dc 00 00 00    	je     8036f7 <dhcp_recv+0x341>
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  80361b:	83 c0 02             	add    $0x2,%eax
  80361e:	e8 ab f2 ff ff       	call   8028ce <dhcp_get_option_long>
  803623:	89 46 50             	mov    %eax,0x50(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  803626:	ba 3b 00 00 00       	mov    $0x3b,%edx
  80362b:	89 f0                	mov    %esi,%eax
  80362d:	e8 88 f1 ff ff       	call   8027ba <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803632:	85 c0                	test   %eax,%eax
  803634:	0f 84 c7 00 00 00    	je     803701 <dhcp_recv+0x34b>
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  80363a:	83 c0 02             	add    $0x2,%eax
  80363d:	e8 8c f2 ff ff       	call   8028ce <dhcp_get_option_long>
  803642:	89 46 54             	mov    %eax,0x54(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803645:	8b 46 10             	mov    0x10(%esi),%eax
  803648:	8b 40 10             	mov    0x10(%eax),%eax
  80364b:	89 46 30             	mov    %eax,0x30(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  80364e:	ba 01 00 00 00       	mov    $0x1,%edx
  803653:	89 f0                	mov    %esi,%eax
  803655:	e8 60 f1 ff ff       	call   8027ba <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80365a:	85 c0                	test   %eax,%eax
  80365c:	74 17                	je     803675 <dhcp_recv+0x2bf>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80365e:	83 c0 02             	add    $0x2,%eax
  803661:	e8 68 f2 ff ff       	call   8028ce <dhcp_get_option_long>
  803666:	83 ec 0c             	sub    $0xc,%esp
  803669:	50                   	push   %eax
  80366a:	e8 31 40 00 00       	call   8076a0 <htonl>
  80366f:	89 46 34             	mov    %eax,0x34(%esi)
  803672:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  803675:	ba 03 00 00 00       	mov    $0x3,%edx
  80367a:	89 f0                	mov    %esi,%eax
  80367c:	e8 39 f1 ff ff       	call   8027ba <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803681:	85 c0                	test   %eax,%eax
  803683:	74 17                	je     80369c <dhcp_recv+0x2e6>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803685:	83 c0 02             	add    $0x2,%eax
  803688:	e8 41 f2 ff ff       	call   8028ce <dhcp_get_option_long>
  80368d:	83 ec 0c             	sub    $0xc,%esp
  803690:	50                   	push   %eax
  803691:	e8 0a 40 00 00       	call   8076a0 <htonl>
  803696:	89 46 38             	mov    %eax,0x38(%esi)
  803699:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  80369c:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8036a1:	89 f0                	mov    %esi,%eax
  8036a3:	e8 12 f1 ff ff       	call   8027ba <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8036a8:	85 c0                	test   %eax,%eax
  8036aa:	74 17                	je     8036c3 <dhcp_recv+0x30d>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8036ac:	83 c0 02             	add    $0x2,%eax
  8036af:	e8 1a f2 ff ff       	call   8028ce <dhcp_get_option_long>
  8036b4:	83 ec 0c             	sub    $0xc,%esp
  8036b7:	50                   	push   %eax
  8036b8:	e8 e3 3f 00 00       	call   8076a0 <htonl>
  8036bd:	89 46 3c             	mov    %eax,0x3c(%esi)
  8036c0:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  8036c3:	ba 06 00 00 00       	mov    $0x6,%edx
  8036c8:	89 f0                	mov    %esi,%eax
  8036ca:	e8 eb f0 ff ff       	call   8027ba <dhcp_get_option_ptr>
  8036cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (option_ptr != NULL) {
  8036d2:	85 c0                	test   %eax,%eax
  8036d4:	74 60                	je     803736 <dhcp_recv+0x380>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  8036d6:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  8036da:	c0 e8 02             	shr    $0x2,%al
  8036dd:	0f b6 c0             	movzbl %al,%eax
  8036e0:	ba 02 00 00 00       	mov    $0x2,%edx
  8036e5:	39 d0                	cmp    %edx,%eax
  8036e7:	0f 47 c2             	cmova  %edx,%eax
  8036ea:	89 46 40             	mov    %eax,0x40(%esi)
  8036ed:	bb 00 00 00 00       	mov    $0x0,%ebx
  8036f2:	89 7d e0             	mov    %edi,-0x20(%ebp)
  8036f5:	eb 34                	jmp    80372b <dhcp_recv+0x375>
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  8036f7:	8b 46 4c             	mov    0x4c(%esi),%eax
  8036fa:	d1 e8                	shr    %eax
  8036fc:	e9 22 ff ff ff       	jmp    803623 <dhcp_recv+0x26d>
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  803701:	8b 46 4c             	mov    0x4c(%esi),%eax
  803704:	e9 39 ff ff ff       	jmp    803642 <dhcp_recv+0x28c>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803709:	0f b6 fb             	movzbl %bl,%edi
  80370c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80370f:	8d 44 b8 02          	lea    0x2(%eax,%edi,4),%eax
  803713:	e8 b6 f1 ff ff       	call   8028ce <dhcp_get_option_long>
  803718:	83 ec 0c             	sub    $0xc,%esp
  80371b:	50                   	push   %eax
  80371c:	e8 7f 3f 00 00       	call   8076a0 <htonl>
  803721:	89 44 be 44          	mov    %eax,0x44(%esi,%edi,4)
    for (n = 0; n < dhcp->dns_count; n++) {
  803725:	83 c3 01             	add    $0x1,%ebx
  803728:	83 c4 10             	add    $0x10,%esp
  80372b:	0f b6 c3             	movzbl %bl,%eax
  80372e:	3b 46 40             	cmp    0x40(%esi),%eax
  803731:	72 d6                	jb     803709 <dhcp_recv+0x353>
  803733:	8b 7d e0             	mov    -0x20(%ebp),%edi
      dhcp->request_timeout = 0;
  803736:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_check(netif);
  80373c:	8b 45 08             	mov    0x8(%ebp),%eax
  80373f:	e8 39 fa ff ff       	call   80317d <dhcp_check>
  803744:	e9 b3 fc ff ff       	jmp    8033fc <dhcp_recv+0x46>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  803749:	0f b6 07             	movzbl (%edi),%eax
  80374c:	8d 50 fd             	lea    -0x3(%eax),%edx
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80374f:	80 fa 02             	cmp    $0x2,%dl
  803752:	76 08                	jbe    80375c <dhcp_recv+0x3a6>
  803754:	3c 01                	cmp    $0x1,%al
  803756:	0f 85 a0 fc ff ff    	jne    8033fc <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  80375c:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  803762:	8b 45 08             	mov    0x8(%ebp),%eax
  803765:	8b 58 20             	mov    0x20(%eax),%ebx
  netif_set_down(netif);
  803768:	83 ec 0c             	sub    $0xc,%esp
  80376b:	50                   	push   %eax
  80376c:	e8 e7 0f 00 00       	call   804758 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803771:	83 c4 08             	add    $0x8,%esp
  803774:	68 a8 1c 81 00       	push   $0x811ca8
  803779:	ff 75 08             	push   0x8(%ebp)
  80377c:	e8 39 0e 00 00       	call   8045ba <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803781:	83 c4 08             	add    $0x8,%esp
  803784:	68 a8 1c 81 00       	push   $0x811ca8
  803789:	ff 75 08             	push   0x8(%ebp)
  80378c:	e8 55 0f 00 00       	call   8046e6 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803791:	83 c4 08             	add    $0x8,%esp
  803794:	68 a8 1c 81 00       	push   $0x811ca8
  803799:	ff 75 08             	push   0x8(%ebp)
  80379c:	e8 5e 0f 00 00       	call   8046ff <netif_set_netmask>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8037a1:	ba 0c 00 00 00       	mov    $0xc,%edx
  8037a6:	89 d8                	mov    %ebx,%eax
  8037a8:	e8 02 f0 ff ff       	call   8027af <dhcp_set_state>
  dhcp_discover(netif);
  8037ad:	8b 45 08             	mov    0x8(%ebp),%eax
  8037b0:	e8 0f f7 ff ff       	call   802ec4 <dhcp_discover>
}
  8037b5:	83 c4 10             	add    $0x10,%esp
  8037b8:	e9 3f fc ff ff       	jmp    8033fc <dhcp_recv+0x46>

008037bd <dhcp_inform>:
{
  8037bd:	55                   	push   %ebp
  8037be:	89 e5                	mov    %esp,%ebp
  8037c0:	57                   	push   %edi
  8037c1:	56                   	push   %esi
  8037c2:	53                   	push   %ebx
  8037c3:	83 ec 18             	sub    $0x18,%esp
  8037c6:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  8037c9:	8b 7e 20             	mov    0x20(%esi),%edi
  dhcp = mem_malloc(sizeof(struct dhcp));
  8037cc:	6a 58                	push   $0x58
  8037ce:	e8 7e 0a 00 00       	call   804251 <mem_malloc>
  if (dhcp == NULL) {
  8037d3:	83 c4 10             	add    $0x10,%esp
  8037d6:	85 c0                	test   %eax,%eax
  8037d8:	74 55                	je     80382f <dhcp_inform+0x72>
  8037da:	89 c3                	mov    %eax,%ebx
  netif->dhcp = dhcp;
  8037dc:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  8037df:	83 ec 04             	sub    $0x4,%esp
  8037e2:	6a 58                	push   $0x58
  8037e4:	6a 00                	push   $0x0
  8037e6:	50                   	push   %eax
  8037e7:	e8 ef b4 00 00       	call   80ecdb <memset>
  dhcp->pcb = udp_new();
  8037ec:	e8 94 57 00 00       	call   808f85 <udp_new>
  8037f1:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8037f4:	83 c4 10             	add    $0x10,%esp
  8037f7:	85 c0                	test   %eax,%eax
  8037f9:	74 3c                	je     803837 <dhcp_inform+0x7a>
  result = dhcp_create_request(netif);
  8037fb:	89 f0                	mov    %esi,%eax
  8037fd:	e8 43 f3 ff ff       	call   802b45 <dhcp_create_request>
  if (result == ERR_OK) {
  803802:	84 c0                	test   %al,%al
  803804:	74 3f                	je     803845 <dhcp_inform+0x88>
    if (dhcp->pcb != NULL) {
  803806:	8b 43 08             	mov    0x8(%ebx),%eax
  803809:	85 c0                	test   %eax,%eax
  80380b:	74 0c                	je     803819 <dhcp_inform+0x5c>
      udp_remove(dhcp->pcb);
  80380d:	83 ec 0c             	sub    $0xc,%esp
  803810:	50                   	push   %eax
  803811:	e8 2b 57 00 00       	call   808f41 <udp_remove>
  803816:	83 c4 10             	add    $0x10,%esp
    dhcp->pcb = NULL;
  803819:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  803820:	83 ec 0c             	sub    $0xc,%esp
  803823:	53                   	push   %ebx
  803824:	e8 39 07 00 00       	call   803f62 <mem_free>
    netif->dhcp = old_dhcp;
  803829:	89 7e 20             	mov    %edi,0x20(%esi)
  80382c:	83 c4 10             	add    $0x10,%esp
}
  80382f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803832:	5b                   	pop    %ebx
  803833:	5e                   	pop    %esi
  803834:	5f                   	pop    %edi
  803835:	5d                   	pop    %ebp
  803836:	c3                   	ret    
    mem_free((void *)dhcp);
  803837:	83 ec 0c             	sub    $0xc,%esp
  80383a:	53                   	push   %ebx
  80383b:	e8 22 07 00 00       	call   803f62 <mem_free>
    return;
  803840:	83 c4 10             	add    $0x10,%esp
  803843:	eb ea                	jmp    80382f <dhcp_inform+0x72>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803845:	b9 01 00 00 00       	mov    $0x1,%ecx
  80384a:	ba 35 00 00 00       	mov    $0x35,%edx
  80384f:	89 d8                	mov    %ebx,%eax
  803851:	e8 d8 f0 ff ff       	call   80292e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803856:	ba 08 00 00 00       	mov    $0x8,%edx
  80385b:	89 d8                	mov    %ebx,%eax
  80385d:	e8 8b f0 ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803862:	b9 02 00 00 00       	mov    $0x2,%ecx
  803867:	ba 39 00 00 00       	mov    $0x39,%edx
  80386c:	89 d8                	mov    %ebx,%eax
  80386e:	e8 bb f0 ff ff       	call   80292e <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803873:	ba 40 02 00 00       	mov    $0x240,%edx
  803878:	89 d8                	mov    %ebx,%eax
  80387a:	e8 18 f1 ff ff       	call   802997 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  80387f:	89 d8                	mov    %ebx,%eax
  803881:	e8 71 f1 ff ff       	call   8029f7 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803886:	83 ec 08             	sub    $0x8,%esp
  803889:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80388d:	66 05 f0 00          	add    $0xf0,%ax
  803891:	0f b7 c0             	movzwl %ax,%eax
  803894:	50                   	push   %eax
  803895:	ff 73 1c             	push   0x1c(%ebx)
  803898:	e8 d4 12 00 00       	call   804b71 <pbuf_realloc>
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80389d:	83 c4 0c             	add    $0xc,%esp
  8038a0:	6a 44                	push   $0x44
  8038a2:	68 a8 1c 81 00       	push   $0x811ca8
  8038a7:	ff 73 08             	push   0x8(%ebx)
  8038aa:	e8 42 53 00 00       	call   808bf1 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  8038af:	83 c4 0c             	add    $0xc,%esp
  8038b2:	6a 43                	push   $0x43
  8038b4:	68 a4 1c 81 00       	push   $0x811ca4
  8038b9:	ff 73 08             	push   0x8(%ebx)
  8038bc:	e8 e0 55 00 00       	call   808ea1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8038c1:	89 34 24             	mov    %esi,(%esp)
  8038c4:	6a 43                	push   $0x43
  8038c6:	68 a4 1c 81 00       	push   $0x811ca4
  8038cb:	ff 73 1c             	push   0x1c(%ebx)
  8038ce:	ff 73 08             	push   0x8(%ebx)
  8038d1:	e8 d6 53 00 00       	call   808cac <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8038d6:	83 c4 1c             	add    $0x1c,%esp
  8038d9:	6a 43                	push   $0x43
  8038db:	68 a8 1c 81 00       	push   $0x811ca8
  8038e0:	ff 73 08             	push   0x8(%ebx)
  8038e3:	e8 b9 55 00 00       	call   808ea1 <udp_connect>
    dhcp_delete_request(netif);
  8038e8:	89 f0                	mov    %esi,%eax
  8038ea:	e8 49 f4 ff ff       	call   802d38 <dhcp_delete_request>
  8038ef:	83 c4 10             	add    $0x10,%esp
  8038f2:	e9 0f ff ff ff       	jmp    803806 <dhcp_inform+0x49>

008038f7 <dhcp_arp_reply>:
{
  8038f7:	55                   	push   %ebp
  8038f8:	89 e5                	mov    %esp,%ebp
  8038fa:	56                   	push   %esi
  8038fb:	53                   	push   %ebx
  8038fc:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8038ff:	85 f6                	test   %esi,%esi
  803901:	74 13                	je     803916 <dhcp_arp_reply+0x1f>
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803903:	8b 5e 20             	mov    0x20(%esi),%ebx
  803906:	85 db                	test   %ebx,%ebx
  803908:	74 05                	je     80390f <dhcp_arp_reply+0x18>
  80390a:	80 3b 08             	cmpb   $0x8,(%ebx)
  80390d:	74 1e                	je     80392d <dhcp_arp_reply+0x36>
}
  80390f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803912:	5b                   	pop    %ebx
  803913:	5e                   	pop    %esi
  803914:	5d                   	pop    %ebp
  803915:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803916:	83 ec 04             	sub    $0x4,%esp
  803919:	68 22 14 81 00       	push   $0x811422
  80391e:	68 b5 02 00 00       	push   $0x2b5
  803923:	68 02 14 81 00       	push   $0x811402
  803928:	e8 a9 ab 00 00       	call   80e4d6 <_panic>
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80392d:	8b 45 0c             	mov    0xc(%ebp),%eax
  803930:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803933:	39 08                	cmp    %ecx,(%eax)
  803935:	75 d8                	jne    80390f <dhcp_arp_reply+0x18>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803937:	ba 0c 00 00 00       	mov    $0xc,%edx
  80393c:	89 d8                	mov    %ebx,%eax
  80393e:	e8 6c ee ff ff       	call   8027af <dhcp_set_state>
  result = dhcp_create_request(netif);
  803943:	89 f0                	mov    %esi,%eax
  803945:	e8 fb f1 ff ff       	call   802b45 <dhcp_create_request>
  if (result == ERR_OK) {
  80394a:	84 c0                	test   %al,%al
  80394c:	74 0c                	je     80395a <dhcp_arp_reply+0x63>
  dhcp->tries++;
  80394e:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803952:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
  return result;
  803958:	eb b5                	jmp    80390f <dhcp_arp_reply+0x18>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80395a:	b9 01 00 00 00       	mov    $0x1,%ecx
  80395f:	ba 35 00 00 00       	mov    $0x35,%edx
  803964:	89 d8                	mov    %ebx,%eax
  803966:	e8 c3 ef ff ff       	call   80292e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  80396b:	ba 04 00 00 00       	mov    $0x4,%edx
  803970:	89 d8                	mov    %ebx,%eax
  803972:	e8 76 ef ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803977:	b9 02 00 00 00       	mov    $0x2,%ecx
  80397c:	ba 39 00 00 00       	mov    $0x39,%edx
  803981:	89 d8                	mov    %ebx,%eax
  803983:	e8 a6 ef ff ff       	call   80292e <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803988:	ba 40 02 00 00       	mov    $0x240,%edx
  80398d:	89 d8                	mov    %ebx,%eax
  80398f:	e8 03 f0 ff ff       	call   802997 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803994:	b9 04 00 00 00       	mov    $0x4,%ecx
  803999:	ba 32 00 00 00       	mov    $0x32,%edx
  80399e:	89 d8                	mov    %ebx,%eax
  8039a0:	e8 89 ef ff ff       	call   80292e <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8039a5:	83 ec 0c             	sub    $0xc,%esp
  8039a8:	ff 73 30             	push   0x30(%ebx)
  8039ab:	e8 18 3f 00 00       	call   8078c8 <ntohl>
  8039b0:	89 c2                	mov    %eax,%edx
  8039b2:	89 d8                	mov    %ebx,%eax
  8039b4:	e8 f4 f0 ff ff       	call   802aad <dhcp_option_long>
    dhcp_option_trailer(dhcp);
  8039b9:	89 d8                	mov    %ebx,%eax
  8039bb:	e8 37 f0 ff ff       	call   8029f7 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8039c0:	83 c4 08             	add    $0x8,%esp
  8039c3:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8039c7:	66 05 f0 00          	add    $0xf0,%ax
  8039cb:	0f b7 c0             	movzwl %ax,%eax
  8039ce:	50                   	push   %eax
  8039cf:	ff 73 1c             	push   0x1c(%ebx)
  8039d2:	e8 9a 11 00 00       	call   804b71 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8039d7:	83 c4 0c             	add    $0xc,%esp
  8039da:	6a 43                	push   $0x43
  8039dc:	68 a8 1c 81 00       	push   $0x811ca8
  8039e1:	ff 73 08             	push   0x8(%ebx)
  8039e4:	e8 b8 54 00 00       	call   808ea1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8039e9:	89 34 24             	mov    %esi,(%esp)
  8039ec:	6a 43                	push   $0x43
  8039ee:	68 a4 1c 81 00       	push   $0x811ca4
  8039f3:	ff 73 1c             	push   0x1c(%ebx)
  8039f6:	ff 73 08             	push   0x8(%ebx)
  8039f9:	e8 ae 52 00 00       	call   808cac <udp_sendto_if>
    dhcp_delete_request(netif);
  8039fe:	83 c4 20             	add    $0x20,%esp
  803a01:	89 f0                	mov    %esi,%eax
  803a03:	e8 30 f3 ff ff       	call   802d38 <dhcp_delete_request>
  803a08:	e9 41 ff ff ff       	jmp    80394e <dhcp_arp_reply+0x57>

00803a0d <dhcp_renew>:
{
  803a0d:	55                   	push   %ebp
  803a0e:	89 e5                	mov    %esp,%ebp
  803a10:	57                   	push   %edi
  803a11:	56                   	push   %esi
  803a12:	53                   	push   %ebx
  803a13:	83 ec 1c             	sub    $0x1c,%esp
  803a16:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  803a19:	8b 5f 20             	mov    0x20(%edi),%ebx
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803a1c:	ba 05 00 00 00       	mov    $0x5,%edx
  803a21:	89 d8                	mov    %ebx,%eax
  803a23:	e8 87 ed ff ff       	call   8027af <dhcp_set_state>
  result = dhcp_create_request(netif);
  803a28:	89 f8                	mov    %edi,%eax
  803a2a:	e8 16 f1 ff ff       	call   802b45 <dhcp_create_request>
  803a2f:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803a31:	84 c0                	test   %al,%al
  803a33:	74 3d                	je     803a72 <dhcp_renew+0x65>
  dhcp->tries++;
  803a35:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803a39:	83 c0 01             	add    $0x1,%eax
  803a3c:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803a3f:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803a44:	3c 09                	cmp    $0x9,%al
  803a46:	77 08                	ja     803a50 <dhcp_renew+0x43>
  803a48:	0f b6 c0             	movzbl %al,%eax
  803a4b:	66 69 d0 d0 07       	imul   $0x7d0,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803a50:	66 81 c2 f3 01       	add    $0x1f3,%dx
  803a55:	0f b7 d2             	movzwl %dx,%edx
  803a58:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803a5d:	89 d0                	mov    %edx,%eax
  803a5f:	f7 e9                	imul   %ecx
  803a61:	c1 fa 05             	sar    $0x5,%edx
  803a64:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  803a68:	89 f0                	mov    %esi,%eax
  803a6a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803a6d:	5b                   	pop    %ebx
  803a6e:	5e                   	pop    %esi
  803a6f:	5f                   	pop    %edi
  803a70:	5d                   	pop    %ebp
  803a71:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803a72:	b9 01 00 00 00       	mov    $0x1,%ecx
  803a77:	ba 35 00 00 00       	mov    $0x35,%edx
  803a7c:	89 d8                	mov    %ebx,%eax
  803a7e:	e8 ab ee ff ff       	call   80292e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803a83:	ba 03 00 00 00       	mov    $0x3,%edx
  803a88:	89 d8                	mov    %ebx,%eax
  803a8a:	e8 5e ee ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803a8f:	b9 02 00 00 00       	mov    $0x2,%ecx
  803a94:	ba 39 00 00 00       	mov    $0x39,%edx
  803a99:	89 d8                	mov    %ebx,%eax
  803a9b:	e8 8e ee ff ff       	call   80292e <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803aa0:	ba 40 02 00 00       	mov    $0x240,%edx
  803aa5:	89 d8                	mov    %ebx,%eax
  803aa7:	e8 eb ee ff ff       	call   802997 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803aac:	89 d8                	mov    %ebx,%eax
  803aae:	e8 44 ef ff ff       	call   8029f7 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803ab3:	83 ec 08             	sub    $0x8,%esp
  803ab6:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803aba:	66 05 f0 00          	add    $0xf0,%ax
  803abe:	0f b7 c0             	movzwl %ax,%eax
  803ac1:	50                   	push   %eax
  803ac2:	ff 73 1c             	push   0x1c(%ebx)
  803ac5:	e8 a7 10 00 00       	call   804b71 <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803aca:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803acd:	83 c4 0c             	add    $0xc,%esp
  803ad0:	6a 43                	push   $0x43
  803ad2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803ad5:	50                   	push   %eax
  803ad6:	ff 73 08             	push   0x8(%ebx)
  803ad9:	e8 c3 53 00 00       	call   808ea1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803ade:	89 3c 24             	mov    %edi,(%esp)
  803ae1:	6a 43                	push   $0x43
  803ae3:	ff 75 e4             	push   -0x1c(%ebp)
  803ae6:	ff 73 1c             	push   0x1c(%ebx)
  803ae9:	ff 73 08             	push   0x8(%ebx)
  803aec:	e8 bb 51 00 00       	call   808cac <udp_sendto_if>
    dhcp_delete_request(netif);
  803af1:	83 c4 20             	add    $0x20,%esp
  803af4:	89 f8                	mov    %edi,%eax
  803af6:	e8 3d f2 ff ff       	call   802d38 <dhcp_delete_request>
  803afb:	e9 35 ff ff ff       	jmp    803a35 <dhcp_renew+0x28>

00803b00 <dhcp_coarse_tmr>:
{
  803b00:	55                   	push   %ebp
  803b01:	89 e5                	mov    %esp,%ebp
  803b03:	53                   	push   %ebx
  803b04:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803b07:	8b 1d 3c 44 b3 00    	mov    0xb3443c,%ebx
  while (netif != NULL) {
  803b0d:	eb 1d                	jmp    803b2c <dhcp_coarse_tmr+0x2c>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b0f:	8b 43 20             	mov    0x20(%ebx),%eax
  803b12:	0f b6 00             	movzbl (%eax),%eax
  803b15:	89 c2                	mov    %eax,%edx
  803b17:	83 e2 fb             	and    $0xfffffffb,%edx
  803b1a:	80 fa 01             	cmp    $0x1,%dl
  803b1d:	74 04                	je     803b23 <dhcp_coarse_tmr+0x23>
  803b1f:	3c 0a                	cmp    $0xa,%al
  803b21:	75 07                	jne    803b2a <dhcp_coarse_tmr+0x2a>
    dhcp_rebind(netif);
  803b23:	89 d8                	mov    %ebx,%eax
  803b25:	e8 a8 f2 ff ff       	call   802dd2 <dhcp_rebind>
    netif = netif->next;
  803b2a:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803b2c:	85 db                	test   %ebx,%ebx
  803b2e:	74 4e                	je     803b7e <dhcp_coarse_tmr+0x7e>
    if (netif->dhcp != NULL) {
  803b30:	8b 43 20             	mov    0x20(%ebx),%eax
  803b33:	85 c0                	test   %eax,%eax
  803b35:	74 f3                	je     803b2a <dhcp_coarse_tmr+0x2a>
      if (netif->dhcp->t2_timeout-- == 1) {
  803b37:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803b3b:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803b3e:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803b42:	66 83 fa 01          	cmp    $0x1,%dx
  803b46:	74 c7                	je     803b0f <dhcp_coarse_tmr+0xf>
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803b48:	8b 53 20             	mov    0x20(%ebx),%edx
  803b4b:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803b4f:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803b52:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803b56:	66 83 f8 01          	cmp    $0x1,%ax
  803b5a:	75 ce                	jne    803b2a <dhcp_coarse_tmr+0x2a>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b5c:	8b 43 20             	mov    0x20(%ebx),%eax
  803b5f:	0f b6 00             	movzbl (%eax),%eax
  803b62:	89 c2                	mov    %eax,%edx
  803b64:	83 e2 fb             	and    $0xfffffffb,%edx
  803b67:	80 fa 01             	cmp    $0x1,%dl
  803b6a:	74 04                	je     803b70 <dhcp_coarse_tmr+0x70>
  803b6c:	3c 0a                	cmp    $0xa,%al
  803b6e:	75 ba                	jne    803b2a <dhcp_coarse_tmr+0x2a>
    dhcp_renew(netif);
  803b70:	83 ec 0c             	sub    $0xc,%esp
  803b73:	53                   	push   %ebx
  803b74:	e8 94 fe ff ff       	call   803a0d <dhcp_renew>
  803b79:	83 c4 10             	add    $0x10,%esp
  803b7c:	eb ac                	jmp    803b2a <dhcp_coarse_tmr+0x2a>
}
  803b7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803b81:	c9                   	leave  
  803b82:	c3                   	ret    

00803b83 <dhcp_release>:
{
  803b83:	55                   	push   %ebp
  803b84:	89 e5                	mov    %esp,%ebp
  803b86:	57                   	push   %edi
  803b87:	56                   	push   %esi
  803b88:	53                   	push   %ebx
  803b89:	83 ec 1c             	sub    $0x1c,%esp
  803b8c:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803b8f:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_OFF);
  803b92:	ba 0d 00 00 00       	mov    $0xd,%edx
  803b97:	89 d8                	mov    %ebx,%eax
  803b99:	e8 11 ec ff ff       	call   8027af <dhcp_set_state>
  dhcp->server_ip_addr.addr = 0;
  803b9e:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803ba5:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803bac:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803bb3:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803bba:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803bc1:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803bc8:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803bcf:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803bd6:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  result = dhcp_create_request(netif);
  803bdd:	89 f0                	mov    %esi,%eax
  803bdf:	e8 61 ef ff ff       	call   802b45 <dhcp_create_request>
  803be4:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803be6:	84 c0                	test   %al,%al
  803be8:	74 70                	je     803c5a <dhcp_release+0xd7>
  dhcp->tries++;
  803bea:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803bee:	83 c0 01             	add    $0x1,%eax
  803bf1:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803bf4:	ba 10 27 00 00       	mov    $0x2710,%edx
  803bf9:	3c 09                	cmp    $0x9,%al
  803bfb:	77 08                	ja     803c05 <dhcp_release+0x82>
  803bfd:	0f b6 c0             	movzbl %al,%eax
  803c00:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803c05:	66 81 c2 f3 01       	add    $0x1f3,%dx
  803c0a:	0f b7 d2             	movzwl %dx,%edx
  803c0d:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803c12:	89 d0                	mov    %edx,%eax
  803c14:	f7 e9                	imul   %ecx
  803c16:	c1 fa 05             	sar    $0x5,%edx
  803c19:	66 89 53 26          	mov    %dx,0x26(%ebx)
  netif_set_down(netif);
  803c1d:	83 ec 0c             	sub    $0xc,%esp
  803c20:	56                   	push   %esi
  803c21:	e8 32 0b 00 00       	call   804758 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803c26:	83 c4 08             	add    $0x8,%esp
  803c29:	68 a8 1c 81 00       	push   $0x811ca8
  803c2e:	56                   	push   %esi
  803c2f:	e8 86 09 00 00       	call   8045ba <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803c34:	83 c4 08             	add    $0x8,%esp
  803c37:	68 a8 1c 81 00       	push   $0x811ca8
  803c3c:	56                   	push   %esi
  803c3d:	e8 a4 0a 00 00       	call   8046e6 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803c42:	83 c4 08             	add    $0x8,%esp
  803c45:	68 a8 1c 81 00       	push   $0x811ca8
  803c4a:	56                   	push   %esi
  803c4b:	e8 af 0a 00 00       	call   8046ff <netif_set_netmask>
}
  803c50:	89 f8                	mov    %edi,%eax
  803c52:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803c55:	5b                   	pop    %ebx
  803c56:	5e                   	pop    %esi
  803c57:	5f                   	pop    %edi
  803c58:	5d                   	pop    %ebp
  803c59:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803c5a:	b9 01 00 00 00       	mov    $0x1,%ecx
  803c5f:	ba 35 00 00 00       	mov    $0x35,%edx
  803c64:	89 d8                	mov    %ebx,%eax
  803c66:	e8 c3 ec ff ff       	call   80292e <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803c6b:	ba 07 00 00 00       	mov    $0x7,%edx
  803c70:	89 d8                	mov    %ebx,%eax
  803c72:	e8 76 ec ff ff       	call   8028ed <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803c77:	89 d8                	mov    %ebx,%eax
  803c79:	e8 79 ed ff ff       	call   8029f7 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803c7e:	83 ec 08             	sub    $0x8,%esp
  803c81:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803c85:	66 05 f0 00          	add    $0xf0,%ax
  803c89:	0f b7 c0             	movzwl %ax,%eax
  803c8c:	50                   	push   %eax
  803c8d:	ff 73 1c             	push   0x1c(%ebx)
  803c90:	e8 dc 0e 00 00       	call   804b71 <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803c95:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803c98:	83 c4 0c             	add    $0xc,%esp
  803c9b:	6a 43                	push   $0x43
  803c9d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803ca0:	50                   	push   %eax
  803ca1:	ff 73 08             	push   0x8(%ebx)
  803ca4:	e8 f8 51 00 00       	call   808ea1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803ca9:	89 34 24             	mov    %esi,(%esp)
  803cac:	6a 43                	push   $0x43
  803cae:	ff 75 e4             	push   -0x1c(%ebp)
  803cb1:	ff 73 1c             	push   0x1c(%ebx)
  803cb4:	ff 73 08             	push   0x8(%ebx)
  803cb7:	e8 f0 4f 00 00       	call   808cac <udp_sendto_if>
    dhcp_delete_request(netif);
  803cbc:	83 c4 20             	add    $0x20,%esp
  803cbf:	89 f0                	mov    %esi,%eax
  803cc1:	e8 72 f0 ff ff       	call   802d38 <dhcp_delete_request>
  803cc6:	e9 1f ff ff ff       	jmp    803bea <dhcp_release+0x67>

00803ccb <dhcp_fine_tmr>:
{
  803ccb:	55                   	push   %ebp
  803ccc:	89 e5                	mov    %esp,%ebp
  803cce:	53                   	push   %ebx
  803ccf:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803cd2:	8b 1d 3c 44 b3 00    	mov    0xb3443c,%ebx
  while (netif != NULL) {
  803cd8:	eb 04                	jmp    803cde <dhcp_fine_tmr+0x13>
      else if (netif->dhcp->request_timeout == 1) {
  803cda:	74 24                	je     803d00 <dhcp_fine_tmr+0x35>
    netif = netif->next;
  803cdc:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803cde:	85 db                	test   %ebx,%ebx
  803ce0:	0f 84 c4 00 00 00    	je     803daa <dhcp_fine_tmr+0xdf>
    if (netif->dhcp != NULL) {
  803ce6:	8b 43 20             	mov    0x20(%ebx),%eax
  803ce9:	85 c0                	test   %eax,%eax
  803ceb:	74 ef                	je     803cdc <dhcp_fine_tmr+0x11>
      if (netif->dhcp->request_timeout > 1) {
  803ced:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  803cf1:	66 83 fa 01          	cmp    $0x1,%dx
  803cf5:	76 e3                	jbe    803cda <dhcp_fine_tmr+0xf>
        netif->dhcp->request_timeout--;
  803cf7:	83 ea 01             	sub    $0x1,%edx
  803cfa:	66 89 50 26          	mov    %dx,0x26(%eax)
  803cfe:	eb dc                	jmp    803cdc <dhcp_fine_tmr+0x11>
        netif->dhcp->request_timeout--;
  803d00:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
  struct dhcp *dhcp = netif->dhcp;
  803d06:	8b 53 20             	mov    0x20(%ebx),%edx
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803d09:	0f b6 02             	movzbl (%edx),%eax
  803d0c:	3c 0c                	cmp    $0xc,%al
  803d0e:	74 23                	je     803d33 <dhcp_fine_tmr+0x68>
  803d10:	3c 06                	cmp    $0x6,%al
  803d12:	74 1f                	je     803d33 <dhcp_fine_tmr+0x68>
  } else if (dhcp->state == DHCP_REQUESTING) {
  803d14:	3c 01                	cmp    $0x1,%al
  803d16:	74 24                	je     803d3c <dhcp_fine_tmr+0x71>
  } else if (dhcp->state == DHCP_CHECKING) {
  803d18:	3c 08                	cmp    $0x8,%al
  803d1a:	74 47                	je     803d63 <dhcp_fine_tmr+0x98>
  else if (dhcp->state == DHCP_RENEWING) {
  803d1c:	3c 05                	cmp    $0x5,%al
  803d1e:	74 61                	je     803d81 <dhcp_fine_tmr+0xb6>
  } else if (dhcp->state == DHCP_REBINDING) {
  803d20:	3c 04                	cmp    $0x4,%al
  803d22:	75 b8                	jne    803cdc <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 8) {
  803d24:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803d28:	77 68                	ja     803d92 <dhcp_fine_tmr+0xc7>
      dhcp_rebind(netif);
  803d2a:	89 d8                	mov    %ebx,%eax
  803d2c:	e8 a1 f0 ff ff       	call   802dd2 <dhcp_rebind>
  803d31:	eb a9                	jmp    803cdc <dhcp_fine_tmr+0x11>
    dhcp_discover(netif);
  803d33:	89 d8                	mov    %ebx,%eax
  803d35:	e8 8a f1 ff ff       	call   802ec4 <dhcp_discover>
  803d3a:	eb a0                	jmp    803cdc <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 5) {
  803d3c:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803d40:	77 09                	ja     803d4b <dhcp_fine_tmr+0x80>
      dhcp_select(netif);
  803d42:	89 d8                	mov    %ebx,%eax
  803d44:	e8 b9 f2 ff ff       	call   803002 <dhcp_select>
  803d49:	eb 91                	jmp    803cdc <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803d4b:	83 ec 0c             	sub    $0xc,%esp
  803d4e:	53                   	push   %ebx
  803d4f:	e8 2f fe ff ff       	call   803b83 <dhcp_release>
      dhcp_discover(netif);
  803d54:	89 d8                	mov    %ebx,%eax
  803d56:	e8 69 f1 ff ff       	call   802ec4 <dhcp_discover>
  803d5b:	83 c4 10             	add    $0x10,%esp
  803d5e:	e9 79 ff ff ff       	jmp    803cdc <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 1) {
  803d63:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803d67:	76 0c                	jbe    803d75 <dhcp_fine_tmr+0xaa>
      dhcp_bind(netif);
  803d69:	89 d8                	mov    %ebx,%eax
  803d6b:	e8 41 f4 ff ff       	call   8031b1 <dhcp_bind>
  803d70:	e9 67 ff ff ff       	jmp    803cdc <dhcp_fine_tmr+0x11>
      dhcp_check(netif);
  803d75:	89 d8                	mov    %ebx,%eax
  803d77:	e8 01 f4 ff ff       	call   80317d <dhcp_check>
  803d7c:	e9 5b ff ff ff       	jmp    803cdc <dhcp_fine_tmr+0x11>
    dhcp_renew(netif);
  803d81:	83 ec 0c             	sub    $0xc,%esp
  803d84:	53                   	push   %ebx
  803d85:	e8 83 fc ff ff       	call   803a0d <dhcp_renew>
  803d8a:	83 c4 10             	add    $0x10,%esp
  803d8d:	e9 4a ff ff ff       	jmp    803cdc <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803d92:	83 ec 0c             	sub    $0xc,%esp
  803d95:	53                   	push   %ebx
  803d96:	e8 e8 fd ff ff       	call   803b83 <dhcp_release>
      dhcp_discover(netif);
  803d9b:	89 d8                	mov    %ebx,%eax
  803d9d:	e8 22 f1 ff ff       	call   802ec4 <dhcp_discover>
  803da2:	83 c4 10             	add    $0x10,%esp
  803da5:	e9 32 ff ff ff       	jmp    803cdc <dhcp_fine_tmr+0x11>
}
  803daa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803dad:	c9                   	leave  
  803dae:	c3                   	ret    

00803daf <dhcp_stop>:
{
  803daf:	55                   	push   %ebp
  803db0:	89 e5                	mov    %esp,%ebp
  803db2:	56                   	push   %esi
  803db3:	53                   	push   %ebx
  803db4:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803db7:	8b 5e 20             	mov    0x20(%esi),%ebx
  netif->flags &= ~NETIF_FLAG_DHCP;
  803dba:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)
  if (dhcp != NULL) {
  803dbe:	85 db                	test   %ebx,%ebx
  803dc0:	74 4e                	je     803e10 <dhcp_stop+0x61>
    if (dhcp->pcb != NULL) {
  803dc2:	8b 43 08             	mov    0x8(%ebx),%eax
  803dc5:	85 c0                	test   %eax,%eax
  803dc7:	74 13                	je     803ddc <dhcp_stop+0x2d>
      udp_remove(dhcp->pcb);
  803dc9:	83 ec 0c             	sub    $0xc,%esp
  803dcc:	50                   	push   %eax
  803dcd:	e8 6f 51 00 00       	call   808f41 <udp_remove>
      dhcp->pcb = NULL;
  803dd2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803dd9:	83 c4 10             	add    $0x10,%esp
    if (dhcp->p != NULL) {
  803ddc:	8b 43 0c             	mov    0xc(%ebx),%eax
  803ddf:	85 c0                	test   %eax,%eax
  803de1:	74 13                	je     803df6 <dhcp_stop+0x47>
      pbuf_free(dhcp->p);
  803de3:	83 ec 0c             	sub    $0xc,%esp
  803de6:	50                   	push   %eax
  803de7:	e8 60 0a 00 00       	call   80484c <pbuf_free>
      dhcp->p = NULL;
  803dec:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803df3:	83 c4 10             	add    $0x10,%esp
    dhcp_free_reply(dhcp);
  803df6:	89 d8                	mov    %ebx,%eax
  803df8:	e8 71 f5 ff ff       	call   80336e <dhcp_free_reply>
    mem_free((void *)dhcp);
  803dfd:	83 ec 0c             	sub    $0xc,%esp
  803e00:	53                   	push   %ebx
  803e01:	e8 5c 01 00 00       	call   803f62 <mem_free>
    netif->dhcp = NULL;
  803e06:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803e0d:	83 c4 10             	add    $0x10,%esp
}
  803e10:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e13:	5b                   	pop    %ebx
  803e14:	5e                   	pop    %esi
  803e15:	5d                   	pop    %ebp
  803e16:	c3                   	ret    

00803e17 <dhcp_start>:
{
  803e17:	55                   	push   %ebp
  803e18:	89 e5                	mov    %esp,%ebp
  803e1a:	56                   	push   %esi
  803e1b:	53                   	push   %ebx
  803e1c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803e1f:	85 db                	test   %ebx,%ebx
  803e21:	74 73                	je     803e96 <dhcp_start+0x7f>
  dhcp = netif->dhcp;
  803e23:	8b 73 20             	mov    0x20(%ebx),%esi
  netif->flags &= ~NETIF_FLAG_DHCP;
  803e26:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)
  if (dhcp == NULL) {
  803e2a:	85 f6                	test   %esi,%esi
  803e2c:	74 7f                	je     803ead <dhcp_start+0x96>
  memset(dhcp, 0, sizeof(struct dhcp));
  803e2e:	83 ec 04             	sub    $0x4,%esp
  803e31:	6a 58                	push   $0x58
  803e33:	6a 00                	push   $0x0
  803e35:	56                   	push   %esi
  803e36:	e8 a0 ae 00 00       	call   80ecdb <memset>
  dhcp->pcb = udp_new();
  803e3b:	e8 45 51 00 00       	call   808f85 <udp_new>
  803e40:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803e43:	83 c4 10             	add    $0x10,%esp
  803e46:	85 c0                	test   %eax,%eax
  803e48:	74 7e                	je     803ec8 <dhcp_start+0xb1>
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803e4a:	83 ec 04             	sub    $0x4,%esp
  803e4d:	6a 44                	push   $0x44
  803e4f:	68 a8 1c 81 00       	push   $0x811ca8
  803e54:	50                   	push   %eax
  803e55:	e8 97 4d 00 00       	call   808bf1 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803e5a:	83 c4 0c             	add    $0xc,%esp
  803e5d:	6a 43                	push   $0x43
  803e5f:	68 a8 1c 81 00       	push   $0x811ca8
  803e64:	ff 76 08             	push   0x8(%esi)
  803e67:	e8 35 50 00 00       	call   808ea1 <udp_connect>
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803e6c:	83 c4 0c             	add    $0xc,%esp
  803e6f:	53                   	push   %ebx
  803e70:	68 b6 33 80 00       	push   $0x8033b6
  803e75:	ff 76 08             	push   0x8(%esi)
  803e78:	e8 b0 50 00 00       	call   808f2d <udp_recv>
  result = dhcp_discover(netif);
  803e7d:	89 d8                	mov    %ebx,%eax
  803e7f:	e8 40 f0 ff ff       	call   802ec4 <dhcp_discover>
  if (result != ERR_OK) {
  803e84:	83 c4 10             	add    $0x10,%esp
  803e87:	84 c0                	test   %al,%al
  803e89:	75 57                	jne    803ee2 <dhcp_start+0xcb>
  netif->flags |= NETIF_FLAG_DHCP;
  803e8b:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
}
  803e8f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e92:	5b                   	pop    %ebx
  803e93:	5e                   	pop    %esi
  803e94:	5d                   	pop    %ebp
  803e95:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803e96:	83 ec 04             	sub    $0x4,%esp
  803e99:	68 22 14 81 00       	push   $0x811422
  803e9e:	68 38 02 00 00       	push   $0x238
  803ea3:	68 02 14 81 00       	push   $0x811402
  803ea8:	e8 29 a6 00 00       	call   80e4d6 <_panic>
    dhcp = mem_malloc(sizeof(struct dhcp));
  803ead:	83 ec 0c             	sub    $0xc,%esp
  803eb0:	6a 58                	push   $0x58
  803eb2:	e8 9a 03 00 00       	call   804251 <mem_malloc>
  803eb7:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803eb9:	83 c4 10             	add    $0x10,%esp
  803ebc:	85 c0                	test   %eax,%eax
  803ebe:	74 35                	je     803ef5 <dhcp_start+0xde>
    netif->dhcp = dhcp;
  803ec0:	89 43 20             	mov    %eax,0x20(%ebx)
  803ec3:	e9 66 ff ff ff       	jmp    803e2e <dhcp_start+0x17>
    mem_free((void *)dhcp);
  803ec8:	83 ec 0c             	sub    $0xc,%esp
  803ecb:	56                   	push   %esi
  803ecc:	e8 91 00 00 00       	call   803f62 <mem_free>
    netif->dhcp = dhcp = NULL;
  803ed1:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803ed8:	83 c4 10             	add    $0x10,%esp
  803edb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803ee0:	eb ad                	jmp    803e8f <dhcp_start+0x78>
    dhcp_stop(netif);
  803ee2:	83 ec 0c             	sub    $0xc,%esp
  803ee5:	53                   	push   %ebx
  803ee6:	e8 c4 fe ff ff       	call   803daf <dhcp_stop>
    return ERR_MEM;
  803eeb:	83 c4 10             	add    $0x10,%esp
  803eee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803ef3:	eb 9a                	jmp    803e8f <dhcp_start+0x78>
      return ERR_MEM;
  803ef5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803efa:	eb 93                	jmp    803e8f <dhcp_start+0x78>

00803efc <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803efc:	55                   	push   %ebp
  803efd:	89 e5                	mov    %esp,%ebp
  803eff:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803f02:	b8 63 53 81 00       	mov    $0x815363,%eax
  803f07:	83 e0 fc             	and    $0xfffffffc,%eax
  803f0a:	a3 4c 53 81 00       	mov    %eax,0x81534c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803f0f:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803f15:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803f1c:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803f20:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803f26:	89 15 48 53 81 00    	mov    %edx,0x815348
  ram_end->used = 1;
  803f2c:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803f33:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803f3a:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803f3d:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  803f44:	00 22 00 

  mem_sem = sys_sem_new(1);
  803f47:	6a 01                	push   $0x1
  803f49:	e8 16 5e 00 00       	call   809d64 <sys_sem_new>
  803f4e:	a3 40 53 81 00       	mov    %eax,0x815340

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  803f53:	a1 4c 53 81 00       	mov    0x81534c,%eax
  803f58:	a3 44 53 81 00       	mov    %eax,0x815344

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  803f5d:	83 c4 10             	add    $0x10,%esp
  803f60:	c9                   	leave  
  803f61:	c3                   	ret    

00803f62 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  803f62:	55                   	push   %ebp
  803f63:	89 e5                	mov    %esp,%ebp
  803f65:	56                   	push   %esi
  803f66:	53                   	push   %ebx
  803f67:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  803f6a:	85 db                	test   %ebx,%ebx
  803f6c:	0f 84 e1 00 00 00    	je     804053 <mem_free+0xf1>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803f72:	f6 c3 03             	test   $0x3,%bl
  803f75:	0f 85 df 00 00 00    	jne    80405a <mem_free+0xf8>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  803f7b:	39 1d 4c 53 81 00    	cmp    %ebx,0x81534c
  803f81:	0f 87 ea 00 00 00    	ja     804071 <mem_free+0x10f>
  803f87:	39 1d 48 53 81 00    	cmp    %ebx,0x815348
  803f8d:	0f 86 de 00 00 00    	jbe    804071 <mem_free+0x10f>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  803f93:	83 ec 08             	sub    $0x8,%esp
  803f96:	6a 00                	push   $0x0
  803f98:	ff 35 40 53 81 00    	push   0x815340
  803f9e:	e8 ee 60 00 00       	call   80a091 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  803fa3:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  803fa6:	83 c4 10             	add    $0x10,%esp
  803fa9:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  803fad:	0f 84 d5 00 00 00    	je     804088 <mem_free+0x126>
  /* ... and is now unused. */
  mem->used = 0;
  803fb3:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  803fb7:	39 05 44 53 81 00    	cmp    %eax,0x815344
  803fbd:	76 05                	jbe    803fc4 <mem_free+0x62>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  803fbf:	a3 44 53 81 00       	mov    %eax,0x815344
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  803fc4:	8b 0d 4c 53 81 00    	mov    0x81534c,%ecx
  803fca:	39 c8                	cmp    %ecx,%eax
  803fcc:	0f 82 cd 00 00 00    	jb     80409f <mem_free+0x13d>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  803fd2:	8b 35 48 53 81 00    	mov    0x815348,%esi
  803fd8:	39 f0                	cmp    %esi,%eax
  803fda:	0f 83 d6 00 00 00    	jae    8040b6 <mem_free+0x154>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  803fe0:	8b 53 f4             	mov    -0xc(%ebx),%edx
  803fe3:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  803fe9:	0f 87 de 00 00 00    	ja     8040cd <mem_free+0x16b>
  nmem = (struct mem *)&ram[mem->next];
  803fef:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  803ff1:	39 d0                	cmp    %edx,%eax
  803ff3:	74 25                	je     80401a <mem_free+0xb8>
  803ff5:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  803ff9:	75 1f                	jne    80401a <mem_free+0xb8>
  803ffb:	39 d6                	cmp    %edx,%esi
  803ffd:	74 1b                	je     80401a <mem_free+0xb8>
    if (lfree == nmem) {
  803fff:	3b 15 44 53 81 00    	cmp    0x815344,%edx
  804005:	0f 84 d9 00 00 00    	je     8040e4 <mem_free+0x182>
    mem->next = nmem->next;
  80400b:	8b 32                	mov    (%edx),%esi
  80400d:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  804010:	8b 12                	mov    (%edx),%edx
  804012:	89 c6                	mov    %eax,%esi
  804014:	29 ce                	sub    %ecx,%esi
  804016:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  pmem = (struct mem *)&ram[mem->prev];
  80401a:	8b 73 f8             	mov    -0x8(%ebx),%esi
  80401d:	8d 14 31             	lea    (%ecx,%esi,1),%edx
  if (pmem != mem && pmem->used == 0) {
  804020:	39 d0                	cmp    %edx,%eax
  804022:	74 1e                	je     804042 <mem_free+0xe0>
  804024:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804028:	75 18                	jne    804042 <mem_free+0xe0>
    if (lfree == mem) {
  80402a:	3b 05 44 53 81 00    	cmp    0x815344,%eax
  804030:	0f 84 b8 00 00 00    	je     8040ee <mem_free+0x18c>
    pmem->next = mem->next;
  804036:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804039:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80403b:	8b 43 f4             	mov    -0xc(%ebx),%eax
  80403e:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804042:	83 ec 0c             	sub    $0xc,%esp
  804045:	ff 35 40 53 81 00    	push   0x815340
  80404b:	e8 d1 5f 00 00       	call   80a021 <sys_sem_signal>
  804050:	83 c4 10             	add    $0x10,%esp
}
  804053:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804056:	5b                   	pop    %ebx
  804057:	5e                   	pop    %esi
  804058:	5d                   	pop    %ebp
  804059:	c3                   	ret    
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80405a:	83 ec 04             	sub    $0x4,%esp
  80405d:	68 74 14 81 00       	push   $0x811474
  804062:	68 30 01 00 00       	push   $0x130
  804067:	68 6b 15 81 00       	push   $0x81156b
  80406c:	e8 65 a4 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804071:	83 ec 04             	sub    $0x4,%esp
  804074:	68 7f 15 81 00       	push   $0x81157f
  804079:	68 32 01 00 00       	push   $0x132
  80407e:	68 6b 15 81 00       	push   $0x81156b
  804083:	e8 4e a4 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  804088:	83 ec 04             	sub    $0x4,%esp
  80408b:	68 96 15 81 00       	push   $0x811596
  804090:	68 43 01 00 00       	push   $0x143
  804095:	68 6b 15 81 00       	push   $0x81156b
  80409a:	e8 37 a4 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80409f:	83 ec 04             	sub    $0x4,%esp
  8040a2:	68 aa 15 81 00       	push   $0x8115aa
  8040a7:	68 e3 00 00 00       	push   $0xe3
  8040ac:	68 6b 15 81 00       	push   $0x81156b
  8040b1:	e8 20 a4 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  8040b6:	83 ec 04             	sub    $0x4,%esp
  8040b9:	68 c1 15 81 00       	push   $0x8115c1
  8040be:	68 e4 00 00 00       	push   $0xe4
  8040c3:	68 6b 15 81 00       	push   $0x81156b
  8040c8:	e8 09 a4 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  8040cd:	83 ec 04             	sub    $0x4,%esp
  8040d0:	68 98 14 81 00       	push   $0x811498
  8040d5:	68 e8 00 00 00       	push   $0xe8
  8040da:	68 6b 15 81 00       	push   $0x81156b
  8040df:	e8 f2 a3 00 00       	call   80e4d6 <_panic>
      lfree = mem;
  8040e4:	a3 44 53 81 00       	mov    %eax,0x815344
  8040e9:	e9 1d ff ff ff       	jmp    80400b <mem_free+0xa9>
      lfree = pmem;
  8040ee:	89 15 44 53 81 00    	mov    %edx,0x815344
  8040f4:	e9 3d ff ff ff       	jmp    804036 <mem_free+0xd4>

008040f9 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8040f9:	55                   	push   %ebp
  8040fa:	89 e5                	mov    %esp,%ebp
  8040fc:	57                   	push   %edi
  8040fd:	56                   	push   %esi
  8040fe:	53                   	push   %ebx
  8040ff:	83 ec 1c             	sub    $0x1c,%esp
  804102:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  804105:	8b 45 0c             	mov    0xc(%ebp),%eax
  804108:	8d 58 03             	lea    0x3(%eax),%ebx
  80410b:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  80410e:	83 fb 0b             	cmp    $0xb,%ebx
  804111:	76 12                	jbe    804125 <mem_realloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  804113:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  804119:	76 0f                	jbe    80412a <mem_realloc+0x31>
    return NULL;
  80411b:	be 00 00 00 00       	mov    $0x0,%esi
  804120:	e9 a1 00 00 00       	jmp    8041c6 <mem_realloc+0xcd>
    newsize = MIN_SIZE_ALIGNED;
  804125:	bb 0c 00 00 00       	mov    $0xc,%ebx
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80412a:	a1 4c 53 81 00       	mov    0x81534c,%eax
  80412f:	39 f0                	cmp    %esi,%eax
  804131:	0f 87 99 00 00 00    	ja     8041d0 <mem_realloc+0xd7>
  804137:	39 35 48 53 81 00    	cmp    %esi,0x815348
  80413d:	0f 86 8d 00 00 00    	jbe    8041d0 <mem_realloc+0xd7>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  804143:	8d 56 f4             	lea    -0xc(%esi),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  804146:	29 c2                	sub    %eax,%edx
  804148:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80414b:	8b 4e f4             	mov    -0xc(%esi),%ecx
  80414e:	8d 79 f4             	lea    -0xc(%ecx),%edi
  804151:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804153:	39 df                	cmp    %ebx,%edi
  804155:	0f 82 8c 00 00 00    	jb     8041e7 <mem_realloc+0xee>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  80415b:	74 69                	je     8041c6 <mem_realloc+0xcd>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80415d:	83 ec 08             	sub    $0x8,%esp
  804160:	6a 00                	push   $0x0
  804162:	ff 35 40 53 81 00    	push   0x815340
  804168:	e8 24 5f 00 00       	call   80a091 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80416d:	a1 4c 53 81 00       	mov    0x81534c,%eax
  804172:	89 c2                	mov    %eax,%edx
  804174:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  804177:	83 c4 10             	add    $0x10,%esp
  80417a:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80417e:	0f 85 85 00 00 00    	jne    804209 <mem_realloc+0x110>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804184:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804186:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804189:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  80418d:	39 15 44 53 81 00    	cmp    %edx,0x815344
  804193:	74 69                	je     8041fe <mem_realloc+0x105>
      lfree = (struct mem *)&ram[ptr2];
    }
    mem2 = (struct mem *)&ram[ptr2];
  804195:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  804198:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  80419c:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  80419e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8041a1:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  8041a4:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8041a7:	8b 12                	mov    (%edx),%edx
  8041a9:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8041af:	74 04                	je     8041b5 <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8041b1:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8041b5:	83 ec 0c             	sub    $0xc,%esp
  8041b8:	ff 35 40 53 81 00    	push   0x815340
  8041be:	e8 5e 5e 00 00       	call   80a021 <sys_sem_signal>
  return rmem;
  8041c3:	83 c4 10             	add    $0x10,%esp
}
  8041c6:	89 f0                	mov    %esi,%eax
  8041c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8041cb:	5b                   	pop    %ebx
  8041cc:	5e                   	pop    %esi
  8041cd:	5f                   	pop    %edi
  8041ce:	5d                   	pop    %ebp
  8041cf:	c3                   	ret    
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8041d0:	83 ec 04             	sub    $0x4,%esp
  8041d3:	68 db 15 81 00       	push   $0x8115db
  8041d8:	68 78 01 00 00       	push   $0x178
  8041dd:	68 6b 15 81 00       	push   $0x81156b
  8041e2:	e8 ef a2 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8041e7:	83 ec 04             	sub    $0x4,%esp
  8041ea:	68 c4 14 81 00       	push   $0x8114c4
  8041ef:	68 8a 01 00 00       	push   $0x18a
  8041f4:	68 6b 15 81 00       	push   $0x81156b
  8041f9:	e8 d8 a2 00 00       	call   80e4d6 <_panic>
      lfree = (struct mem *)&ram[ptr2];
  8041fe:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  804201:	89 15 44 53 81 00    	mov    %edx,0x815344
  804207:	eb 8c                	jmp    804195 <mem_realloc+0x9c>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  804209:	8d 53 18             	lea    0x18(%ebx),%edx
  80420c:	39 fa                	cmp    %edi,%edx
  80420e:	77 a5                	ja     8041b5 <mem_realloc+0xbc>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804210:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  804213:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  804217:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  80421a:	39 15 44 53 81 00    	cmp    %edx,0x815344
  804220:	76 06                	jbe    804228 <mem_realloc+0x12f>
      lfree = mem2;
  804222:	89 15 44 53 81 00    	mov    %edx,0x815344
    mem2->used = 0;
  804228:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  80422c:	8b 5e f4             	mov    -0xc(%esi),%ebx
  80422f:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  804231:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804234:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  804237:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80423a:	8b 12                	mov    (%edx),%edx
  80423c:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804242:	0f 84 6d ff ff ff    	je     8041b5 <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804248:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
  80424c:	e9 64 ff ff ff       	jmp    8041b5 <mem_realloc+0xbc>

00804251 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  804251:	55                   	push   %ebp
  804252:	89 e5                	mov    %esp,%ebp
  804254:	57                   	push   %edi
  804255:	56                   	push   %esi
  804256:	53                   	push   %ebx
  804257:	83 ec 1c             	sub    $0x1c,%esp
  80425a:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80425d:	85 f6                	test   %esi,%esi
  80425f:	0f 84 a0 01 00 00    	je     804405 <mem_malloc+0x1b4>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804265:	83 c6 03             	add    $0x3,%esi
  804268:	83 e6 fc             	and    $0xfffffffc,%esi

  if(size < MIN_SIZE_ALIGNED) {
  80426b:	83 fe 0b             	cmp    $0xb,%esi
  80426e:	76 3b                	jbe    8042ab <mem_malloc+0x5a>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  804270:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  804276:	0f 87 90 01 00 00    	ja     80440c <mem_malloc+0x1bb>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80427c:	83 ec 08             	sub    $0x8,%esp
  80427f:	6a 00                	push   $0x0
  804281:	ff 35 40 53 81 00    	push   0x815340
  804287:	e8 05 5e 00 00       	call   80a091 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80428c:	a1 44 53 81 00       	mov    0x815344,%eax
  804291:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804294:	8b 3d 4c 53 81 00    	mov    0x81534c,%edi
  80429a:	29 f8                	sub    %edi,%eax
  80429c:	83 c4 10             	add    $0x10,%esp
  80429f:	b9 00 00 22 00       	mov    $0x220000,%ecx
  8042a4:	29 f1                	sub    %esi,%ecx
  8042a6:	e9 e3 00 00 00       	jmp    80438e <mem_malloc+0x13d>
    size = MIN_SIZE_ALIGNED;
  8042ab:	be 0c 00 00 00       	mov    $0xc,%esi
  8042b0:	eb ca                	jmp    80427c <mem_malloc+0x2b>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  8042b2:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  8042b6:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
  8042b9:	74 4d                	je     804308 <mem_malloc+0xb7>
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  8042bb:	83 ec 0c             	sub    $0xc,%esp
  8042be:	ff 35 40 53 81 00    	push   0x815340
  8042c4:	e8 58 5d 00 00       	call   80a021 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  8042c9:	8d 44 33 0c          	lea    0xc(%ebx,%esi,1),%eax
  8042cd:	83 c4 10             	add    $0x10,%esp
  8042d0:	39 05 48 53 81 00    	cmp    %eax,0x815348
  8042d6:	0f 82 82 00 00 00    	jb     80435e <mem_malloc+0x10d>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  8042dc:	8d 43 0c             	lea    0xc(%ebx),%eax
  8042df:	f6 c3 03             	test   $0x3,%bl
  8042e2:	0f 85 8d 00 00 00    	jne    804375 <mem_malloc+0x124>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  8042e8:	f6 c3 03             	test   $0x3,%bl
  8042eb:	0f 84 0c 01 00 00    	je     8043fd <mem_malloc+0x1ac>
  8042f1:	83 ec 04             	sub    $0x4,%esp
  8042f4:	68 48 15 81 00       	push   $0x811548
  8042f9:	68 4e 02 00 00       	push   $0x24e
  8042fe:	68 6b 15 81 00       	push   $0x81156b
  804303:	e8 ce a1 00 00       	call   80e4d6 <_panic>
          while (lfree->used && lfree != ram_end) {
  804308:	8b 15 48 53 81 00    	mov    0x815348,%edx
  80430e:	b8 00 00 00 00       	mov    $0x0,%eax
            lfree = (struct mem *)&ram[lfree->next];
  804313:	b9 01 00 00 00       	mov    $0x1,%ecx
  804318:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80431b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80431e:	eb 08                	jmp    804328 <mem_malloc+0xd7>
  804320:	89 f8                	mov    %edi,%eax
  804322:	03 06                	add    (%esi),%eax
  804324:	89 c6                	mov    %eax,%esi
  804326:	89 c8                	mov    %ecx,%eax
          while (lfree->used && lfree != ram_end) {
  804328:	80 7e 08 00          	cmpb   $0x0,0x8(%esi)
  80432c:	74 18                	je     804346 <mem_malloc+0xf5>
  80432e:	39 f2                	cmp    %esi,%edx
  804330:	75 ee                	jne    804320 <mem_malloc+0xcf>
  804332:	89 f7                	mov    %esi,%edi
  804334:	8b 75 e0             	mov    -0x20(%ebp),%esi
  804337:	84 c0                	test   %al,%al
  804339:	74 80                	je     8042bb <mem_malloc+0x6a>
  80433b:	89 3d 44 53 81 00    	mov    %edi,0x815344
  804341:	e9 75 ff ff ff       	jmp    8042bb <mem_malloc+0x6a>
  804346:	89 f7                	mov    %esi,%edi
  804348:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80434b:	84 c0                	test   %al,%al
  80434d:	0f 84 68 ff ff ff    	je     8042bb <mem_malloc+0x6a>
  804353:	89 3d 44 53 81 00    	mov    %edi,0x815344
  804359:	e9 5d ff ff ff       	jmp    8042bb <mem_malloc+0x6a>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80435e:	83 ec 04             	sub    $0x4,%esp
  804361:	68 e8 14 81 00       	push   $0x8114e8
  804366:	68 4a 02 00 00       	push   $0x24a
  80436b:	68 6b 15 81 00       	push   $0x81156b
  804370:	e8 61 a1 00 00       	call   80e4d6 <_panic>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804375:	83 ec 04             	sub    $0x4,%esp
  804378:	68 18 15 81 00       	push   $0x811518
  80437d:	68 4c 02 00 00       	push   $0x24c
  804382:	68 6b 15 81 00       	push   $0x81156b
  804387:	e8 4a a1 00 00       	call   80e4d6 <_panic>
         ptr = ((struct mem *)&ram[ptr])->next) {
  80438c:	8b 03                	mov    (%ebx),%eax
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80438e:	39 c1                	cmp    %eax,%ecx
  804390:	76 55                	jbe    8043e7 <mem_malloc+0x196>
      mem = (struct mem *)&ram[ptr];
  804392:	8d 1c 07             	lea    (%edi,%eax,1),%ebx
      if ((!mem->used) &&
  804395:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804399:	75 f1                	jne    80438c <mem_malloc+0x13b>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80439b:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  8043a0:	29 c2                	sub    %eax,%edx
  8043a2:	03 13                	add    (%ebx),%edx
      if ((!mem->used) &&
  8043a4:	39 f2                	cmp    %esi,%edx
  8043a6:	72 e4                	jb     80438c <mem_malloc+0x13b>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  8043a8:	8d 4e 18             	lea    0x18(%esi),%ecx
  8043ab:	39 ca                	cmp    %ecx,%edx
  8043ad:	0f 82 ff fe ff ff    	jb     8042b2 <mem_malloc+0x61>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  8043b3:	8d 4c 30 0c          	lea    0xc(%eax,%esi,1),%ecx
          mem2 = (struct mem *)&ram[ptr2];
  8043b7:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  8043ba:	8d 14 0f             	lea    (%edi,%ecx,1),%edx
          mem2->used = 0;
  8043bd:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  8043c1:	8b 0b                	mov    (%ebx),%ecx
  8043c3:	89 0a                	mov    %ecx,(%edx)
          mem2->prev = ptr;
  8043c5:	89 42 04             	mov    %eax,0x4(%edx)
          mem->next = ptr2;
  8043c8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8043cb:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  8043cd:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          if (mem2->next != MEM_SIZE_ALIGNED) {
  8043d1:	8b 02                	mov    (%edx),%eax
  8043d3:	3d 00 00 22 00       	cmp    $0x220000,%eax
  8043d8:	0f 84 d8 fe ff ff    	je     8042b6 <mem_malloc+0x65>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8043de:	89 4c 07 04          	mov    %ecx,0x4(%edi,%eax,1)
  8043e2:	e9 cf fe ff ff       	jmp    8042b6 <mem_malloc+0x65>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  8043e7:	83 ec 0c             	sub    $0xc,%esp
  8043ea:	ff 35 40 53 81 00    	push   0x815340
  8043f0:	e8 2c 5c 00 00       	call   80a021 <sys_sem_signal>
  return NULL;
  8043f5:	83 c4 10             	add    $0x10,%esp
  8043f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8043fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804400:	5b                   	pop    %ebx
  804401:	5e                   	pop    %esi
  804402:	5f                   	pop    %edi
  804403:	5d                   	pop    %ebp
  804404:	c3                   	ret    
    return NULL;
  804405:	b8 00 00 00 00       	mov    $0x0,%eax
  80440a:	eb f1                	jmp    8043fd <mem_malloc+0x1ac>
    return NULL;
  80440c:	b8 00 00 00 00       	mov    $0x0,%eax
  804411:	eb ea                	jmp    8043fd <mem_malloc+0x1ac>

00804413 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  804413:	55                   	push   %ebp
  804414:	89 e5                	mov    %esp,%ebp
  804416:	56                   	push   %esi
  804417:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  804418:	8b 75 0c             	mov    0xc(%ebp),%esi
  80441b:	0f af 75 08          	imul   0x8(%ebp),%esi
  80441f:	83 ec 0c             	sub    $0xc,%esp
  804422:	56                   	push   %esi
  804423:	e8 29 fe ff ff       	call   804251 <mem_malloc>
  804428:	89 c3                	mov    %eax,%ebx
  if (p) {
  80442a:	83 c4 10             	add    $0x10,%esp
  80442d:	85 c0                	test   %eax,%eax
  80442f:	74 0f                	je     804440 <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  804431:	83 ec 04             	sub    $0x4,%esp
  804434:	56                   	push   %esi
  804435:	6a 00                	push   $0x0
  804437:	50                   	push   %eax
  804438:	e8 9e a8 00 00       	call   80ecdb <memset>
  80443d:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  804440:	89 d8                	mov    %ebx,%eax
  804442:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804445:	5b                   	pop    %ebx
  804446:	5e                   	pop    %esi
  804447:	5d                   	pop    %ebp
  804448:	c3                   	ret    

00804449 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  804449:	55                   	push   %ebp
  80444a:	89 e5                	mov    %esp,%ebp
  80444c:	56                   	push   %esi
  80444d:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80444e:	b8 83 53 a3 00       	mov    $0xa35383,%eax
  804453:	83 e0 fc             	and    $0xfffffffc,%eax
  804456:	ba 00 00 00 00       	mov    $0x0,%edx
  80445b:	eb 2a                	jmp    804487 <memp_init+0x3e>
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  80445d:	8b 1c 95 00 44 b3 00 	mov    0xb34400(,%edx,4),%ebx
  804464:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  804466:	89 04 95 00 44 b3 00 	mov    %eax,0xb34400(,%edx,4)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80446d:	0f b7 9c 12 88 16 81 	movzwl 0x811688(%edx,%edx,1),%ebx
  804474:	00 
  804475:	01 d8                	add    %ebx,%eax
    for (j = 0; j < memp_num[i]; ++j) {
  804477:	83 c1 01             	add    $0x1,%ecx
  80447a:	66 39 ce             	cmp    %cx,%si
  80447d:	75 de                	jne    80445d <memp_init+0x14>
  for (i = 0; i < MEMP_MAX; ++i) {
  80447f:	83 c2 01             	add    $0x1,%edx
  804482:	83 fa 0e             	cmp    $0xe,%edx
  804485:	74 1a                	je     8044a1 <memp_init+0x58>
    memp_tab[i] = NULL;
  804487:	c7 04 95 00 44 b3 00 	movl   $0x0,0xb34400(,%edx,4)
  80448e:	00 00 00 00 
    for (j = 0; j < memp_num[i]; ++j) {
  804492:	0f b7 b4 12 6c 16 81 	movzwl 0x81166c(%edx,%edx,1),%esi
  804499:	00 
  80449a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80449f:	eb d9                	jmp    80447a <memp_init+0x31>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  8044a1:	5b                   	pop    %ebx
  8044a2:	5e                   	pop    %esi
  8044a3:	5d                   	pop    %ebp
  8044a4:	c3                   	ret    

008044a5 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  8044a5:	55                   	push   %ebp
  8044a6:	89 e5                	mov    %esp,%ebp
  8044a8:	83 ec 08             	sub    $0x8,%esp
  8044ab:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  8044ae:	83 fa 0d             	cmp    $0xd,%edx
  8044b1:	77 1a                	ja     8044cd <memp_malloc+0x28>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  8044b3:	8b 04 95 00 44 b3 00 	mov    0xb34400(,%edx,4),%eax
  
  if (memp != NULL) {    
  8044ba:	85 c0                	test   %eax,%eax
  8044bc:	74 0d                	je     8044cb <memp_malloc+0x26>
    memp_tab[type] = memp->next;    
  8044be:	8b 08                	mov    (%eax),%ecx
  8044c0:	89 0c 95 00 44 b3 00 	mov    %ecx,0xb34400(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  8044c7:	a8 03                	test   $0x3,%al
  8044c9:	75 19                	jne    8044e4 <memp_malloc+0x3f>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8044cb:	c9                   	leave  
  8044cc:	c3                   	ret    
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  8044cd:	83 ec 04             	sub    $0x4,%esp
  8044d0:	68 f5 15 81 00       	push   $0x8115f5
  8044d5:	68 2d 01 00 00       	push   $0x12d
  8044da:	68 12 16 81 00       	push   $0x811612
  8044df:	e8 f2 9f 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  8044e4:	83 ec 04             	sub    $0x4,%esp
  8044e7:	68 28 16 81 00       	push   $0x811628
  8044ec:	68 3e 01 00 00       	push   $0x13e
  8044f1:	68 12 16 81 00       	push   $0x811612
  8044f6:	e8 db 9f 00 00       	call   80e4d6 <_panic>

008044fb <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8044fb:	55                   	push   %ebp
  8044fc:	89 e5                	mov    %esp,%ebp
  8044fe:	83 ec 08             	sub    $0x8,%esp
  804501:	8b 55 08             	mov    0x8(%ebp),%edx
  804504:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  804507:	85 c0                	test   %eax,%eax
  804509:	74 14                	je     80451f <memp_free+0x24>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  80450b:	a8 03                	test   $0x3,%al
  80450d:	75 12                	jne    804521 <memp_free+0x26>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  80450f:	8b 0c 95 00 44 b3 00 	mov    0xb34400(,%edx,4),%ecx
  804516:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  804518:	89 04 95 00 44 b3 00 	mov    %eax,0xb34400(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80451f:	c9                   	leave  
  804520:	c3                   	ret    
  LWIP_ASSERT("memp_free: mem properly aligned",
  804521:	83 ec 04             	sub    $0x4,%esp
  804524:	68 4c 16 81 00       	push   $0x81164c
  804529:	68 5a 01 00 00       	push   $0x15a
  80452e:	68 12 16 81 00       	push   $0x811612
  804533:	e8 9e 9f 00 00       	call   80e4d6 <_panic>

00804538 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  804538:	55                   	push   %ebp
  804539:	89 e5                	mov    %esp,%ebp
  80453b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  80453e:	85 c9                	test   %ecx,%ecx
  804540:	74 2c                	je     80456e <netif_remove+0x36>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  804542:	a1 3c 44 b3 00       	mov    0xb3443c,%eax
  804547:	39 c8                	cmp    %ecx,%eax
  804549:	74 0e                	je     804559 <netif_remove+0x21>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80454b:	85 c0                	test   %eax,%eax
  80454d:	74 1f                	je     80456e <netif_remove+0x36>
      if (tmpNetif->next == netif) {
  80454f:	8b 10                	mov    (%eax),%edx
  804551:	39 ca                	cmp    %ecx,%edx
  804553:	74 0d                	je     804562 <netif_remove+0x2a>
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804555:	89 d0                	mov    %edx,%eax
  804557:	eb f2                	jmp    80454b <netif_remove+0x13>
    netif_list = netif->next;
  804559:	8b 01                	mov    (%ecx),%eax
  80455b:	a3 3c 44 b3 00       	mov    %eax,0xb3443c
  804560:	eb 04                	jmp    804566 <netif_remove+0x2e>
        tmpNetif->next = netif->next;
  804562:	8b 11                	mov    (%ecx),%edx
  804564:	89 10                	mov    %edx,(%eax)
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804566:	39 0d 38 44 b3 00    	cmp    %ecx,0xb34438
  80456c:	74 02                	je     804570 <netif_remove+0x38>
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80456e:	5d                   	pop    %ebp
  80456f:	c3                   	ret    
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804570:	c7 05 38 44 b3 00 00 	movl   $0x0,0xb34438
  804577:	00 00 00 
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80457a:	eb f2                	jmp    80456e <netif_remove+0x36>

0080457c <netif_find>:
{
  80457c:	55                   	push   %ebp
  80457d:	89 e5                	mov    %esp,%ebp
  80457f:	53                   	push   %ebx
  804580:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (name == NULL) {
  804583:	85 c9                	test   %ecx,%ecx
  804585:	74 2f                	je     8045b6 <netif_find+0x3a>
  num = name[2] - '0';
  804587:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  80458b:	8d 50 d0             	lea    -0x30(%eax),%edx
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80458e:	a1 3c 44 b3 00       	mov    0xb3443c,%eax
  804593:	eb 02                	jmp    804597 <netif_find+0x1b>
  804595:	8b 00                	mov    (%eax),%eax
  804597:	85 c0                	test   %eax,%eax
  804599:	74 16                	je     8045b1 <netif_find+0x35>
    if (num == netif->num &&
  80459b:	38 50 31             	cmp    %dl,0x31(%eax)
  80459e:	75 f5                	jne    804595 <netif_find+0x19>
  8045a0:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  8045a4:	38 19                	cmp    %bl,(%ecx)
  8045a6:	75 ed                	jne    804595 <netif_find+0x19>
       name[0] == netif->name[0] &&
  8045a8:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  8045ac:	38 59 01             	cmp    %bl,0x1(%ecx)
  8045af:	75 e4                	jne    804595 <netif_find+0x19>
}
  8045b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8045b4:	c9                   	leave  
  8045b5:	c3                   	ret    
    return NULL;
  8045b6:	89 c8                	mov    %ecx,%eax
  8045b8:	eb f7                	jmp    8045b1 <netif_find+0x35>

008045ba <netif_set_ipaddr>:
{
  8045ba:	55                   	push   %ebp
  8045bb:	89 e5                	mov    %esp,%ebp
  8045bd:	57                   	push   %edi
  8045be:	56                   	push   %esi
  8045bf:	53                   	push   %ebx
  8045c0:	83 ec 0c             	sub    $0xc,%esp
  8045c3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8045c6:	8b 75 0c             	mov    0xc(%ebp),%esi
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  8045c9:	8b 43 04             	mov    0x4(%ebx),%eax
  8045cc:	39 06                	cmp    %eax,(%esi)
  8045ce:	74 47                	je     804617 <netif_set_ipaddr+0x5d>
    pcb = tcp_active_pcbs;
  8045d0:	a1 4c 44 b3 00       	mov    0xb3444c,%eax
    while (pcb != NULL) {
  8045d5:	eb 03                	jmp    8045da <netif_set_ipaddr+0x20>
        pcb = pcb->next;
  8045d7:	8b 40 0c             	mov    0xc(%eax),%eax
    while (pcb != NULL) {
  8045da:	85 c0                	test   %eax,%eax
  8045dc:	74 1a                	je     8045f8 <netif_set_ipaddr+0x3e>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8045de:	8b 4b 04             	mov    0x4(%ebx),%ecx
  8045e1:	39 08                	cmp    %ecx,(%eax)
  8045e3:	75 f2                	jne    8045d7 <netif_set_ipaddr+0x1d>
        struct tcp_pcb *next = pcb->next;
  8045e5:	8b 78 0c             	mov    0xc(%eax),%edi
        tcp_abort(pcb);
  8045e8:	83 ec 0c             	sub    $0xc,%esp
  8045eb:	50                   	push   %eax
  8045ec:	e8 64 15 00 00       	call   805b55 <tcp_abort>
  8045f1:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  8045f4:	89 f8                	mov    %edi,%eax
  8045f6:	eb e2                	jmp    8045da <netif_set_ipaddr+0x20>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8045f8:	a1 50 44 b3 00       	mov    0xb34450,%eax
  8045fd:	eb 03                	jmp    804602 <netif_set_ipaddr+0x48>
  8045ff:	8b 40 0c             	mov    0xc(%eax),%eax
  804602:	85 c0                	test   %eax,%eax
  804604:	74 11                	je     804617 <netif_set_ipaddr+0x5d>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  804606:	8b 10                	mov    (%eax),%edx
  804608:	85 d2                	test   %edx,%edx
  80460a:	74 f3                	je     8045ff <netif_set_ipaddr+0x45>
  80460c:	3b 53 04             	cmp    0x4(%ebx),%edx
  80460f:	75 ee                	jne    8045ff <netif_set_ipaddr+0x45>
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804611:	8b 16                	mov    (%esi),%edx
  804613:	89 10                	mov    %edx,(%eax)
  804615:	eb e8                	jmp    8045ff <netif_set_ipaddr+0x45>
  ip_addr_set(&(netif->ip_addr), ipaddr);
  804617:	8b 06                	mov    (%esi),%eax
  804619:	89 43 04             	mov    %eax,0x4(%ebx)
}
  80461c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80461f:	5b                   	pop    %ebx
  804620:	5e                   	pop    %esi
  804621:	5f                   	pop    %edi
  804622:	5d                   	pop    %ebp
  804623:	c3                   	ret    

00804624 <netif_set_addr>:
{
  804624:	55                   	push   %ebp
  804625:	89 e5                	mov    %esp,%ebp
  804627:	57                   	push   %edi
  804628:	56                   	push   %esi
  804629:	53                   	push   %ebx
  80462a:	83 ec 14             	sub    $0x14,%esp
  80462d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804630:	8b 7d 10             	mov    0x10(%ebp),%edi
  804633:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  804636:	ff 75 0c             	push   0xc(%ebp)
  804639:	53                   	push   %ebx
  80463a:	e8 7b ff ff ff       	call   8045ba <netif_set_ipaddr>
  ip_addr_set(&(netif->netmask), netmask);
  80463f:	83 c4 10             	add    $0x10,%esp
  804642:	b8 00 00 00 00       	mov    $0x0,%eax
  804647:	85 ff                	test   %edi,%edi
  804649:	74 02                	je     80464d <netif_set_addr+0x29>
  80464b:	8b 07                	mov    (%edi),%eax
  80464d:	89 43 08             	mov    %eax,0x8(%ebx)
  ip_addr_set(&(netif->gw), gw);
  804650:	b8 00 00 00 00       	mov    $0x0,%eax
  804655:	85 f6                	test   %esi,%esi
  804657:	74 02                	je     80465b <netif_set_addr+0x37>
  804659:	8b 06                	mov    (%esi),%eax
  80465b:	89 43 0c             	mov    %eax,0xc(%ebx)
}
  80465e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804661:	5b                   	pop    %ebx
  804662:	5e                   	pop    %esi
  804663:	5f                   	pop    %edi
  804664:	5d                   	pop    %ebp
  804665:	c3                   	ret    

00804666 <netif_add>:
{
  804666:	55                   	push   %ebp
  804667:	89 e5                	mov    %esp,%ebp
  804669:	53                   	push   %ebx
  80466a:	83 ec 04             	sub    $0x4,%esp
  80466d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif->ip_addr.addr = 0;
  804670:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804677:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  80467e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804685:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
  netif->dhcp = NULL;
  804689:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->state = state;
  804690:	8b 45 18             	mov    0x18(%ebp),%eax
  804693:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804696:	0f b6 05 40 44 b3 00 	movzbl 0xb34440,%eax
  80469d:	8d 50 01             	lea    0x1(%eax),%edx
  8046a0:	88 15 40 44 b3 00    	mov    %dl,0xb34440
  8046a6:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  8046a9:	8b 45 20             	mov    0x20(%ebp),%eax
  8046ac:	89 43 10             	mov    %eax,0x10(%ebx)
  netif_set_addr(netif, ipaddr, netmask, gw);
  8046af:	ff 75 14             	push   0x14(%ebp)
  8046b2:	ff 75 10             	push   0x10(%ebp)
  8046b5:	ff 75 0c             	push   0xc(%ebp)
  8046b8:	53                   	push   %ebx
  8046b9:	e8 66 ff ff ff       	call   804624 <netif_set_addr>
  if (init(netif) != ERR_OK) {
  8046be:	89 1c 24             	mov    %ebx,(%esp)
  8046c1:	ff 55 1c             	call   *0x1c(%ebp)
  8046c4:	83 c4 10             	add    $0x10,%esp
  8046c7:	84 c0                	test   %al,%al
  8046c9:	75 14                	jne    8046df <netif_add+0x79>
  netif->next = netif_list;
  8046cb:	a1 3c 44 b3 00       	mov    0xb3443c,%eax
  8046d0:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  8046d2:	89 1d 3c 44 b3 00    	mov    %ebx,0xb3443c
  return netif;
  8046d8:	89 d8                	mov    %ebx,%eax
}
  8046da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8046dd:	c9                   	leave  
  8046de:	c3                   	ret    
    return NULL;
  8046df:	b8 00 00 00 00       	mov    $0x0,%eax
  8046e4:	eb f4                	jmp    8046da <netif_add+0x74>

008046e6 <netif_set_gw>:
{
  8046e6:	55                   	push   %ebp
  8046e7:	89 e5                	mov    %esp,%ebp
  8046e9:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  8046ec:	b8 00 00 00 00       	mov    $0x0,%eax
  8046f1:	85 d2                	test   %edx,%edx
  8046f3:	74 02                	je     8046f7 <netif_set_gw+0x11>
  8046f5:	8b 02                	mov    (%edx),%eax
  8046f7:	8b 55 08             	mov    0x8(%ebp),%edx
  8046fa:	89 42 0c             	mov    %eax,0xc(%edx)
}
  8046fd:	5d                   	pop    %ebp
  8046fe:	c3                   	ret    

008046ff <netif_set_netmask>:
{
  8046ff:	55                   	push   %ebp
  804700:	89 e5                	mov    %esp,%ebp
  804702:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->netmask), netmask);
  804705:	b8 00 00 00 00       	mov    $0x0,%eax
  80470a:	85 d2                	test   %edx,%edx
  80470c:	74 02                	je     804710 <netif_set_netmask+0x11>
  80470e:	8b 02                	mov    (%edx),%eax
  804710:	8b 55 08             	mov    0x8(%ebp),%edx
  804713:	89 42 08             	mov    %eax,0x8(%edx)
}
  804716:	5d                   	pop    %ebp
  804717:	c3                   	ret    

00804718 <netif_set_default>:
{
  804718:	55                   	push   %ebp
  804719:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  80471b:	8b 45 08             	mov    0x8(%ebp),%eax
  80471e:	a3 38 44 b3 00       	mov    %eax,0xb34438
}
  804723:	5d                   	pop    %ebp
  804724:	c3                   	ret    

00804725 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  804725:	55                   	push   %ebp
  804726:	89 e5                	mov    %esp,%ebp
  804728:	83 ec 08             	sub    $0x8,%esp
  80472b:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80472e:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804732:	a8 01                	test   $0x1,%al
  804734:	75 0c                	jne    804742 <netif_set_up+0x1d>
    netif->flags |= NETIF_FLAG_UP;
  804736:	89 c1                	mov    %eax,%ecx
  804738:	83 c9 01             	or     $0x1,%ecx
  80473b:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80473e:	a8 20                	test   $0x20,%al
  804740:	75 02                	jne    804744 <netif_set_up+0x1f>
      etharp_query(netif, &(netif->ip_addr), NULL);
    }
#endif /* LWIP_ARP */
    
  }
}
  804742:	c9                   	leave  
  804743:	c3                   	ret    
      etharp_query(netif, &(netif->ip_addr), NULL);
  804744:	83 ec 04             	sub    $0x4,%esp
  804747:	6a 00                	push   $0x0
  804749:	8d 42 04             	lea    0x4(%edx),%eax
  80474c:	50                   	push   %eax
  80474d:	52                   	push   %edx
  80474e:	e8 2c 51 00 00       	call   80987f <etharp_query>
  804753:	83 c4 10             	add    $0x10,%esp
}
  804756:	eb ea                	jmp    804742 <netif_set_up+0x1d>

00804758 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804758:	55                   	push   %ebp
  804759:	89 e5                	mov    %esp,%ebp
  80475b:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  80475e:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804762:	a8 01                	test   $0x1,%al
  804764:	74 06                	je     80476c <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804766:	83 e0 fe             	and    $0xfffffffe,%eax
  804769:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80476c:	5d                   	pop    %ebp
  80476d:	c3                   	ret    

0080476e <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80476e:	55                   	push   %ebp
  80476f:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804771:	8b 45 08             	mov    0x8(%ebp),%eax
  804774:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804778:	83 e0 01             	and    $0x1,%eax
}
  80477b:	5d                   	pop    %ebp
  80477c:	c3                   	ret    

0080477d <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  80477d:	55                   	push   %ebp
  80477e:	89 e5                	mov    %esp,%ebp
  804780:	56                   	push   %esi
  804781:	53                   	push   %ebx
  804782:	8b 45 08             	mov    0x8(%ebp),%eax
  804785:	8b 55 0c             	mov    0xc(%ebp),%edx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804788:	85 c0                	test   %eax,%eax
  80478a:	74 42                	je     8047ce <pbuf_header+0x51>
  if ((header_size_increment == 0) || (p == NULL))
  80478c:	66 85 d2             	test   %dx,%dx
  80478f:	0f 84 b0 00 00 00    	je     804845 <pbuf_header+0xc8>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  804795:	89 d6                	mov    %edx,%esi
  if (header_size_increment < 0){
  804797:	78 4c                	js     8047e5 <pbuf_header+0x68>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804799:	0f b6 48 0c          	movzbl 0xc(%eax),%ecx
  /* remember current payload pointer */
  payload = p->payload;
  80479d:	8b 58 04             	mov    0x4(%eax),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  8047a0:	66 85 c9             	test   %cx,%cx
  8047a3:	74 5f                	je     804804 <pbuf_header+0x87>
  8047a5:	66 83 f9 03          	cmp    $0x3,%cx
  8047a9:	74 59                	je     804804 <pbuf_header+0x87>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  8047ab:	83 e9 01             	sub    $0x1,%ecx
  8047ae:	66 83 f9 01          	cmp    $0x1,%cx
  8047b2:	77 7a                	ja     80482e <pbuf_header+0xb1>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  8047b4:	b9 01 00 00 00       	mov    $0x1,%ecx
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8047b9:	66 85 d2             	test   %dx,%dx
  8047bc:	79 67                	jns    804825 <pbuf_header+0xa8>
  8047be:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8047c2:	72 61                	jb     804825 <pbuf_header+0xa8>
      p->payload = (u8_t *)p->payload - header_size_increment;
  8047c4:	0f bf ca             	movswl %dx,%ecx
  8047c7:	29 cb                	sub    %ecx,%ebx
  8047c9:	89 58 04             	mov    %ebx,0x4(%eax)
  8047cc:	eb 4a                	jmp    804818 <pbuf_header+0x9b>
  LWIP_ASSERT("p != NULL", p != NULL);
  8047ce:	83 ec 04             	sub    $0x4,%esp
  8047d1:	68 68 17 81 00       	push   $0x811768
  8047d6:	68 64 01 00 00       	push   $0x164
  8047db:	68 a4 16 81 00       	push   $0x8116a4
  8047e0:	e8 f1 9c 00 00       	call   80e4d6 <_panic>
    increment_magnitude = -header_size_increment;
  8047e5:	f7 de                	neg    %esi
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  8047e7:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8047eb:	73 ac                	jae    804799 <pbuf_header+0x1c>
  8047ed:	83 ec 04             	sub    $0x4,%esp
  8047f0:	68 b9 16 81 00       	push   $0x8116b9
  8047f5:	68 6b 01 00 00       	push   $0x16b
  8047fa:	68 a4 16 81 00       	push   $0x8116a4
  8047ff:	e8 d2 9c 00 00       	call   80e4d6 <_panic>
    p->payload = (u8_t *)p->payload - header_size_increment;
  804804:	0f bf ca             	movswl %dx,%ecx
  804807:	29 cb                	sub    %ecx,%ebx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804809:	8d 70 10             	lea    0x10(%eax),%esi
      return 1;
  80480c:	b9 01 00 00 00       	mov    $0x1,%ecx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804811:	39 f3                	cmp    %esi,%ebx
  804813:	72 10                	jb     804825 <pbuf_header+0xa8>
    p->payload = (u8_t *)p->payload - header_size_increment;
  804815:	89 58 04             	mov    %ebx,0x4(%eax)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  804818:	66 01 50 0a          	add    %dx,0xa(%eax)
  p->tot_len += header_size_increment;
  80481c:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804820:	b9 00 00 00 00       	mov    $0x0,%ecx
}
  804825:	89 c8                	mov    %ecx,%eax
  804827:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80482a:	5b                   	pop    %ebx
  80482b:	5e                   	pop    %esi
  80482c:	5d                   	pop    %ebp
  80482d:	c3                   	ret    
    LWIP_ASSERT("bad pbuf type", 0);
  80482e:	83 ec 04             	sub    $0x4,%esp
  804831:	68 d7 16 81 00       	push   $0x8116d7
  804836:	68 9a 01 00 00       	push   $0x19a
  80483b:	68 a4 16 81 00       	push   $0x8116a4
  804840:	e8 91 9c 00 00       	call   80e4d6 <_panic>
    return 0;
  804845:	b9 00 00 00 00       	mov    $0x0,%ecx
  80484a:	eb d9                	jmp    804825 <pbuf_header+0xa8>

0080484c <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80484c:	55                   	push   %ebp
  80484d:	89 e5                	mov    %esp,%ebp
  80484f:	56                   	push   %esi
  804850:	53                   	push   %ebx
  804851:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804854:	85 c0                	test   %eax,%eax
  804856:	74 0d                	je     804865 <pbuf_free+0x19>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804858:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  80485c:	77 1e                	ja     80487c <pbuf_free+0x30>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80485e:	bb 00 00 00 00       	mov    $0x0,%ebx
  804863:	eb 6c                	jmp    8048d1 <pbuf_free+0x85>
    LWIP_ASSERT("p != NULL", p != NULL);
  804865:	83 ec 04             	sub    $0x4,%esp
  804868:	68 68 17 81 00       	push   $0x811768
  80486d:	68 d0 01 00 00       	push   $0x1d0
  804872:	68 a4 16 81 00       	push   $0x8116a4
  804877:	e8 5a 9c 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("pbuf_free: sane type",
  80487c:	83 ec 04             	sub    $0x4,%esp
  80487f:	68 e5 16 81 00       	push   $0x8116e5
  804884:	68 d9 01 00 00       	push   $0x1d9
  804889:	68 a4 16 81 00       	push   $0x8116a4
  80488e:	e8 43 9c 00 00       	call   80e4d6 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804893:	83 ec 04             	sub    $0x4,%esp
  804896:	68 fa 16 81 00       	push   $0x8116fa
  80489b:	68 e8 01 00 00       	push   $0x1e8
  8048a0:	68 a4 16 81 00       	push   $0x8116a4
  8048a5:	e8 2c 9c 00 00       	call   80e4d6 <_panic>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
  8048aa:	83 ec 08             	sub    $0x8,%esp
  8048ad:	50                   	push   %eax
  8048ae:	6a 0d                	push   $0xd
  8048b0:	e8 46 fc ff ff       	call   8044fb <memp_free>
  8048b5:	83 c4 10             	add    $0x10,%esp
  8048b8:	eb 0e                	jmp    8048c8 <pbuf_free+0x7c>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
        memp_free(MEMP_PBUF, p);
  8048ba:	83 ec 08             	sub    $0x8,%esp
  8048bd:	50                   	push   %eax
  8048be:	6a 0c                	push   $0xc
  8048c0:	e8 36 fc ff ff       	call   8044fb <memp_free>
  8048c5:	83 c4 10             	add    $0x10,%esp
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
      }
      count++;
  8048c8:	83 c3 01             	add    $0x1,%ebx
  while (p != NULL) {
  8048cb:	85 f6                	test   %esi,%esi
  8048cd:	74 3a                	je     804909 <pbuf_free+0xbd>
      /* proceed to next pbuf */
      p = q;
  8048cf:	89 f0                	mov    %esi,%eax
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  8048d1:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  8048d5:	66 85 d2             	test   %dx,%dx
  8048d8:	74 b9                	je     804893 <pbuf_free+0x47>
    ref = --(p->ref);
  8048da:	83 ea 01             	sub    $0x1,%edx
  8048dd:	66 89 50 0e          	mov    %dx,0xe(%eax)
    if (ref == 0) {
  8048e1:	66 85 d2             	test   %dx,%dx
  8048e4:	75 23                	jne    804909 <pbuf_free+0xbd>
      q = p->next;
  8048e6:	8b 30                	mov    (%eax),%esi
      type = p->type;
  8048e8:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      if (type == PBUF_POOL) {
  8048ec:	66 83 fa 03          	cmp    $0x3,%dx
  8048f0:	74 b8                	je     8048aa <pbuf_free+0x5e>
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  8048f2:	83 ea 01             	sub    $0x1,%edx
  8048f5:	66 83 fa 01          	cmp    $0x1,%dx
  8048f9:	76 bf                	jbe    8048ba <pbuf_free+0x6e>
        mem_free(p);
  8048fb:	83 ec 0c             	sub    $0xc,%esp
  8048fe:	50                   	push   %eax
  8048ff:	e8 5e f6 ff ff       	call   803f62 <mem_free>
  804904:	83 c4 10             	add    $0x10,%esp
  804907:	eb bf                	jmp    8048c8 <pbuf_free+0x7c>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  804909:	89 d8                	mov    %ebx,%eax
  80490b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80490e:	5b                   	pop    %ebx
  80490f:	5e                   	pop    %esi
  804910:	5d                   	pop    %ebp
  804911:	c3                   	ret    

00804912 <pbuf_alloc>:
{
  804912:	55                   	push   %ebp
  804913:	89 e5                	mov    %esp,%ebp
  804915:	57                   	push   %edi
  804916:	56                   	push   %esi
  804917:	53                   	push   %ebx
  804918:	83 ec 1c             	sub    $0x1c,%esp
  80491b:	8b 45 08             	mov    0x8(%ebp),%eax
  80491e:	8b 75 0c             	mov    0xc(%ebp),%esi
  804921:	8b 5d 10             	mov    0x10(%ebp),%ebx
  switch (layer) {
  804924:	83 f8 02             	cmp    $0x2,%eax
  804927:	0f 84 88 00 00 00    	je     8049b5 <pbuf_alloc+0xa3>
  80492d:	83 f8 02             	cmp    $0x2,%eax
  804930:	77 14                	ja     804946 <pbuf_alloc+0x34>
  offset = 0;
  804932:	83 f8 01             	cmp    $0x1,%eax
  804935:	19 c0                	sbb    %eax,%eax
  804937:	83 e0 14             	and    $0x14,%eax
    offset += PBUF_IP_HLEN;
  80493a:	83 c0 14             	add    $0x14,%eax
    offset += PBUF_LINK_HLEN;
  80493d:	83 c0 0e             	add    $0xe,%eax
  804940:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    break;
  804944:	eb 0b                	jmp    804951 <pbuf_alloc+0x3f>
  switch (layer) {
  804946:	83 f8 03             	cmp    $0x3,%eax
  804949:	75 71                	jne    8049bc <pbuf_alloc+0xaa>
  80494b:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  switch (type) {
  804951:	83 fb 02             	cmp    $0x2,%ebx
  804954:	77 7d                	ja     8049d3 <pbuf_alloc+0xc1>
  804956:	85 db                	test   %ebx,%ebx
  804958:	0f 85 c8 01 00 00    	jne    804b26 <pbuf_alloc+0x214>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  80495e:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  804962:	83 ec 0c             	sub    $0xc,%esp
  804965:	8d 43 13             	lea    0x13(%ebx),%eax
  804968:	83 e0 fc             	and    $0xfffffffc,%eax
  80496b:	0f b7 d6             	movzwl %si,%edx
  80496e:	83 c2 03             	add    $0x3,%edx
  804971:	83 e2 fc             	and    $0xfffffffc,%edx
  804974:	01 d0                	add    %edx,%eax
  804976:	50                   	push   %eax
  804977:	e8 d5 f8 ff ff       	call   804251 <mem_malloc>
  80497c:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  80497e:	83 c4 10             	add    $0x10,%esp
  804981:	85 c0                	test   %eax,%eax
  804983:	74 26                	je     8049ab <pbuf_alloc+0x99>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  804985:	8d 44 18 13          	lea    0x13(%eax,%ebx,1),%eax
  804989:	83 e0 fc             	and    $0xfffffffc,%eax
  80498c:	89 47 04             	mov    %eax,0x4(%edi)
    p->len = p->tot_len = length;
  80498f:	66 89 77 08          	mov    %si,0x8(%edi)
  804993:	66 89 77 0a          	mov    %si,0xa(%edi)
    p->next = NULL;
  804997:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    p->type = type;
  80499d:	c6 47 0c 00          	movb   $0x0,0xc(%edi)
  p->ref = 1;
  8049a1:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
  p->flags = 0;
  8049a7:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
}
  8049ab:	89 f8                	mov    %edi,%eax
  8049ad:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8049b0:	5b                   	pop    %ebx
  8049b1:	5e                   	pop    %esi
  8049b2:	5f                   	pop    %edi
  8049b3:	5d                   	pop    %ebp
  8049b4:	c3                   	ret    
  switch (layer) {
  8049b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8049ba:	eb 81                	jmp    80493d <pbuf_alloc+0x2b>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  8049bc:	83 ec 04             	sub    $0x4,%esp
  8049bf:	68 10 17 81 00       	push   $0x811710
  8049c4:	68 8a 00 00 00       	push   $0x8a
  8049c9:	68 a4 16 81 00       	push   $0x8116a4
  8049ce:	e8 03 9b 00 00       	call   80e4d6 <_panic>
  switch (type) {
  8049d3:	83 fb 03             	cmp    $0x3,%ebx
  8049d6:	0f 85 7e 01 00 00    	jne    804b5a <pbuf_alloc+0x248>
      p = memp_malloc(MEMP_PBUF_POOL);
  8049dc:	83 ec 0c             	sub    $0xc,%esp
  8049df:	6a 0d                	push   $0xd
  8049e1:	e8 bf fa ff ff       	call   8044a5 <memp_malloc>
  8049e6:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  8049e8:	83 c4 10             	add    $0x10,%esp
  8049eb:	85 c0                	test   %eax,%eax
  8049ed:	74 bc                	je     8049ab <pbuf_alloc+0x99>
    p->type = type;
  8049ef:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  8049f3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  8049f9:	0f b7 4d e4          	movzwl -0x1c(%ebp),%ecx
  8049fd:	8d 41 10             	lea    0x10(%ecx),%eax
  804a00:	0f b7 c0             	movzwl %ax,%eax
  804a03:	8d 54 07 03          	lea    0x3(%edi,%eax,1),%edx
  804a07:	83 e2 fc             	and    $0xfffffffc,%edx
  804a0a:	89 57 04             	mov    %edx,0x4(%edi)
    p->tot_len = length;
  804a0d:	66 89 77 08          	mov    %si,0x8(%edi)
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804a11:	0f b7 f6             	movzwl %si,%esi
  804a14:	83 c1 03             	add    $0x3,%ecx
  804a17:	81 e1 fc ff 00 00    	and    $0xfffc,%ecx
  804a1d:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804a22:	29 c8                	sub    %ecx,%eax
  804a24:	39 f0                	cmp    %esi,%eax
  804a26:	0f 4f c6             	cmovg  %esi,%eax
  804a29:	66 89 47 0a          	mov    %ax,0xa(%edi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a2d:	8d 8f e0 07 00 00    	lea    0x7e0(%edi),%ecx
  804a33:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  804a36:	01 c2                	add    %eax,%edx
  804a38:	39 d1                	cmp    %edx,%ecx
  804a3a:	72 7b                	jb     804ab7 <pbuf_alloc+0x1a5>
    p->ref = 1;
  804a3c:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
    rem_len = length - p->len;
  804a42:	29 c6                	sub    %eax,%esi
    r = p;
  804a44:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    while (rem_len > 0) {
  804a47:	85 f6                	test   %esi,%esi
  804a49:	0f 8e 52 ff ff ff    	jle    8049a1 <pbuf_alloc+0x8f>
      q = memp_malloc(MEMP_PBUF_POOL);
  804a4f:	83 ec 0c             	sub    $0xc,%esp
  804a52:	6a 0d                	push   $0xd
  804a54:	e8 4c fa ff ff       	call   8044a5 <memp_malloc>
  804a59:	89 c3                	mov    %eax,%ebx
      if (q == NULL) {
  804a5b:	83 c4 10             	add    $0x10,%esp
  804a5e:	85 c0                	test   %eax,%eax
  804a60:	74 6c                	je     804ace <pbuf_alloc+0x1bc>
      q->type = type;
  804a62:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804a66:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804a6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      r->next = q;
  804a70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804a73:	89 18                	mov    %ebx,(%eax)
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804a75:	81 fe fe ff 00 00    	cmp    $0xfffe,%esi
  804a7b:	7f 64                	jg     804ae1 <pbuf_alloc+0x1cf>
      q->tot_len = (u16_t)rem_len;
  804a7d:	66 89 73 08          	mov    %si,0x8(%ebx)
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804a81:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804a86:	66 39 c6             	cmp    %ax,%si
  804a89:	0f 46 c6             	cmovbe %esi,%eax
  804a8c:	66 89 43 0a          	mov    %ax,0xa(%ebx)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804a90:	8d 53 10             	lea    0x10(%ebx),%edx
  804a93:	89 53 04             	mov    %edx,0x4(%ebx)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804a96:	f6 c2 03             	test   $0x3,%dl
  804a99:	75 5d                	jne    804af8 <pbuf_alloc+0x1e6>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a9b:	0f b7 57 0a          	movzwl 0xa(%edi),%edx
  804a9f:	03 57 04             	add    0x4(%edi),%edx
  804aa2:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  804aa5:	72 68                	jb     804b0f <pbuf_alloc+0x1fd>
      q->ref = 1;
  804aa7:	66 c7 43 0e 01 00    	movw   $0x1,0xe(%ebx)
      rem_len -= q->len;
  804aad:	0f b7 c0             	movzwl %ax,%eax
  804ab0:	29 c6                	sub    %eax,%esi
      r = q;
  804ab2:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  804ab5:	eb 90                	jmp    804a47 <pbuf_alloc+0x135>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804ab7:	83 ec 04             	sub    $0x4,%esp
  804aba:	68 28 18 81 00       	push   $0x811828
  804abf:	68 a1 00 00 00       	push   $0xa1
  804ac4:	68 a4 16 81 00       	push   $0x8116a4
  804ac9:	e8 08 9a 00 00       	call   80e4d6 <_panic>
        pbuf_free(p);
  804ace:	83 ec 0c             	sub    $0xc,%esp
  804ad1:	57                   	push   %edi
  804ad2:	e8 75 fd ff ff       	call   80484c <pbuf_free>
        return NULL;
  804ad7:	83 c4 10             	add    $0x10,%esp
  804ada:	89 df                	mov    %ebx,%edi
  804adc:	e9 ca fe ff ff       	jmp    8049ab <pbuf_alloc+0x99>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804ae1:	83 ec 04             	sub    $0x4,%esp
  804ae4:	68 2b 17 81 00       	push   $0x81172b
  804ae9:	68 bc 00 00 00       	push   $0xbc
  804aee:	68 a4 16 81 00       	push   $0x8116a4
  804af3:	e8 de 99 00 00       	call   80e4d6 <_panic>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804af8:	83 ec 04             	sub    $0x4,%esp
  804afb:	68 5c 18 81 00       	push   $0x81185c
  804b00:	68 c1 00 00 00       	push   $0xc1
  804b05:	68 a4 16 81 00       	push   $0x8116a4
  804b0a:	e8 c7 99 00 00       	call   80e4d6 <_panic>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804b0f:	83 ec 04             	sub    $0x4,%esp
  804b12:	68 28 18 81 00       	push   $0x811828
  804b17:	68 c3 00 00 00       	push   $0xc3
  804b1c:	68 a4 16 81 00       	push   $0x8116a4
  804b21:	e8 b0 99 00 00       	call   80e4d6 <_panic>
    p = memp_malloc(MEMP_PBUF);
  804b26:	83 ec 0c             	sub    $0xc,%esp
  804b29:	6a 0c                	push   $0xc
  804b2b:	e8 75 f9 ff ff       	call   8044a5 <memp_malloc>
  804b30:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804b32:	83 c4 10             	add    $0x10,%esp
  804b35:	85 c0                	test   %eax,%eax
  804b37:	0f 84 6e fe ff ff    	je     8049ab <pbuf_alloc+0x99>
    p->payload = NULL;
  804b3d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804b44:	66 89 70 08          	mov    %si,0x8(%eax)
  804b48:	66 89 70 0a          	mov    %si,0xa(%eax)
    p->next = NULL;
  804b4c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804b52:	88 58 0c             	mov    %bl,0xc(%eax)
    break;
  804b55:	e9 47 fe ff ff       	jmp    8049a1 <pbuf_alloc+0x8f>
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804b5a:	83 ec 04             	sub    $0x4,%esp
  804b5d:	68 3f 17 81 00       	push   $0x81173f
  804b62:	68 f1 00 00 00       	push   $0xf1
  804b67:	68 a4 16 81 00       	push   $0x8116a4
  804b6c:	e8 65 99 00 00       	call   80e4d6 <_panic>

00804b71 <pbuf_realloc>:
{
  804b71:	55                   	push   %ebp
  804b72:	89 e5                	mov    %esp,%ebp
  804b74:	57                   	push   %edi
  804b75:	56                   	push   %esi
  804b76:	53                   	push   %ebx
  804b77:	83 ec 0c             	sub    $0xc,%esp
  804b7a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804b7d:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804b80:	85 db                	test   %ebx,%ebx
  804b82:	74 53                	je     804bd7 <pbuf_realloc+0x66>
  804b84:	89 f2                	mov    %esi,%edx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804b86:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804b8a:	77 62                	ja     804bee <pbuf_realloc+0x7d>
  if (new_len >= p->tot_len) {
  804b8c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804b90:	66 39 f0             	cmp    %si,%ax
  804b93:	0f 86 ae 00 00 00    	jbe    804c47 <pbuf_realloc+0xd6>
  grow = new_len - p->tot_len;
  804b99:	0f b7 ce             	movzwl %si,%ecx
  804b9c:	0f b7 f8             	movzwl %ax,%edi
  804b9f:	29 f9                	sub    %edi,%ecx
    q->tot_len += (u16_t)grow;
  804ba1:	29 c2                	sub    %eax,%edx
  while (rem_len > q->len) {
  804ba3:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804ba7:	66 39 f0             	cmp    %si,%ax
  804baa:	73 70                	jae    804c1c <pbuf_realloc+0xab>
    rem_len -= q->len;
  804bac:	29 c6                	sub    %eax,%esi
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804bae:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804bb4:	7f 4f                	jg     804c05 <pbuf_realloc+0x94>
    q->tot_len += (u16_t)grow;
  804bb6:	66 01 53 08          	add    %dx,0x8(%ebx)
    q = q->next;
  804bba:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804bbc:	85 db                	test   %ebx,%ebx
  804bbe:	75 e3                	jne    804ba3 <pbuf_realloc+0x32>
  804bc0:	83 ec 04             	sub    $0x4,%esp
  804bc3:	68 9e 17 81 00       	push   $0x81179e
  804bc8:	68 2f 01 00 00       	push   $0x12f
  804bcd:	68 a4 16 81 00       	push   $0x8116a4
  804bd2:	e8 ff 98 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804bd7:	83 ec 04             	sub    $0x4,%esp
  804bda:	68 5a 17 81 00       	push   $0x81175a
  804bdf:	68 13 01 00 00       	push   $0x113
  804be4:	68 a4 16 81 00       	push   $0x8116a4
  804be9:	e8 e8 98 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804bee:	83 ec 04             	sub    $0x4,%esp
  804bf1:	68 72 17 81 00       	push   $0x811772
  804bf6:	68 14 01 00 00       	push   $0x114
  804bfb:	68 a4 16 81 00       	push   $0x8116a4
  804c00:	e8 d1 98 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804c05:	83 ec 04             	sub    $0x4,%esp
  804c08:	68 8d 17 81 00       	push   $0x81178d
  804c0d:	68 2b 01 00 00       	push   $0x12b
  804c12:	68 a4 16 81 00       	push   $0x8116a4
  804c17:	e8 ba 98 00 00       	call   80e4d6 <_panic>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804c1c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804c20:	75 05                	jne    804c27 <pbuf_realloc+0xb6>
  804c22:	66 39 f0             	cmp    %si,%ax
  804c25:	75 28                	jne    804c4f <pbuf_realloc+0xde>
  q->len = rem_len;
  804c27:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804c2b:	66 89 73 08          	mov    %si,0x8(%ebx)
  if (q->next != NULL) {
  804c2f:	8b 03                	mov    (%ebx),%eax
  804c31:	85 c0                	test   %eax,%eax
  804c33:	74 0c                	je     804c41 <pbuf_realloc+0xd0>
    pbuf_free(q->next);
  804c35:	83 ec 0c             	sub    $0xc,%esp
  804c38:	50                   	push   %eax
  804c39:	e8 0e fc ff ff       	call   80484c <pbuf_free>
  804c3e:	83 c4 10             	add    $0x10,%esp
  q->next = NULL;
  804c41:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  804c47:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804c4a:	5b                   	pop    %ebx
  804c4b:	5e                   	pop    %esi
  804c4c:	5f                   	pop    %edi
  804c4d:	5d                   	pop    %ebp
  804c4e:	c3                   	ret    
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804c4f:	8b 43 04             	mov    0x4(%ebx),%eax
  804c52:	29 d8                	sub    %ebx,%eax
  804c54:	0f b7 d6             	movzwl %si,%edx
  804c57:	01 d0                	add    %edx,%eax
  804c59:	83 ec 08             	sub    $0x8,%esp
  804c5c:	50                   	push   %eax
  804c5d:	53                   	push   %ebx
  804c5e:	e8 96 f4 ff ff       	call   8040f9 <mem_realloc>
  804c63:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804c65:	83 c4 10             	add    $0x10,%esp
  804c68:	85 c0                	test   %eax,%eax
  804c6a:	75 bb                	jne    804c27 <pbuf_realloc+0xb6>
  804c6c:	83 ec 04             	sub    $0x4,%esp
  804c6f:	68 b6 17 81 00       	push   $0x8117b6
  804c74:	68 39 01 00 00       	push   $0x139
  804c79:	68 a4 16 81 00       	push   $0x8116a4
  804c7e:	e8 53 98 00 00       	call   80e4d6 <_panic>

00804c83 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804c83:	55                   	push   %ebp
  804c84:	89 e5                	mov    %esp,%ebp
  804c86:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t len;

  len = 0;
  804c89:	ba 00 00 00 00       	mov    $0x0,%edx
  while (p != NULL) {
  804c8e:	eb 05                	jmp    804c95 <pbuf_clen+0x12>
    ++len;
  804c90:	83 c2 01             	add    $0x1,%edx
    p = p->next;
  804c93:	8b 00                	mov    (%eax),%eax
  while (p != NULL) {
  804c95:	85 c0                	test   %eax,%eax
  804c97:	75 f7                	jne    804c90 <pbuf_clen+0xd>
  }
  return len;
}
  804c99:	89 d0                	mov    %edx,%eax
  804c9b:	5d                   	pop    %ebp
  804c9c:	c3                   	ret    

00804c9d <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804c9d:	55                   	push   %ebp
  804c9e:	89 e5                	mov    %esp,%ebp
  804ca0:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804ca3:	85 c0                	test   %eax,%eax
  804ca5:	74 05                	je     804cac <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804ca7:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804cac:	5d                   	pop    %ebp
  804cad:	c3                   	ret    

00804cae <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804cae:	55                   	push   %ebp
  804caf:	89 e5                	mov    %esp,%ebp
  804cb1:	53                   	push   %ebx
  804cb2:	83 ec 04             	sub    $0x4,%esp
  804cb5:	8b 45 08             	mov    0x8(%ebp),%eax
  804cb8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804cbb:	85 c0                	test   %eax,%eax
  804cbd:	74 04                	je     804cc3 <pbuf_cat+0x15>
  804cbf:	85 db                	test   %ebx,%ebx
  804cc1:	75 21                	jne    804ce4 <pbuf_cat+0x36>
  804cc3:	83 ec 04             	sub    $0x4,%esp
  804cc6:	68 8c 18 81 00       	push   $0x81188c
  804ccb:	68 41 02 00 00       	push   $0x241
  804cd0:	68 a4 16 81 00       	push   $0x8116a4
  804cd5:	e8 fc 97 00 00       	call   80e4d6 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804cda:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804cde:	66 01 48 08          	add    %cx,0x8(%eax)
  for (p = h; p->next != NULL; p = p->next) {
  804ce2:	89 d0                	mov    %edx,%eax
  804ce4:	8b 10                	mov    (%eax),%edx
  804ce6:	85 d2                	test   %edx,%edx
  804ce8:	75 f0                	jne    804cda <pbuf_cat+0x2c>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804cea:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804cee:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804cf2:	75 0f                	jne    804d03 <pbuf_cat+0x55>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804cf4:	66 03 53 08          	add    0x8(%ebx),%dx
  804cf8:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804cfc:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804cfe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804d01:	c9                   	leave  
  804d02:	c3                   	ret    
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804d03:	83 ec 04             	sub    $0x4,%esp
  804d06:	68 c4 18 81 00       	push   $0x8118c4
  804d0b:	68 4a 02 00 00       	push   $0x24a
  804d10:	68 a4 16 81 00       	push   $0x8116a4
  804d15:	e8 bc 97 00 00       	call   80e4d6 <_panic>

00804d1a <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804d1a:	55                   	push   %ebp
  804d1b:	89 e5                	mov    %esp,%ebp
  804d1d:	53                   	push   %ebx
  804d1e:	83 ec 0c             	sub    $0xc,%esp
  804d21:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804d24:	53                   	push   %ebx
  804d25:	ff 75 08             	push   0x8(%ebp)
  804d28:	e8 81 ff ff ff       	call   804cae <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804d2d:	89 1c 24             	mov    %ebx,(%esp)
  804d30:	e8 68 ff ff ff       	call   804c9d <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804d35:	83 c4 10             	add    $0x10,%esp
  804d38:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804d3b:	c9                   	leave  
  804d3c:	c3                   	ret    

00804d3d <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804d3d:	55                   	push   %ebp
  804d3e:	89 e5                	mov    %esp,%ebp
  804d40:	57                   	push   %edi
  804d41:	56                   	push   %esi
  804d42:	53                   	push   %ebx
  804d43:	83 ec 1c             	sub    $0x1c,%esp
  804d46:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804d49:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804d4b:	85 f6                	test   %esi,%esi
  804d4d:	74 71                	je     804dc0 <pbuf_dechain+0x83>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804d4f:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804d53:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804d57:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  804d5b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  804d5e:	0f b7 f8             	movzwl %ax,%edi
  804d61:	0f b7 d1             	movzwl %cx,%edx
  804d64:	29 d7                	sub    %edx,%edi
  804d66:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  804d69:	75 3e                	jne    804da9 <pbuf_dechain+0x6c>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804d6b:	29 c8                	sub    %ecx,%eax
  804d6d:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804d71:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804d77:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d7b:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804d7f:	83 ec 0c             	sub    $0xc,%esp
  804d82:	56                   	push   %esi
  804d83:	e8 c4 fa ff ff       	call   80484c <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804d88:	83 c4 10             	add    $0x10,%esp
  804d8b:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  804d8f:	66 39 7b 08          	cmp    %di,0x8(%ebx)
  804d93:	75 35                	jne    804dca <pbuf_dechain+0x8d>
  return ((tail_gone > 0) ? NULL : q);
  804d95:	84 c0                	test   %al,%al
  804d97:	b8 00 00 00 00       	mov    $0x0,%eax
  804d9c:	0f 45 f0             	cmovne %eax,%esi
}
  804d9f:	89 f0                	mov    %esi,%eax
  804da1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804da4:	5b                   	pop    %ebx
  804da5:	5e                   	pop    %esi
  804da6:	5f                   	pop    %edi
  804da7:	5d                   	pop    %ebp
  804da8:	c3                   	ret    
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804da9:	83 ec 04             	sub    $0x4,%esp
  804dac:	68 f4 18 81 00       	push   $0x8118f4
  804db1:	68 80 02 00 00       	push   $0x280
  804db6:	68 a4 16 81 00       	push   $0x8116a4
  804dbb:	e8 16 97 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804dc0:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804dc4:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804dc8:	74 d5                	je     804d9f <pbuf_dechain+0x62>
  804dca:	83 ec 04             	sub    $0x4,%esp
  804dcd:	68 d1 17 81 00       	push   $0x8117d1
  804dd2:	68 91 02 00 00       	push   $0x291
  804dd7:	68 a4 16 81 00       	push   $0x8116a4
  804ddc:	e8 f5 96 00 00       	call   80e4d6 <_panic>

00804de1 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804de1:	55                   	push   %ebp
  804de2:	89 e5                	mov    %esp,%ebp
  804de4:	57                   	push   %edi
  804de5:	56                   	push   %esi
  804de6:	53                   	push   %ebx
  804de7:	83 ec 1c             	sub    $0x1c,%esp
  804dea:	8b 7d 08             	mov    0x8(%ebp),%edi
  804ded:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804df0:	85 ff                	test   %edi,%edi
  804df2:	74 1e                	je     804e12 <pbuf_copy+0x31>
  804df4:	85 db                	test   %ebx,%ebx
  804df6:	74 1a                	je     804e12 <pbuf_copy+0x31>
  804df8:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804dfc:	66 39 47 08          	cmp    %ax,0x8(%edi)
  804e00:	72 10                	jb     804e12 <pbuf_copy+0x31>
  u16_t offset_to=0, offset_from=0, len;
  804e02:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804e08:	be 00 00 00 00       	mov    $0x0,%esi
  804e0d:	e9 83 00 00 00       	jmp    804e95 <pbuf_copy+0xb4>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804e12:	83 ec 04             	sub    $0x4,%esp
  804e15:	68 18 19 81 00       	push   $0x811918
  804e1a:	68 b0 02 00 00       	push   $0x2b0
  804e1f:	68 a4 16 81 00       	push   $0x8116a4
  804e24:	e8 ad 96 00 00       	call   80e4d6 <_panic>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804e29:	83 ec 04             	sub    $0x4,%esp
  804e2c:	68 e6 17 81 00       	push   $0x8117e6
  804e31:	68 c2 02 00 00       	push   $0x2c2
  804e36:	68 a4 16 81 00       	push   $0x8116a4
  804e3b:	e8 96 96 00 00       	call   80e4d6 <_panic>
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804e40:	8b 3f                	mov    (%edi),%edi
      offset_to = 0;
  804e42:	be 00 00 00 00       	mov    $0x0,%esi
  804e47:	e9 bb 00 00 00       	jmp    804f07 <pbuf_copy+0x126>
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804e4c:	83 ec 04             	sub    $0x4,%esp
  804e4f:	68 fd 17 81 00       	push   $0x8117fd
  804e54:	68 c8 02 00 00       	push   $0x2c8
  804e59:	68 a4 16 81 00       	push   $0x8116a4
  804e5e:	e8 73 96 00 00       	call   80e4d6 <_panic>
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  804e63:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804e69:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804e6d:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804e71:	0f 84 c1 00 00 00    	je     804f38 <pbuf_copy+0x157>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804e77:	85 ff                	test   %edi,%edi
  804e79:	0f 84 f9 00 00 00    	je     804f78 <pbuf_copy+0x197>
  804e7f:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  804e83:	66 39 47 0a          	cmp    %ax,0xa(%edi)
  804e87:	0f 84 cb 00 00 00    	je     804f58 <pbuf_copy+0x177>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804e8d:	85 db                	test   %ebx,%ebx
  804e8f:	0f 84 fa 00 00 00    	je     804f8f <pbuf_copy+0x1ae>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804e95:	0f b7 57 0a          	movzwl 0xa(%edi),%edx
  804e99:	0f b7 c6             	movzwl %si,%eax
  804e9c:	29 c2                	sub    %eax,%edx
  804e9e:	89 55 e0             	mov    %edx,-0x20(%ebp)
  804ea1:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  804ea5:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
  804ea9:	0f b7 c1             	movzwl %cx,%eax
  804eac:	29 c2                	sub    %eax,%edx
      len = p_from->len - offset_from;
  804eae:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804eb2:	29 c8                	sub    %ecx,%eax
  804eb4:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
  804eb8:	29 f1                	sub    %esi,%ecx
  804eba:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
  804ebe:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  804ec1:	89 c1                	mov    %eax,%ecx
  804ec3:	66 0f 4c 4d e4       	cmovl  -0x1c(%ebp),%cx
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804ec8:	83 ec 04             	sub    $0x4,%esp
  804ecb:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  804ecf:	0f b7 c1             	movzwl %cx,%eax
  804ed2:	50                   	push   %eax
  804ed3:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804ed7:	03 43 04             	add    0x4(%ebx),%eax
  804eda:	50                   	push   %eax
  804edb:	0f b7 c6             	movzwl %si,%eax
  804ede:	03 47 04             	add    0x4(%edi),%eax
  804ee1:	50                   	push   %eax
  804ee2:	e8 9c 9e 00 00       	call   80ed83 <memcpy>
    offset_to += len;
  804ee7:	0f b7 4d e0          	movzwl -0x20(%ebp),%ecx
  804eeb:	01 ce                	add    %ecx,%esi
    offset_from += len;
  804eed:	66 01 4d e6          	add    %cx,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804ef1:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
  804ef5:	83 c4 10             	add    $0x10,%esp
  804ef8:	66 39 f0             	cmp    %si,%ax
  804efb:	0f 82 28 ff ff ff    	jb     804e29 <pbuf_copy+0x48>
    if (offset_to == p_to->len) {
  804f01:	0f 84 39 ff ff ff    	je     804e40 <pbuf_copy+0x5f>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804f07:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804f0b:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804f0f:	0f 82 37 ff ff ff    	jb     804e4c <pbuf_copy+0x6b>
    if (offset_from >= p_from->len) {
  804f15:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804f19:	0f 85 4a ff ff ff    	jne    804e69 <pbuf_copy+0x88>
      p_from = p_from->next;
  804f1f:	8b 1b                	mov    (%ebx),%ebx
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804f21:	85 db                	test   %ebx,%ebx
  804f23:	0f 85 3a ff ff ff    	jne    804e63 <pbuf_copy+0x82>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804f29:	85 ff                	test   %edi,%edi
  804f2b:	74 62                	je     804f8f <pbuf_copy+0x1ae>
      offset_from = 0;
  804f2d:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804f33:	e9 47 ff ff ff       	jmp    804e7f <pbuf_copy+0x9e>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804f38:	83 3b 00             	cmpl   $0x0,(%ebx)
  804f3b:	0f 84 36 ff ff ff    	je     804e77 <pbuf_copy+0x96>
  804f41:	83 ec 04             	sub    $0x4,%esp
  804f44:	68 48 19 81 00       	push   $0x811948
  804f49:	68 d1 02 00 00       	push   $0x2d1
  804f4e:	68 a4 16 81 00       	push   $0x8116a4
  804f53:	e8 7e 95 00 00       	call   80e4d6 <_panic>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804f58:	83 3f 00             	cmpl   $0x0,(%edi)
  804f5b:	0f 84 2c ff ff ff    	je     804e8d <pbuf_copy+0xac>
  804f61:	83 ec 04             	sub    $0x4,%esp
  804f64:	68 48 19 81 00       	push   $0x811948
  804f69:	68 d6 02 00 00       	push   $0x2d6
  804f6e:	68 a4 16 81 00       	push   $0x8116a4
  804f73:	e8 5e 95 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  804f78:	83 ec 04             	sub    $0x4,%esp
  804f7b:	68 18 18 81 00       	push   $0x811818
  804f80:	68 b6 02 00 00       	push   $0x2b6
  804f85:	68 a4 16 81 00       	push   $0x8116a4
  804f8a:	e8 47 95 00 00       	call   80e4d6 <_panic>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  804f8f:	b8 00 00 00 00       	mov    $0x0,%eax
  804f94:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804f97:	5b                   	pop    %ebx
  804f98:	5e                   	pop    %esi
  804f99:	5f                   	pop    %edi
  804f9a:	5d                   	pop    %ebp
  804f9b:	c3                   	ret    

00804f9c <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  804f9c:	55                   	push   %ebp
  804f9d:	89 e5                	mov    %esp,%ebp
  804f9f:	57                   	push   %edi
  804fa0:	56                   	push   %esi
  804fa1:	53                   	push   %ebx
  804fa2:	83 ec 1c             	sub    $0x1c,%esp
  804fa5:	8b 75 08             	mov    0x8(%ebp),%esi
  804fa8:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  804fac:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804fb0:	85 f6                	test   %esi,%esi
  804fb2:	74 14                	je     804fc8 <pbuf_copy_partial+0x2c>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804fb4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  804fb8:	74 25                	je     804fdf <pbuf_copy_partial+0x43>
  u16_t copied_total = 0;
  804fba:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)

  left = 0;
  804fc0:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804fc6:	eb 69                	jmp    805031 <pbuf_copy_partial+0x95>
  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804fc8:	83 ec 04             	sub    $0x4,%esp
  804fcb:	68 74 19 81 00       	push   $0x811974
  804fd0:	68 ef 02 00 00       	push   $0x2ef
  804fd5:	68 a4 16 81 00       	push   $0x8116a4
  804fda:	e8 f7 94 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804fdf:	83 ec 04             	sub    $0x4,%esp
  804fe2:	68 98 19 81 00       	push   $0x811998
  804fe7:	68 f0 02 00 00       	push   $0x2f0
  804fec:	68 a4 16 81 00       	push   $0x8116a4
  804ff1:	e8 e0 94 00 00       	call   80e4d6 <_panic>
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  804ff6:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  804ffa:	29 c3                	sub    %eax,%ebx
  804ffc:	66 39 fb             	cmp    %di,%bx
  804fff:	0f 47 df             	cmova  %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  805002:	83 ec 04             	sub    $0x4,%esp
  805005:	0f b7 d3             	movzwl %bx,%edx
  805008:	52                   	push   %edx
  805009:	0f b7 c0             	movzwl %ax,%eax
  80500c:	03 46 04             	add    0x4(%esi),%eax
  80500f:	50                   	push   %eax
  805010:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805014:	03 45 0c             	add    0xc(%ebp),%eax
  805017:	50                   	push   %eax
  805018:	e8 66 9d 00 00       	call   80ed83 <memcpy>
      copied_total += buf_copy_len;
  80501d:	66 01 5d e4          	add    %bx,-0x1c(%ebp)
      left += buf_copy_len;
  805021:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      len -= buf_copy_len;
  805025:	29 df                	sub    %ebx,%edi
  805027:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  80502a:	b8 00 00 00 00       	mov    $0x0,%eax
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80502f:	8b 36                	mov    (%esi),%esi
  805031:	66 85 ff             	test   %di,%di
  805034:	74 16                	je     80504c <pbuf_copy_partial+0xb0>
  805036:	85 f6                	test   %esi,%esi
  805038:	74 12                	je     80504c <pbuf_copy_partial+0xb0>
    if ((offset != 0) && (offset >= p->len)) {
  80503a:	66 85 c0             	test   %ax,%ax
  80503d:	74 b7                	je     804ff6 <pbuf_copy_partial+0x5a>
  80503f:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  805043:	66 39 c2             	cmp    %ax,%dx
  805046:	77 ae                	ja     804ff6 <pbuf_copy_partial+0x5a>
      offset -= p->len;
  805048:	29 d0                	sub    %edx,%eax
  80504a:	eb e3                	jmp    80502f <pbuf_copy_partial+0x93>
    }
  }
  return copied_total;
}
  80504c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  805050:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805053:	5b                   	pop    %ebx
  805054:	5e                   	pop    %esi
  805055:	5f                   	pop    %edi
  805056:	5d                   	pop    %ebp
  805057:	c3                   	ret    

00805058 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805058:	55                   	push   %ebp
  805059:	89 e5                	mov    %esp,%ebp
  80505b:	83 ec 14             	sub    $0x14,%esp
  80505e:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  805061:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  805066:	8b 40 04             	mov    0x4(%eax),%eax
  805069:	ff 30                	push   (%eax)
  80506b:	e8 b1 4f 00 00       	call   80a021 <sys_sem_signal>
}
  805070:	83 c4 10             	add    $0x10,%esp
  805073:	c9                   	leave  
  805074:	c3                   	ret    

00805075 <sys_mbox_fetch>:
{
  805075:	55                   	push   %ebp
  805076:	89 e5                	mov    %esp,%ebp
  805078:	57                   	push   %edi
  805079:	56                   	push   %esi
  80507a:	53                   	push   %ebx
  80507b:	83 ec 0c             	sub    $0xc,%esp
  80507e:	8b 7d 0c             	mov    0xc(%ebp),%edi
  805081:	eb 40                	jmp    8050c3 <sys_mbox_fetch+0x4e>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  805083:	83 ec 04             	sub    $0x4,%esp
  805086:	6a 00                	push   $0x0
  805088:	57                   	push   %edi
  805089:	ff 75 08             	push   0x8(%ebp)
  80508c:	e8 28 52 00 00       	call   80a2b9 <sys_arch_mbox_fetch>
  805091:	83 c4 10             	add    $0x10,%esp
}
  805094:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805097:	5b                   	pop    %ebx
  805098:	5e                   	pop    %esi
  805099:	5f                   	pop    %edi
  80509a:	5d                   	pop    %ebp
  80509b:	c3                   	ret    
      tmptimeout = timeouts->next;
  80509c:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  80509e:	8b 10                	mov    (%eax),%edx
  8050a0:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8050a2:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8050a5:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8050a8:	83 ec 08             	sub    $0x8,%esp
  8050ab:	50                   	push   %eax
  8050ac:	6a 0b                	push   $0xb
  8050ae:	e8 48 f4 ff ff       	call   8044fb <memp_free>
      if (h != NULL) {
  8050b3:	83 c4 10             	add    $0x10,%esp
  8050b6:	85 db                	test   %ebx,%ebx
  8050b8:	74 09                	je     8050c3 <sys_mbox_fetch+0x4e>
        h(arg);
  8050ba:	83 ec 0c             	sub    $0xc,%esp
  8050bd:	56                   	push   %esi
  8050be:	ff d3                	call   *%ebx
  8050c0:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  8050c3:	e8 8f 53 00 00       	call   80a457 <sys_arch_timeouts>
  8050c8:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  8050ca:	85 c0                	test   %eax,%eax
  8050cc:	74 b5                	je     805083 <sys_mbox_fetch+0xe>
  8050ce:	8b 00                	mov    (%eax),%eax
  8050d0:	85 c0                	test   %eax,%eax
  8050d2:	74 af                	je     805083 <sys_mbox_fetch+0xe>
    if (timeouts->next->time > 0) {
  8050d4:	8b 40 04             	mov    0x4(%eax),%eax
  8050d7:	85 c0                	test   %eax,%eax
  8050d9:	74 c1                	je     80509c <sys_mbox_fetch+0x27>
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8050db:	83 ec 04             	sub    $0x4,%esp
  8050de:	50                   	push   %eax
  8050df:	57                   	push   %edi
  8050e0:	ff 75 08             	push   0x8(%ebp)
  8050e3:	e8 d1 51 00 00       	call   80a2b9 <sys_arch_mbox_fetch>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  8050e8:	83 c4 10             	add    $0x10,%esp
  8050eb:	83 f8 ff             	cmp    $0xffffffff,%eax
  8050ee:	74 ac                	je     80509c <sys_mbox_fetch+0x27>
      if (time_needed < timeouts->next->time) {
  8050f0:	8b 0b                	mov    (%ebx),%ecx
  8050f2:	8b 59 04             	mov    0x4(%ecx),%ebx
        timeouts->next->time -= time_needed;
  8050f5:	89 da                	mov    %ebx,%edx
  8050f7:	29 c2                	sub    %eax,%edx
  8050f9:	39 c3                	cmp    %eax,%ebx
  8050fb:	b8 00 00 00 00       	mov    $0x0,%eax
  805100:	0f 47 c2             	cmova  %edx,%eax
  805103:	89 41 04             	mov    %eax,0x4(%ecx)
  805106:	eb 8c                	jmp    805094 <sys_mbox_fetch+0x1f>

00805108 <sys_sem_wait>:
{
  805108:	55                   	push   %ebp
  805109:	89 e5                	mov    %esp,%ebp
  80510b:	57                   	push   %edi
  80510c:	56                   	push   %esi
  80510d:	53                   	push   %ebx
  80510e:	83 ec 0c             	sub    $0xc,%esp
  805111:	8b 75 08             	mov    0x8(%ebp),%esi
  805114:	eb 3d                	jmp    805153 <sys_sem_wait+0x4b>
    sys_arch_sem_wait(sem, 0);
  805116:	83 ec 08             	sub    $0x8,%esp
  805119:	6a 00                	push   $0x0
  80511b:	56                   	push   %esi
  80511c:	e8 70 4f 00 00       	call   80a091 <sys_arch_sem_wait>
  805121:	83 c4 10             	add    $0x10,%esp
}
  805124:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805127:	5b                   	pop    %ebx
  805128:	5e                   	pop    %esi
  805129:	5f                   	pop    %edi
  80512a:	5d                   	pop    %ebp
  80512b:	c3                   	ret    
      tmptimeout = timeouts->next;
  80512c:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  80512e:	8b 10                	mov    (%eax),%edx
  805130:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  805132:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805135:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805138:	83 ec 08             	sub    $0x8,%esp
  80513b:	50                   	push   %eax
  80513c:	6a 0b                	push   $0xb
  80513e:	e8 b8 f3 ff ff       	call   8044fb <memp_free>
      if (h != NULL) {
  805143:	83 c4 10             	add    $0x10,%esp
  805146:	85 db                	test   %ebx,%ebx
  805148:	74 09                	je     805153 <sys_sem_wait+0x4b>
        h(arg);
  80514a:	83 ec 0c             	sub    $0xc,%esp
  80514d:	57                   	push   %edi
  80514e:	ff d3                	call   *%ebx
  805150:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  805153:	e8 ff 52 00 00       	call   80a457 <sys_arch_timeouts>
  805158:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  80515a:	85 c0                	test   %eax,%eax
  80515c:	74 b8                	je     805116 <sys_sem_wait+0xe>
  80515e:	8b 00                	mov    (%eax),%eax
  805160:	85 c0                	test   %eax,%eax
  805162:	74 b2                	je     805116 <sys_sem_wait+0xe>
    if (timeouts->next->time > 0) {
  805164:	8b 40 04             	mov    0x4(%eax),%eax
  805167:	85 c0                	test   %eax,%eax
  805169:	74 c1                	je     80512c <sys_sem_wait+0x24>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80516b:	83 ec 08             	sub    $0x8,%esp
  80516e:	50                   	push   %eax
  80516f:	56                   	push   %esi
  805170:	e8 1c 4f 00 00       	call   80a091 <sys_arch_sem_wait>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  805175:	83 c4 10             	add    $0x10,%esp
  805178:	83 f8 ff             	cmp    $0xffffffff,%eax
  80517b:	74 af                	je     80512c <sys_sem_wait+0x24>
      if (time_needed < timeouts->next->time) {
  80517d:	8b 0b                	mov    (%ebx),%ecx
  80517f:	8b 59 04             	mov    0x4(%ecx),%ebx
        timeouts->next->time -= time_needed;
  805182:	89 da                	mov    %ebx,%edx
  805184:	29 c2                	sub    %eax,%edx
  805186:	39 c3                	cmp    %eax,%ebx
  805188:	b8 00 00 00 00       	mov    $0x0,%eax
  80518d:	0f 47 c2             	cmova  %edx,%eax
  805190:	89 41 04             	mov    %eax,0x4(%ecx)
  805193:	eb 8f                	jmp    805124 <sys_sem_wait+0x1c>

00805195 <sys_timeout>:
{
  805195:	55                   	push   %ebp
  805196:	89 e5                	mov    %esp,%ebp
  805198:	57                   	push   %edi
  805199:	56                   	push   %esi
  80519a:	53                   	push   %ebx
  80519b:	83 ec 28             	sub    $0x28,%esp
  80519e:	8b 75 08             	mov    0x8(%ebp),%esi
  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8051a1:	6a 0b                	push   $0xb
  8051a3:	e8 fd f2 ff ff       	call   8044a5 <memp_malloc>
  if (timeout == NULL) {
  8051a8:	83 c4 10             	add    $0x10,%esp
  8051ab:	85 c0                	test   %eax,%eax
  8051ad:	74 42                	je     8051f1 <sys_timeout+0x5c>
  8051af:	89 c3                	mov    %eax,%ebx
  timeout->next = NULL;
  8051b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8051b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8051ba:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8051bd:	8b 45 10             	mov    0x10(%ebp),%eax
  8051c0:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8051c3:	89 73 04             	mov    %esi,0x4(%ebx)
  timeouts = sys_arch_timeouts();
  8051c6:	e8 8c 52 00 00       	call   80a457 <sys_arch_timeouts>
  8051cb:	89 c2                	mov    %eax,%edx
  if (timeouts == NULL) {
  8051cd:	85 c0                	test   %eax,%eax
  8051cf:	74 37                	je     805208 <sys_timeout+0x73>
  if (timeouts->next == NULL) {
  8051d1:	8b 00                	mov    (%eax),%eax
  8051d3:	85 c0                	test   %eax,%eax
  8051d5:	74 48                	je     80521f <sys_timeout+0x8a>
  if (timeouts->next->time > msecs) {
  8051d7:	8b 48 04             	mov    0x4(%eax),%ecx
  8051da:	39 f1                	cmp    %esi,%ecx
  8051dc:	76 45                	jbe    805223 <sys_timeout+0x8e>
    timeouts->next->time -= msecs;
  8051de:	29 f1                	sub    %esi,%ecx
  8051e0:	89 48 04             	mov    %ecx,0x4(%eax)
    timeout->next = timeouts->next;
  8051e3:	8b 02                	mov    (%edx),%eax
  8051e5:	89 03                	mov    %eax,(%ebx)
    timeouts->next = timeout;
  8051e7:	89 1a                	mov    %ebx,(%edx)
}
  8051e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8051ec:	5b                   	pop    %ebx
  8051ed:	5e                   	pop    %esi
  8051ee:	5f                   	pop    %edi
  8051ef:	5d                   	pop    %ebp
  8051f0:	c3                   	ret    
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  8051f1:	83 ec 04             	sub    $0x4,%esp
  8051f4:	68 bd 19 81 00       	push   $0x8119bd
  8051f9:	68 c3 00 00 00       	push   $0xc3
  8051fe:	68 da 19 81 00       	push   $0x8119da
  805203:	e8 ce 92 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  805208:	83 ec 04             	sub    $0x4,%esp
  80520b:	68 ee 19 81 00       	push   $0x8119ee
  805210:	68 d1 00 00 00       	push   $0xd1
  805215:	68 da 19 81 00       	push   $0x8119da
  80521a:	e8 b7 92 00 00       	call   80e4d6 <_panic>
    timeouts->next = timeout;
  80521f:	89 1a                	mov    %ebx,(%edx)
    return;
  805221:	eb c6                	jmp    8051e9 <sys_timeout+0x54>
      timeout->time -= t->time;
  805223:	8b 73 04             	mov    0x4(%ebx),%esi
  805226:	8b 48 04             	mov    0x4(%eax),%ecx
  805229:	89 f2                	mov    %esi,%edx
  80522b:	29 ca                	sub    %ecx,%edx
  80522d:	89 53 04             	mov    %edx,0x4(%ebx)
  805230:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if (t->next == NULL || t->next->time > timeout->time) {
  805233:	8b 00                	mov    (%eax),%eax
  805235:	85 c0                	test   %eax,%eax
  805237:	74 0e                	je     805247 <sys_timeout+0xb2>
  805239:	8b 78 04             	mov    0x4(%eax),%edi
  80523c:	39 fa                	cmp    %edi,%edx
  80523e:	73 e3                	jae    805223 <sys_timeout+0x8e>
          t->next->time -= timeout->time;
  805240:	29 f1                	sub    %esi,%ecx
  805242:	01 f9                	add    %edi,%ecx
  805244:	89 48 04             	mov    %ecx,0x4(%eax)
        timeout->next = t->next;
  805247:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80524a:	8b 07                	mov    (%edi),%eax
  80524c:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  80524e:	89 1f                	mov    %ebx,(%edi)
        break;
  805250:	eb 97                	jmp    8051e9 <sys_timeout+0x54>

00805252 <sys_untimeout>:
{
  805252:	55                   	push   %ebp
  805253:	89 e5                	mov    %esp,%ebp
  805255:	57                   	push   %edi
  805256:	56                   	push   %esi
  805257:	53                   	push   %ebx
  805258:	83 ec 0c             	sub    $0xc,%esp
  80525b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80525e:	8b 75 0c             	mov    0xc(%ebp),%esi
  timeouts = sys_arch_timeouts();
  805261:	e8 f1 51 00 00       	call   80a457 <sys_arch_timeouts>
  if (timeouts == NULL) {
  805266:	85 c0                	test   %eax,%eax
  805268:	74 0f                	je     805279 <sys_untimeout+0x27>
  80526a:	89 c7                	mov    %eax,%edi
  if (timeouts->next == NULL) {
  80526c:	8b 00                	mov    (%eax),%eax
  80526e:	85 c0                	test   %eax,%eax
  805270:	74 5a                	je     8052cc <sys_untimeout+0x7a>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805272:	b9 00 00 00 00       	mov    $0x0,%ecx
  805277:	eb 27                	jmp    8052a0 <sys_untimeout+0x4e>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  805279:	83 ec 04             	sub    $0x4,%esp
  80527c:	68 0c 1a 81 00       	push   $0x811a0c
  805281:	68 00 01 00 00       	push   $0x100
  805286:	68 da 19 81 00       	push   $0x8119da
  80528b:	e8 46 92 00 00       	call   80e4d6 <_panic>
        timeouts->next = t->next;
  805290:	8b 10                	mov    (%eax),%edx
  805292:	89 17                	mov    %edx,(%edi)
  805294:	eb 1c                	jmp    8052b2 <sys_untimeout+0x60>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805296:	8b 10                	mov    (%eax),%edx
  805298:	89 c1                	mov    %eax,%ecx
  80529a:	85 d2                	test   %edx,%edx
  80529c:	74 2e                	je     8052cc <sys_untimeout+0x7a>
  80529e:	89 d0                	mov    %edx,%eax
    if ((t->h == h) && (t->arg == arg)) {
  8052a0:	39 58 08             	cmp    %ebx,0x8(%eax)
  8052a3:	75 f1                	jne    805296 <sys_untimeout+0x44>
  8052a5:	39 70 0c             	cmp    %esi,0xc(%eax)
  8052a8:	75 ec                	jne    805296 <sys_untimeout+0x44>
      if (prev_t == NULL)
  8052aa:	85 c9                	test   %ecx,%ecx
  8052ac:	74 e2                	je     805290 <sys_untimeout+0x3e>
        prev_t->next = t->next;
  8052ae:	8b 10                	mov    (%eax),%edx
  8052b0:	89 11                	mov    %edx,(%ecx)
      if (t->next != NULL)
  8052b2:	8b 10                	mov    (%eax),%edx
  8052b4:	85 d2                	test   %edx,%edx
  8052b6:	74 06                	je     8052be <sys_untimeout+0x6c>
        t->next->time += t->time;
  8052b8:	8b 48 04             	mov    0x4(%eax),%ecx
  8052bb:	01 4a 04             	add    %ecx,0x4(%edx)
      memp_free(MEMP_SYS_TIMEOUT, t);
  8052be:	83 ec 08             	sub    $0x8,%esp
  8052c1:	50                   	push   %eax
  8052c2:	6a 0b                	push   $0xb
  8052c4:	e8 32 f2 ff ff       	call   8044fb <memp_free>
      return;
  8052c9:	83 c4 10             	add    $0x10,%esp
}
  8052cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8052cf:	5b                   	pop    %ebx
  8052d0:	5e                   	pop    %esi
  8052d1:	5f                   	pop    %edi
  8052d2:	5d                   	pop    %ebp
  8052d3:	c3                   	ret    

008052d4 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8052d4:	55                   	push   %ebp
  8052d5:	89 e5                	mov    %esp,%ebp
  8052d7:	83 ec 18             	sub    $0x18,%esp
  8052da:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8052dd:	8d 4d 08             	lea    0x8(%ebp),%ecx
  8052e0:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8052e3:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8052e9:	85 c0                	test   %eax,%eax
  8052eb:	75 1c                	jne    805309 <sys_sem_wait_timeout+0x35>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  8052ed:	83 ec 0c             	sub    $0xc,%esp
  8052f0:	ff 75 08             	push   0x8(%ebp)
  8052f3:	e8 10 fe ff ff       	call   805108 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8052f8:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  8052fb:	b8 00 00 00 00       	mov    $0x0,%eax
  if (sswt_cb.timeflag) {
  805300:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  805305:	74 19                	je     805320 <sys_sem_wait_timeout+0x4c>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  805307:	c9                   	leave  
  805308:	c3                   	ret    
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  805309:	83 ec 04             	sub    $0x4,%esp
  80530c:	8d 55 f0             	lea    -0x10(%ebp),%edx
  80530f:	52                   	push   %edx
  805310:	68 58 50 80 00       	push   $0x805058
  805315:	50                   	push   %eax
  805316:	e8 7a fe ff ff       	call   805195 <sys_timeout>
  80531b:	83 c4 10             	add    $0x10,%esp
  80531e:	eb cd                	jmp    8052ed <sys_sem_wait_timeout+0x19>
    sys_untimeout(sswt_handler, &sswt_cb);
  805320:	83 ec 08             	sub    $0x8,%esp
  805323:	8d 45 f0             	lea    -0x10(%ebp),%eax
  805326:	50                   	push   %eax
  805327:	68 58 50 80 00       	push   $0x805058
  80532c:	e8 21 ff ff ff       	call   805252 <sys_untimeout>
    return 1;
  805331:	83 c4 10             	add    $0x10,%esp
  805334:	b8 01 00 00 00       	mov    $0x1,%eax
  805339:	eb cc                	jmp    805307 <sys_sem_wait_timeout+0x33>

0080533b <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80533b:	55                   	push   %ebp
  80533c:	89 e5                	mov    %esp,%ebp
  80533e:	53                   	push   %ebx
  80533f:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  805342:	6a 00                	push   $0x0
  805344:	e8 1b 4a 00 00       	call   809d64 <sys_sem_new>
  805349:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  80534b:	83 c4 08             	add    $0x8,%esp
  80534e:	ff 75 08             	push   0x8(%ebp)
  805351:	50                   	push   %eax
  805352:	e8 7d ff ff ff       	call   8052d4 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  805357:	89 1c 24             	mov    %ebx,(%esp)
  80535a:	e8 86 4a 00 00       	call   809de5 <sys_sem_free>
}
  80535f:	83 c4 10             	add    $0x10,%esp
  805362:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805365:	c9                   	leave  
  805366:	c3                   	ret    

00805367 <tcp_accept_null>:
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805367:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80536c:	c3                   	ret    

0080536d <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80536d:	55                   	push   %ebp
  80536e:	89 e5                	mov    %esp,%ebp
  805370:	57                   	push   %edi
  805371:	56                   	push   %esi
  805372:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805373:	8b 1d 4c 44 b3 00    	mov    0xb3444c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805379:	8b 35 48 44 b3 00    	mov    0xb34448,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80537f:	8b 3d 50 44 b3 00    	mov    0xb34450,%edi
  805385:	0f b7 15 0c 40 81 00 	movzwl 0x81400c,%edx
    port = TCP_LOCAL_PORT_RANGE_START;
  80538c:	b9 00 10 00 00       	mov    $0x1000,%ecx
  805391:	66 83 c2 01          	add    $0x1,%dx
  805395:	0f 48 d1             	cmovs  %ecx,%edx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805398:	89 d8                	mov    %ebx,%eax
  80539a:	85 c0                	test   %eax,%eax
  80539c:	74 0b                	je     8053a9 <tcp_new_port+0x3c>
    if (pcb->local_port == port) {
  80539e:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8053a2:	74 ed                	je     805391 <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8053a4:	8b 40 0c             	mov    0xc(%eax),%eax
  8053a7:	eb f1                	jmp    80539a <tcp_new_port+0x2d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8053a9:	89 f0                	mov    %esi,%eax
  8053ab:	85 c0                	test   %eax,%eax
  8053ad:	74 0b                	je     8053ba <tcp_new_port+0x4d>
    if (pcb->local_port == port) {
  8053af:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8053b3:	74 dc                	je     805391 <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8053b5:	8b 40 0c             	mov    0xc(%eax),%eax
  8053b8:	eb f1                	jmp    8053ab <tcp_new_port+0x3e>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8053ba:	89 f8                	mov    %edi,%eax
  8053bc:	eb 03                	jmp    8053c1 <tcp_new_port+0x54>
  8053be:	8b 40 0c             	mov    0xc(%eax),%eax
  8053c1:	85 c0                	test   %eax,%eax
  8053c3:	74 08                	je     8053cd <tcp_new_port+0x60>
    if (pcb->local_port == port) {
  8053c5:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8053c9:	75 f3                	jne    8053be <tcp_new_port+0x51>
  8053cb:	eb c4                	jmp    805391 <tcp_new_port+0x24>
  8053cd:	66 89 15 0c 40 81 00 	mov    %dx,0x81400c
      goto again;
    }
  }
  return port;
}
  8053d4:	89 d0                	mov    %edx,%eax
  8053d6:	5b                   	pop    %ebx
  8053d7:	5e                   	pop    %esi
  8053d8:	5f                   	pop    %edi
  8053d9:	5d                   	pop    %ebp
  8053da:	c3                   	ret    

008053db <tcp_bind>:
{
  8053db:	55                   	push   %ebp
  8053dc:	89 e5                	mov    %esp,%ebp
  8053de:	57                   	push   %edi
  8053df:	56                   	push   %esi
  8053e0:	53                   	push   %ebx
  8053e1:	83 ec 0c             	sub    $0xc,%esp
  8053e4:	8b 75 08             	mov    0x8(%ebp),%esi
  8053e7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8053ea:	8b 45 10             	mov    0x10(%ebp),%eax
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8053ed:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  8053f1:	75 0e                	jne    805401 <tcp_bind+0x26>
  8053f3:	89 c2                	mov    %eax,%edx
  if (port == 0) {
  8053f5:	66 85 c0             	test   %ax,%ax
  8053f8:	74 1e                	je     805418 <tcp_bind+0x3d>
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8053fa:	a1 50 44 b3 00       	mov    0xb34450,%eax
  8053ff:	eb 23                	jmp    805424 <tcp_bind+0x49>
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805401:	83 ec 04             	sub    $0x4,%esp
  805404:	68 2c 1a 81 00       	push   $0x811a2c
  805409:	68 05 01 00 00       	push   $0x105
  80540e:	68 0e 1c 81 00       	push   $0x811c0e
  805413:	e8 be 90 00 00       	call   80e4d6 <_panic>
    port = tcp_new_port();
  805418:	e8 50 ff ff ff       	call   80536d <tcp_new_port>
  80541d:	89 c2                	mov    %eax,%edx
  80541f:	eb d9                	jmp    8053fa <tcp_bind+0x1f>
      cpcb != NULL; cpcb = cpcb->next) {
  805421:	8b 40 0c             	mov    0xc(%eax),%eax
  805424:	85 c0                	test   %eax,%eax
  805426:	74 2c                	je     805454 <tcp_bind+0x79>
    if (cpcb->local_port == port) {
  805428:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  80542c:	75 f3                	jne    805421 <tcp_bind+0x46>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80542e:	8b 08                	mov    (%eax),%ecx
  805430:	85 db                	test   %ebx,%ebx
  805432:	0f 84 d1 00 00 00    	je     805509 <tcp_bind+0x12e>
  805438:	85 c9                	test   %ecx,%ecx
  80543a:	0f 84 c9 00 00 00    	je     805509 <tcp_bind+0x12e>
          ip_addr_isany(ipaddr) ||
  805440:	8b 3b                	mov    (%ebx),%edi
  805442:	39 f9                	cmp    %edi,%ecx
  805444:	74 04                	je     80544a <tcp_bind+0x6f>
  805446:	85 ff                	test   %edi,%edi
  805448:	75 d7                	jne    805421 <tcp_bind+0x46>
        return ERR_USE;
  80544a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80544f:	e9 ba 00 00 00       	jmp    80550e <tcp_bind+0x133>
  for(cpcb = tcp_active_pcbs;
  805454:	a1 4c 44 b3 00       	mov    0xb3444c,%eax
  805459:	eb 03                	jmp    80545e <tcp_bind+0x83>
      cpcb != NULL; cpcb = cpcb->next) {
  80545b:	8b 40 0c             	mov    0xc(%eax),%eax
  80545e:	85 c0                	test   %eax,%eax
  805460:	74 2c                	je     80548e <tcp_bind+0xb3>
    if (cpcb->local_port == port) {
  805462:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  805466:	75 f3                	jne    80545b <tcp_bind+0x80>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805468:	8b 08                	mov    (%eax),%ecx
  80546a:	85 db                	test   %ebx,%ebx
  80546c:	0f 84 a4 00 00 00    	je     805516 <tcp_bind+0x13b>
  805472:	85 c9                	test   %ecx,%ecx
  805474:	0f 84 9c 00 00 00    	je     805516 <tcp_bind+0x13b>
          ip_addr_isany(ipaddr) ||
  80547a:	8b 3b                	mov    (%ebx),%edi
  80547c:	39 f9                	cmp    %edi,%ecx
  80547e:	74 04                	je     805484 <tcp_bind+0xa9>
  805480:	85 ff                	test   %edi,%edi
  805482:	75 d7                	jne    80545b <tcp_bind+0x80>
        return ERR_USE;
  805484:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805489:	e9 80 00 00 00       	jmp    80550e <tcp_bind+0x133>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80548e:	a1 54 44 b3 00       	mov    0xb34454,%eax
  805493:	eb 03                	jmp    805498 <tcp_bind+0xbd>
  805495:	8b 40 0c             	mov    0xc(%eax),%eax
  805498:	85 c0                	test   %eax,%eax
  80549a:	74 21                	je     8054bd <tcp_bind+0xe2>
    if (cpcb->local_port == port) {
  80549c:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8054a0:	75 f3                	jne    805495 <tcp_bind+0xba>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8054a2:	8b 08                	mov    (%eax),%ecx
  8054a4:	85 db                	test   %ebx,%ebx
  8054a6:	74 75                	je     80551d <tcp_bind+0x142>
  8054a8:	85 c9                	test   %ecx,%ecx
  8054aa:	74 71                	je     80551d <tcp_bind+0x142>
          ip_addr_isany(ipaddr) ||
  8054ac:	8b 3b                	mov    (%ebx),%edi
  8054ae:	39 f9                	cmp    %edi,%ecx
  8054b0:	74 04                	je     8054b6 <tcp_bind+0xdb>
  8054b2:	85 ff                	test   %edi,%edi
  8054b4:	75 df                	jne    805495 <tcp_bind+0xba>
        return ERR_USE;
  8054b6:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054bb:	eb 51                	jmp    80550e <tcp_bind+0x133>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8054bd:	a1 48 44 b3 00       	mov    0xb34448,%eax
  8054c2:	eb 03                	jmp    8054c7 <tcp_bind+0xec>
  8054c4:	8b 40 0c             	mov    0xc(%eax),%eax
  8054c7:	85 c0                	test   %eax,%eax
  8054c9:	74 13                	je     8054de <tcp_bind+0x103>
    if (cpcb->local_port == port) {
  8054cb:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8054cf:	75 f3                	jne    8054c4 <tcp_bind+0xe9>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  8054d1:	8b 3b                	mov    (%ebx),%edi
  8054d3:	39 38                	cmp    %edi,(%eax)
  8054d5:	75 ed                	jne    8054c4 <tcp_bind+0xe9>
        return ERR_USE;
  8054d7:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054dc:	eb 30                	jmp    80550e <tcp_bind+0x133>
  if (!ip_addr_isany(ipaddr)) {
  8054de:	85 db                	test   %ebx,%ebx
  8054e0:	74 09                	je     8054eb <tcp_bind+0x110>
  8054e2:	83 3b 00             	cmpl   $0x0,(%ebx)
  8054e5:	74 04                	je     8054eb <tcp_bind+0x110>
    pcb->local_ip = *ipaddr;
  8054e7:	8b 03                	mov    (%ebx),%eax
  8054e9:	89 06                	mov    %eax,(%esi)
  pcb->local_port = port;
  8054eb:	66 89 56 1c          	mov    %dx,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  8054ef:	a1 54 44 b3 00       	mov    0xb34454,%eax
  8054f4:	89 46 0c             	mov    %eax,0xc(%esi)
  8054f7:	89 35 54 44 b3 00    	mov    %esi,0xb34454
  8054fd:	e8 31 cd ff ff       	call   802233 <tcp_timer_needed>
  return ERR_OK;
  805502:	b8 00 00 00 00       	mov    $0x0,%eax
  805507:	eb 05                	jmp    80550e <tcp_bind+0x133>
        return ERR_USE;
  805509:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  80550e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805511:	5b                   	pop    %ebx
  805512:	5e                   	pop    %esi
  805513:	5f                   	pop    %edi
  805514:	5d                   	pop    %ebp
  805515:	c3                   	ret    
        return ERR_USE;
  805516:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80551b:	eb f1                	jmp    80550e <tcp_bind+0x133>
        return ERR_USE;
  80551d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805522:	eb ea                	jmp    80550e <tcp_bind+0x133>

00805524 <tcp_listen_with_backlog>:
{
  805524:	55                   	push   %ebp
  805525:	89 e5                	mov    %esp,%ebp
  805527:	57                   	push   %edi
  805528:	56                   	push   %esi
  805529:	53                   	push   %ebx
  80552a:	83 ec 0c             	sub    $0xc,%esp
  80552d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805530:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805534:	75 65                	jne    80559b <tcp_listen_with_backlog+0x77>
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805536:	83 ec 0c             	sub    $0xc,%esp
  805539:	6a 03                	push   $0x3
  80553b:	e8 65 ef ff ff       	call   8044a5 <memp_malloc>
  805540:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805542:	83 c4 10             	add    $0x10,%esp
  805545:	85 c0                	test   %eax,%eax
  805547:	0f 84 9c 00 00 00    	je     8055e9 <tcp_listen_with_backlog+0xc5>
  lpcb->callback_arg = pcb->callback_arg;
  80554d:	8b 43 18             	mov    0x18(%ebx),%eax
  805550:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805553:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805557:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  80555b:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options |= SOF_ACCEPTCONN;
  805562:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805566:	83 c8 02             	or     $0x2,%eax
  805569:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  80556d:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  805571:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  805574:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  805578:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80557b:	8b 03                	mov    (%ebx),%eax
  80557d:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80557f:	8b 15 54 44 b3 00    	mov    0xb34454,%edx
  805585:	39 da                	cmp    %ebx,%edx
  805587:	74 29                	je     8055b2 <tcp_listen_with_backlog+0x8e>
  805589:	89 15 44 44 b3 00    	mov    %edx,0xb34444
  80558f:	b9 00 00 00 00       	mov    $0x0,%ecx
  805594:	bf 01 00 00 00       	mov    $0x1,%edi
  805599:	eb 5c                	jmp    8055f7 <tcp_listen_with_backlog+0xd3>
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80559b:	83 ec 04             	sub    $0x4,%esp
  80559e:	68 58 1a 81 00       	push   $0x811a58
  8055a3:	68 60 01 00 00       	push   $0x160
  8055a8:	68 0e 1c 81 00       	push   $0x811c0e
  8055ad:	e8 24 8f 00 00       	call   80e4d6 <_panic>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8055b2:	8b 43 0c             	mov    0xc(%ebx),%eax
  8055b5:	a3 54 44 b3 00       	mov    %eax,0xb34454
  8055ba:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  8055c1:	83 ec 08             	sub    $0x8,%esp
  8055c4:	53                   	push   %ebx
  8055c5:	6a 02                	push   $0x2
  8055c7:	e8 2f ef ff ff       	call   8044fb <memp_free>
  lpcb->accept = tcp_accept_null;
  8055cc:	c7 46 20 67 53 80 00 	movl   $0x805367,0x20(%esi)
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  8055d3:	a1 50 44 b3 00       	mov    0xb34450,%eax
  8055d8:	89 46 0c             	mov    %eax,0xc(%esi)
  8055db:	89 35 50 44 b3 00    	mov    %esi,0xb34450
  8055e1:	e8 4d cc ff ff       	call   802233 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  8055e6:	83 c4 10             	add    $0x10,%esp
}
  8055e9:	89 f0                	mov    %esi,%eax
  8055eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8055ee:	5b                   	pop    %ebx
  8055ef:	5e                   	pop    %esi
  8055f0:	5f                   	pop    %edi
  8055f1:	5d                   	pop    %ebp
  8055f2:	c3                   	ret    
  8055f3:	89 f9                	mov    %edi,%ecx
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8055f5:	89 c2                	mov    %eax,%edx
  8055f7:	85 d2                	test   %edx,%edx
  8055f9:	74 1d                	je     805618 <tcp_listen_with_backlog+0xf4>
  8055fb:	8b 42 0c             	mov    0xc(%edx),%eax
  8055fe:	39 d8                	cmp    %ebx,%eax
  805600:	75 f1                	jne    8055f3 <tcp_listen_with_backlog+0xcf>
  805602:	85 c0                	test   %eax,%eax
  805604:	74 ed                	je     8055f3 <tcp_listen_with_backlog+0xcf>
  805606:	84 c9                	test   %cl,%cl
  805608:	74 06                	je     805610 <tcp_listen_with_backlog+0xec>
  80560a:	89 15 44 44 b3 00    	mov    %edx,0xb34444
  805610:	8b 43 0c             	mov    0xc(%ebx),%eax
  805613:	89 42 0c             	mov    %eax,0xc(%edx)
  805616:	eb a2                	jmp    8055ba <tcp_listen_with_backlog+0x96>
  805618:	84 c9                	test   %cl,%cl
  80561a:	74 9e                	je     8055ba <tcp_listen_with_backlog+0x96>
  80561c:	c7 05 44 44 b3 00 00 	movl   $0x0,0xb34444
  805623:	00 00 00 
  805626:	eb 92                	jmp    8055ba <tcp_listen_with_backlog+0x96>

00805628 <tcp_recved>:
{
  805628:	55                   	push   %ebp
  805629:	89 e5                	mov    %esp,%ebp
  80562b:	56                   	push   %esi
  80562c:	53                   	push   %ebx
  80562d:	8b 45 08             	mov    0x8(%ebp),%eax
  805630:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805633:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  805637:	0f b7 ca             	movzwl %dx,%ecx
  80563a:	0f b7 f3             	movzwl %bx,%esi
  80563d:	01 f1                	add    %esi,%ecx
  80563f:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  805645:	76 27                	jbe    80566e <tcp_recved+0x46>
    pcb->rcv_wnd = TCP_WND;
  805647:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  80564d:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  if (!(pcb->flags & TF_ACK_DELAY) &&
  805653:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  805657:	f6 c2 03             	test   $0x3,%dl
  80565a:	75 3b                	jne    805697 <tcp_recved+0x6f>
    tcp_ack(pcb);
  80565c:	f6 c2 01             	test   $0x1,%dl
  80565f:	75 1f                	jne    805680 <tcp_recved+0x58>
  805661:	83 ca 01             	or     $0x1,%edx
  805664:	88 50 20             	mov    %dl,0x20(%eax)
}
  805667:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80566a:	5b                   	pop    %ebx
  80566b:	5e                   	pop    %esi
  80566c:	5d                   	pop    %ebp
  80566d:	c3                   	ret    
    pcb->rcv_wnd += len;
  80566e:	01 da                	add    %ebx,%edx
  805670:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805674:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805678:	72 d9                	jb     805653 <tcp_recved+0x2b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80567a:	66 89 50 2a          	mov    %dx,0x2a(%eax)
  80567e:	eb d3                	jmp    805653 <tcp_recved+0x2b>
    tcp_ack(pcb);
  805680:	83 e2 fe             	and    $0xfffffffe,%edx
  805683:	83 ca 02             	or     $0x2,%edx
  805686:	88 50 20             	mov    %dl,0x20(%eax)
  805689:	83 ec 0c             	sub    $0xc,%esp
  80568c:	50                   	push   %eax
  80568d:	e8 5f 29 00 00       	call   807ff1 <tcp_output>
  805692:	83 c4 10             	add    $0x10,%esp
  805695:	eb d0                	jmp    805667 <tcp_recved+0x3f>
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805697:	f6 c2 01             	test   $0x1,%dl
  80569a:	74 cb                	je     805667 <tcp_recved+0x3f>
  80569c:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  8056a2:	76 c3                	jbe    805667 <tcp_recved+0x3f>
    tcp_ack_now(pcb);
  8056a4:	83 ca 02             	or     $0x2,%edx
  8056a7:	88 50 20             	mov    %dl,0x20(%eax)
  8056aa:	83 ec 0c             	sub    $0xc,%esp
  8056ad:	50                   	push   %eax
  8056ae:	e8 3e 29 00 00       	call   807ff1 <tcp_output>
  8056b3:	83 c4 10             	add    $0x10,%esp
}
  8056b6:	eb af                	jmp    805667 <tcp_recved+0x3f>

008056b8 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  8056b8:	55                   	push   %ebp
  8056b9:	89 e5                	mov    %esp,%ebp
  8056bb:	53                   	push   %ebx
  8056bc:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8056bf:	8b 1d 4c 44 b3 00    	mov    0xb3444c,%ebx
  8056c5:	eb 21                	jmp    8056e8 <tcp_fasttmr+0x30>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8056c7:	83 ec 0c             	sub    $0xc,%esp
  8056ca:	50                   	push   %eax
  8056cb:	e8 7c f1 ff ff       	call   80484c <pbuf_free>
  8056d0:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  8056d3:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8056da:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  8056dd:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  8056e1:	a8 01                	test   $0x1,%al
  8056e3:	75 2d                	jne    805712 <tcp_fasttmr+0x5a>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8056e5:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8056e8:	85 db                	test   %ebx,%ebx
  8056ea:	74 3e                	je     80572a <tcp_fasttmr+0x72>
    if (pcb->refused_data != NULL) {
  8056ec:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8056f2:	85 c0                	test   %eax,%eax
  8056f4:	74 e7                	je     8056dd <tcp_fasttmr+0x25>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8056f6:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  8056fc:	85 d2                	test   %edx,%edx
  8056fe:	74 c7                	je     8056c7 <tcp_fasttmr+0xf>
  805700:	6a 00                	push   $0x0
  805702:	50                   	push   %eax
  805703:	53                   	push   %ebx
  805704:	ff 73 18             	push   0x18(%ebx)
  805707:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805709:	83 c4 10             	add    $0x10,%esp
  80570c:	84 c0                	test   %al,%al
  80570e:	74 c3                	je     8056d3 <tcp_fasttmr+0x1b>
  805710:	eb cb                	jmp    8056dd <tcp_fasttmr+0x25>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805712:	83 c8 02             	or     $0x2,%eax
  805715:	88 43 20             	mov    %al,0x20(%ebx)
  805718:	83 ec 0c             	sub    $0xc,%esp
  80571b:	53                   	push   %ebx
  80571c:	e8 d0 28 00 00       	call   807ff1 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805721:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  805725:	83 c4 10             	add    $0x10,%esp
  805728:	eb bb                	jmp    8056e5 <tcp_fasttmr+0x2d>
    }
  }
}
  80572a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80572d:	c9                   	leave  
  80572e:	c3                   	ret    

0080572f <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  80572f:	55                   	push   %ebp
  805730:	89 e5                	mov    %esp,%ebp
  805732:	56                   	push   %esi
  805733:	53                   	push   %ebx
  805734:	8b 75 08             	mov    0x8(%ebp),%esi
  u8_t count = 0;
  805737:	bb 00 00 00 00       	mov    $0x0,%ebx
  
  if (seg != NULL) {
  80573c:	85 f6                	test   %esi,%esi
  80573e:	74 23                	je     805763 <tcp_seg_free+0x34>
    if (seg->p != NULL) {
  805740:	8b 46 04             	mov    0x4(%esi),%eax
  805743:	85 c0                	test   %eax,%eax
  805745:	74 0e                	je     805755 <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  805747:	83 ec 0c             	sub    $0xc,%esp
  80574a:	50                   	push   %eax
  80574b:	e8 fc f0 ff ff       	call   80484c <pbuf_free>
  805750:	89 c3                	mov    %eax,%ebx
  805752:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805755:	83 ec 08             	sub    $0x8,%esp
  805758:	56                   	push   %esi
  805759:	6a 04                	push   $0x4
  80575b:	e8 9b ed ff ff       	call   8044fb <memp_free>
  805760:	83 c4 10             	add    $0x10,%esp
  }
  return count;
}
  805763:	89 d8                	mov    %ebx,%eax
  805765:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805768:	5b                   	pop    %ebx
  805769:	5e                   	pop    %esi
  80576a:	5d                   	pop    %ebp
  80576b:	c3                   	ret    

0080576c <tcp_segs_free>:
{
  80576c:	55                   	push   %ebp
  80576d:	89 e5                	mov    %esp,%ebp
  80576f:	56                   	push   %esi
  805770:	53                   	push   %ebx
  805771:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  805774:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (seg != NULL) {
  805779:	eb 12                	jmp    80578d <tcp_segs_free+0x21>
    next = seg->next;
  80577b:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  80577d:	83 ec 0c             	sub    $0xc,%esp
  805780:	50                   	push   %eax
  805781:	e8 a9 ff ff ff       	call   80572f <tcp_seg_free>
  805786:	01 c3                	add    %eax,%ebx
  805788:	83 c4 10             	add    $0x10,%esp
    seg = next;
  80578b:	89 f0                	mov    %esi,%eax
  while (seg != NULL) {
  80578d:	85 c0                	test   %eax,%eax
  80578f:	75 ea                	jne    80577b <tcp_segs_free+0xf>
}
  805791:	89 d8                	mov    %ebx,%eax
  805793:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805796:	5b                   	pop    %ebx
  805797:	5e                   	pop    %esi
  805798:	5d                   	pop    %ebp
  805799:	c3                   	ret    

0080579a <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  80579a:	55                   	push   %ebp
  80579b:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  80579d:	8b 45 08             	mov    0x8(%ebp),%eax
  8057a0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057a3:	88 50 14             	mov    %dl,0x14(%eax)
}
  8057a6:	5d                   	pop    %ebp
  8057a7:	c3                   	ret    

008057a8 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8057a8:	55                   	push   %ebp
  8057a9:	89 e5                	mov    %esp,%ebp
  8057ab:	53                   	push   %ebx
  8057ac:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8057af:	6a 04                	push   $0x4
  8057b1:	e8 ef ec ff ff       	call   8044a5 <memp_malloc>
  8057b6:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  8057b8:	83 c4 10             	add    $0x10,%esp
  8057bb:	85 c0                	test   %eax,%eax
  8057bd:	74 1c                	je     8057db <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  8057bf:	83 ec 04             	sub    $0x4,%esp
  8057c2:	6a 14                	push   $0x14
  8057c4:	ff 75 08             	push   0x8(%ebp)
  8057c7:	50                   	push   %eax
  8057c8:	e8 b6 95 00 00       	call   80ed83 <memcpy>
  pbuf_ref(cseg->p);
  8057cd:	83 c4 04             	add    $0x4,%esp
  8057d0:	ff 73 04             	push   0x4(%ebx)
  8057d3:	e8 c5 f4 ff ff       	call   804c9d <pbuf_ref>
  return cseg;
  8057d8:	83 c4 10             	add    $0x10,%esp
}
  8057db:	89 d8                	mov    %ebx,%eax
  8057dd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8057e0:	c9                   	leave  
  8057e1:	c3                   	ret    

008057e2 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8057e2:	55                   	push   %ebp
  8057e3:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  8057e5:	8b 45 08             	mov    0x8(%ebp),%eax
  8057e8:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057eb:	89 50 18             	mov    %edx,0x18(%eax)
}
  8057ee:	5d                   	pop    %ebp
  8057ef:	c3                   	ret    

008057f0 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  8057f0:	55                   	push   %ebp
  8057f1:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  8057f3:	8b 45 08             	mov    0x8(%ebp),%eax
  8057f6:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057f9:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  8057ff:	5d                   	pop    %ebp
  805800:	c3                   	ret    

00805801 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805801:	55                   	push   %ebp
  805802:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805804:	8b 45 08             	mov    0x8(%ebp),%eax
  805807:	8b 55 0c             	mov    0xc(%ebp),%edx
  80580a:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805810:	5d                   	pop    %ebp
  805811:	c3                   	ret    

00805812 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805812:	55                   	push   %ebp
  805813:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805815:	8b 45 08             	mov    0x8(%ebp),%eax
  805818:	8b 55 0c             	mov    0xc(%ebp),%edx
  80581b:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805821:	5d                   	pop    %ebp
  805822:	c3                   	ret    

00805823 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805823:	55                   	push   %ebp
  805824:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805826:	8b 45 08             	mov    0x8(%ebp),%eax
  805829:	8b 55 0c             	mov    0xc(%ebp),%edx
  80582c:	89 50 20             	mov    %edx,0x20(%eax)
}
  80582f:	5d                   	pop    %ebp
  805830:	c3                   	ret    

00805831 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805831:	55                   	push   %ebp
  805832:	89 e5                	mov    %esp,%ebp
  805834:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805837:	8b 55 0c             	mov    0xc(%ebp),%edx
  80583a:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805840:	8b 55 10             	mov    0x10(%ebp),%edx
  805843:	88 50 31             	mov    %dl,0x31(%eax)
}
  805846:	5d                   	pop    %ebp
  805847:	c3                   	ret    

00805848 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805848:	55                   	push   %ebp
  805849:	89 e5                	mov    %esp,%ebp
  80584b:	53                   	push   %ebx
  80584c:	83 ec 04             	sub    $0x4,%esp
  80584f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805852:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  805855:	83 f8 0a             	cmp    $0xa,%eax
  805858:	74 05                	je     80585f <tcp_pcb_purge+0x17>
  80585a:	83 f8 01             	cmp    $0x1,%eax
  80585d:	77 05                	ja     805864 <tcp_pcb_purge+0x1c>
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
  }
}
  80585f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805862:	c9                   	leave  
  805863:	c3                   	ret    
    if (pcb->refused_data != NULL) {
  805864:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80586a:	85 c0                	test   %eax,%eax
  80586c:	74 16                	je     805884 <tcp_pcb_purge+0x3c>
      pbuf_free(pcb->refused_data);
  80586e:	83 ec 0c             	sub    $0xc,%esp
  805871:	50                   	push   %eax
  805872:	e8 d5 ef ff ff       	call   80484c <pbuf_free>
      pcb->refused_data = NULL;
  805877:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80587e:	00 00 00 
  805881:	83 c4 10             	add    $0x10,%esp
    pcb->rtime = -1;
  805884:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    tcp_segs_free(pcb->ooseq);
  80588a:	83 ec 0c             	sub    $0xc,%esp
  80588d:	ff 73 7c             	push   0x7c(%ebx)
  805890:	e8 d7 fe ff ff       	call   80576c <tcp_segs_free>
    pcb->ooseq = NULL;
  805895:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
    tcp_segs_free(pcb->unsent);
  80589c:	83 c4 04             	add    $0x4,%esp
  80589f:	ff 73 74             	push   0x74(%ebx)
  8058a2:	e8 c5 fe ff ff       	call   80576c <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  8058a7:	83 c4 04             	add    $0x4,%esp
  8058aa:	ff 73 78             	push   0x78(%ebx)
  8058ad:	e8 ba fe ff ff       	call   80576c <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  8058b2:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  8058b9:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  8058c0:	83 c4 10             	add    $0x10,%esp
}
  8058c3:	eb 9a                	jmp    80585f <tcp_pcb_purge+0x17>

008058c5 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  8058c5:	55                   	push   %ebp
  8058c6:	89 e5                	mov    %esp,%ebp
  8058c8:	56                   	push   %esi
  8058c9:	53                   	push   %ebx
  8058ca:	8b 45 08             	mov    0x8(%ebp),%eax
  8058cd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  8058d0:	8b 10                	mov    (%eax),%edx
  8058d2:	39 da                	cmp    %ebx,%edx
  8058d4:	74 12                	je     8058e8 <tcp_pcb_remove+0x23>
  8058d6:	89 15 44 44 b3 00    	mov    %edx,0xb34444
  8058dc:	b9 00 00 00 00       	mov    $0x0,%ecx
  8058e1:	be 01 00 00 00       	mov    $0x1,%esi
  8058e6:	eb 59                	jmp    805941 <tcp_pcb_remove+0x7c>
  8058e8:	8b 53 0c             	mov    0xc(%ebx),%edx
  8058eb:	89 10                	mov    %edx,(%eax)
  8058ed:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  8058f4:	83 ec 0c             	sub    $0xc,%esp
  8058f7:	53                   	push   %ebx
  8058f8:	e8 4b ff ff ff       	call   805848 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  8058fd:	8b 43 10             	mov    0x10(%ebx),%eax
  805900:	83 c4 10             	add    $0x10,%esp
  805903:	83 f8 0a             	cmp    $0xa,%eax
  805906:	74 7f                	je     805987 <tcp_pcb_remove+0xc2>
  805908:	83 f8 01             	cmp    $0x1,%eax
  80590b:	74 7a                	je     805987 <tcp_pcb_remove+0xc2>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  80590d:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
     pcb->state != LISTEN &&
  805911:	a8 01                	test   $0x1,%al
  805913:	75 60                	jne    805975 <tcp_pcb_remove+0xb0>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805915:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805919:	75 74                	jne    80598f <tcp_pcb_remove+0xca>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  80591b:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80591f:	0f 85 81 00 00 00    	jne    8059a6 <tcp_pcb_remove+0xe1>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805925:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  805929:	0f 85 8e 00 00 00    	jne    8059bd <tcp_pcb_remove+0xf8>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  80592f:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805936:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805939:	5b                   	pop    %ebx
  80593a:	5e                   	pop    %esi
  80593b:	5d                   	pop    %ebp
  80593c:	c3                   	ret    
  80593d:	89 f1                	mov    %esi,%ecx
  TCP_RMV(pcblist, pcb);
  80593f:	89 c2                	mov    %eax,%edx
  805941:	85 d2                	test   %edx,%edx
  805943:	74 1d                	je     805962 <tcp_pcb_remove+0x9d>
  805945:	8b 42 0c             	mov    0xc(%edx),%eax
  805948:	39 d8                	cmp    %ebx,%eax
  80594a:	75 f1                	jne    80593d <tcp_pcb_remove+0x78>
  80594c:	85 c0                	test   %eax,%eax
  80594e:	74 ed                	je     80593d <tcp_pcb_remove+0x78>
  805950:	84 c9                	test   %cl,%cl
  805952:	74 06                	je     80595a <tcp_pcb_remove+0x95>
  805954:	89 15 44 44 b3 00    	mov    %edx,0xb34444
  80595a:	8b 43 0c             	mov    0xc(%ebx),%eax
  80595d:	89 42 0c             	mov    %eax,0xc(%edx)
  805960:	eb 8b                	jmp    8058ed <tcp_pcb_remove+0x28>
  805962:	84 c9                	test   %cl,%cl
  805964:	74 87                	je     8058ed <tcp_pcb_remove+0x28>
  805966:	c7 05 44 44 b3 00 00 	movl   $0x0,0xb34444
  80596d:	00 00 00 
  805970:	e9 78 ff ff ff       	jmp    8058ed <tcp_pcb_remove+0x28>
    pcb->flags |= TF_ACK_NOW;
  805975:	83 c8 02             	or     $0x2,%eax
  805978:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  80597b:	83 ec 0c             	sub    $0xc,%esp
  80597e:	53                   	push   %ebx
  80597f:	e8 6d 26 00 00       	call   807ff1 <tcp_output>
  805984:	83 c4 10             	add    $0x10,%esp
  if (pcb->state != LISTEN) {
  805987:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  80598b:	74 a2                	je     80592f <tcp_pcb_remove+0x6a>
  80598d:	eb 86                	jmp    805915 <tcp_pcb_remove+0x50>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  80598f:	83 ec 04             	sub    $0x4,%esp
  805992:	68 22 1c 81 00       	push   $0x811c22
  805997:	68 b4 04 00 00       	push   $0x4b4
  80599c:	68 0e 1c 81 00       	push   $0x811c0e
  8059a1:	e8 30 8b 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  8059a6:	83 ec 04             	sub    $0x4,%esp
  8059a9:	68 3a 1c 81 00       	push   $0x811c3a
  8059ae:	68 b5 04 00 00       	push   $0x4b5
  8059b3:	68 0e 1c 81 00       	push   $0x811c0e
  8059b8:	e8 19 8b 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  8059bd:	83 ec 04             	sub    $0x4,%esp
  8059c0:	68 53 1c 81 00       	push   $0x811c53
  8059c5:	68 b7 04 00 00       	push   $0x4b7
  8059ca:	68 0e 1c 81 00       	push   $0x811c0e
  8059cf:	e8 02 8b 00 00       	call   80e4d6 <_panic>

008059d4 <tcp_close>:
{
  8059d4:	55                   	push   %ebp
  8059d5:	89 e5                	mov    %esp,%ebp
  8059d7:	56                   	push   %esi
  8059d8:	53                   	push   %ebx
  8059d9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  switch (pcb->state) {
  8059dc:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8059e0:	0f 87 2c 01 00 00    	ja     805b12 <tcp_close+0x13e>
  8059e6:	8b 43 10             	mov    0x10(%ebx),%eax
  8059e9:	ff 24 85 6c 1c 81 00 	jmp    *0x811c6c(,%eax,4)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  8059f0:	8b 15 54 44 b3 00    	mov    0xb34454,%edx
  8059f6:	39 da                	cmp    %ebx,%edx
  8059f8:	74 12                	je     805a0c <tcp_close+0x38>
  8059fa:	89 15 44 44 b3 00    	mov    %edx,0xb34444
  805a00:	b9 00 00 00 00       	mov    $0x0,%ecx
  805a05:	be 01 00 00 00       	mov    $0x1,%esi
  805a0a:	eb 2b                	jmp    805a37 <tcp_close+0x63>
  805a0c:	8b 43 0c             	mov    0xc(%ebx),%eax
  805a0f:	a3 54 44 b3 00       	mov    %eax,0xb34454
  805a14:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805a1b:	83 ec 08             	sub    $0x8,%esp
  805a1e:	53                   	push   %ebx
  805a1f:	6a 02                	push   $0x2
  805a21:	e8 d5 ea ff ff       	call   8044fb <memp_free>
    break;
  805a26:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805a29:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805a2e:	e9 a6 00 00 00       	jmp    805ad9 <tcp_close+0x105>
  805a33:	89 f1                	mov    %esi,%ecx
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805a35:	89 c2                	mov    %eax,%edx
  805a37:	85 d2                	test   %edx,%edx
  805a39:	74 1d                	je     805a58 <tcp_close+0x84>
  805a3b:	8b 42 0c             	mov    0xc(%edx),%eax
  805a3e:	39 d8                	cmp    %ebx,%eax
  805a40:	75 f1                	jne    805a33 <tcp_close+0x5f>
  805a42:	85 c0                	test   %eax,%eax
  805a44:	74 ed                	je     805a33 <tcp_close+0x5f>
  805a46:	84 c9                	test   %cl,%cl
  805a48:	74 06                	je     805a50 <tcp_close+0x7c>
  805a4a:	89 15 44 44 b3 00    	mov    %edx,0xb34444
  805a50:	8b 43 0c             	mov    0xc(%ebx),%eax
  805a53:	89 42 0c             	mov    %eax,0xc(%edx)
  805a56:	eb bc                	jmp    805a14 <tcp_close+0x40>
  805a58:	84 c9                	test   %cl,%cl
  805a5a:	74 b8                	je     805a14 <tcp_close+0x40>
  805a5c:	c7 05 44 44 b3 00 00 	movl   $0x0,0xb34444
  805a63:	00 00 00 
  805a66:	eb ac                	jmp    805a14 <tcp_close+0x40>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805a68:	83 ec 08             	sub    $0x8,%esp
  805a6b:	53                   	push   %ebx
  805a6c:	68 50 44 b3 00       	push   $0xb34450
  805a71:	e8 4f fe ff ff       	call   8058c5 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805a76:	83 c4 08             	add    $0x8,%esp
  805a79:	53                   	push   %ebx
  805a7a:	6a 03                	push   $0x3
  805a7c:	e8 7a ea ff ff       	call   8044fb <memp_free>
    break;
  805a81:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805a84:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805a89:	eb 4e                	jmp    805ad9 <tcp_close+0x105>
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805a8b:	83 ec 08             	sub    $0x8,%esp
  805a8e:	53                   	push   %ebx
  805a8f:	68 4c 44 b3 00       	push   $0xb3444c
  805a94:	e8 2c fe ff ff       	call   8058c5 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805a99:	83 c4 08             	add    $0x8,%esp
  805a9c:	53                   	push   %ebx
  805a9d:	6a 02                	push   $0x2
  805a9f:	e8 57 ea ff ff       	call   8044fb <memp_free>
    break;
  805aa4:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805aa7:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805aac:	eb 2b                	jmp    805ad9 <tcp_close+0x105>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805aae:	83 ec 08             	sub    $0x8,%esp
  805ab1:	6a 01                	push   $0x1
  805ab3:	53                   	push   %ebx
  805ab4:	e8 c2 24 00 00       	call   807f7b <tcp_send_ctrl>
    if (err == ERR_OK) {
  805ab9:	83 c4 10             	add    $0x10,%esp
  805abc:	84 c0                	test   %al,%al
  805abe:	75 19                	jne    805ad9 <tcp_close+0x105>
  805ac0:	b8 05 00 00 00       	mov    $0x5,%eax
      pcb->state = LAST_ACK;
  805ac5:	89 43 10             	mov    %eax,0x10(%ebx)
    tcp_output(pcb);
  805ac8:	83 ec 0c             	sub    $0xc,%esp
  805acb:	53                   	push   %ebx
  805acc:	e8 20 25 00 00       	call   807ff1 <tcp_output>
  805ad1:	83 c4 10             	add    $0x10,%esp
  805ad4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805ad9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805adc:	5b                   	pop    %ebx
  805add:	5e                   	pop    %esi
  805ade:	5d                   	pop    %ebp
  805adf:	c3                   	ret    
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805ae0:	83 ec 08             	sub    $0x8,%esp
  805ae3:	6a 01                	push   $0x1
  805ae5:	53                   	push   %ebx
  805ae6:	e8 90 24 00 00       	call   807f7b <tcp_send_ctrl>
    if (err == ERR_OK) {
  805aeb:	83 c4 10             	add    $0x10,%esp
  805aee:	84 c0                	test   %al,%al
  805af0:	75 e7                	jne    805ad9 <tcp_close+0x105>
  805af2:	b8 05 00 00 00       	mov    $0x5,%eax
  805af7:	eb cc                	jmp    805ac5 <tcp_close+0xf1>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805af9:	83 ec 08             	sub    $0x8,%esp
  805afc:	6a 01                	push   $0x1
  805afe:	53                   	push   %ebx
  805aff:	e8 77 24 00 00       	call   807f7b <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b04:	83 c4 10             	add    $0x10,%esp
  805b07:	84 c0                	test   %al,%al
  805b09:	75 ce                	jne    805ad9 <tcp_close+0x105>
  805b0b:	b8 09 00 00 00       	mov    $0x9,%eax
  805b10:	eb b3                	jmp    805ac5 <tcp_close+0xf1>
  switch (pcb->state) {
  805b12:	b8 00 00 00 00       	mov    $0x0,%eax
  return err;
  805b17:	eb c0                	jmp    805ad9 <tcp_close+0x105>

00805b19 <tcp_recv_null>:
{
  805b19:	55                   	push   %ebp
  805b1a:	89 e5                	mov    %esp,%ebp
  805b1c:	83 ec 08             	sub    $0x8,%esp
  805b1f:	8b 45 10             	mov    0x10(%ebp),%eax
  805b22:	8b 55 14             	mov    0x14(%ebp),%edx
  if (p != NULL) {
  805b25:	85 c0                	test   %eax,%eax
  805b27:	74 13                	je     805b3c <tcp_recv_null+0x23>
    pbuf_free(p);
  805b29:	83 ec 0c             	sub    $0xc,%esp
  805b2c:	50                   	push   %eax
  805b2d:	e8 1a ed ff ff       	call   80484c <pbuf_free>
  805b32:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  805b35:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805b3a:	c9                   	leave  
  805b3b:	c3                   	ret    
  return ERR_OK;
  805b3c:	b8 00 00 00 00       	mov    $0x0,%eax
  } else if (err == ERR_OK) {
  805b41:	84 d2                	test   %dl,%dl
  805b43:	75 f5                	jne    805b3a <tcp_recv_null+0x21>
    return tcp_close(pcb);
  805b45:	83 ec 0c             	sub    $0xc,%esp
  805b48:	ff 75 0c             	push   0xc(%ebp)
  805b4b:	e8 84 fe ff ff       	call   8059d4 <tcp_close>
  805b50:	83 c4 10             	add    $0x10,%esp
  805b53:	eb e5                	jmp    805b3a <tcp_recv_null+0x21>

00805b55 <tcp_abort>:
{
  805b55:	55                   	push   %ebp
  805b56:	89 e5                	mov    %esp,%ebp
  805b58:	57                   	push   %edi
  805b59:	56                   	push   %esi
  805b5a:	53                   	push   %ebx
  805b5b:	83 ec 2c             	sub    $0x2c,%esp
  805b5e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state == TIME_WAIT) {
  805b61:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805b65:	0f 84 c2 00 00 00    	je     805c2d <tcp_abort+0xd8>
    seqno = pcb->snd_nxt;
  805b6b:	8b 43 54             	mov    0x54(%ebx),%eax
  805b6e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805b71:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805b74:	8b 03                	mov    (%ebx),%eax
  805b76:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805b79:	8b 43 04             	mov    0x4(%ebx),%eax
  805b7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805b7f:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805b83:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805b87:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805b8b:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
    errf = pcb->errf;
  805b8f:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
    errf_arg = pcb->callback_arg;
  805b95:	8b 43 18             	mov    0x18(%ebx),%eax
  805b98:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805b9b:	83 ec 08             	sub    $0x8,%esp
  805b9e:	53                   	push   %ebx
  805b9f:	68 4c 44 b3 00       	push   $0xb3444c
  805ba4:	e8 1c fd ff ff       	call   8058c5 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805ba9:	8b 43 78             	mov    0x78(%ebx),%eax
  805bac:	83 c4 10             	add    $0x10,%esp
  805baf:	85 c0                	test   %eax,%eax
  805bb1:	74 0c                	je     805bbf <tcp_abort+0x6a>
      tcp_segs_free(pcb->unacked);
  805bb3:	83 ec 0c             	sub    $0xc,%esp
  805bb6:	50                   	push   %eax
  805bb7:	e8 b0 fb ff ff       	call   80576c <tcp_segs_free>
  805bbc:	83 c4 10             	add    $0x10,%esp
    if (pcb->unsent != NULL) {
  805bbf:	8b 43 74             	mov    0x74(%ebx),%eax
  805bc2:	85 c0                	test   %eax,%eax
  805bc4:	74 0c                	je     805bd2 <tcp_abort+0x7d>
      tcp_segs_free(pcb->unsent);
  805bc6:	83 ec 0c             	sub    $0xc,%esp
  805bc9:	50                   	push   %eax
  805bca:	e8 9d fb ff ff       	call   80576c <tcp_segs_free>
  805bcf:	83 c4 10             	add    $0x10,%esp
    if (pcb->ooseq != NULL) {
  805bd2:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805bd5:	85 c0                	test   %eax,%eax
  805bd7:	74 0c                	je     805be5 <tcp_abort+0x90>
      tcp_segs_free(pcb->ooseq);
  805bd9:	83 ec 0c             	sub    $0xc,%esp
  805bdc:	50                   	push   %eax
  805bdd:	e8 8a fb ff ff       	call   80576c <tcp_segs_free>
  805be2:	83 c4 10             	add    $0x10,%esp
    memp_free(MEMP_TCP_PCB, pcb);
  805be5:	83 ec 08             	sub    $0x8,%esp
  805be8:	53                   	push   %ebx
  805be9:	6a 02                	push   $0x2
  805beb:	e8 0b e9 ff ff       	call   8044fb <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805bf0:	83 c4 10             	add    $0x10,%esp
  805bf3:	85 f6                	test   %esi,%esi
  805bf5:	74 0d                	je     805c04 <tcp_abort+0xaf>
  805bf7:	83 ec 08             	sub    $0x8,%esp
  805bfa:	6a fb                	push   $0xfffffffb
  805bfc:	ff 75 cc             	push   -0x34(%ebp)
  805bff:	ff d6                	call   *%esi
  805c01:	83 c4 10             	add    $0x10,%esp
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805c04:	83 ec 08             	sub    $0x8,%esp
  805c07:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805c0b:	50                   	push   %eax
  805c0c:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805c10:	50                   	push   %eax
  805c11:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805c14:	50                   	push   %eax
  805c15:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805c18:	50                   	push   %eax
  805c19:	57                   	push   %edi
  805c1a:	ff 75 d4             	push   -0x2c(%ebp)
  805c1d:	e8 72 28 00 00       	call   808494 <tcp_rst>
  805c22:	83 c4 20             	add    $0x20,%esp
}
  805c25:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805c28:	5b                   	pop    %ebx
  805c29:	5e                   	pop    %esi
  805c2a:	5f                   	pop    %edi
  805c2b:	5d                   	pop    %ebp
  805c2c:	c3                   	ret    
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805c2d:	83 ec 08             	sub    $0x8,%esp
  805c30:	53                   	push   %ebx
  805c31:	68 48 44 b3 00       	push   $0xb34448
  805c36:	e8 8a fc ff ff       	call   8058c5 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805c3b:	83 c4 08             	add    $0x8,%esp
  805c3e:	53                   	push   %ebx
  805c3f:	6a 02                	push   $0x2
  805c41:	e8 b5 e8 ff ff       	call   8044fb <memp_free>
  805c46:	83 c4 10             	add    $0x10,%esp
  805c49:	eb da                	jmp    805c25 <tcp_abort+0xd0>

00805c4b <tcp_slowtmr>:
{
  805c4b:	55                   	push   %ebp
  805c4c:	89 e5                	mov    %esp,%ebp
  805c4e:	57                   	push   %edi
  805c4f:	56                   	push   %esi
  805c50:	53                   	push   %ebx
  805c51:	83 ec 1c             	sub    $0x1c,%esp
  ++tcp_ticks;
  805c54:	83 05 58 44 b3 00 01 	addl   $0x1,0xb34458
  pcb = tcp_active_pcbs;
  805c5b:	8b 1d 4c 44 b3 00    	mov    0xb3444c,%ebx
  err = ERR_OK;
  805c61:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  prev = NULL;
  805c65:	bf 00 00 00 00       	mov    $0x0,%edi
  805c6a:	e9 21 02 00 00       	jmp    805e90 <tcp_slowtmr+0x245>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805c6f:	83 ec 04             	sub    $0x4,%esp
  805c72:	68 7c 1a 81 00       	push   $0x811a7c
  805c77:	68 36 02 00 00       	push   $0x236
  805c7c:	68 0e 1c 81 00       	push   $0x811c0e
  805c81:	e8 50 88 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805c86:	83 ec 04             	sub    $0x4,%esp
  805c89:	68 a8 1a 81 00       	push   $0x811aa8
  805c8e:	68 37 02 00 00       	push   $0x237
  805c93:	68 0e 1c 81 00       	push   $0x811c0e
  805c98:	e8 39 88 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805c9d:	83 ec 04             	sub    $0x4,%esp
  805ca0:	68 d4 1a 81 00       	push   $0x811ad4
  805ca5:	68 38 02 00 00       	push   $0x238
  805caa:	68 0e 1c 81 00       	push   $0x811c0e
  805caf:	e8 22 88 00 00       	call   80e4d6 <_panic>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805cb4:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805cb8:	80 fa 06             	cmp    $0x6,%dl
  805cbb:	0f 84 d1 00 00 00    	je     805d92 <tcp_slowtmr+0x147>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805cc1:	80 fa 0c             	cmp    $0xc,%dl
  805cc4:	0f 85 02 02 00 00    	jne    805ecc <tcp_slowtmr+0x281>
  805cca:	be 01 00 00 00       	mov    $0x1,%esi
  805ccf:	e9 c3 00 00 00       	jmp    805d97 <tcp_slowtmr+0x14c>
        if(pcb->rtime >= 0)
  805cd4:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805cd8:	66 85 c9             	test   %cx,%cx
  805cdb:	78 07                	js     805ce4 <tcp_slowtmr+0x99>
          ++pcb->rtime;
  805cdd:	83 c1 01             	add    $0x1,%ecx
  805ce0:	66 89 4b 32          	mov    %cx,0x32(%ebx)
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805ce4:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805ce8:	0f 84 3d 02 00 00    	je     805f2b <tcp_slowtmr+0x2e0>
  805cee:	0f b7 4b 44          	movzwl 0x44(%ebx),%ecx
  805cf2:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  805cf6:	0f 8c 2f 02 00 00    	jl     805f2b <tcp_slowtmr+0x2e0>
          if (pcb->state != SYN_SENT) {
  805cfc:	83 f8 02             	cmp    $0x2,%eax
  805cff:	74 1f                	je     805d20 <tcp_slowtmr+0xd5>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805d01:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805d05:	66 c1 f8 03          	sar    $0x3,%ax
  805d09:	98                   	cwtl   
  805d0a:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805d0e:	01 c8                	add    %ecx,%eax
  805d10:	0f b6 d2             	movzbl %dl,%edx
  805d13:	0f b6 8a 94 1c 81 00 	movzbl 0x811c94(%edx),%ecx
  805d1a:	d3 e0                	shl    %cl,%eax
  805d1c:	66 89 43 44          	mov    %ax,0x44(%ebx)
          pcb->rtime = 0;
  805d20:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  805d26:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  805d2a:	0f b7 53 4e          	movzwl 0x4e(%ebx),%edx
  805d2e:	66 39 d0             	cmp    %dx,%ax
  805d31:	0f 47 c2             	cmova  %edx,%eax
          pcb->ssthresh = eff_wnd >> 1;
  805d34:	66 d1 e8             	shr    %ax
          if (pcb->ssthresh < pcb->mss) {
  805d37:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
            pcb->ssthresh = pcb->mss * 2;
  805d3b:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  805d3e:	66 39 d0             	cmp    %dx,%ax
  805d41:	0f 42 c1             	cmovb  %ecx,%eax
  805d44:	66 89 43 50          	mov    %ax,0x50(%ebx)
          pcb->cwnd = pcb->mss;
  805d48:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
          tcp_rexmit_rto(pcb);
  805d4c:	83 ec 0c             	sub    $0xc,%esp
  805d4f:	53                   	push   %ebx
  805d50:	e8 68 28 00 00       	call   8085bd <tcp_rexmit_rto>
  805d55:	83 c4 10             	add    $0x10,%esp
  805d58:	e9 ce 01 00 00       	jmp    805f2b <tcp_slowtmr+0x2e0>
    pcb_remove = 0;
  805d5d:	be 00 00 00 00       	mov    $0x0,%esi
  805d62:	e9 c4 01 00 00       	jmp    805f2b <tcp_slowtmr+0x2e0>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805d67:	a1 58 44 b3 00       	mov    0xb34458,%eax
  805d6c:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805d6f:	83 f8 29             	cmp    $0x29,%eax
  805d72:	89 f0                	mov    %esi,%eax
  805d74:	1c ff                	sbb    $0xff,%al
  805d76:	89 c6                	mov    %eax,%esi
    if (pcb->ooseq != NULL &&
  805d78:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805d7b:	85 c9                	test   %ecx,%ecx
  805d7d:	75 1f                	jne    805d9e <tcp_slowtmr+0x153>
  805d7f:	e9 cb 00 00 00       	jmp    805e4f <tcp_slowtmr+0x204>
        tcp_abort(pcb);
  805d84:	83 ec 0c             	sub    $0xc,%esp
  805d87:	53                   	push   %ebx
  805d88:	e8 c8 fd ff ff       	call   805b55 <tcp_abort>
  805d8d:	83 c4 10             	add    $0x10,%esp
  805d90:	eb 05                	jmp    805d97 <tcp_slowtmr+0x14c>
  805d92:	be 01 00 00 00       	mov    $0x1,%esi
    if (pcb->ooseq != NULL &&
  805d97:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805d9a:	85 c9                	test   %ecx,%ecx
  805d9c:	74 16                	je     805db4 <tcp_slowtmr+0x169>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  805d9e:	8b 15 58 44 b3 00    	mov    0xb34458,%edx
  805da4:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805da7:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805dab:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805dae:	01 c0                	add    %eax,%eax
    if (pcb->ooseq != NULL &&
  805db0:	39 c2                	cmp    %eax,%edx
  805db2:	73 76                	jae    805e2a <tcp_slowtmr+0x1df>
    if (pcb->state == SYN_RCVD) {
  805db4:	8b 43 10             	mov    0x10(%ebx),%eax
  805db7:	83 f8 03             	cmp    $0x3,%eax
  805dba:	0f 84 82 00 00 00    	je     805e42 <tcp_slowtmr+0x1f7>
    if (pcb->state == LAST_ACK) {
  805dc0:	83 f8 09             	cmp    $0x9,%eax
  805dc3:	0f 85 86 00 00 00    	jne    805e4f <tcp_slowtmr+0x204>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805dc9:	a1 58 44 b3 00       	mov    0xb34458,%eax
  805dce:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805dd1:	3d f0 00 00 00       	cmp    $0xf0,%eax
  805dd6:	76 77                	jbe    805e4f <tcp_slowtmr+0x204>
      tcp_pcb_purge(pcb);      
  805dd8:	83 ec 0c             	sub    $0xc,%esp
  805ddb:	53                   	push   %ebx
  805ddc:	e8 67 fa ff ff       	call   805848 <tcp_pcb_purge>
      if (prev != NULL) {
  805de1:	83 c4 10             	add    $0x10,%esp
  805de4:	85 ff                	test   %edi,%edi
  805de6:	0f 84 de 01 00 00    	je     805fca <tcp_slowtmr+0x37f>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805dec:	3b 1d 4c 44 b3 00    	cmp    0xb3444c,%ebx
  805df2:	0f 84 bb 01 00 00    	je     805fb3 <tcp_slowtmr+0x368>
        prev->next = pcb->next;
  805df8:	8b 43 0c             	mov    0xc(%ebx),%eax
  805dfb:	89 47 0c             	mov    %eax,0xc(%edi)
      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  805dfe:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  805e04:	85 c0                	test   %eax,%eax
  805e06:	74 0d                	je     805e15 <tcp_slowtmr+0x1ca>
  805e08:	83 ec 08             	sub    $0x8,%esp
  805e0b:	6a fb                	push   $0xfffffffb
  805e0d:	ff 73 18             	push   0x18(%ebx)
  805e10:	ff d0                	call   *%eax
  805e12:	83 c4 10             	add    $0x10,%esp
      pcb2 = pcb->next;
  805e15:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  805e18:	83 ec 08             	sub    $0x8,%esp
  805e1b:	53                   	push   %ebx
  805e1c:	6a 02                	push   $0x2
  805e1e:	e8 d8 e6 ff ff       	call   8044fb <memp_free>
  805e23:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  805e26:	89 f3                	mov    %esi,%ebx
  805e28:	eb 66                	jmp    805e90 <tcp_slowtmr+0x245>
      tcp_segs_free(pcb->ooseq);
  805e2a:	83 ec 0c             	sub    $0xc,%esp
  805e2d:	51                   	push   %ecx
  805e2e:	e8 39 f9 ff ff       	call   80576c <tcp_segs_free>
      pcb->ooseq = NULL;
  805e33:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  805e3a:	83 c4 10             	add    $0x10,%esp
  805e3d:	e9 72 ff ff ff       	jmp    805db4 <tcp_slowtmr+0x169>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805e42:	a1 58 44 b3 00       	mov    0xb34458,%eax
  805e47:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805e4a:	83 f8 28             	cmp    $0x28,%eax
  805e4d:	77 89                	ja     805dd8 <tcp_slowtmr+0x18d>
    if (pcb_remove) {
  805e4f:	89 f0                	mov    %esi,%eax
  805e51:	84 c0                	test   %al,%al
  805e53:	75 83                	jne    805dd8 <tcp_slowtmr+0x18d>
      ++pcb->polltmr;
  805e55:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  805e59:	83 c0 01             	add    $0x1,%eax
  805e5c:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  805e5f:	3a 43 31             	cmp    0x31(%ebx),%al
  805e62:	72 27                	jb     805e8b <tcp_slowtmr+0x240>
        pcb->polltmr = 0;
  805e64:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        TCP_EVENT_POLL(pcb, err);
  805e68:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  805e6e:	85 c0                	test   %eax,%eax
  805e70:	74 0f                	je     805e81 <tcp_slowtmr+0x236>
  805e72:	83 ec 08             	sub    $0x8,%esp
  805e75:	53                   	push   %ebx
  805e76:	ff 73 18             	push   0x18(%ebx)
  805e79:	ff d0                	call   *%eax
  805e7b:	88 45 e7             	mov    %al,-0x19(%ebp)
  805e7e:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  805e81:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  805e85:	0f 84 6b 01 00 00    	je     805ff6 <tcp_slowtmr+0x3ab>
      prev = pcb;
  805e8b:	89 df                	mov    %ebx,%edi
      pcb = pcb->next;
  805e8d:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while (pcb != NULL) {
  805e90:	85 db                	test   %ebx,%ebx
  805e92:	0f 84 6f 01 00 00    	je     806007 <tcp_slowtmr+0x3bc>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805e98:	8b 43 10             	mov    0x10(%ebx),%eax
  805e9b:	85 c0                	test   %eax,%eax
  805e9d:	0f 84 cc fd ff ff    	je     805c6f <tcp_slowtmr+0x24>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805ea3:	83 f8 01             	cmp    $0x1,%eax
  805ea6:	0f 84 da fd ff ff    	je     805c86 <tcp_slowtmr+0x3b>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805eac:	83 f8 0a             	cmp    $0xa,%eax
  805eaf:	0f 84 e8 fd ff ff    	je     805c9d <tcp_slowtmr+0x52>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805eb5:	83 f8 02             	cmp    $0x2,%eax
  805eb8:	0f 84 f6 fd ff ff    	je     805cb4 <tcp_slowtmr+0x69>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805ebe:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  805ec2:	be 01 00 00 00       	mov    $0x1,%esi
    else if (pcb->nrtx == TCP_MAXRTX) {
  805ec7:	80 fa 0c             	cmp    $0xc,%dl
  805eca:	74 5f                	je     805f2b <tcp_slowtmr+0x2e0>
      if (pcb->persist_backoff > 0) {
  805ecc:	0f b6 b3 a4 00 00 00 	movzbl 0xa4(%ebx),%esi
  805ed3:	89 f1                	mov    %esi,%ecx
  805ed5:	84 c9                	test   %cl,%cl
  805ed7:	0f 84 f7 fd ff ff    	je     805cd4 <tcp_slowtmr+0x89>
        pcb->persist_cnt++;
  805edd:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  805ee3:	83 c0 01             	add    $0x1,%eax
  805ee6:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805eec:	0f b6 d1             	movzbl %cl,%edx
  805eef:	b9 8c 1c 81 00       	mov    $0x811c8c,%ecx
  805ef4:	0f b6 54 11 ff       	movzbl -0x1(%ecx,%edx,1),%edx
  805ef9:	39 d0                	cmp    %edx,%eax
  805efb:	0f 82 5c fe ff ff    	jb     805d5d <tcp_slowtmr+0x112>
          pcb->persist_cnt = 0;
  805f01:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  805f08:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  805f0b:	89 f0                	mov    %esi,%eax
  805f0d:	3c 06                	cmp    $0x6,%al
  805f0f:	77 09                	ja     805f1a <tcp_slowtmr+0x2cf>
            pcb->persist_backoff++;
  805f11:	8d 46 01             	lea    0x1(%esi),%eax
  805f14:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          tcp_zero_window_probe(pcb);
  805f1a:	83 ec 0c             	sub    $0xc,%esp
  805f1d:	53                   	push   %ebx
  805f1e:	e8 64 28 00 00       	call   808787 <tcp_zero_window_probe>
  805f23:	83 c4 10             	add    $0x10,%esp
    pcb_remove = 0;
  805f26:	be 00 00 00 00       	mov    $0x0,%esi
    if (pcb->state == FIN_WAIT_2) {
  805f2b:	8b 43 10             	mov    0x10(%ebx),%eax
  805f2e:	83 f8 06             	cmp    $0x6,%eax
  805f31:	0f 84 30 fe ff ff    	je     805d67 <tcp_slowtmr+0x11c>
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805f37:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805f3b:	0f 84 56 fe ff ff    	je     805d97 <tcp_slowtmr+0x14c>
  805f41:	83 f8 04             	cmp    $0x4,%eax
  805f44:	74 09                	je     805f4f <tcp_slowtmr+0x304>
  805f46:	83 f8 07             	cmp    $0x7,%eax
  805f49:	0f 85 48 fe ff ff    	jne    805d97 <tcp_slowtmr+0x14c>
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f4f:	8b 0d 58 44 b3 00    	mov    0xb34458,%ecx
  805f55:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  805f58:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
  805f5e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  805f61:	8d 90 b8 4c 0a 00    	lea    0xa4cb8(%eax),%edx
  805f67:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805f6c:	f7 e2                	mul    %edx
  805f6e:	c1 ea 05             	shr    $0x5,%edx
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f71:	39 d1                	cmp    %edx,%ecx
  805f73:	0f 87 0b fe ff ff    	ja     805d84 <tcp_slowtmr+0x139>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  805f79:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  805f80:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  805f86:	03 55 e0             	add    -0x20(%ebp),%edx
              / TCP_SLOW_INTERVAL)
  805f89:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805f8e:	f7 e2                	mul    %edx
  805f90:	c1 ea 05             	shr    $0x5,%edx
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f93:	39 d1                	cmp    %edx,%ecx
  805f95:	0f 86 fc fd ff ff    	jbe    805d97 <tcp_slowtmr+0x14c>
        tcp_keepalive(pcb);
  805f9b:	83 ec 0c             	sub    $0xc,%esp
  805f9e:	53                   	push   %ebx
  805f9f:	e8 bd 26 00 00       	call   808661 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  805fa4:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  805fab:	83 c4 10             	add    $0x10,%esp
  805fae:	e9 e4 fd ff ff       	jmp    805d97 <tcp_slowtmr+0x14c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805fb3:	83 ec 04             	sub    $0x4,%esp
  805fb6:	68 04 1b 81 00       	push   $0x811b04
  805fbb:	68 c1 02 00 00       	push   $0x2c1
  805fc0:	68 0e 1c 81 00       	push   $0x811c0e
  805fc5:	e8 0c 85 00 00       	call   80e4d6 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  805fca:	3b 1d 4c 44 b3 00    	cmp    0xb3444c,%ebx
  805fd0:	75 0d                	jne    805fdf <tcp_slowtmr+0x394>
        tcp_active_pcbs = pcb->next;
  805fd2:	8b 43 0c             	mov    0xc(%ebx),%eax
  805fd5:	a3 4c 44 b3 00       	mov    %eax,0xb3444c
  805fda:	e9 1f fe ff ff       	jmp    805dfe <tcp_slowtmr+0x1b3>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  805fdf:	83 ec 04             	sub    $0x4,%esp
  805fe2:	68 30 1b 81 00       	push   $0x811b30
  805fe7:	68 c5 02 00 00       	push   $0x2c5
  805fec:	68 0e 1c 81 00       	push   $0x811c0e
  805ff1:	e8 e0 84 00 00       	call   80e4d6 <_panic>
          tcp_output(pcb);
  805ff6:	83 ec 0c             	sub    $0xc,%esp
  805ff9:	53                   	push   %ebx
  805ffa:	e8 f2 1f 00 00       	call   807ff1 <tcp_output>
  805fff:	83 c4 10             	add    $0x10,%esp
  806002:	e9 84 fe ff ff       	jmp    805e8b <tcp_slowtmr+0x240>
  pcb = tcp_tw_pcbs;
  806007:	8b 35 48 44 b3 00    	mov    0xb34448,%esi
  while (pcb != NULL) {
  80600d:	eb 48                	jmp    806057 <tcp_slowtmr+0x40c>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80600f:	83 ec 04             	sub    $0x4,%esp
  806012:	68 5c 1b 81 00       	push   $0x811b5c
  806017:	68 e5 02 00 00       	push   $0x2e5
  80601c:	68 0e 1c 81 00       	push   $0x811c0e
  806021:	e8 b0 84 00 00       	call   80e4d6 <_panic>
      tcp_pcb_purge(pcb);      
  806026:	83 ec 0c             	sub    $0xc,%esp
  806029:	56                   	push   %esi
  80602a:	e8 19 f8 ff ff       	call   805848 <tcp_pcb_purge>
      if (prev != NULL) {
  80602f:	83 c4 10             	add    $0x10,%esp
  806032:	85 db                	test   %ebx,%ebx
  806034:	74 58                	je     80608e <tcp_slowtmr+0x443>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806036:	3b 35 48 44 b3 00    	cmp    0xb34448,%esi
  80603c:	74 39                	je     806077 <tcp_slowtmr+0x42c>
        prev->next = pcb->next;
  80603e:	8b 46 0c             	mov    0xc(%esi),%eax
  806041:	89 43 0c             	mov    %eax,0xc(%ebx)
      pcb2 = pcb->next;
  806044:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806047:	83 ec 08             	sub    $0x8,%esp
  80604a:	56                   	push   %esi
  80604b:	6a 02                	push   $0x2
  80604d:	e8 a9 e4 ff ff       	call   8044fb <memp_free>
  806052:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806055:	89 fe                	mov    %edi,%esi
  while (pcb != NULL) {
  806057:	85 f6                	test   %esi,%esi
  806059:	74 5c                	je     8060b7 <tcp_slowtmr+0x46c>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80605b:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  80605f:	75 ae                	jne    80600f <tcp_slowtmr+0x3c4>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  806061:	a1 58 44 b3 00       	mov    0xb34458,%eax
  806066:	2b 46 2c             	sub    0x2c(%esi),%eax
  806069:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80606e:	77 b6                	ja     806026 <tcp_slowtmr+0x3db>
      prev = pcb;
  806070:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  806072:	8b 76 0c             	mov    0xc(%esi),%esi
  806075:	eb e0                	jmp    806057 <tcp_slowtmr+0x40c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806077:	83 ec 04             	sub    $0x4,%esp
  80607a:	68 8c 1b 81 00       	push   $0x811b8c
  80607f:	68 f4 02 00 00       	push   $0x2f4
  806084:	68 0e 1c 81 00       	push   $0x811c0e
  806089:	e8 48 84 00 00       	call   80e4d6 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80608e:	3b 35 48 44 b3 00    	cmp    0xb34448,%esi
  806094:	75 0a                	jne    8060a0 <tcp_slowtmr+0x455>
        tcp_tw_pcbs = pcb->next;
  806096:	8b 46 0c             	mov    0xc(%esi),%eax
  806099:	a3 48 44 b3 00       	mov    %eax,0xb34448
  80609e:	eb a4                	jmp    806044 <tcp_slowtmr+0x3f9>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  8060a0:	83 ec 04             	sub    $0x4,%esp
  8060a3:	68 b4 1b 81 00       	push   $0x811bb4
  8060a8:	68 f8 02 00 00       	push   $0x2f8
  8060ad:	68 0e 1c 81 00       	push   $0x811c0e
  8060b2:	e8 1f 84 00 00       	call   80e4d6 <_panic>
}
  8060b7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8060ba:	5b                   	pop    %ebx
  8060bb:	5e                   	pop    %esi
  8060bc:	5f                   	pop    %edi
  8060bd:	5d                   	pop    %ebp
  8060be:	c3                   	ret    

008060bf <tcp_tmr>:
{
  8060bf:	55                   	push   %ebp
  8060c0:	89 e5                	mov    %esp,%ebp
  8060c2:	83 ec 08             	sub    $0x8,%esp
  tcp_fasttmr();
  8060c5:	e8 ee f5 ff ff       	call   8056b8 <tcp_fasttmr>
  if (++tcp_timer & 1) {
  8060ca:	0f b6 05 5c 44 b3 00 	movzbl 0xb3445c,%eax
  8060d1:	83 c0 01             	add    $0x1,%eax
  8060d4:	a2 5c 44 b3 00       	mov    %al,0xb3445c
  8060d9:	a8 01                	test   $0x1,%al
  8060db:	75 02                	jne    8060df <tcp_tmr+0x20>
}
  8060dd:	c9                   	leave  
  8060de:	c3                   	ret    
    tcp_slowtmr();
  8060df:	e8 67 fb ff ff       	call   805c4b <tcp_slowtmr>
}
  8060e4:	eb f7                	jmp    8060dd <tcp_tmr+0x1e>

008060e6 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  8060e6:	a1 58 44 b3 00       	mov    0xb34458,%eax
  8060eb:	03 05 08 40 81 00    	add    0x814008,%eax
  8060f1:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  8060f6:	c3                   	ret    

008060f7 <tcp_alloc>:
{
  8060f7:	55                   	push   %ebp
  8060f8:	89 e5                	mov    %esp,%ebp
  8060fa:	57                   	push   %edi
  8060fb:	56                   	push   %esi
  8060fc:	53                   	push   %ebx
  8060fd:	83 ec 28             	sub    $0x28,%esp
  806100:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  pcb = memp_malloc(MEMP_TCP_PCB);
  806104:	6a 02                	push   $0x2
  806106:	e8 9a e3 ff ff       	call   8044a5 <memp_malloc>
  80610b:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  80610d:	83 c4 10             	add    $0x10,%esp
  806110:	85 c0                	test   %eax,%eax
  806112:	0f 84 a0 00 00 00    	je     8061b8 <tcp_alloc+0xc1>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806118:	83 ec 04             	sub    $0x4,%esp
  80611b:	68 a8 00 00 00       	push   $0xa8
  806120:	6a 00                	push   $0x0
  806122:	53                   	push   %ebx
  806123:	e8 b3 8b 00 00       	call   80ecdb <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806128:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  80612c:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  806132:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  806138:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  80613e:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  806144:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  806148:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80614c:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  806152:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  806158:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  80615e:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  806164:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  80616a:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  806170:	e8 71 ff ff ff       	call   8060e6 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  806175:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  806178:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  80617b:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  80617e:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  806181:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  806184:	a1 58 44 b3 00       	mov    0xb34458,%eax
  806189:	89 43 2c             	mov    %eax,0x2c(%ebx)
    pcb->polltmr = 0;
  80618c:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
    pcb->recv = tcp_recv_null;
  806190:	c7 83 88 00 00 00 19 	movl   $0x805b19,0x88(%ebx)
  806197:	5b 80 00 
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  80619a:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  8061a1:	dd 6d 00 
    pcb->keep_cnt_sent = 0;
  8061a4:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  8061ab:	83 c4 10             	add    $0x10,%esp
}
  8061ae:	89 d8                	mov    %ebx,%eax
  8061b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8061b3:	5b                   	pop    %ebx
  8061b4:	5e                   	pop    %esi
  8061b5:	5f                   	pop    %edi
  8061b6:	5d                   	pop    %ebp
  8061b7:	c3                   	ret    
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8061b8:	a1 48 44 b3 00       	mov    0xb34448,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8061bd:	8b 3d 58 44 b3 00    	mov    0xb34458,%edi
  inactivity = 0;
  8061c3:	b9 00 00 00 00       	mov    $0x0,%ecx
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8061c8:	eb 03                	jmp    8061cd <tcp_alloc+0xd6>
  8061ca:	8b 40 0c             	mov    0xc(%eax),%eax
  8061cd:	85 c0                	test   %eax,%eax
  8061cf:	74 0f                	je     8061e0 <tcp_alloc+0xe9>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8061d1:	89 fa                	mov    %edi,%edx
  8061d3:	2b 50 2c             	sub    0x2c(%eax),%edx
  8061d6:	39 ca                	cmp    %ecx,%edx
  8061d8:	72 f0                	jb     8061ca <tcp_alloc+0xd3>
      inactivity = tcp_ticks - pcb->tmr;
  8061da:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8061dc:	89 c3                	mov    %eax,%ebx
  8061de:	eb ea                	jmp    8061ca <tcp_alloc+0xd3>
  if (inactive != NULL) {
  8061e0:	85 db                	test   %ebx,%ebx
  8061e2:	74 0c                	je     8061f0 <tcp_alloc+0xf9>
    tcp_abort(inactive);
  8061e4:	83 ec 0c             	sub    $0xc,%esp
  8061e7:	53                   	push   %ebx
  8061e8:	e8 68 f9 ff ff       	call   805b55 <tcp_abort>
  8061ed:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
  8061f0:	83 ec 0c             	sub    $0xc,%esp
  8061f3:	6a 02                	push   $0x2
  8061f5:	e8 ab e2 ff ff       	call   8044a5 <memp_malloc>
  8061fa:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  8061fc:	83 c4 10             	add    $0x10,%esp
  8061ff:	85 c0                	test   %eax,%eax
  806201:	0f 85 11 ff ff ff    	jne    806118 <tcp_alloc+0x21>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806207:	a1 4c 44 b3 00       	mov    0xb3444c,%eax
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80620c:	8b 3d 58 44 b3 00    	mov    0xb34458,%edi
  806212:	89 7d dc             	mov    %edi,-0x24(%ebp)
  mprio = TCP_PRIO_MAX;
  806215:	ba 7f 00 00 00       	mov    $0x7f,%edx
  inactivity = 0;
  80621a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806221:	89 df                	mov    %ebx,%edi
  806223:	89 f1                	mov    %esi,%ecx
  806225:	88 4d e7             	mov    %cl,-0x19(%ebp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806228:	eb 03                	jmp    80622d <tcp_alloc+0x136>
  80622a:	8b 40 0c             	mov    0xc(%eax),%eax
  80622d:	85 c0                	test   %eax,%eax
  80622f:	74 29                	je     80625a <tcp_alloc+0x163>
    if (pcb->prio <= prio &&
  806231:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
  806235:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  806239:	38 d3                	cmp    %dl,%bl
  80623b:	89 d6                	mov    %edx,%esi
  80623d:	0f 46 f3             	cmovbe %ebx,%esi
  806240:	89 f3                	mov    %esi,%ebx
  806242:	38 cb                	cmp    %cl,%bl
  806244:	72 e4                	jb     80622a <tcp_alloc+0x133>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806246:	8b 75 dc             	mov    -0x24(%ebp),%esi
  806249:	2b 70 2c             	sub    0x2c(%eax),%esi
       pcb->prio <= mprio &&
  80624c:	3b 75 e0             	cmp    -0x20(%ebp),%esi
  80624f:	72 d9                	jb     80622a <tcp_alloc+0x133>
      mprio = pcb->prio;
  806251:	89 ca                	mov    %ecx,%edx
      inactivity = tcp_ticks - pcb->tmr;
  806253:	89 75 e0             	mov    %esi,-0x20(%ebp)
      inactive = pcb;
  806256:	89 c7                	mov    %eax,%edi
  806258:	eb d0                	jmp    80622a <tcp_alloc+0x133>
  if (inactive != NULL) {
  80625a:	85 ff                	test   %edi,%edi
  80625c:	74 0c                	je     80626a <tcp_alloc+0x173>
    tcp_abort(inactive);
  80625e:	83 ec 0c             	sub    $0xc,%esp
  806261:	57                   	push   %edi
  806262:	e8 ee f8 ff ff       	call   805b55 <tcp_abort>
  806267:	83 c4 10             	add    $0x10,%esp
      pcb = memp_malloc(MEMP_TCP_PCB);
  80626a:	83 ec 0c             	sub    $0xc,%esp
  80626d:	6a 02                	push   $0x2
  80626f:	e8 31 e2 ff ff       	call   8044a5 <memp_malloc>
  806274:	89 c3                	mov    %eax,%ebx
  if (pcb != NULL) {
  806276:	83 c4 10             	add    $0x10,%esp
  806279:	85 c0                	test   %eax,%eax
  80627b:	0f 84 2d ff ff ff    	je     8061ae <tcp_alloc+0xb7>
  806281:	e9 92 fe ff ff       	jmp    806118 <tcp_alloc+0x21>

00806286 <tcp_new>:
{
  806286:	55                   	push   %ebp
  806287:	89 e5                	mov    %esp,%ebp
  806289:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  80628c:	6a 40                	push   $0x40
  80628e:	e8 64 fe ff ff       	call   8060f7 <tcp_alloc>
}
  806293:	c9                   	leave  
  806294:	c3                   	ret    

00806295 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  806295:	55                   	push   %ebp
  806296:	89 e5                	mov    %esp,%ebp
  806298:	56                   	push   %esi
  806299:	53                   	push   %ebx
  80629a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80629d:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80629f:	83 ec 0c             	sub    $0xc,%esp
  8062a2:	ff 75 0c             	push   0xc(%ebp)
  8062a5:	e8 e5 01 00 00       	call   80648f <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  8062aa:	83 c4 10             	add    $0x10,%esp
  8062ad:	85 c0                	test   %eax,%eax
  8062af:	74 13                	je     8062c4 <tcp_eff_send_mss+0x2f>
  8062b1:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  8062b5:	8d 42 d8             	lea    -0x28(%edx),%eax
  8062b8:	66 39 d8             	cmp    %bx,%ax
  8062bb:	0f 47 c3             	cmova  %ebx,%eax
  8062be:	66 85 d2             	test   %dx,%dx
  8062c1:	0f 45 f0             	cmovne %eax,%esi
  }
  return sendmss;
}
  8062c4:	89 f0                	mov    %esi,%eax
  8062c6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8062c9:	5b                   	pop    %ebx
  8062ca:	5e                   	pop    %esi
  8062cb:	5d                   	pop    %ebp
  8062cc:	c3                   	ret    

008062cd <tcp_connect>:
{
  8062cd:	55                   	push   %ebp
  8062ce:	89 e5                	mov    %esp,%ebp
  8062d0:	56                   	push   %esi
  8062d1:	53                   	push   %ebx
  8062d2:	83 ec 10             	sub    $0x10,%esp
  8062d5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8062d8:	8b 75 0c             	mov    0xc(%ebp),%esi
  8062db:	8b 45 10             	mov    0x10(%ebp),%eax
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8062de:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8062e2:	0f 85 9c 00 00 00    	jne    806384 <tcp_connect+0xb7>
  if (ipaddr != NULL) {
  8062e8:	85 f6                	test   %esi,%esi
  8062ea:	0f 84 53 01 00 00    	je     806443 <tcp_connect+0x176>
    pcb->remote_ip = *ipaddr;
  8062f0:	8b 16                	mov    (%esi),%edx
  8062f2:	89 53 04             	mov    %edx,0x4(%ebx)
  pcb->remote_port = port;
  8062f5:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  8062f9:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  8062fe:	0f 84 97 00 00 00    	je     80639b <tcp_connect+0xce>
  iss = tcp_next_iss();
  806304:	e8 dd fd ff ff       	call   8060e6 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  806309:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  806310:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  806313:	83 e8 01             	sub    $0x1,%eax
  806316:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  806319:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  80631c:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  806322:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  806328:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80632e:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  806334:	83 ec 08             	sub    $0x8,%esp
  806337:	56                   	push   %esi
  806338:	68 18 02 00 00       	push   $0x218
  80633d:	e8 53 ff ff ff       	call   806295 <tcp_eff_send_mss>
  806342:	66 89 43 34          	mov    %ax,0x34(%ebx)
  pcb->cwnd = 1;
  806346:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  80634c:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80634f:	01 c0                	add    %eax,%eax
  806351:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  806355:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
  pcb->connected = connected;
  80635c:	8b 45 14             	mov    0x14(%ebp),%eax
  80635f:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806365:	8b 15 54 44 b3 00    	mov    0xb34454,%edx
  80636b:	83 c4 10             	add    $0x10,%esp
  80636e:	39 da                	cmp    %ebx,%edx
  806370:	74 37                	je     8063a9 <tcp_connect+0xdc>
  806372:	89 15 44 44 b3 00    	mov    %edx,0xb34444
  806378:	b9 00 00 00 00       	mov    $0x0,%ecx
  80637d:	be 01 00 00 00       	mov    $0x1,%esi
  806382:	eb 7d                	jmp    806401 <tcp_connect+0x134>
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806384:	83 ec 04             	sub    $0x4,%esp
  806387:	68 dc 1b 81 00       	push   $0x811bdc
  80638c:	68 ec 01 00 00       	push   $0x1ec
  806391:	68 0e 1c 81 00       	push   $0x811c0e
  806396:	e8 3b 81 00 00       	call   80e4d6 <_panic>
    pcb->local_port = tcp_new_port();
  80639b:	e8 cd ef ff ff       	call   80536d <tcp_new_port>
  8063a0:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  8063a4:	e9 5b ff ff ff       	jmp    806304 <tcp_connect+0x37>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8063a9:	8b 43 0c             	mov    0xc(%ebx),%eax
  8063ac:	a3 54 44 b3 00       	mov    %eax,0xb34454
  TCP_REG(&tcp_active_pcbs, pcb);
  8063b1:	a1 4c 44 b3 00       	mov    0xb3444c,%eax
  8063b6:	89 43 0c             	mov    %eax,0xc(%ebx)
  8063b9:	89 1d 4c 44 b3 00    	mov    %ebx,0xb3444c
  8063bf:	e8 6f be ff ff       	call   802233 <tcp_timer_needed>
  optdata = TCP_BUILD_MSS_OPTION();
  8063c4:	83 ec 0c             	sub    $0xc,%esp
  8063c7:	68 b4 05 04 02       	push   $0x20405b4
  8063cc:	e8 cf 12 00 00       	call   8076a0 <htonl>
  8063d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  8063d4:	83 c4 0c             	add    $0xc,%esp
  8063d7:	6a 04                	push   $0x4
  8063d9:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8063dc:	50                   	push   %eax
  8063dd:	6a 00                	push   $0x0
  8063df:	6a 02                	push   $0x2
  8063e1:	6a 00                	push   $0x0
  8063e3:	6a 00                	push   $0x0
  8063e5:	53                   	push   %ebx
  8063e6:	e8 f0 14 00 00       	call   8078db <tcp_enqueue>
  8063eb:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  8063ed:	83 c4 20             	add    $0x20,%esp
  8063f0:	84 c0                	test   %al,%al
  8063f2:	74 41                	je     806435 <tcp_connect+0x168>
} 
  8063f4:	89 f0                	mov    %esi,%eax
  8063f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8063f9:	5b                   	pop    %ebx
  8063fa:	5e                   	pop    %esi
  8063fb:	5d                   	pop    %ebp
  8063fc:	c3                   	ret    
  8063fd:	89 f1                	mov    %esi,%ecx
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8063ff:	89 c2                	mov    %eax,%edx
  806401:	85 d2                	test   %edx,%edx
  806403:	74 1d                	je     806422 <tcp_connect+0x155>
  806405:	8b 42 0c             	mov    0xc(%edx),%eax
  806408:	39 d8                	cmp    %ebx,%eax
  80640a:	75 f1                	jne    8063fd <tcp_connect+0x130>
  80640c:	85 c0                	test   %eax,%eax
  80640e:	74 ed                	je     8063fd <tcp_connect+0x130>
  806410:	84 c9                	test   %cl,%cl
  806412:	74 06                	je     80641a <tcp_connect+0x14d>
  806414:	89 15 44 44 b3 00    	mov    %edx,0xb34444
  80641a:	8b 43 0c             	mov    0xc(%ebx),%eax
  80641d:	89 42 0c             	mov    %eax,0xc(%edx)
  806420:	eb 8f                	jmp    8063b1 <tcp_connect+0xe4>
  806422:	84 c9                	test   %cl,%cl
  806424:	74 8b                	je     8063b1 <tcp_connect+0xe4>
  806426:	c7 05 44 44 b3 00 00 	movl   $0x0,0xb34444
  80642d:	00 00 00 
  806430:	e9 7c ff ff ff       	jmp    8063b1 <tcp_connect+0xe4>
    tcp_output(pcb);
  806435:	83 ec 0c             	sub    $0xc,%esp
  806438:	53                   	push   %ebx
  806439:	e8 b3 1b 00 00       	call   807ff1 <tcp_output>
  80643e:	83 c4 10             	add    $0x10,%esp
  806441:	eb b1                	jmp    8063f4 <tcp_connect+0x127>
    return ERR_VAL;
  806443:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  806448:	eb aa                	jmp    8063f4 <tcp_connect+0x127>

0080644a <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  80644a:	55                   	push   %ebp
  80644b:	89 e5                	mov    %esp,%ebp
  80644d:	53                   	push   %ebx
  80644e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806451:	8b 45 08             	mov    0x8(%ebp),%eax
  806454:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806456:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  806459:	b8 01 00 00 00       	mov    $0x1,%eax
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  80645e:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806461:	77 27                	ja     80648a <ip_addr_isbroadcast+0x40>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  806463:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  806467:	83 e0 02             	and    $0x2,%eax
  80646a:	74 1e                	je     80648a <ip_addr_isbroadcast+0x40>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  80646c:	8b 59 04             	mov    0x4(%ecx),%ebx
    return 0;
  80646f:	b8 00 00 00 00       	mov    $0x0,%eax
  else if (addr2test == netif->ip_addr.addr)
  806474:	39 d3                	cmp    %edx,%ebx
  806476:	74 12                	je     80648a <ip_addr_isbroadcast+0x40>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806478:	8b 49 08             	mov    0x8(%ecx),%ecx
  80647b:	31 d3                	xor    %edx,%ebx
  80647d:	85 cb                	test   %ecx,%ebx
  80647f:	75 09                	jne    80648a <ip_addr_isbroadcast+0x40>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806481:	f7 d1                	not    %ecx
  806483:	21 ca                	and    %ecx,%edx
  806485:	39 ca                	cmp    %ecx,%edx
  806487:	0f 94 c0             	sete   %al
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  80648a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80648d:	c9                   	leave  
  80648e:	c3                   	ret    

0080648f <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  80648f:	55                   	push   %ebp
  806490:	89 e5                	mov    %esp,%ebp
  806492:	56                   	push   %esi
  806493:	53                   	push   %ebx
  806494:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806497:	8b 1d 3c 44 b3 00    	mov    0xb3443c,%ebx
  80649d:	eb 02                	jmp    8064a1 <ip_route+0x12>
  80649f:	8b 1b                	mov    (%ebx),%ebx
  8064a1:	85 db                	test   %ebx,%ebx
  8064a3:	74 1c                	je     8064c1 <ip_route+0x32>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  8064a5:	83 ec 0c             	sub    $0xc,%esp
  8064a8:	53                   	push   %ebx
  8064a9:	e8 c0 e2 ff ff       	call   80476e <netif_is_up>
  8064ae:	83 c4 10             	add    $0x10,%esp
  8064b1:	84 c0                	test   %al,%al
  8064b3:	74 ea                	je     80649f <ip_route+0x10>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  8064b5:	8b 06                	mov    (%esi),%eax
  8064b7:	33 43 04             	xor    0x4(%ebx),%eax
  8064ba:	23 43 08             	and    0x8(%ebx),%eax
  8064bd:	75 e0                	jne    80649f <ip_route+0x10>
  8064bf:	eb 1e                	jmp    8064df <ip_route+0x50>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  8064c1:	a1 38 44 b3 00       	mov    0xb34438,%eax
  8064c6:	85 c0                	test   %eax,%eax
  8064c8:	74 1e                	je     8064e8 <ip_route+0x59>
  8064ca:	83 ec 0c             	sub    $0xc,%esp
  8064cd:	50                   	push   %eax
  8064ce:	e8 9b e2 ff ff       	call   80476e <netif_is_up>
  8064d3:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  8064d6:	84 c0                	test   %al,%al
  8064d8:	0f 45 1d 38 44 b3 00 	cmovne 0xb34438,%ebx
}
  8064df:	89 d8                	mov    %ebx,%eax
  8064e1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8064e4:	5b                   	pop    %ebx
  8064e5:	5e                   	pop    %esi
  8064e6:	5d                   	pop    %ebp
  8064e7:	c3                   	ret    
    return NULL;
  8064e8:	89 c3                	mov    %eax,%ebx
  8064ea:	eb f3                	jmp    8064df <ip_route+0x50>

008064ec <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  8064ec:	55                   	push   %ebp
  8064ed:	89 e5                	mov    %esp,%ebp
  8064ef:	57                   	push   %edi
  8064f0:	56                   	push   %esi
  8064f1:	53                   	push   %ebx
  8064f2:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  8064f5:	8b 45 08             	mov    0x8(%ebp),%eax
  8064f8:	8b 78 04             	mov    0x4(%eax),%edi
  if (IPH_V(iphdr) != 4) {
  8064fb:	0f b7 07             	movzwl (%edi),%eax
  8064fe:	50                   	push   %eax
  8064ff:	e8 8f 11 00 00       	call   807693 <ntohs>
  806504:	66 c1 e8 0c          	shr    $0xc,%ax
  806508:	83 c4 10             	add    $0x10,%esp
  80650b:	66 83 f8 04          	cmp    $0x4,%ax
  80650f:	74 1b                	je     80652c <ip_input+0x40>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  806511:	83 ec 0c             	sub    $0xc,%esp
  806514:	ff 75 08             	push   0x8(%ebp)
  806517:	e8 30 e3 ff ff       	call   80484c <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  80651c:	83 c4 10             	add    $0x10,%esp
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  80651f:	b8 00 00 00 00       	mov    $0x0,%eax
  806524:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806527:	5b                   	pop    %ebx
  806528:	5e                   	pop    %esi
  806529:	5f                   	pop    %edi
  80652a:	5d                   	pop    %ebp
  80652b:	c3                   	ret    
  iphdr_hlen = IPH_HL(iphdr);
  80652c:	83 ec 0c             	sub    $0xc,%esp
  80652f:	0f b7 07             	movzwl (%edi),%eax
  806532:	50                   	push   %eax
  806533:	e8 5b 11 00 00       	call   807693 <ntohs>
  806538:	66 c1 e8 06          	shr    $0x6,%ax
  iphdr_hlen *= 4;
  80653c:	83 e0 3c             	and    $0x3c,%eax
  80653f:	89 c6                	mov    %eax,%esi
  806541:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806545:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  806549:	89 04 24             	mov    %eax,(%esp)
  80654c:	e8 42 11 00 00       	call   807693 <ntohs>
  806551:	89 c3                	mov    %eax,%ebx
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806553:	83 c4 10             	add    $0x10,%esp
  806556:	8b 45 08             	mov    0x8(%ebp),%eax
  806559:	66 39 70 0a          	cmp    %si,0xa(%eax)
  80655d:	72 06                	jb     806565 <ip_input+0x79>
  80655f:	66 39 58 08          	cmp    %bx,0x8(%eax)
  806563:	73 10                	jae    806575 <ip_input+0x89>
    pbuf_free(p);
  806565:	83 ec 0c             	sub    $0xc,%esp
  806568:	ff 75 08             	push   0x8(%ebp)
  80656b:	e8 dc e2 ff ff       	call   80484c <pbuf_free>
    return ERR_OK;
  806570:	83 c4 10             	add    $0x10,%esp
  806573:	eb aa                	jmp    80651f <ip_input+0x33>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806575:	83 ec 08             	sub    $0x8,%esp
  806578:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80657c:	50                   	push   %eax
  80657d:	57                   	push   %edi
  80657e:	e8 d2 0f 00 00       	call   807555 <inet_chksum>
  806583:	83 c4 10             	add    $0x10,%esp
  806586:	66 85 c0             	test   %ax,%ax
  806589:	75 27                	jne    8065b2 <ip_input+0xc6>
  pbuf_realloc(p, iphdr_len);
  80658b:	83 ec 08             	sub    $0x8,%esp
  80658e:	0f b7 db             	movzwl %bx,%ebx
  806591:	53                   	push   %ebx
  806592:	ff 75 08             	push   0x8(%ebp)
  806595:	e8 d7 e5 ff ff       	call   804b71 <pbuf_realloc>
  80659a:	83 c4 10             	add    $0x10,%esp
    netif = inp;
  80659d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int first = 1;
  8065a0:	be 01 00 00 00       	mov    $0x1,%esi
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8065a5:	8d 47 10             	lea    0x10(%edi),%eax
  8065a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8065ab:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  8065ae:	89 df                	mov    %ebx,%edi
  8065b0:	eb 2e                	jmp    8065e0 <ip_input+0xf4>
    pbuf_free(p);
  8065b2:	83 ec 0c             	sub    $0xc,%esp
  8065b5:	ff 75 08             	push   0x8(%ebp)
  8065b8:	e8 8f e2 ff ff       	call   80484c <pbuf_free>
    return ERR_OK;
  8065bd:	83 c4 10             	add    $0x10,%esp
  8065c0:	e9 5a ff ff ff       	jmp    80651f <ip_input+0x33>
      if (first) {
  8065c5:	85 f6                	test   %esi,%esi
  8065c7:	74 51                	je     80661a <ip_input+0x12e>
        netif = netif_list;
  8065c9:	8b 1d 3c 44 b3 00    	mov    0xb3443c,%ebx
      if (netif == inp) {
  8065cf:	39 df                	cmp    %ebx,%edi
  8065d1:	74 4b                	je     80661e <ip_input+0x132>
  8065d3:	be 00 00 00 00       	mov    $0x0,%esi
    } while(netif != NULL);
  8065d8:	85 db                	test   %ebx,%ebx
  8065da:	0f 84 1b 01 00 00    	je     8066fb <ip_input+0x20f>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  8065e0:	83 ec 0c             	sub    $0xc,%esp
  8065e3:	53                   	push   %ebx
  8065e4:	e8 85 e1 ff ff       	call   80476e <netif_is_up>
  8065e9:	83 c4 10             	add    $0x10,%esp
  8065ec:	84 c0                	test   %al,%al
  8065ee:	74 d5                	je     8065c5 <ip_input+0xd9>
  8065f0:	8b 43 04             	mov    0x4(%ebx),%eax
  8065f3:	85 c0                	test   %eax,%eax
  8065f5:	74 ce                	je     8065c5 <ip_input+0xd9>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8065f7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8065fa:	3b 41 10             	cmp    0x10(%ecx),%eax
  8065fd:	74 4a                	je     806649 <ip_input+0x15d>
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8065ff:	83 ec 08             	sub    $0x8,%esp
  806602:	53                   	push   %ebx
  806603:	ff 75 dc             	push   -0x24(%ebp)
  806606:	e8 3f fe ff ff       	call   80644a <ip_addr_isbroadcast>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80660b:	83 c4 10             	add    $0x10,%esp
  80660e:	84 c0                	test   %al,%al
  806610:	74 b3                	je     8065c5 <ip_input+0xd9>
  806612:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806615:	e9 fc 00 00 00       	jmp    806716 <ip_input+0x22a>
        netif = netif->next;
  80661a:	8b 1b                	mov    (%ebx),%ebx
  80661c:	eb b1                	jmp    8065cf <ip_input+0xe3>
        netif = netif->next;
  80661e:	8b 1b                	mov    (%ebx),%ebx
  806620:	eb b1                	jmp    8065d3 <ip_input+0xe7>
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806622:	83 ec 0c             	sub    $0xc,%esp
  806625:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806629:	0f b7 44 07 02       	movzwl 0x2(%edi,%eax,1),%eax
  80662e:	50                   	push   %eax
  80662f:	e8 5f 10 00 00       	call   807693 <ntohs>
  806634:	83 c4 10             	add    $0x10,%esp
  806637:	66 83 f8 44          	cmp    $0x44,%ax
  80663b:	0f 85 d5 00 00 00    	jne    806716 <ip_input+0x22a>
        netif = inp;
  806641:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  806644:	e9 10 01 00 00       	jmp    806759 <ip_input+0x26d>
  806649:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80664c:	e9 c5 00 00 00       	jmp    806716 <ip_input+0x22a>
      pbuf_free(p);
  806651:	83 ec 0c             	sub    $0xc,%esp
  806654:	ff 75 08             	push   0x8(%ebp)
  806657:	e8 f0 e1 ff ff       	call   80484c <pbuf_free>
      return ERR_OK;
  80665c:	83 c4 10             	add    $0x10,%esp
  80665f:	e9 bb fe ff ff       	jmp    80651f <ip_input+0x33>
    pbuf_free(p);
  806664:	83 ec 0c             	sub    $0xc,%esp
  806667:	ff 75 08             	push   0x8(%ebp)
  80666a:	e8 dd e1 ff ff       	call   80484c <pbuf_free>
    return ERR_OK;
  80666f:	83 c4 10             	add    $0x10,%esp
  806672:	e9 a8 fe ff ff       	jmp    80651f <ip_input+0x33>
      udp_input(p, inp);
  806677:	83 ec 08             	sub    $0x8,%esp
  80667a:	ff 75 0c             	push   0xc(%ebp)
  80667d:	ff 75 08             	push   0x8(%ebp)
  806680:	e8 52 22 00 00       	call   8088d7 <udp_input>
      break;
  806685:	83 c4 10             	add    $0x10,%esp
  806688:	e9 92 fe ff ff       	jmp    80651f <ip_input+0x33>
      tcp_input(p, inp);
  80668d:	83 ec 08             	sub    $0x8,%esp
  806690:	ff 75 0c             	push   0xc(%ebp)
  806693:	ff 75 08             	push   0x8(%ebp)
  806696:	e8 62 69 00 00       	call   80cffd <tcp_input>
      break;
  80669b:	83 c4 10             	add    $0x10,%esp
  80669e:	e9 7c fe ff ff       	jmp    80651f <ip_input+0x33>
      icmp_input(p, inp);
  8066a3:	83 ec 08             	sub    $0x8,%esp
  8066a6:	ff 75 0c             	push   0xc(%ebp)
  8066a9:	ff 75 08             	push   0x8(%ebp)
  8066ac:	e8 e4 78 00 00       	call   80df95 <icmp_input>
      break;
  8066b1:	83 c4 10             	add    $0x10,%esp
  8066b4:	e9 66 fe ff ff       	jmp    80651f <ip_input+0x33>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  8066b9:	8b 5f 10             	mov    0x10(%edi),%ebx
  8066bc:	83 ec 0c             	sub    $0xc,%esp
  8066bf:	68 00 00 00 f0       	push   $0xf0000000
  8066c4:	e8 ff 11 00 00       	call   8078c8 <ntohl>
  8066c9:	21 c3                	and    %eax,%ebx
  8066cb:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8066d2:	e8 f1 11 00 00       	call   8078c8 <ntohl>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8066d7:	83 c4 10             	add    $0x10,%esp
  8066da:	39 c3                	cmp    %eax,%ebx
  8066dc:	0f 84 19 01 00 00    	je     8067fb <ip_input+0x30f>
        p->payload = iphdr;
  8066e2:	8b 45 08             	mov    0x8(%ebp),%eax
  8066e5:	89 78 04             	mov    %edi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  8066e8:	83 ec 08             	sub    $0x8,%esp
  8066eb:	6a 02                	push   $0x2
  8066ed:	50                   	push   %eax
  8066ee:	e8 bd 7b 00 00       	call   80e2b0 <icmp_dest_unreach>
  8066f3:	83 c4 10             	add    $0x10,%esp
  8066f6:	e9 00 01 00 00       	jmp    8067fb <ip_input+0x30f>
  8066fb:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  8066fe:	83 ec 0c             	sub    $0xc,%esp
  806701:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  806705:	50                   	push   %eax
  806706:	e8 88 0f 00 00       	call   807693 <ntohs>
  80670b:	83 c4 10             	add    $0x10,%esp
  80670e:	3c 11                	cmp    $0x11,%al
  806710:	0f 84 0c ff ff ff    	je     806622 <ip_input+0x136>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806716:	83 ec 08             	sub    $0x8,%esp
  806719:	ff 75 0c             	push   0xc(%ebp)
  80671c:	8d 47 0c             	lea    0xc(%edi),%eax
  80671f:	50                   	push   %eax
  806720:	e8 25 fd ff ff       	call   80644a <ip_addr_isbroadcast>
  806725:	83 c4 10             	add    $0x10,%esp
  806728:	84 c0                	test   %al,%al
  80672a:	0f 85 21 ff ff ff    	jne    806651 <ip_input+0x165>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806730:	8b 77 0c             	mov    0xc(%edi),%esi
  806733:	83 ec 0c             	sub    $0xc,%esp
  806736:	68 00 00 00 f0       	push   $0xf0000000
  80673b:	e8 88 11 00 00       	call   8078c8 <ntohl>
  806740:	21 c6                	and    %eax,%esi
  806742:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806749:	e8 7a 11 00 00       	call   8078c8 <ntohl>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  80674e:	83 c4 10             	add    $0x10,%esp
  806751:	39 c6                	cmp    %eax,%esi
  806753:	0f 84 f8 fe ff ff    	je     806651 <ip_input+0x165>
  if (netif == NULL) {
  806759:	85 db                	test   %ebx,%ebx
  80675b:	0f 84 03 ff ff ff    	je     806664 <ip_input+0x178>
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806761:	0f b7 5f 06          	movzwl 0x6(%edi),%ebx
  806765:	83 ec 0c             	sub    $0xc,%esp
  806768:	68 ff 3f 00 00       	push   $0x3fff
  80676d:	e8 14 0f 00 00       	call   807686 <htons>
  806772:	83 c4 10             	add    $0x10,%esp
  806775:	66 85 c3             	test   %ax,%bx
  806778:	74 1c                	je     806796 <ip_input+0x2aa>
    p = ip_reass(p);
  80677a:	83 ec 0c             	sub    $0xc,%esp
  80677d:	ff 75 08             	push   0x8(%ebp)
  806780:	e8 78 04 00 00       	call   806bfd <ip_reass>
  806785:	89 45 08             	mov    %eax,0x8(%ebp)
    if (p == NULL) {
  806788:	83 c4 10             	add    $0x10,%esp
  80678b:	85 c0                	test   %eax,%eax
  80678d:	0f 84 8c fd ff ff    	je     80651f <ip_input+0x33>
    iphdr = p->payload;
  806793:	8b 78 04             	mov    0x4(%eax),%edi
  if (raw_input(p, inp) == 0)
  806796:	83 ec 08             	sub    $0x8,%esp
  806799:	ff 75 0c             	push   0xc(%ebp)
  80679c:	ff 75 08             	push   0x8(%ebp)
  80679f:	e8 48 75 00 00       	call   80dcec <raw_input>
  8067a4:	83 c4 10             	add    $0x10,%esp
  8067a7:	84 c0                	test   %al,%al
  8067a9:	0f 85 70 fd ff ff    	jne    80651f <ip_input+0x33>
    switch (IPH_PROTO(iphdr)) {
  8067af:	83 ec 0c             	sub    $0xc,%esp
  8067b2:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8067b6:	50                   	push   %eax
  8067b7:	e8 d7 0e 00 00       	call   807693 <ntohs>
  8067bc:	89 c2                	mov    %eax,%edx
  8067be:	0f b6 c0             	movzbl %al,%eax
  8067c1:	83 c4 10             	add    $0x10,%esp
  8067c4:	80 fa 06             	cmp    $0x6,%dl
  8067c7:	0f 84 c0 fe ff ff    	je     80668d <ip_input+0x1a1>
  8067cd:	66 83 f8 11          	cmp    $0x11,%ax
  8067d1:	0f 84 a0 fe ff ff    	je     806677 <ip_input+0x18b>
  8067d7:	66 83 f8 01          	cmp    $0x1,%ax
  8067db:	0f 84 c2 fe ff ff    	je     8066a3 <ip_input+0x1b7>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8067e1:	83 ec 08             	sub    $0x8,%esp
  8067e4:	ff 75 0c             	push   0xc(%ebp)
  8067e7:	8d 47 10             	lea    0x10(%edi),%eax
  8067ea:	50                   	push   %eax
  8067eb:	e8 5a fc ff ff       	call   80644a <ip_addr_isbroadcast>
  8067f0:	83 c4 10             	add    $0x10,%esp
  8067f3:	84 c0                	test   %al,%al
  8067f5:	0f 84 be fe ff ff    	je     8066b9 <ip_input+0x1cd>
      pbuf_free(p);
  8067fb:	83 ec 0c             	sub    $0xc,%esp
  8067fe:	ff 75 08             	push   0x8(%ebp)
  806801:	e8 46 e0 ff ff       	call   80484c <pbuf_free>
  806806:	83 c4 10             	add    $0x10,%esp
  806809:	e9 11 fd ff ff       	jmp    80651f <ip_input+0x33>

0080680e <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  80680e:	55                   	push   %ebp
  80680f:	89 e5                	mov    %esp,%ebp
  806811:	57                   	push   %edi
  806812:	56                   	push   %esi
  806813:	53                   	push   %ebx
  806814:	83 ec 1c             	sub    $0x1c,%esp
  806817:	8b 75 08             	mov    0x8(%ebp),%esi
  80681a:	8b 7d 14             	mov    0x14(%ebp),%edi
  80681d:	8b 45 18             	mov    0x18(%ebp),%eax
  806820:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806823:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806826:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806829:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80682d:	0f 84 2c 01 00 00    	je     80695f <ip_output_if+0x151>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806833:	83 ec 08             	sub    $0x8,%esp
  806836:	6a 14                	push   $0x14
  806838:	56                   	push   %esi
  806839:	e8 3f df ff ff       	call   80477d <pbuf_header>
  80683e:	83 c4 10             	add    $0x10,%esp
  806841:	84 c0                	test   %al,%al
  806843:	0f 85 35 01 00 00    	jne    80697e <ip_output_if+0x170>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806849:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  80684c:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806851:	0f 86 f1 00 00 00    	jbe    806948 <ip_output_if+0x13a>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806857:	83 ec 0c             	sub    $0xc,%esp
  80685a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80685e:	50                   	push   %eax
  80685f:	e8 2f 0e 00 00       	call   807693 <ntohs>
  806864:	0f b6 c0             	movzbl %al,%eax
  806867:	c1 e7 08             	shl    $0x8,%edi
  80686a:	09 c7                	or     %eax,%edi
  80686c:	0f b7 ff             	movzwl %di,%edi
  80686f:	89 3c 24             	mov    %edi,(%esp)
  806872:	e8 0f 0e 00 00       	call   807686 <htons>
  806877:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  80687b:	0f b7 c0             	movzwl %ax,%eax
  80687e:	89 04 24             	mov    %eax,(%esp)
  806881:	e8 0d 0e 00 00       	call   807693 <ntohs>
  806886:	b0 00                	mov    $0x0,%al
  806888:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  80688c:	09 d0                	or     %edx,%eax
  80688e:	0f b7 c0             	movzwl %ax,%eax
  806891:	89 04 24             	mov    %eax,(%esp)
  806894:	e8 ed 0d 00 00       	call   807686 <htons>
  806899:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  80689d:	8b 45 10             	mov    0x10(%ebp),%eax
  8068a0:	8b 00                	mov    (%eax),%eax
  8068a2:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  8068a5:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8068a9:	80 cc 45             	or     $0x45,%ah
  8068ac:	89 04 24             	mov    %eax,(%esp)
  8068af:	e8 d2 0d 00 00       	call   807686 <htons>
  8068b4:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  8068b7:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8068bb:	89 04 24             	mov    %eax,(%esp)
  8068be:	e8 c3 0d 00 00       	call   807686 <htons>
  8068c3:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  8068c7:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  8068cd:	0f b7 05 5e 44 b3 00 	movzwl 0xb3445e,%eax
  8068d4:	89 04 24             	mov    %eax,(%esp)
  8068d7:	e8 aa 0d 00 00       	call   807686 <htons>
  8068dc:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  8068e0:	66 83 05 5e 44 b3 00 	addw   $0x1,0xb3445e
  8068e7:	01 

    if (ip_addr_isany(src)) {
  8068e8:	83 c4 10             	add    $0x10,%esp
  8068eb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8068ef:	74 09                	je     8068fa <ip_output_if+0xec>
  8068f1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8068f4:	8b 00                	mov    (%eax),%eax
  8068f6:	85 c0                	test   %eax,%eax
  8068f8:	75 06                	jne    806900 <ip_output_if+0xf2>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  8068fa:	8b 45 20             	mov    0x20(%ebp),%eax
  8068fd:	8b 40 04             	mov    0x4(%eax),%eax
  806900:	89 43 0c             	mov    %eax,0xc(%ebx)
    } else {
      ip_addr_set(&(iphdr->src), src);
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806903:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806909:	83 ec 08             	sub    $0x8,%esp
  80690c:	6a 14                	push   $0x14
  80690e:	53                   	push   %ebx
  80690f:	e8 41 0c 00 00       	call   807555 <inet_chksum>
  806914:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806918:	83 c4 10             	add    $0x10,%esp
    dest = &(iphdr->dest);
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  80691b:	8b 45 20             	mov    0x20(%ebp),%eax
  80691e:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806922:	66 85 c0             	test   %ax,%ax
  806925:	74 06                	je     80692d <ip_output_if+0x11f>
  806927:	66 3b 46 08          	cmp    0x8(%esi),%ax
  80692b:	72 3d                	jb     80696a <ip_output_if+0x15c>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  80692d:	83 ec 04             	sub    $0x4,%esp
  806930:	ff 75 10             	push   0x10(%ebp)
  806933:	56                   	push   %esi
  806934:	ff 75 20             	push   0x20(%ebp)
  806937:	8b 45 20             	mov    0x20(%ebp),%eax
  80693a:	ff 50 14             	call   *0x14(%eax)
  80693d:	83 c4 10             	add    $0x10,%esp
  }
}
  806940:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806943:	5b                   	pop    %ebx
  806944:	5e                   	pop    %esi
  806945:	5f                   	pop    %edi
  806946:	5d                   	pop    %ebp
  806947:	c3                   	ret    
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806948:	83 ec 04             	sub    $0x4,%esp
  80694b:	68 ac 1c 81 00       	push   $0x811cac
  806950:	68 ed 01 00 00       	push   $0x1ed
  806955:	68 d9 1c 81 00       	push   $0x811cd9
  80695a:	e8 77 7b 00 00       	call   80e4d6 <_panic>
    dest = &(iphdr->dest);
  80695f:	8b 46 04             	mov    0x4(%esi),%eax
  806962:	83 c0 10             	add    $0x10,%eax
  806965:	89 45 10             	mov    %eax,0x10(%ebp)
  806968:	eb b1                	jmp    80691b <ip_output_if+0x10d>
    return ip_frag(p,netif,dest);
  80696a:	83 ec 04             	sub    $0x4,%esp
  80696d:	ff 75 10             	push   0x10(%ebp)
  806970:	ff 75 20             	push   0x20(%ebp)
  806973:	56                   	push   %esi
  806974:	e8 58 07 00 00       	call   8070d1 <ip_frag>
  806979:	83 c4 10             	add    $0x10,%esp
  80697c:	eb c2                	jmp    806940 <ip_output_if+0x132>
      return ERR_BUF;
  80697e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  806983:	eb bb                	jmp    806940 <ip_output_if+0x132>

00806985 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806985:	55                   	push   %ebp
  806986:	89 e5                	mov    %esp,%ebp
  806988:	57                   	push   %edi
  806989:	56                   	push   %esi
  80698a:	53                   	push   %ebx
  80698b:	83 ec 18             	sub    $0x18,%esp
  80698e:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806991:	8b 75 18             	mov    0x18(%ebp),%esi
  806994:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806997:	ff 75 10             	push   0x10(%ebp)
  80699a:	e8 f0 fa ff ff       	call   80648f <ip_route>
  80699f:	83 c4 10             	add    $0x10,%esp
  8069a2:	85 c0                	test   %eax,%eax
  8069a4:	74 2d                	je     8069d3 <ip_output+0x4e>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  8069a6:	83 ec 04             	sub    $0x4,%esp
  8069a9:	50                   	push   %eax
  8069aa:	89 f8                	mov    %edi,%eax
  8069ac:	0f b6 f8             	movzbl %al,%edi
  8069af:	57                   	push   %edi
  8069b0:	89 f0                	mov    %esi,%eax
  8069b2:	0f b6 f0             	movzbl %al,%esi
  8069b5:	56                   	push   %esi
  8069b6:	0f b6 db             	movzbl %bl,%ebx
  8069b9:	53                   	push   %ebx
  8069ba:	ff 75 10             	push   0x10(%ebp)
  8069bd:	ff 75 0c             	push   0xc(%ebp)
  8069c0:	ff 75 08             	push   0x8(%ebp)
  8069c3:	e8 46 fe ff ff       	call   80680e <ip_output_if>
  8069c8:	83 c4 20             	add    $0x20,%esp
}
  8069cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8069ce:	5b                   	pop    %ebx
  8069cf:	5e                   	pop    %esi
  8069d0:	5f                   	pop    %edi
  8069d1:	5d                   	pop    %ebp
  8069d2:	c3                   	ret    
    return ERR_RTE;
  8069d3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8069d8:	eb f1                	jmp    8069cb <ip_output+0x46>

008069da <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8069da:	55                   	push   %ebp
  8069db:	89 e5                	mov    %esp,%ebp
  8069dd:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  8069e0:	39 05 40 4a b3 00    	cmp    %eax,0xb34a40
  8069e6:	74 18                	je     806a00 <ip_reass_dequeue_datagram+0x26>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  8069e8:	85 d2                	test   %edx,%edx
  8069ea:	74 1e                	je     806a0a <ip_reass_dequeue_datagram+0x30>
    prev->next = ipr->next;
  8069ec:	8b 08                	mov    (%eax),%ecx
  8069ee:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  8069f0:	83 ec 08             	sub    $0x8,%esp
  8069f3:	50                   	push   %eax
  8069f4:	6a 05                	push   $0x5
  8069f6:	e8 00 db ff ff       	call   8044fb <memp_free>
}
  8069fb:	83 c4 10             	add    $0x10,%esp
  8069fe:	c9                   	leave  
  8069ff:	c3                   	ret    
    reassdatagrams = ipr->next;
  806a00:	8b 10                	mov    (%eax),%edx
  806a02:	89 15 40 4a b3 00    	mov    %edx,0xb34a40
  806a08:	eb e6                	jmp    8069f0 <ip_reass_dequeue_datagram+0x16>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806a0a:	83 ec 04             	sub    $0x4,%esp
  806a0d:	68 f1 1c 81 00       	push   $0x811cf1
  806a12:	68 29 01 00 00       	push   $0x129
  806a17:	68 0a 1d 81 00       	push   $0x811d0a
  806a1c:	e8 b5 7a 00 00       	call   80e4d6 <_panic>

00806a21 <ip_reass_free_complete_datagram>:
{
  806a21:	55                   	push   %ebp
  806a22:	89 e5                	mov    %esp,%ebp
  806a24:	57                   	push   %edi
  806a25:	56                   	push   %esi
  806a26:	53                   	push   %ebx
  806a27:	83 ec 1c             	sub    $0x1c,%esp
  806a2a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806a2d:	89 55 e0             	mov    %edx,-0x20(%ebp)
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806a30:	39 c2                	cmp    %eax,%edx
  806a32:	74 2e                	je     806a62 <ip_reass_free_complete_datagram+0x41>
  if (prev != NULL) {
  806a34:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806a37:	85 c0                	test   %eax,%eax
  806a39:	74 07                	je     806a42 <ip_reass_free_complete_datagram+0x21>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806a3b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806a3e:	39 08                	cmp    %ecx,(%eax)
  806a40:	75 37                	jne    806a79 <ip_reass_free_complete_datagram+0x58>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806a42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a45:	8b 58 04             	mov    0x4(%eax),%ebx
  806a48:	8b 43 04             	mov    0x4(%ebx),%eax
  int pbufs_freed = 0;
  806a4b:	be 00 00 00 00       	mov    $0x0,%esi
  if (iprh->start == 0) {
  806a50:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806a55:	74 39                	je     806a90 <ip_reass_free_complete_datagram+0x6f>
  p = ipr->p;
  806a57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a5a:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806a5d:	e9 8a 00 00 00       	jmp    806aec <ip_reass_free_complete_datagram+0xcb>
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806a62:	83 ec 04             	sub    $0x4,%esp
  806a65:	68 27 1d 81 00       	push   $0x811d27
  806a6a:	68 99 00 00 00       	push   $0x99
  806a6f:	68 0a 1d 81 00       	push   $0x811d0a
  806a74:	e8 5d 7a 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806a79:	83 ec 04             	sub    $0x4,%esp
  806a7c:	68 33 1d 81 00       	push   $0x811d33
  806a81:	68 9b 00 00 00       	push   $0x9b
  806a86:	68 0a 1d 81 00       	push   $0x811d0a
  806a8b:	e8 46 7a 00 00       	call   80e4d6 <_panic>
    ipr->p = iprh->next_pbuf;
  806a90:	8b 00                	mov    (%eax),%eax
  806a92:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806a95:	89 42 04             	mov    %eax,0x4(%edx)
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806a98:	83 ec 04             	sub    $0x4,%esp
  806a9b:	6a 14                	push   $0x14
  806a9d:	8d 42 08             	lea    0x8(%edx),%eax
  806aa0:	50                   	push   %eax
  806aa1:	ff 73 04             	push   0x4(%ebx)
  806aa4:	e8 da 82 00 00       	call   80ed83 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806aa9:	83 c4 08             	add    $0x8,%esp
  806aac:	6a 01                	push   $0x1
  806aae:	53                   	push   %ebx
  806aaf:	e8 df 78 00 00       	call   80e393 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806ab4:	89 1c 24             	mov    %ebx,(%esp)
  806ab7:	e8 c7 e1 ff ff       	call   804c83 <pbuf_clen>
  806abc:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806abf:	89 1c 24             	mov    %ebx,(%esp)
  806ac2:	e8 85 dd ff ff       	call   80484c <pbuf_free>
  806ac7:	83 c4 10             	add    $0x10,%esp
  806aca:	eb 8b                	jmp    806a57 <ip_reass_free_complete_datagram+0x36>
    iprh = (struct ip_reass_helper *)p->payload;
  806acc:	8b 43 04             	mov    0x4(%ebx),%eax
    p = iprh->next_pbuf;
  806acf:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806ad1:	83 ec 0c             	sub    $0xc,%esp
  806ad4:	53                   	push   %ebx
  806ad5:	e8 a9 e1 ff ff       	call   804c83 <pbuf_clen>
  806ada:	0f b6 c0             	movzbl %al,%eax
  806add:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806adf:	89 1c 24             	mov    %ebx,(%esp)
  806ae2:	e8 65 dd ff ff       	call   80484c <pbuf_free>
  806ae7:	83 c4 10             	add    $0x10,%esp
    p = iprh->next_pbuf;
  806aea:	89 fb                	mov    %edi,%ebx
  while (p != NULL) {
  806aec:	85 db                	test   %ebx,%ebx
  806aee:	75 dc                	jne    806acc <ip_reass_free_complete_datagram+0xab>
  ip_reass_dequeue_datagram(ipr, prev);
  806af0:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806af3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806af6:	e8 df fe ff ff       	call   8069da <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806afb:	0f b7 05 3c 4a b3 00 	movzwl 0xb34a3c,%eax
  806b02:	0f b7 d0             	movzwl %ax,%edx
  806b05:	39 f2                	cmp    %esi,%edx
  806b07:	7c 12                	jl     806b1b <ip_reass_free_complete_datagram+0xfa>
  ip_reass_pbufcount -= pbufs_freed;
  806b09:	29 f0                	sub    %esi,%eax
  806b0b:	66 a3 3c 4a b3 00    	mov    %ax,0xb34a3c
}
  806b11:	89 f0                	mov    %esi,%eax
  806b13:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806b16:	5b                   	pop    %ebx
  806b17:	5e                   	pop    %esi
  806b18:	5f                   	pop    %edi
  806b19:	5d                   	pop    %ebp
  806b1a:	c3                   	ret    
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806b1b:	83 ec 04             	sub    $0x4,%esp
  806b1e:	68 45 1d 81 00       	push   $0x811d45
  806b23:	68 bc 00 00 00       	push   $0xbc
  806b28:	68 0a 1d 81 00       	push   $0x811d0a
  806b2d:	e8 a4 79 00 00       	call   80e4d6 <_panic>

00806b32 <ip_reass_remove_oldest_datagram>:
{
  806b32:	55                   	push   %ebp
  806b33:	89 e5                	mov    %esp,%ebp
  806b35:	57                   	push   %edi
  806b36:	56                   	push   %esi
  806b37:	53                   	push   %ebx
  806b38:	83 ec 1c             	sub    $0x1c,%esp
  806b3b:	89 c6                	mov    %eax,%esi
  806b3d:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0, pbufs_freed_current;
  806b40:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  806b47:	eb 5b                	jmp    806ba4 <ip_reass_remove_oldest_datagram+0x72>
        other_datagrams++;
  806b49:	83 c3 01             	add    $0x1,%ebx
        if (oldest == NULL) {
  806b4c:	85 c9                	test   %ecx,%ecx
  806b4e:	74 33                	je     806b83 <ip_reass_remove_oldest_datagram+0x51>
          oldest = r;
  806b50:	0f b6 51 1f          	movzbl 0x1f(%ecx),%edx
  806b54:	38 50 1f             	cmp    %dl,0x1f(%eax)
  806b57:	0f 46 c8             	cmovbe %eax,%ecx
      if (r->next != NULL) {
  806b5a:	8b 10                	mov    (%eax),%edx
        prev = r;
  806b5c:	85 d2                	test   %edx,%edx
  806b5e:	0f 45 f8             	cmovne %eax,%edi
  806b61:	89 d0                	mov    %edx,%eax
    while (r != NULL) {
  806b63:	85 c0                	test   %eax,%eax
  806b65:	74 20                	je     806b87 <ip_reass_remove_oldest_datagram+0x55>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806b67:	8b 56 0c             	mov    0xc(%esi),%edx
  806b6a:	39 50 14             	cmp    %edx,0x14(%eax)
  806b6d:	75 da                	jne    806b49 <ip_reass_remove_oldest_datagram+0x17>
  806b6f:	8b 56 10             	mov    0x10(%esi),%edx
  806b72:	39 50 18             	cmp    %edx,0x18(%eax)
  806b75:	75 d2                	jne    806b49 <ip_reass_remove_oldest_datagram+0x17>
  806b77:	0f b7 56 04          	movzwl 0x4(%esi),%edx
  806b7b:	66 39 50 0c          	cmp    %dx,0xc(%eax)
  806b7f:	75 c8                	jne    806b49 <ip_reass_remove_oldest_datagram+0x17>
  806b81:	eb d7                	jmp    806b5a <ip_reass_remove_oldest_datagram+0x28>
          oldest = r;
  806b83:	89 c1                	mov    %eax,%ecx
  806b85:	eb d3                	jmp    806b5a <ip_reass_remove_oldest_datagram+0x28>
    if (oldest != NULL) {
  806b87:	85 c9                	test   %ecx,%ecx
  806b89:	74 0c                	je     806b97 <ip_reass_remove_oldest_datagram+0x65>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806b8b:	89 fa                	mov    %edi,%edx
  806b8d:	89 c8                	mov    %ecx,%eax
  806b8f:	e8 8d fe ff ff       	call   806a21 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806b94:	01 45 e4             	add    %eax,-0x1c(%ebp)
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806b97:	8b 7d e0             	mov    -0x20(%ebp),%edi
  806b9a:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  806b9d:	7d 1b                	jge    806bba <ip_reass_remove_oldest_datagram+0x88>
  806b9f:	83 fb 01             	cmp    $0x1,%ebx
  806ba2:	7e 16                	jle    806bba <ip_reass_remove_oldest_datagram+0x88>
    r = reassdatagrams;
  806ba4:	a1 40 4a b3 00       	mov    0xb34a40,%eax
    other_datagrams = 0;
  806ba9:	bb 00 00 00 00       	mov    $0x0,%ebx
    prev = NULL;
  806bae:	bf 00 00 00 00       	mov    $0x0,%edi
    oldest = NULL;
  806bb3:	b9 00 00 00 00       	mov    $0x0,%ecx
    while (r != NULL) {
  806bb8:	eb a9                	jmp    806b63 <ip_reass_remove_oldest_datagram+0x31>
}
  806bba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806bbd:	83 c4 1c             	add    $0x1c,%esp
  806bc0:	5b                   	pop    %ebx
  806bc1:	5e                   	pop    %esi
  806bc2:	5f                   	pop    %edi
  806bc3:	5d                   	pop    %ebp
  806bc4:	c3                   	ret    

00806bc5 <ip_reass_tmr>:
{
  806bc5:	55                   	push   %ebp
  806bc6:	89 e5                	mov    %esp,%ebp
  806bc8:	56                   	push   %esi
  806bc9:	53                   	push   %ebx
  r = reassdatagrams;
  806bca:	a1 40 4a b3 00       	mov    0xb34a40,%eax
  struct ip_reassdata *r, *prev = NULL;
  806bcf:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (r != NULL) {
  806bd4:	eb 0a                	jmp    806be0 <ip_reass_tmr+0x1b>
      r->timer--;
  806bd6:	83 ea 01             	sub    $0x1,%edx
  806bd9:	88 50 1f             	mov    %dl,0x1f(%eax)
      prev = r;
  806bdc:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806bde:	8b 00                	mov    (%eax),%eax
  while (r != NULL) {
  806be0:	85 c0                	test   %eax,%eax
  806be2:	74 15                	je     806bf9 <ip_reass_tmr+0x34>
    if (r->timer > 0) {
  806be4:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806be8:	84 d2                	test   %dl,%dl
  806bea:	75 ea                	jne    806bd6 <ip_reass_tmr+0x11>
      r = r->next;
  806bec:	8b 30                	mov    (%eax),%esi
      ip_reass_free_complete_datagram(tmp, prev);
  806bee:	89 da                	mov    %ebx,%edx
  806bf0:	e8 2c fe ff ff       	call   806a21 <ip_reass_free_complete_datagram>
      r = r->next;
  806bf5:	89 f0                	mov    %esi,%eax
  806bf7:	eb e7                	jmp    806be0 <ip_reass_tmr+0x1b>
}
  806bf9:	5b                   	pop    %ebx
  806bfa:	5e                   	pop    %esi
  806bfb:	5d                   	pop    %ebp
  806bfc:	c3                   	ret    

00806bfd <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806bfd:	55                   	push   %ebp
  806bfe:	89 e5                	mov    %esp,%ebp
  806c00:	57                   	push   %edi
  806c01:	56                   	push   %esi
  806c02:	53                   	push   %ebx
  806c03:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806c06:	8b 45 08             	mov    0x8(%ebp),%eax
  806c09:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806c0c:	0f b7 03             	movzwl (%ebx),%eax
  806c0f:	50                   	push   %eax
  806c10:	e8 7e 0a 00 00       	call   807693 <ntohs>
  806c15:	66 c1 e8 08          	shr    $0x8,%ax
  806c19:	83 e0 0f             	and    $0xf,%eax
  806c1c:	83 c4 10             	add    $0x10,%esp
  806c1f:	66 83 f8 05          	cmp    $0x5,%ax
  806c23:	0f 85 de 01 00 00    	jne    806e07 <ip_reass+0x20a>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806c29:	83 ec 0c             	sub    $0xc,%esp
  806c2c:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806c30:	50                   	push   %eax
  806c31:	e8 5d 0a 00 00       	call   807693 <ntohs>
  806c36:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806c3a:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806c3e:	89 04 24             	mov    %eax,(%esp)
  806c41:	e8 4d 0a 00 00       	call   807693 <ntohs>
  806c46:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  806c4a:	0f b7 03             	movzwl (%ebx),%eax
  806c4d:	89 04 24             	mov    %eax,(%esp)
  806c50:	e8 3e 0a 00 00       	call   807693 <ntohs>
  806c55:	66 89 45 d8          	mov    %ax,-0x28(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806c59:	83 c4 04             	add    $0x4,%esp
  806c5c:	ff 75 08             	push   0x8(%ebp)
  806c5f:	e8 1f e0 ff ff       	call   804c83 <pbuf_clen>
  806c64:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806c67:	0f b6 f0             	movzbl %al,%esi
  806c6a:	0f b7 05 3c 4a b3 00 	movzwl 0xb34a3c,%eax
  806c71:	01 f0                	add    %esi,%eax
  806c73:	83 c4 10             	add    $0x10,%esp
  806c76:	83 f8 0a             	cmp    $0xa,%eax
  806c79:	7f 0d                	jg     806c88 <ip_reass+0x8b>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806c7b:	8b 3d 40 4a b3 00    	mov    0xb34a40,%edi
  struct ip_reassdata *ipr_prev = NULL;
  806c81:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806c86:	eb 28                	jmp    806cb0 <ip_reass+0xb3>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806c88:	89 f2                	mov    %esi,%edx
  806c8a:	89 d8                	mov    %ebx,%eax
  806c8c:	e8 a1 fe ff ff       	call   806b32 <ip_reass_remove_oldest_datagram>
  806c91:	85 c0                	test   %eax,%eax
  806c93:	0f 84 6e 01 00 00    	je     806e07 <ip_reass+0x20a>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  806c99:	0f b7 05 3c 4a b3 00 	movzwl 0xb34a3c,%eax
  806ca0:	01 f0                	add    %esi,%eax
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806ca2:	83 f8 0a             	cmp    $0xa,%eax
  806ca5:	7e d4                	jle    806c7b <ip_reass+0x7e>
  806ca7:	e9 5b 01 00 00       	jmp    806e07 <ip_reass+0x20a>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806cac:	89 f8                	mov    %edi,%eax
  806cae:	8b 3f                	mov    (%edi),%edi
  806cb0:	85 ff                	test   %edi,%edi
  806cb2:	0f 84 f7 00 00 00    	je     806daf <ip_reass+0x1b2>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806cb8:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806cbb:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806cbe:	75 ec                	jne    806cac <ip_reass+0xaf>
  806cc0:	8b 53 10             	mov    0x10(%ebx),%edx
  806cc3:	39 57 18             	cmp    %edx,0x18(%edi)
  806cc6:	75 e4                	jne    806cac <ip_reass+0xaf>
  806cc8:	0f b7 53 04          	movzwl 0x4(%ebx),%edx
  806ccc:	66 39 57 0c          	cmp    %dx,0xc(%edi)
  806cd0:	75 da                	jne    806cac <ip_reass+0xaf>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806cd2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  806cd5:	83 ec 0c             	sub    $0xc,%esp
  806cd8:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806cdc:	50                   	push   %eax
  806cdd:	e8 b1 09 00 00       	call   807693 <ntohs>
  806ce2:	83 c4 10             	add    $0x10,%esp
  806ce5:	66 a9 ff 1f          	test   $0x1fff,%ax
  806ce9:	0f 84 4d 01 00 00    	je     806e3c <ip_reass+0x23f>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806cef:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806cf3:	66 01 05 3c 4a b3 00 	add    %ax,0xb34a3c

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806cfa:	83 ec 0c             	sub    $0xc,%esp
  806cfd:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d01:	50                   	push   %eax
  806d02:	e8 8c 09 00 00       	call   807693 <ntohs>
  806d07:	83 c4 10             	add    $0x10,%esp
  806d0a:	f6 c4 20             	test   $0x20,%ah
  806d0d:	75 20                	jne    806d2f <ip_reass+0x132>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806d0f:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806d13:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806d17:	0f b7 75 de          	movzwl -0x22(%ebp),%esi
  806d1b:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d1e:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  806d22:	66 c1 ea 06          	shr    $0x6,%dx
  806d26:	83 e2 3c             	and    $0x3c,%edx
    ipr->datagram_len = offset + len;
  806d29:	29 d0                	sub    %edx,%eax
  806d2b:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806d2f:	8b 45 08             	mov    0x8(%ebp),%eax
  806d32:	8b 70 04             	mov    0x4(%eax),%esi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d35:	83 ec 0c             	sub    $0xc,%esp
  806d38:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  806d3c:	50                   	push   %eax
  806d3d:	e8 51 09 00 00       	call   807693 <ntohs>
  806d42:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  806d46:	0f b7 06             	movzwl (%esi),%eax
  806d49:	89 04 24             	mov    %eax,(%esp)
  806d4c:	e8 42 09 00 00       	call   807693 <ntohs>
  806d51:	89 c3                	mov    %eax,%ebx
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806d53:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  806d57:	89 04 24             	mov    %eax,(%esp)
  806d5a:	e8 34 09 00 00       	call   807693 <ntohs>
  806d5f:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
  iprh = (struct ip_reass_helper*)new_p->payload;
  806d66:	8b 55 08             	mov    0x8(%ebp),%edx
  806d69:	8b 72 04             	mov    0x4(%edx),%esi
  806d6c:	89 75 e0             	mov    %esi,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  806d6f:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  iprh->start = offset;
  806d75:	66 89 4e 04          	mov    %cx,0x4(%esi)
  iprh->end = offset + len;
  806d79:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806d7d:	01 c8                	add    %ecx,%eax
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d7f:	66 c1 eb 06          	shr    $0x6,%bx
  806d83:	83 e3 3c             	and    $0x3c,%ebx
  iprh->end = offset + len;
  806d86:	29 d8                	sub    %ebx,%eax
  806d88:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  806d8c:	66 89 46 06          	mov    %ax,0x6(%esi)
  for (q = ipr->p; q != NULL;) {
  806d90:	8b 47 04             	mov    0x4(%edi),%eax
  806d93:	89 45 d8             	mov    %eax,-0x28(%ebp)
  806d96:	83 c4 10             	add    $0x10,%esp
  806d99:	89 c3                	mov    %eax,%ebx
  int valid = 1;
  806d9b:	b8 01 00 00 00       	mov    $0x1,%eax
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806da0:	be 00 00 00 00       	mov    $0x0,%esi
  806da5:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806da8:	89 c7                	mov    %eax,%edi
  for (q = ipr->p; q != NULL;) {
  806daa:	e9 3f 01 00 00       	jmp    806eee <ip_reass+0x2f1>
  ipr = memp_malloc(MEMP_REASSDATA);
  806daf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  806db2:	83 ec 0c             	sub    $0xc,%esp
  806db5:	6a 05                	push   $0x5
  806db7:	e8 e9 d6 ff ff       	call   8044a5 <memp_malloc>
  806dbc:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806dbe:	83 c4 10             	add    $0x10,%esp
  806dc1:	85 c0                	test   %eax,%eax
  806dc3:	74 35                	je     806dfa <ip_reass+0x1fd>
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806dc5:	83 ec 04             	sub    $0x4,%esp
  806dc8:	6a 20                	push   $0x20
  806dca:	6a 00                	push   $0x0
  806dcc:	57                   	push   %edi
  806dcd:	e8 09 7f 00 00       	call   80ecdb <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806dd2:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)
  ipr->next = reassdatagrams;
  806dd6:	a1 40 4a b3 00       	mov    0xb34a40,%eax
  806ddb:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806ddd:	89 3d 40 4a b3 00    	mov    %edi,0xb34a40
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806de3:	83 c4 0c             	add    $0xc,%esp
  806de6:	6a 14                	push   $0x14
  806de8:	53                   	push   %ebx
  806de9:	8d 47 08             	lea    0x8(%edi),%eax
  806dec:	50                   	push   %eax
  806ded:	e8 91 7f 00 00       	call   80ed83 <memcpy>
  806df2:	83 c4 10             	add    $0x10,%esp
  806df5:	e9 f5 fe ff ff       	jmp    806cef <ip_reass+0xf2>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806dfa:	89 f2                	mov    %esi,%edx
  806dfc:	89 d8                	mov    %ebx,%eax
  806dfe:	e8 2f fd ff ff       	call   806b32 <ip_reass_remove_oldest_datagram>
  806e03:	39 c6                	cmp    %eax,%esi
  806e05:	7e 20                	jle    806e27 <ip_reass+0x22a>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  806e07:	83 ec 0c             	sub    $0xc,%esp
  806e0a:	ff 75 08             	push   0x8(%ebp)
  806e0d:	e8 3a da ff ff       	call   80484c <pbuf_free>
  return NULL;
  806e12:	83 c4 10             	add    $0x10,%esp
  806e15:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  806e1c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806e1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806e22:	5b                   	pop    %ebx
  806e23:	5e                   	pop    %esi
  806e24:	5f                   	pop    %edi
  806e25:	5d                   	pop    %ebp
  806e26:	c3                   	ret    
      ipr = memp_malloc(MEMP_REASSDATA);
  806e27:	83 ec 0c             	sub    $0xc,%esp
  806e2a:	6a 05                	push   $0x5
  806e2c:	e8 74 d6 ff ff       	call   8044a5 <memp_malloc>
  806e31:	89 c7                	mov    %eax,%edi
    if (ipr == NULL)
  806e33:	83 c4 10             	add    $0x10,%esp
  806e36:	85 c0                	test   %eax,%eax
  806e38:	75 8b                	jne    806dc5 <ip_reass+0x1c8>
  806e3a:	eb cb                	jmp    806e07 <ip_reass+0x20a>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806e3c:	83 ec 0c             	sub    $0xc,%esp
  806e3f:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  806e43:	50                   	push   %eax
  806e44:	e8 4a 08 00 00       	call   807693 <ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806e49:	83 c4 10             	add    $0x10,%esp
  806e4c:	66 a9 ff 1f          	test   $0x1fff,%ax
  806e50:	0f 84 99 fe ff ff    	je     806cef <ip_reass+0xf2>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  806e56:	83 ec 04             	sub    $0x4,%esp
  806e59:	6a 14                	push   $0x14
  806e5b:	53                   	push   %ebx
  806e5c:	8d 47 08             	lea    0x8(%edi),%eax
  806e5f:	50                   	push   %eax
  806e60:	e8 1e 7f 00 00       	call   80ed83 <memcpy>
  806e65:	83 c4 10             	add    $0x10,%esp
  806e68:	e9 82 fe ff ff       	jmp    806cef <ip_reass+0xf2>
      iprh->next_pbuf = q;
  806e6d:	89 7d d0             	mov    %edi,-0x30(%ebp)
  806e70:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806e73:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806e76:	89 1a                	mov    %ebx,(%edx)
      if (iprh_prev != NULL) {
  806e78:	85 f6                	test   %esi,%esi
  806e7a:	74 66                	je     806ee2 <ip_reass+0x2e5>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  806e7c:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  806e80:	0f 82 a3 01 00 00    	jb     807029 <ip_reass+0x42c>
  806e86:	0f b7 4d de          	movzwl -0x22(%ebp),%ecx
  806e8a:	66 3b 48 04          	cmp    0x4(%eax),%cx
  806e8e:	0f 87 95 01 00 00    	ja     807029 <ip_reass+0x42c>
        iprh_prev->next_pbuf = new_p;
  806e94:	8b 45 08             	mov    0x8(%ebp),%eax
  806e97:	89 06                	mov    %eax,(%esi)
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  806e99:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  806e9d:	0f 84 a9 01 00 00    	je     80704c <ip_reass+0x44f>
    if (valid) {
  806ea3:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  806ea7:	0f 84 9f 01 00 00    	je     80704c <ip_reass+0x44f>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  806ead:	8b 4f 04             	mov    0x4(%edi),%ecx
  806eb0:	8b 59 04             	mov    0x4(%ecx),%ebx
  806eb3:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  806eb8:	0f 85 8e 01 00 00    	jne    80704c <ip_reass+0x44f>
        q = iprh->next_pbuf;
  806ebe:	8b 75 e0             	mov    -0x20(%ebp),%esi
  806ec1:	8b 16                	mov    (%esi),%edx
        while (q != NULL) {
  806ec3:	85 d2                	test   %edx,%edx
  806ec5:	0f 84 9c 00 00 00    	je     806f67 <ip_reass+0x36a>
          iprh = (struct ip_reass_helper*)q->payload;
  806ecb:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  806ece:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  806ed2:	66 39 56 06          	cmp    %dx,0x6(%esi)
  806ed6:	0f 85 70 01 00 00    	jne    80704c <ip_reass+0x44f>
          q = iprh->next_pbuf;
  806edc:	8b 10                	mov    (%eax),%edx
          iprh = (struct ip_reass_helper*)q->payload;
  806ede:	89 c6                	mov    %eax,%esi
  806ee0:	eb e1                	jmp    806ec3 <ip_reass+0x2c6>
        ipr->p = new_p;
  806ee2:	8b 45 08             	mov    0x8(%ebp),%eax
  806ee5:	89 47 04             	mov    %eax,0x4(%edi)
  806ee8:	eb af                	jmp    806e99 <ip_reass+0x29c>
    q = iprh_tmp->next_pbuf;
  806eea:	8b 18                	mov    (%eax),%ebx
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806eec:	89 c6                	mov    %eax,%esi
  for (q = ipr->p; q != NULL;) {
  806eee:	85 db                	test   %ebx,%ebx
  806ef0:	0f 84 ad 01 00 00    	je     8070a3 <ip_reass+0x4a6>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806ef6:	8b 43 04             	mov    0x4(%ebx),%eax
    if (iprh->start < iprh_tmp->start) {
  806ef9:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  806efd:	66 39 d1             	cmp    %dx,%cx
  806f00:	0f 82 67 ff ff ff    	jb     806e6d <ip_reass+0x270>
    } else if(iprh->start == iprh_tmp->start) {
  806f06:	0f 84 1d 01 00 00    	je     807029 <ip_reass+0x42c>
    } else if(iprh->start < iprh_tmp->end) {
  806f0c:	66 3b 48 06          	cmp    0x6(%eax),%cx
  806f10:	0f 82 13 01 00 00    	jb     807029 <ip_reass+0x42c>
      if (iprh_prev != NULL) {
  806f16:	85 f6                	test   %esi,%esi
  806f18:	74 d0                	je     806eea <ip_reass+0x2ed>
          valid = 0;
  806f1a:	66 3b 56 06          	cmp    0x6(%esi),%dx
  806f1e:	ba 00 00 00 00       	mov    $0x0,%edx
  806f23:	0f 45 fa             	cmovne %edx,%edi
  806f26:	eb c2                	jmp    806eea <ip_reass+0x2ed>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  806f28:	83 ec 04             	sub    $0x4,%esp
  806f2b:	68 60 1d 81 00       	push   $0x811d60
  806f30:	68 83 01 00 00       	push   $0x183
  806f35:	68 0a 1d 81 00       	push   $0x811d0a
  806f3a:	e8 97 75 00 00       	call   80e4d6 <_panic>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806f3f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  806f43:	75 0b                	jne    806f50 <ip_reass+0x353>
      ipr->p = new_p;
  806f45:	8b 45 08             	mov    0x8(%ebp),%eax
  806f48:	89 47 04             	mov    %eax,0x4(%edi)
  806f4b:	e9 49 ff ff ff       	jmp    806e99 <ip_reass+0x29c>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806f50:	83 ec 04             	sub    $0x4,%esp
  806f53:	68 8c 1d 81 00       	push   $0x811d8c
  806f58:	68 8b 01 00 00       	push   $0x18b
  806f5d:	68 0a 1d 81 00       	push   $0x811d0a
  806f62:	e8 6f 75 00 00       	call   80e4d6 <_panic>
          LWIP_ASSERT("sanity check",
  806f67:	89 75 e0             	mov    %esi,-0x20(%ebp)
  806f6a:	39 f3                	cmp    %esi,%ebx
  806f6c:	74 76                	je     806fe4 <ip_reass+0x3e7>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  806f6e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806f71:	83 38 00             	cmpl   $0x0,(%eax)
  806f74:	0f 85 81 00 00 00    	jne    806ffb <ip_reass+0x3fe>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  806f7a:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  806f7e:	8b 75 e0             	mov    -0x20(%ebp),%esi
  806f81:	66 39 46 06          	cmp    %ax,0x6(%esi)
  806f85:	0f 85 87 00 00 00    	jne    807012 <ip_reass+0x415>
    ipr->datagram_len += IP_HLEN;
  806f8b:	83 c0 14             	add    $0x14,%eax
  806f8e:	66 89 47 1c          	mov    %ax,0x1c(%edi)
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  806f92:	8b 71 04             	mov    0x4(%ecx),%esi
  806f95:	8b 1e                	mov    (%esi),%ebx
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  806f97:	83 ec 04             	sub    $0x4,%esp
  806f9a:	6a 14                	push   $0x14
  806f9c:	8d 47 08             	lea    0x8(%edi),%eax
  806f9f:	50                   	push   %eax
  806fa0:	56                   	push   %esi
  806fa1:	e8 dd 7d 00 00       	call   80ed83 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  806fa6:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  806faa:	89 04 24             	mov    %eax,(%esp)
  806fad:	e8 d4 06 00 00       	call   807686 <htons>
  806fb2:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  806fb6:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  806fbc:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  806fc2:	83 c4 08             	add    $0x8,%esp
  806fc5:	6a 14                	push   $0x14
  806fc7:	56                   	push   %esi
  806fc8:	e8 88 05 00 00       	call   807555 <inet_chksum>
  806fcd:	66 89 46 0a          	mov    %ax,0xa(%esi)
    p = ipr->p;
  806fd1:	8b 47 04             	mov    0x4(%edi),%eax
  806fd4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while(r != NULL) {
  806fd7:	83 c4 10             	add    $0x10,%esp
  806fda:	89 7d e0             	mov    %edi,-0x20(%ebp)
  806fdd:	89 c7                	mov    %eax,%edi
  806fdf:	e9 91 00 00 00       	jmp    807075 <ip_reass+0x478>
          LWIP_ASSERT("sanity check",
  806fe4:	83 ec 04             	sub    $0x4,%esp
  806fe7:	68 7e 1d 81 00       	push   $0x811d7e
  806fec:	68 ad 01 00 00       	push   $0x1ad
  806ff1:	68 0a 1d 81 00       	push   $0x811d0a
  806ff6:	e8 db 74 00 00       	call   80e4d6 <_panic>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  806ffb:	83 ec 04             	sub    $0x4,%esp
  806ffe:	68 c4 1d 81 00       	push   $0x811dc4
  807003:	68 af 01 00 00       	push   $0x1af
  807008:	68 0a 1d 81 00       	push   $0x811d0a
  80700d:	e8 c4 74 00 00       	call   80e4d6 <_panic>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  807012:	83 ec 04             	sub    $0x4,%esp
  807015:	68 e8 1d 81 00       	push   $0x811de8
  80701a:	68 b1 01 00 00       	push   $0x1b1
  80701f:	68 0a 1d 81 00       	push   $0x811d0a
  807024:	e8 ad 74 00 00       	call   80e4d6 <_panic>
  ip_reass_pbufcount -= pbuf_clen(new_p);
  807029:	83 ec 0c             	sub    $0xc,%esp
  80702c:	ff 75 08             	push   0x8(%ebp)
  80702f:	e8 4f dc ff ff       	call   804c83 <pbuf_clen>
  807034:	0f b6 c0             	movzbl %al,%eax
  807037:	66 29 05 3c 4a b3 00 	sub    %ax,0xb34a3c
  pbuf_free(new_p);
  80703e:	83 c4 04             	add    $0x4,%esp
  807041:	ff 75 08             	push   0x8(%ebp)
  807044:	e8 03 d8 ff ff       	call   80484c <pbuf_free>
  return 0;
  807049:	83 c4 10             	add    $0x10,%esp
  return NULL;
  80704c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  807053:	e9 c4 fd ff ff       	jmp    806e1c <ip_reass+0x21f>
      iprh = (struct ip_reass_helper*)r->payload;
  807058:	8b 73 04             	mov    0x4(%ebx),%esi
      pbuf_header(r, -IP_HLEN);
  80705b:	83 ec 08             	sub    $0x8,%esp
  80705e:	6a ec                	push   $0xffffffec
  807060:	53                   	push   %ebx
  807061:	e8 17 d7 ff ff       	call   80477d <pbuf_header>
      pbuf_cat(p, r);
  807066:	83 c4 08             	add    $0x8,%esp
  807069:	53                   	push   %ebx
  80706a:	57                   	push   %edi
  80706b:	e8 3e dc ff ff       	call   804cae <pbuf_cat>
      r = iprh->next_pbuf;
  807070:	8b 1e                	mov    (%esi),%ebx
  807072:	83 c4 10             	add    $0x10,%esp
    while(r != NULL) {
  807075:	85 db                	test   %ebx,%ebx
  807077:	75 df                	jne    807058 <ip_reass+0x45b>
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  807079:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80707c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80707f:	89 f8                	mov    %edi,%eax
  807081:	e8 54 f9 ff ff       	call   8069da <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
  807086:	83 ec 0c             	sub    $0xc,%esp
  807089:	ff 75 e4             	push   -0x1c(%ebp)
  80708c:	e8 f2 db ff ff       	call   804c83 <pbuf_clen>
  807091:	0f b6 c0             	movzbl %al,%eax
  807094:	66 29 05 3c 4a b3 00 	sub    %ax,0xb34a3c
    return p;
  80709b:	83 c4 10             	add    $0x10,%esp
  80709e:	e9 79 fd ff ff       	jmp    806e1c <ip_reass+0x21f>
  8070a3:	89 7d d0             	mov    %edi,-0x30(%ebp)
  8070a6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (iprh_prev != NULL) {
  8070a9:	85 f6                	test   %esi,%esi
  8070ab:	0f 84 8e fe ff ff    	je     806f3f <ip_reass+0x342>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8070b1:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  8070b5:	66 39 c1             	cmp    %ax,%cx
  8070b8:	0f 82 6a fe ff ff    	jb     806f28 <ip_reass+0x32b>
      iprh_prev->next_pbuf = new_p;
  8070be:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8070c1:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  8070c3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8070c6:	66 3b 41 04          	cmp    0x4(%ecx),%ax
  8070ca:	75 80                	jne    80704c <ip_reass+0x44f>
  8070cc:	e9 c8 fd ff ff       	jmp    806e99 <ip_reass+0x29c>

008070d1 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  8070d1:	55                   	push   %ebp
  8070d2:	89 e5                	mov    %esp,%ebp
  8070d4:	57                   	push   %edi
  8070d5:	56                   	push   %esi
  8070d6:	53                   	push   %ebx
  8070d7:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  8070da:	8b 45 0c             	mov    0xc(%ebp),%eax
  8070dd:	0f b7 58 2c          	movzwl 0x2c(%eax),%ebx
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  8070e1:	6a 02                	push   $0x2
  8070e3:	6a 00                	push   $0x0
  8070e5:	6a 02                	push   $0x2
  8070e7:	e8 26 d8 ff ff       	call   804912 <pbuf_alloc>
  8070ec:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  8070ef:	83 c4 10             	add    $0x10,%esp
  8070f2:	85 c0                	test   %eax,%eax
  8070f4:	0f 84 c2 00 00 00    	je     8071bc <ip_frag+0xeb>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8070fa:	66 89 58 0a          	mov    %bx,0xa(%eax)
  8070fe:	66 89 58 08          	mov    %bx,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807102:	be 63 44 b3 00       	mov    $0xb34463,%esi
  807107:	83 e6 fc             	and    $0xfffffffc,%esi
  80710a:	89 70 04             	mov    %esi,0x4(%eax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  80710d:	83 ec 04             	sub    $0x4,%esp
  807110:	6a 14                	push   $0x14
  807112:	8b 45 08             	mov    0x8(%ebp),%eax
  807115:	ff 70 04             	push   0x4(%eax)
  807118:	56                   	push   %esi
  807119:	e8 65 7c 00 00       	call   80ed83 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  80711e:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  807122:	89 04 24             	mov    %eax,(%esp)
  807125:	e8 69 05 00 00       	call   807693 <ntohs>
  ofo = tmp & IP_OFFMASK;
  80712a:	89 c7                	mov    %eax,%edi
  80712c:	66 81 e7 ff 1f       	and    $0x1fff,%di
  807131:	66 89 7d e4          	mov    %di,-0x1c(%ebp)
  omf = tmp & IP_MF;
  807135:	66 25 00 20          	and    $0x2000,%ax
  807139:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  left = p->tot_len - IP_HLEN;
  80713d:	8b 45 08             	mov    0x8(%ebp),%eax
  807140:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807144:	8d 78 ec             	lea    -0x14(%eax),%edi

  nfb = (mtu - IP_HLEN) / 8;
  807147:	0f b7 db             	movzwl %bx,%ebx
  80714a:	8d 43 f3             	lea    -0xd(%ebx),%eax
  80714d:	83 c4 10             	add    $0x10,%esp
  807150:	89 da                	mov    %ebx,%edx
  807152:	83 ea 14             	sub    $0x14,%edx
  807155:	0f 49 c2             	cmovns %edx,%eax
  807158:	c1 f8 03             	sar    $0x3,%eax
  80715b:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80715f:	c1 e0 03             	shl    $0x3,%eax
  807162:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807166:	0f b7 c8             	movzwl %ax,%ecx
  807169:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80716c:	83 c0 14             	add    $0x14,%eax
  80716f:	0f b7 c0             	movzwl %ax,%eax
  807172:	89 45 c8             	mov    %eax,-0x38(%ebp)
  u16_t poff = IP_HLEN;
  807175:	66 c7 45 e6 14 00    	movw   $0x14,-0x1a(%ebp)
    last = (left <= mtu - IP_HLEN);
  80717b:	8d 43 ed             	lea    -0x13(%ebx),%eax
  80717e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807181:	8d 46 14             	lea    0x14(%esi),%eax
  807184:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  while (left) {
  807187:	e9 e3 00 00 00       	jmp    80726f <ip_frag+0x19e>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80718c:	83 ec 0c             	sub    $0xc,%esp
  80718f:	ff 75 dc             	push   -0x24(%ebp)
  807192:	e8 b5 d6 ff ff       	call   80484c <pbuf_free>
      return ERR_MEM;
  807197:	83 c4 10             	add    $0x10,%esp
  80719a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80719f:	eb 13                	jmp    8071b4 <ip_frag+0xe3>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8071a1:	83 ec 0c             	sub    $0xc,%esp
  8071a4:	ff 75 dc             	push   -0x24(%ebp)
  8071a7:	e8 a0 d6 ff ff       	call   80484c <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  8071ac:	83 c4 10             	add    $0x10,%esp
  8071af:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8071b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8071b7:	5b                   	pop    %ebx
  8071b8:	5e                   	pop    %esi
  8071b9:	5f                   	pop    %edi
  8071ba:	5d                   	pop    %ebp
  8071bb:	c3                   	ret    
    return ERR_MEM;
  8071bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8071c1:	eb f1                	jmp    8071b4 <ip_frag+0xe3>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8071c3:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  8071c7:	52                   	push   %edx
  8071c8:	50                   	push   %eax
  8071c9:	ff 75 d4             	push   -0x2c(%ebp)
  8071cc:	ff 75 08             	push   0x8(%ebp)
  8071cf:	e8 c8 dd ff ff       	call   804f9c <pbuf_copy_partial>
  8071d4:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8071d8:	0f b7 db             	movzwl %bx,%ebx
  8071db:	89 1c 24             	mov    %ebx,(%esp)
  8071de:	e8 a3 04 00 00       	call   807686 <htons>
  8071e3:	66 89 46 06          	mov    %ax,0x6(%esi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8071e7:	8d 5f 14             	lea    0x14(%edi),%ebx
  8071ea:	0f b7 db             	movzwl %bx,%ebx
  8071ed:	89 1c 24             	mov    %ebx,(%esp)
  8071f0:	e8 91 04 00 00       	call   807686 <htons>
  8071f5:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  8071f9:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8071ff:	83 c4 08             	add    $0x8,%esp
  807202:	6a 14                	push   $0x14
  807204:	56                   	push   %esi
  807205:	e8 4b 03 00 00       	call   807555 <inet_chksum>
  80720a:	66 89 46 0a          	mov    %ax,0xa(%esi)
      pbuf_realloc(rambuf, left + IP_HLEN);
  80720e:	83 c4 08             	add    $0x8,%esp
  807211:	53                   	push   %ebx
  807212:	ff 75 dc             	push   -0x24(%ebp)
  807215:	e8 57 d9 ff ff       	call   804b71 <pbuf_realloc>
  80721a:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  80721d:	66 89 7d e2          	mov    %di,-0x1e(%ebp)
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  807221:	83 ec 04             	sub    $0x4,%esp
  807224:	6a 00                	push   $0x0
  807226:	6a 00                	push   $0x0
  807228:	6a 02                	push   $0x2
  80722a:	e8 e3 d6 ff ff       	call   804912 <pbuf_alloc>
  80722f:	89 c3                	mov    %eax,%ebx
    if (header != NULL) {
  807231:	83 c4 10             	add    $0x10,%esp
  807234:	85 c0                	test   %eax,%eax
  807236:	0f 84 50 ff ff ff    	je     80718c <ip_frag+0xbb>
      pbuf_chain(header, rambuf);
  80723c:	83 ec 08             	sub    $0x8,%esp
  80723f:	ff 75 dc             	push   -0x24(%ebp)
  807242:	50                   	push   %eax
  807243:	e8 d2 da ff ff       	call   804d1a <pbuf_chain>
      netif->output(netif, header, dest);
  807248:	83 c4 0c             	add    $0xc,%esp
  80724b:	ff 75 10             	push   0x10(%ebp)
  80724e:	53                   	push   %ebx
  80724f:	ff 75 0c             	push   0xc(%ebp)
  807252:	8b 45 0c             	mov    0xc(%ebp),%eax
  807255:	ff 50 14             	call   *0x14(%eax)
      pbuf_free(header);
  807258:	89 1c 24             	mov    %ebx,(%esp)
  80725b:	e8 ec d5 ff ff       	call   80484c <pbuf_free>
    left -= cop;
  807260:	66 2b 7d e2          	sub    -0x1e(%ebp),%di
    ofo += nfb;
  807264:	0f b7 55 d2          	movzwl -0x2e(%ebp),%edx
  807268:	66 01 55 e4          	add    %dx,-0x1c(%ebp)
  80726c:	83 c4 10             	add    $0x10,%esp
  while (left) {
  80726f:	66 85 ff             	test   %di,%di
  807272:	0f 84 29 ff ff ff    	je     8071a1 <ip_frag+0xd0>
    last = (left <= mtu - IP_HLEN);
  807278:	0f b7 c7             	movzwl %di,%eax
    tmp = omf | (IP_OFFMASK & (ofo));
  80727b:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  80727f:	66 81 e3 ff 1f       	and    $0x1fff,%bx
  807284:	66 0b 5d e0          	or     -0x20(%ebp),%bx
    if (!last)
  807288:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  80728b:	0f 8f 32 ff ff ff    	jg     8071c3 <ip_frag+0xf2>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807291:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807295:	50                   	push   %eax
  807296:	ff 75 cc             	push   -0x34(%ebp)
  807299:	ff 75 d4             	push   -0x2c(%ebp)
  80729c:	ff 75 08             	push   0x8(%ebp)
  80729f:	e8 f8 dc ff ff       	call   804f9c <pbuf_copy_partial>
  8072a4:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
      tmp = tmp | IP_MF;
  8072a8:	80 cf 20             	or     $0x20,%bh
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8072ab:	0f b7 db             	movzwl %bx,%ebx
  8072ae:	89 1c 24             	mov    %ebx,(%esp)
  8072b1:	e8 d0 03 00 00       	call   807686 <htons>
  8072b6:	66 89 46 06          	mov    %ax,0x6(%esi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8072ba:	83 c4 04             	add    $0x4,%esp
  8072bd:	ff 75 c8             	push   -0x38(%ebp)
  8072c0:	e8 c1 03 00 00       	call   807686 <htons>
  8072c5:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  8072c9:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8072cf:	83 c4 08             	add    $0x8,%esp
  8072d2:	6a 14                	push   $0x14
  8072d4:	56                   	push   %esi
  8072d5:	e8 7b 02 00 00       	call   807555 <inet_chksum>
  8072da:	66 89 46 0a          	mov    %ax,0xa(%esi)
  8072de:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  8072e1:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  8072e5:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  8072e9:	e9 33 ff ff ff       	jmp    807221 <ip_frag+0x150>

008072ee <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8072ee:	55                   	push   %ebp
  8072ef:	89 e5                	mov    %esp,%ebp
  8072f1:	57                   	push   %edi
  8072f2:	56                   	push   %esi
  8072f3:	53                   	push   %ebx
  8072f4:	83 ec 1c             	sub    $0x1c,%esp
  8072f7:	89 c1                	mov    %eax,%ecx
  8072f9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8072fc:	89 d7                	mov    %edx,%edi
  8072fe:	66 d1 ef             	shr    %di
  807301:	0f b7 c7             	movzwl %di,%eax
  807304:	8d 34 41             	lea    (%ecx,%eax,2),%esi
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  807307:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80730c:	eb 14                	jmp    807322 <lwip_standard_chksum+0x34>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80730e:	0f b6 11             	movzbl (%ecx),%edx
  807311:	c1 e2 08             	shl    $0x8,%edx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  807314:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
  807318:	09 d0                	or     %edx,%eax
  80731a:	83 c1 02             	add    $0x2,%ecx
    octetptr++;
    acc += src;
  80731d:	0f b7 c0             	movzwl %ax,%eax
  807320:	01 c3                	add    %eax,%ebx
  while (len > 1) {
  807322:	39 f1                	cmp    %esi,%ecx
  807324:	75 e8                	jne    80730e <lwip_standard_chksum+0x20>
    len -= 2;
  }
  if (len > 0) {
  807326:	01 ff                	add    %edi,%edi
  807328:	66 3b 7d e4          	cmp    -0x1c(%ebp),%di
  80732c:	74 0b                	je     807339 <lwip_standard_chksum+0x4b>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  80732e:	0f b6 01             	movzbl (%ecx),%eax
  807331:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  807334:	0f b7 c0             	movzwl %ax,%eax
  807337:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807339:	89 da                	mov    %ebx,%edx
  80733b:	c1 ea 10             	shr    $0x10,%edx
  80733e:	0f b7 db             	movzwl %bx,%ebx
  807341:	8d 04 1a             	lea    (%edx,%ebx,1),%eax
  if ((acc & 0xffff0000) != 0) {
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807344:	0f b7 c8             	movzwl %ax,%ecx
  807347:	83 c1 01             	add    $0x1,%ecx
  80734a:	89 c2                	mov    %eax,%edx
  80734c:	a9 00 00 ff ff       	test   $0xffff0000,%eax
  807351:	89 c8                	mov    %ecx,%eax
  807353:	0f 44 c2             	cmove  %edx,%eax
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807356:	83 ec 0c             	sub    $0xc,%esp
  807359:	0f b7 c0             	movzwl %ax,%eax
  80735c:	50                   	push   %eax
  80735d:	e8 24 03 00 00       	call   807686 <htons>
}
  807362:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807365:	5b                   	pop    %ebx
  807366:	5e                   	pop    %esi
  807367:	5f                   	pop    %edi
  807368:	5d                   	pop    %ebp
  807369:	c3                   	ret    

0080736a <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  80736a:	55                   	push   %ebp
  80736b:	89 e5                	mov    %esp,%ebp
  80736d:	57                   	push   %edi
  80736e:	56                   	push   %esi
  80736f:	53                   	push   %ebx
  807370:	83 ec 1c             	sub    $0x1c,%esp
  807373:	8b 75 08             	mov    0x8(%ebp),%esi
  807376:	8b 45 14             	mov    0x14(%ebp),%eax
  807379:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80737c:	8b 45 18             	mov    0x18(%ebp),%eax
  80737f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807382:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  acc = 0;
  807386:	bb 00 00 00 00       	mov    $0x0,%ebx
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
  80738b:	bf 01 00 00 00       	mov    $0x1,%edi
  for(q = p; q != NULL; q = q->next) {
  807390:	eb 02                	jmp    807394 <inet_chksum_pseudo+0x2a>
  807392:	8b 36                	mov    (%esi),%esi
  807394:	85 f6                	test   %esi,%esi
  807396:	74 38                	je     8073d0 <inet_chksum_pseudo+0x66>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807398:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80739c:	8b 46 04             	mov    0x4(%esi),%eax
  80739f:	e8 4a ff ff ff       	call   8072ee <lwip_standard_chksum>
  8073a4:	0f b7 c0             	movzwl %ax,%eax
  8073a7:	01 d8                	add    %ebx,%eax
    acc = FOLD_U32T(acc);
  8073a9:	89 c3                	mov    %eax,%ebx
  8073ab:	c1 eb 10             	shr    $0x10,%ebx
  8073ae:	0f b7 c0             	movzwl %ax,%eax
  8073b1:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  8073b3:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8073b7:	74 d9                	je     807392 <inet_chksum_pseudo+0x28>
      swapped = 1 - swapped;
  8073b9:	89 f8                	mov    %edi,%eax
  8073bb:	2a 45 e7             	sub    -0x19(%ebp),%al
  8073be:	88 45 e7             	mov    %al,-0x19(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  8073c1:	89 d8                	mov    %ebx,%eax
  8073c3:	c1 e0 08             	shl    $0x8,%eax
  8073c6:	0f b7 c0             	movzwl %ax,%eax
  8073c9:	0f b6 df             	movzbl %bh,%ebx
  8073cc:	09 c3                	or     %eax,%ebx
  8073ce:	eb c2                	jmp    807392 <inet_chksum_pseudo+0x28>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8073d0:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8073d4:	74 0d                	je     8073e3 <inet_chksum_pseudo+0x79>
    acc = SWAP_BYTES_IN_WORD(acc);
  8073d6:	89 d8                	mov    %ebx,%eax
  8073d8:	c1 e0 08             	shl    $0x8,%eax
  8073db:	0f b7 c0             	movzwl %ax,%eax
  8073de:	0f b6 df             	movzbl %bh,%ebx
  8073e1:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  8073e3:	8b 45 0c             	mov    0xc(%ebp),%eax
  8073e6:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8073e8:	8b 45 10             	mov    0x10(%ebp),%eax
  8073eb:	8b 08                	mov    (%eax),%ecx
  8073ed:	0f b7 c1             	movzwl %cx,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  8073f0:	c1 e9 10             	shr    $0x10,%ecx
  8073f3:	01 c8                	add    %ecx,%eax
  acc += (src->addr & 0xffffUL);
  8073f5:	0f b7 ca             	movzwl %dx,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8073f8:	01 c8                	add    %ecx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  8073fa:	c1 ea 10             	shr    $0x10,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8073fd:	01 d0                	add    %edx,%eax
  8073ff:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  807401:	83 ec 0c             	sub    $0xc,%esp
  807404:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  807408:	50                   	push   %eax
  807409:	e8 78 02 00 00       	call   807686 <htons>
  80740e:	0f b7 c0             	movzwl %ax,%eax
  807411:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  807413:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  807417:	89 04 24             	mov    %eax,(%esp)
  80741a:	e8 67 02 00 00       	call   807686 <htons>
  80741f:	0f b7 c0             	movzwl %ax,%eax
  807422:	01 d8                	add    %ebx,%eax

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807424:	89 c2                	mov    %eax,%edx
  807426:	c1 ea 10             	shr    $0x10,%edx
  807429:	0f b7 c0             	movzwl %ax,%eax
  80742c:	01 c2                	add    %eax,%edx
  acc = FOLD_U32T(acc);
  80742e:	89 d0                	mov    %edx,%eax
  807430:	c1 e8 10             	shr    $0x10,%eax
  807433:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807435:	f7 d0                	not    %eax
}
  807437:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80743a:	5b                   	pop    %ebx
  80743b:	5e                   	pop    %esi
  80743c:	5f                   	pop    %edi
  80743d:	5d                   	pop    %ebp
  80743e:	c3                   	ret    

0080743f <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80743f:	55                   	push   %ebp
  807440:	89 e5                	mov    %esp,%ebp
  807442:	57                   	push   %edi
  807443:	56                   	push   %esi
  807444:	53                   	push   %ebx
  807445:	83 ec 1c             	sub    $0x1c,%esp
  807448:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80744b:	8b 45 14             	mov    0x14(%ebp),%eax
  80744e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807451:	8b 45 18             	mov    0x18(%ebp),%eax
  807454:	89 45 d8             	mov    %eax,-0x28(%ebp)
  807457:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  80745b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  acc = 0;
  80745f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807466:	eb 19                	jmp    807481 <inet_chksum_pseudo_partial+0x42>
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807468:	83 ec 04             	sub    $0x4,%esp
  80746b:	68 15 1e 81 00       	push   $0x811e15
  807470:	68 60 01 00 00       	push   $0x160
  807475:	68 20 1e 81 00       	push   $0x811e20
  80747a:	e8 57 70 00 00       	call   80e4d6 <_panic>
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80747f:	8b 1b                	mov    (%ebx),%ebx
  807481:	85 db                	test   %ebx,%ebx
  807483:	74 5a                	je     8074df <inet_chksum_pseudo_partial+0xa0>
  807485:	66 85 f6             	test   %si,%si
  807488:	74 55                	je     8074df <inet_chksum_pseudo_partial+0xa0>
  80748a:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  80748e:	66 39 fe             	cmp    %di,%si
  807491:	0f 46 fe             	cmovbe %esi,%edi
    acc += LWIP_CHKSUM(q->payload, chklen);
  807494:	0f b7 d7             	movzwl %di,%edx
  807497:	8b 43 04             	mov    0x4(%ebx),%eax
  80749a:	e8 4f fe ff ff       	call   8072ee <lwip_standard_chksum>
  80749f:	0f b7 c0             	movzwl %ax,%eax
  8074a2:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  8074a5:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8074a7:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  8074ac:	77 ba                	ja     807468 <inet_chksum_pseudo_partial+0x29>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  8074ae:	89 c2                	mov    %eax,%edx
  8074b0:	c1 ea 10             	shr    $0x10,%edx
  8074b3:	0f b7 c0             	movzwl %ax,%eax
  8074b6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  8074b9:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  8074bc:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  8074c0:	74 bd                	je     80747f <inet_chksum_pseudo_partial+0x40>
      swapped = 1 - swapped;
  8074c2:	b8 01 00 00 00       	mov    $0x1,%eax
  8074c7:	2a 45 e3             	sub    -0x1d(%ebp),%al
  8074ca:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  8074cd:	89 c8                	mov    %ecx,%eax
  8074cf:	c1 e0 08             	shl    $0x8,%eax
  8074d2:	0f b7 c0             	movzwl %ax,%eax
  8074d5:	0f b6 d5             	movzbl %ch,%edx
  8074d8:	09 d0                	or     %edx,%eax
  8074da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8074dd:	eb a0                	jmp    80747f <inet_chksum_pseudo_partial+0x40>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8074df:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8074e3:	74 13                	je     8074f8 <inet_chksum_pseudo_partial+0xb9>
    acc = SWAP_BYTES_IN_WORD(acc);
  8074e5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8074e8:	89 c8                	mov    %ecx,%eax
  8074ea:	c1 e0 08             	shl    $0x8,%eax
  8074ed:	0f b7 c0             	movzwl %ax,%eax
  8074f0:	0f b6 d5             	movzbl %ch,%edx
  8074f3:	09 d0                	or     %edx,%eax
  8074f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  8074f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8074fb:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8074fd:	8b 55 10             	mov    0x10(%ebp),%edx
  807500:	8b 12                	mov    (%edx),%edx
  807502:	0f b7 da             	movzwl %dx,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807505:	c1 ea 10             	shr    $0x10,%edx
  807508:	01 d3                	add    %edx,%ebx
  acc += (src->addr & 0xffffUL);
  80750a:	0f b7 d0             	movzwl %ax,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80750d:	01 d3                	add    %edx,%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  80750f:	c1 e8 10             	shr    $0x10,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807512:	01 c3                	add    %eax,%ebx
  807514:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  807517:	83 ec 0c             	sub    $0xc,%esp
  80751a:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  80751e:	50                   	push   %eax
  80751f:	e8 62 01 00 00       	call   807686 <htons>
  807524:	0f b7 c0             	movzwl %ax,%eax
  807527:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  807529:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  80752d:	89 04 24             	mov    %eax,(%esp)
  807530:	e8 51 01 00 00       	call   807686 <htons>
  807535:	0f b7 c0             	movzwl %ax,%eax
  807538:	01 d8                	add    %ebx,%eax

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80753a:	89 c2                	mov    %eax,%edx
  80753c:	c1 ea 10             	shr    $0x10,%edx
  80753f:	0f b7 c0             	movzwl %ax,%eax
  807542:	01 c2                	add    %eax,%edx
  acc = FOLD_U32T(acc);
  807544:	89 d0                	mov    %edx,%eax
  807546:	c1 e8 10             	shr    $0x10,%eax
  807549:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80754b:	f7 d0                	not    %eax
}
  80754d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807550:	5b                   	pop    %ebx
  807551:	5e                   	pop    %esi
  807552:	5f                   	pop    %edi
  807553:	5d                   	pop    %ebp
  807554:	c3                   	ret    

00807555 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807555:	55                   	push   %ebp
  807556:	89 e5                	mov    %esp,%ebp
  807558:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80755b:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  80755f:	8b 45 08             	mov    0x8(%ebp),%eax
  807562:	e8 87 fd ff ff       	call   8072ee <lwip_standard_chksum>
  807567:	f7 d0                	not    %eax
}
  807569:	c9                   	leave  
  80756a:	c3                   	ret    

0080756b <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  80756b:	55                   	push   %ebp
  80756c:	89 e5                	mov    %esp,%ebp
  80756e:	57                   	push   %edi
  80756f:	56                   	push   %esi
  807570:	53                   	push   %ebx
  807571:	83 ec 1c             	sub    $0x1c,%esp
  807574:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807577:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  acc = 0;
  80757b:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
  807580:	bf 01 00 00 00       	mov    $0x1,%edi
  for(q = p; q != NULL; q = q->next) {
  807585:	eb 02                	jmp    807589 <inet_chksum_pbuf+0x1e>
  807587:	8b 36                	mov    (%esi),%esi
  807589:	85 f6                	test   %esi,%esi
  80758b:	74 38                	je     8075c5 <inet_chksum_pbuf+0x5a>
    acc += LWIP_CHKSUM(q->payload, q->len);
  80758d:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807591:	8b 46 04             	mov    0x4(%esi),%eax
  807594:	e8 55 fd ff ff       	call   8072ee <lwip_standard_chksum>
  807599:	0f b7 d0             	movzwl %ax,%edx
  80759c:	01 da                	add    %ebx,%edx
    acc = FOLD_U32T(acc);
  80759e:	89 d3                	mov    %edx,%ebx
  8075a0:	c1 eb 10             	shr    $0x10,%ebx
  8075a3:	0f b7 d2             	movzwl %dx,%edx
  8075a6:	01 d3                	add    %edx,%ebx
    if (q->len % 2 != 0) {
  8075a8:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8075ac:	74 d9                	je     807587 <inet_chksum_pbuf+0x1c>
      swapped = 1 - swapped;
  8075ae:	89 f8                	mov    %edi,%eax
  8075b0:	2a 45 e7             	sub    -0x19(%ebp),%al
  8075b3:	88 45 e7             	mov    %al,-0x19(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  8075b6:	89 da                	mov    %ebx,%edx
  8075b8:	c1 e2 08             	shl    $0x8,%edx
  8075bb:	0f b7 d2             	movzwl %dx,%edx
  8075be:	0f b6 df             	movzbl %bh,%ebx
  8075c1:	09 d3                	or     %edx,%ebx
  8075c3:	eb c2                	jmp    807587 <inet_chksum_pbuf+0x1c>
    }
  }

  if (swapped) {
  8075c5:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8075c9:	74 0d                	je     8075d8 <inet_chksum_pbuf+0x6d>
    acc = SWAP_BYTES_IN_WORD(acc);
  8075cb:	89 da                	mov    %ebx,%edx
  8075cd:	c1 e2 08             	shl    $0x8,%edx
  8075d0:	0f b7 d2             	movzwl %dx,%edx
  8075d3:	0f b6 df             	movzbl %bh,%ebx
  8075d6:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  8075d8:	89 d8                	mov    %ebx,%eax
  8075da:	f7 d0                	not    %eax
}
  8075dc:	83 c4 1c             	add    $0x1c,%esp
  8075df:	5b                   	pop    %ebx
  8075e0:	5e                   	pop    %esi
  8075e1:	5f                   	pop    %edi
  8075e2:	5d                   	pop    %ebp
  8075e3:	c3                   	ret    

008075e4 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  8075e4:	55                   	push   %ebp
  8075e5:	89 e5                	mov    %esp,%ebp
  8075e7:	57                   	push   %edi
  8075e8:	56                   	push   %esi
  8075e9:	53                   	push   %ebx
  8075ea:	83 ec 1c             	sub    $0x1c,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  8075ed:	8b 45 08             	mov    0x8(%ebp),%eax
  8075f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  8075f3:	c6 45 db 00          	movb   $0x0,-0x25(%ebp)
  ap = (u8_t *)&s_addr;
  8075f7:	8d 75 f0             	lea    -0x10(%ebp),%esi
  rp = str;
  8075fa:	c7 45 dc 44 4a b3 00 	movl   $0xb34a44,-0x24(%ebp)
  807601:	eb 32                	jmp    807635 <inet_ntoa+0x51>
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  807603:	0f b6 c8             	movzbl %al,%ecx
  807606:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  80760b:	88 0a                	mov    %cl,(%edx)
  80760d:	83 c2 01             	add    $0x1,%edx
    while(i--)
  807610:	83 e8 01             	sub    $0x1,%eax
  807613:	3c ff                	cmp    $0xff,%al
  807615:	75 ec                	jne    807603 <inet_ntoa+0x1f>
  807617:	0f b6 db             	movzbl %bl,%ebx
  80761a:	03 5d dc             	add    -0x24(%ebp),%ebx
    *rp++ = '.';
  80761d:	8d 43 01             	lea    0x1(%ebx),%eax
  807620:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807623:	c6 03 2e             	movb   $0x2e,(%ebx)
  807626:	83 c6 01             	add    $0x1,%esi
  for(n = 0; n < 4; n++) {
  807629:	80 45 db 01          	addb   $0x1,-0x25(%ebp)
  80762d:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
  807631:	3c 04                	cmp    $0x4,%al
  807633:	74 41                	je     807676 <inet_ntoa+0x92>
  rp = str;
  807635:	bb 00 00 00 00       	mov    $0x0,%ebx
      rem = *ap % (u8_t)10;
  80763a:	0f b6 16             	movzbl (%esi),%edx
      *ap /= (u8_t)10;
  80763d:	b8 cd ff ff ff       	mov    $0xffffffcd,%eax
  807642:	f6 e2                	mul    %dl
  807644:	66 c1 e8 0b          	shr    $0xb,%ax
  807648:	88 06                	mov    %al,(%esi)
  80764a:	89 d9                	mov    %ebx,%ecx
      inv[i++] = '0' + rem;
  80764c:	83 c3 01             	add    $0x1,%ebx
  80764f:	0f b6 f9             	movzbl %cl,%edi
  807652:	89 7d e0             	mov    %edi,-0x20(%ebp)
      rem = *ap % (u8_t)10;
  807655:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807658:	01 c0                	add    %eax,%eax
  80765a:	89 d1                	mov    %edx,%ecx
  80765c:	29 c1                	sub    %eax,%ecx
  80765e:	89 cf                	mov    %ecx,%edi
      inv[i++] = '0' + rem;
  807660:	8d 47 30             	lea    0x30(%edi),%eax
  807663:	8b 7d e0             	mov    -0x20(%ebp),%edi
  807666:	88 44 3d ed          	mov    %al,-0x13(%ebp,%edi,1)
    } while(*ap);
  80766a:	80 fa 09             	cmp    $0x9,%dl
  80766d:	77 cb                	ja     80763a <inet_ntoa+0x56>
  80766f:	8b 55 dc             	mov    -0x24(%ebp),%edx
      inv[i++] = '0' + rem;
  807672:	89 d8                	mov    %ebx,%eax
  807674:	eb 9a                	jmp    807610 <inet_ntoa+0x2c>
    ap++;
  }
  *--rp = 0;
  807676:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  807679:	b8 44 4a b3 00       	mov    $0xb34a44,%eax
  80767e:	83 c4 1c             	add    $0x1c,%esp
  807681:	5b                   	pop    %ebx
  807682:	5e                   	pop    %esi
  807683:	5f                   	pop    %edi
  807684:	5d                   	pop    %ebp
  807685:	c3                   	ret    

00807686 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807686:	55                   	push   %ebp
  807687:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807689:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80768d:	66 c1 c0 08          	rol    $0x8,%ax
}
  807691:	5d                   	pop    %ebp
  807692:	c3                   	ret    

00807693 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  807693:	55                   	push   %ebp
  807694:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807696:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80769a:	66 c1 c0 08          	rol    $0x8,%ax
  return htons(n);
}
  80769e:	5d                   	pop    %ebp
  80769f:	c3                   	ret    

008076a0 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  8076a0:	55                   	push   %ebp
  8076a1:	89 e5                	mov    %esp,%ebp
  8076a3:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  8076a6:	89 d0                	mov    %edx,%eax
  8076a8:	c1 e0 18             	shl    $0x18,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  8076ab:	89 d1                	mov    %edx,%ecx
  8076ad:	c1 e9 18             	shr    $0x18,%ecx
    ((n & 0xff0000UL) >> 8) |
  8076b0:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  8076b2:	89 d1                	mov    %edx,%ecx
  8076b4:	c1 e1 08             	shl    $0x8,%ecx
  8076b7:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
    ((n & 0xff0000UL) >> 8) |
  8076bd:	09 c8                	or     %ecx,%eax
  8076bf:	c1 ea 08             	shr    $0x8,%edx
  8076c2:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8076c8:	09 d0                	or     %edx,%eax
}
  8076ca:	5d                   	pop    %ebp
  8076cb:	c3                   	ret    

008076cc <inet_aton>:
{
  8076cc:	55                   	push   %ebp
  8076cd:	89 e5                	mov    %esp,%ebp
  8076cf:	57                   	push   %edi
  8076d0:	56                   	push   %esi
  8076d1:	53                   	push   %ebx
  8076d2:	83 ec 2c             	sub    $0x2c,%esp
  8076d5:	8b 55 08             	mov    0x8(%ebp),%edx
  c = *cp;
  8076d8:	0f be 02             	movsbl (%edx),%eax
  u32_t *pp = parts;
  8076db:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  8076de:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  8076e1:	e9 a6 00 00 00       	jmp    80778c <inet_aton+0xc0>
      c = *++cp;
  8076e6:	0f b6 42 01          	movzbl 0x1(%edx),%eax
      if (c == 'x' || c == 'X') {
  8076ea:	89 c1                	mov    %eax,%ecx
  8076ec:	83 e1 df             	and    $0xffffffdf,%ecx
  8076ef:	80 f9 58             	cmp    $0x58,%cl
  8076f2:	74 10                	je     807704 <inet_aton+0x38>
      c = *++cp;
  8076f4:	83 c2 01             	add    $0x1,%edx
  8076f7:	0f be c0             	movsbl %al,%eax
        base = 8;
  8076fa:	be 08 00 00 00       	mov    $0x8,%esi
  8076ff:	e9 a2 00 00 00       	jmp    8077a6 <inet_aton+0xda>
        c = *++cp;
  807704:	0f be 42 02          	movsbl 0x2(%edx),%eax
  807708:	8d 52 02             	lea    0x2(%edx),%edx
        base = 16;
  80770b:	be 10 00 00 00       	mov    $0x10,%esi
  807710:	e9 91 00 00 00       	jmp    8077a6 <inet_aton+0xda>
        val = (val * base) + (int)(c - '0');
  807715:	0f af fe             	imul   %esi,%edi
  807718:	8d 7c 38 d0          	lea    -0x30(%eax,%edi,1),%edi
        c = *++cp;
  80771c:	0f be 02             	movsbl (%edx),%eax
  80771f:	83 c2 01             	add    $0x1,%edx
  807722:	8d 5a ff             	lea    -0x1(%edx),%ebx
      if (isdigit(c)) {
  807725:	88 45 d7             	mov    %al,-0x29(%ebp)
  807728:	8d 48 d0             	lea    -0x30(%eax),%ecx
  80772b:	80 f9 09             	cmp    $0x9,%cl
  80772e:	76 e5                	jbe    807715 <inet_aton+0x49>
      } else if (base == 16 && isxdigit(c)) {
  807730:	83 fe 10             	cmp    $0x10,%esi
  807733:	75 34                	jne    807769 <inet_aton+0x9d>
  807735:	0f b6 4d d7          	movzbl -0x29(%ebp),%ecx
  807739:	83 e9 61             	sub    $0x61,%ecx
  80773c:	88 4d d6             	mov    %cl,-0x2a(%ebp)
  80773f:	0f b6 4d d7          	movzbl -0x29(%ebp),%ecx
  807743:	83 e1 df             	and    $0xffffffdf,%ecx
  807746:	83 e9 41             	sub    $0x41,%ecx
  807749:	80 f9 05             	cmp    $0x5,%cl
  80774c:	77 1b                	ja     807769 <inet_aton+0x9d>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80774e:	c1 e7 04             	shl    $0x4,%edi
  807751:	83 c0 0a             	add    $0xa,%eax
  807754:	80 7d d6 1a          	cmpb   $0x1a,-0x2a(%ebp)
  807758:	19 c9                	sbb    %ecx,%ecx
  80775a:	83 e1 20             	and    $0x20,%ecx
  80775d:	83 c1 41             	add    $0x41,%ecx
  807760:	29 c8                	sub    %ecx,%eax
  807762:	09 c7                	or     %eax,%edi
        c = *++cp;
  807764:	0f be 02             	movsbl (%edx),%eax
  807767:	eb b6                	jmp    80771f <inet_aton+0x53>
    if (c == '.') {
  807769:	83 f8 2e             	cmp    $0x2e,%eax
  80776c:	75 45                	jne    8077b3 <inet_aton+0xe7>
      if (pp >= parts + 3)
  80776e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  807771:	8b 75 d0             	mov    -0x30(%ebp),%esi
  807774:	39 c6                	cmp    %eax,%esi
  807776:	0f 84 1b 01 00 00    	je     807897 <inet_aton+0x1cb>
      *pp++ = val;
  80777c:	83 c6 04             	add    $0x4,%esi
  80777f:	89 75 d0             	mov    %esi,-0x30(%ebp)
  807782:	89 7e fc             	mov    %edi,-0x4(%esi)
      c = *++cp;
  807785:	8d 53 01             	lea    0x1(%ebx),%edx
  807788:	0f be 43 01          	movsbl 0x1(%ebx),%eax
    if (!isdigit(c))
  80778c:	8d 48 d0             	lea    -0x30(%eax),%ecx
  80778f:	80 f9 09             	cmp    $0x9,%cl
  807792:	0f 87 f8 00 00 00    	ja     807890 <inet_aton+0x1c4>
    base = 10;
  807798:	be 0a 00 00 00       	mov    $0xa,%esi
    if (c == '0') {
  80779d:	83 f8 30             	cmp    $0x30,%eax
  8077a0:	0f 84 40 ff ff ff    	je     8076e6 <inet_aton+0x1a>
  8077a6:	83 c2 01             	add    $0x1,%edx
        base = 8;
  8077a9:	bf 00 00 00 00       	mov    $0x0,%edi
  8077ae:	e9 6f ff ff ff       	jmp    807722 <inet_aton+0x56>
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8077b3:	0f b6 75 d7          	movzbl -0x29(%ebp),%esi
  8077b7:	85 c0                	test   %eax,%eax
  8077b9:	74 29                	je     8077e4 <inet_aton+0x118>
    return (0);
  8077bb:	ba 00 00 00 00       	mov    $0x0,%edx
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8077c0:	89 f3                	mov    %esi,%ebx
  8077c2:	80 fb 1f             	cmp    $0x1f,%bl
  8077c5:	0f 86 d1 00 00 00    	jbe    80789c <inet_aton+0x1d0>
  8077cb:	84 c0                	test   %al,%al
  8077cd:	0f 88 c9 00 00 00    	js     80789c <inet_aton+0x1d0>
  8077d3:	83 f8 20             	cmp    $0x20,%eax
  8077d6:	74 0c                	je     8077e4 <inet_aton+0x118>
  8077d8:	83 e8 09             	sub    $0x9,%eax
  8077db:	83 f8 04             	cmp    $0x4,%eax
  8077de:	0f 87 b8 00 00 00    	ja     80789c <inet_aton+0x1d0>
  n = pp - parts + 1;
  8077e4:	8d 55 d8             	lea    -0x28(%ebp),%edx
  8077e7:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8077ea:	29 d0                	sub    %edx,%eax
  8077ec:	c1 f8 02             	sar    $0x2,%eax
  8077ef:	8d 50 01             	lea    0x1(%eax),%edx
  switch (n) {
  8077f2:	83 f8 02             	cmp    $0x2,%eax
  8077f5:	74 7a                	je     807871 <inet_aton+0x1a5>
  8077f7:	83 fa 03             	cmp    $0x3,%edx
  8077fa:	7f 49                	jg     807845 <inet_aton+0x179>
  8077fc:	85 d2                	test   %edx,%edx
  8077fe:	0f 84 98 00 00 00    	je     80789c <inet_aton+0x1d0>
  807804:	83 fa 02             	cmp    $0x2,%edx
  807807:	75 19                	jne    807822 <inet_aton+0x156>
      return (0);
  807809:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xffffffUL)
  80780e:	81 ff ff ff ff 00    	cmp    $0xffffff,%edi
  807814:	0f 87 82 00 00 00    	ja     80789c <inet_aton+0x1d0>
    val |= parts[0] << 24;
  80781a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80781d:	c1 e0 18             	shl    $0x18,%eax
  807820:	09 c7                	or     %eax,%edi
  return (1);
  807822:	ba 01 00 00 00       	mov    $0x1,%edx
  if (addr)
  807827:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80782b:	74 6f                	je     80789c <inet_aton+0x1d0>
    addr->s_addr = htonl(val);
  80782d:	83 ec 0c             	sub    $0xc,%esp
  807830:	57                   	push   %edi
  807831:	e8 6a fe ff ff       	call   8076a0 <htonl>
  807836:	83 c4 10             	add    $0x10,%esp
  807839:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80783c:	89 03                	mov    %eax,(%ebx)
  return (1);
  80783e:	ba 01 00 00 00       	mov    $0x1,%edx
  807843:	eb 57                	jmp    80789c <inet_aton+0x1d0>
  switch (n) {
  807845:	83 fa 04             	cmp    $0x4,%edx
  807848:	75 d8                	jne    807822 <inet_aton+0x156>
      return (0);
  80784a:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xff)
  80784f:	81 ff ff 00 00 00    	cmp    $0xff,%edi
  807855:	77 45                	ja     80789c <inet_aton+0x1d0>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807857:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80785a:	c1 e0 18             	shl    $0x18,%eax
  80785d:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807860:	c1 e2 10             	shl    $0x10,%edx
  807863:	09 d0                	or     %edx,%eax
  807865:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807868:	c1 e2 08             	shl    $0x8,%edx
  80786b:	09 d0                	or     %edx,%eax
  80786d:	09 c7                	or     %eax,%edi
    break;
  80786f:	eb b1                	jmp    807822 <inet_aton+0x156>
      return (0);
  807871:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xffff)
  807876:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  80787c:	77 1e                	ja     80789c <inet_aton+0x1d0>
    val |= (parts[0] << 24) | (parts[1] << 16);
  80787e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807881:	c1 e0 18             	shl    $0x18,%eax
  807884:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807887:	c1 e2 10             	shl    $0x10,%edx
  80788a:	09 d0                	or     %edx,%eax
  80788c:	09 c7                	or     %eax,%edi
    break;
  80788e:	eb 92                	jmp    807822 <inet_aton+0x156>
      return (0);
  807890:	ba 00 00 00 00       	mov    $0x0,%edx
  807895:	eb 05                	jmp    80789c <inet_aton+0x1d0>
        return (0);
  807897:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80789c:	89 d0                	mov    %edx,%eax
  80789e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8078a1:	5b                   	pop    %ebx
  8078a2:	5e                   	pop    %esi
  8078a3:	5f                   	pop    %edi
  8078a4:	5d                   	pop    %ebp
  8078a5:	c3                   	ret    

008078a6 <inet_addr>:
{
  8078a6:	55                   	push   %ebp
  8078a7:	89 e5                	mov    %esp,%ebp
  8078a9:	83 ec 20             	sub    $0x20,%esp
  if (inet_aton(cp, &val)) {
  8078ac:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8078af:	50                   	push   %eax
  8078b0:	ff 75 08             	push   0x8(%ebp)
  8078b3:	e8 14 fe ff ff       	call   8076cc <inet_aton>
  8078b8:	83 c4 10             	add    $0x10,%esp
    return (val.s_addr);
  8078bb:	85 c0                	test   %eax,%eax
  8078bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8078c2:	0f 45 45 f4          	cmovne -0xc(%ebp),%eax
}
  8078c6:	c9                   	leave  
  8078c7:	c3                   	ret    

008078c8 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  8078c8:	55                   	push   %ebp
  8078c9:	89 e5                	mov    %esp,%ebp
  8078cb:	83 ec 14             	sub    $0x14,%esp
  return htonl(n);
  8078ce:	ff 75 08             	push   0x8(%ebp)
  8078d1:	e8 ca fd ff ff       	call   8076a0 <htonl>
  8078d6:	83 c4 10             	add    $0x10,%esp
}
  8078d9:	c9                   	leave  
  8078da:	c3                   	ret    

008078db <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  8078db:	55                   	push   %ebp
  8078dc:	89 e5                	mov    %esp,%ebp
  8078de:	57                   	push   %edi
  8078df:	56                   	push   %esi
  8078e0:	53                   	push   %ebx
  8078e1:	83 ec 3c             	sub    $0x3c,%esp
  8078e4:	8b 7d 08             	mov    0x8(%ebp),%edi
  8078e7:	8b 75 10             	mov    0x10(%ebp),%esi
  8078ea:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  8078ed:	8b 55 14             	mov    0x14(%ebp),%edx
  8078f0:	89 55 bc             	mov    %edx,-0x44(%ebp)
  8078f3:	8b 5d 18             	mov    0x18(%ebp),%ebx
  8078f6:	89 5d b8             	mov    %ebx,-0x48(%ebp)
  8078f9:	8b 45 20             	mov    0x20(%ebp),%eax
  8078fc:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  807900:	88 55 dd             	mov    %dl,-0x23(%ebp)
  807903:	89 da                	mov    %ebx,%edx
  807905:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807908:	66 85 f6             	test   %si,%si
  80790b:	74 04                	je     807911 <tcp_enqueue+0x36>
  80790d:	84 c0                	test   %al,%al
  80790f:	75 54                	jne    807965 <tcp_enqueue+0x8a>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807911:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807915:	74 06                	je     80791d <tcp_enqueue+0x42>
  807917:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80791b:	75 5f                	jne    80797c <tcp_enqueue+0xa1>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80791d:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  807921:	66 39 4f 6e          	cmp    %cx,0x6e(%edi)
  807925:	72 6c                	jb     807993 <tcp_enqueue+0xb8>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  807927:	8b 4f 68             	mov    0x68(%edi),%ecx
  80792a:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80792d:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  807931:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807935:	66 83 f9 1f          	cmp    $0x1f,%cx
  807939:	77 66                	ja     8079a1 <tcp_enqueue+0xc6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
  80793b:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  807940:	74 6d                	je     8079af <tcp_enqueue+0xd4>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807942:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807946:	75 7b                	jne    8079c3 <tcp_enqueue+0xe8>
  807948:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80794c:	75 75                	jne    8079c3 <tcp_enqueue+0xe8>
  80794e:	83 ec 04             	sub    $0x4,%esp
  807951:	68 cc 1e 81 00       	push   $0x811ecc
  807956:	68 ad 00 00 00       	push   $0xad
  80795b:	68 e6 1f 81 00       	push   $0x811fe6
  807960:	e8 71 6b 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807965:	83 ec 04             	sub    $0x4,%esp
  807968:	68 44 1e 81 00       	push   $0x811e44
  80796d:	68 8f 00 00 00       	push   $0x8f
  807972:	68 e6 1f 81 00       	push   $0x811fe6
  807977:	e8 5a 6b 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  80797c:	83 ec 04             	sub    $0x4,%esp
  80797f:	68 84 1e 81 00       	push   $0x811e84
  807984:	68 91 00 00 00       	push   $0x91
  807989:	68 e6 1f 81 00       	push   $0x811fe6
  80798e:	e8 43 6b 00 00       	call   80e4d6 <_panic>
    pcb->flags |= TF_NAGLEMEMERR;
  807993:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807997:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80799c:	e9 66 04 00 00       	jmp    807e07 <tcp_enqueue+0x52c>
    pcb->flags |= TF_NAGLEMEMERR;
  8079a1:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8079a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079aa:	e9 58 04 00 00       	jmp    807e07 <tcp_enqueue+0x52c>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  8079af:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8079b3:	0f 85 c7 02 00 00    	jne    807c80 <tcp_enqueue+0x3a5>
  8079b9:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8079bd:	0f 85 bd 02 00 00    	jne    807c80 <tcp_enqueue+0x3a5>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8079c3:	c0 e8 02             	shr    $0x2,%al
  8079c6:	83 c0 05             	add    $0x5,%eax
  8079c9:	c1 e0 0c             	shl    $0xc,%eax
  8079cc:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  8079d0:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8079d4:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  8079d8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8079db:	89 45 d0             	mov    %eax,-0x30(%ebp)
  8079de:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (queue == NULL || left > 0) {
  8079e3:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8079e7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  8079ee:	89 d0                	mov    %edx,%eax
  8079f0:	83 e0 01             	and    $0x1,%eax
  8079f3:	88 45 c9             	mov    %al,-0x37(%ebp)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  8079f6:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  8079fa:	89 45 cc             	mov    %eax,-0x34(%ebp)
    seglen = left > pcb->mss? pcb->mss: left;
  8079fd:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  807a01:	0f b7 4d de          	movzwl -0x22(%ebp),%ecx
  807a05:	66 39 c1             	cmp    %ax,%cx
  807a08:	0f 46 c1             	cmovbe %ecx,%eax
  807a0b:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  807a0f:	89 de                	mov    %ebx,%esi
    seg = memp_malloc(MEMP_TCP_SEG);
  807a11:	83 ec 0c             	sub    $0xc,%esp
  807a14:	6a 04                	push   $0x4
  807a16:	e8 8a ca ff ff       	call   8044a5 <memp_malloc>
  807a1b:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807a1d:	83 c4 10             	add    $0x10,%esp
  807a20:	85 c0                	test   %eax,%eax
  807a22:	0f 84 a4 03 00 00    	je     807dcc <tcp_enqueue+0x4f1>
    seg->next = NULL;
  807a28:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807a2e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (queue == NULL) {
  807a35:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807a39:	0f 85 6f 02 00 00    	jne    807cae <tcp_enqueue+0x3d3>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807a3f:	85 f6                	test   %esi,%esi
  807a41:	0f 84 50 02 00 00    	je     807c97 <tcp_enqueue+0x3bc>
      useg->next = seg;
  807a47:	89 06                	mov    %eax,(%esi)
    if (optdata != NULL) {
  807a49:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807a4d:	0f 84 7a 02 00 00    	je     807ccd <tcp_enqueue+0x3f2>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807a53:	83 ec 04             	sub    $0x4,%esp
  807a56:	6a 00                	push   $0x0
  807a58:	ff 75 cc             	push   -0x34(%ebp)
  807a5b:	6a 00                	push   $0x0
  807a5d:	e8 b0 ce ff ff       	call   804912 <pbuf_alloc>
  807a62:	89 43 04             	mov    %eax,0x4(%ebx)
  807a65:	83 c4 10             	add    $0x10,%esp
  807a68:	85 c0                	test   %eax,%eax
  807a6a:	0f 84 5c 03 00 00    	je     807dcc <tcp_enqueue+0x4f1>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807a70:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807a74:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807a78:	0f 82 38 02 00 00    	jb     807cb6 <tcp_enqueue+0x3db>
      queuelen += pbuf_clen(seg->p);
  807a7e:	83 ec 0c             	sub    $0xc,%esp
  807a81:	50                   	push   %eax
  807a82:	e8 fc d1 ff ff       	call   804c83 <pbuf_clen>
  807a87:	0f b6 c0             	movzbl %al,%eax
  807a8a:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807a8e:	8b 43 04             	mov    0x4(%ebx),%eax
  807a91:	8b 40 04             	mov    0x4(%eax),%eax
  807a94:	89 43 08             	mov    %eax,0x8(%ebx)
  807a97:	83 c4 10             	add    $0x10,%esp
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807a9a:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807a9f:	0f 87 27 03 00 00    	ja     807dcc <tcp_enqueue+0x4f1>
    seg->len = seglen;
  807aa5:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807aa9:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807aad:	83 ec 08             	sub    $0x8,%esp
  807ab0:	6a 14                	push   $0x14
  807ab2:	ff 73 04             	push   0x4(%ebx)
  807ab5:	e8 c3 cc ff ff       	call   80477d <pbuf_header>
  807aba:	83 c4 10             	add    $0x10,%esp
  807abd:	84 c0                	test   %al,%al
  807abf:	0f 85 07 03 00 00    	jne    807dcc <tcp_enqueue+0x4f1>
    seg->tcphdr = seg->p->payload;
  807ac5:	8b 43 04             	mov    0x4(%ebx),%eax
  807ac8:	8b 70 04             	mov    0x4(%eax),%esi
  807acb:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807ace:	83 ec 0c             	sub    $0xc,%esp
  807ad1:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807ad5:	50                   	push   %eax
  807ad6:	e8 ab fb ff ff       	call   807686 <htons>
  807adb:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807ade:	8b 73 10             	mov    0x10(%ebx),%esi
  807ae1:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807ae5:	89 04 24             	mov    %eax,(%esp)
  807ae8:	e8 99 fb ff ff       	call   807686 <htons>
  807aed:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807af1:	8b 73 10             	mov    0x10(%ebx),%esi
  807af4:	83 c4 04             	add    $0x4,%esp
  807af7:	ff 75 d8             	push   -0x28(%ebp)
  807afa:	e8 a1 fb ff ff       	call   8076a0 <htonl>
  807aff:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807b02:	8b 43 10             	mov    0x10(%ebx),%eax
  807b05:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807b0b:	8b 43 10             	mov    0x10(%ebx),%eax
  807b0e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807b12:	89 04 24             	mov    %eax,(%esp)
  807b15:	e8 79 fb ff ff       	call   807693 <ntohs>
  807b1a:	8b 73 10             	mov    0x10(%ebx),%esi
  807b1d:	83 e0 c0             	and    $0xffffffc0,%eax
  807b20:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807b24:	09 d0                	or     %edx,%eax
  807b26:	0f b7 c0             	movzwl %ax,%eax
  807b29:	89 04 24             	mov    %eax,(%esp)
  807b2c:	e8 55 fb ff ff       	call   807686 <htons>
  807b31:	66 89 46 0c          	mov    %ax,0xc(%esi)
    if (optdata == NULL) {
  807b35:	83 c4 10             	add    $0x10,%esp
  807b38:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807b3c:	0f 84 cd 02 00 00    	je     807e0f <tcp_enqueue+0x534>
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807b42:	83 ec 0c             	sub    $0xc,%esp
  807b45:	8b 43 10             	mov    0x10(%ebx),%eax
  807b48:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807b4c:	50                   	push   %eax
  807b4d:	e8 41 fb ff ff       	call   807693 <ntohs>
  807b52:	8b 73 10             	mov    0x10(%ebx),%esi
  807b55:	83 e0 3f             	and    $0x3f,%eax
  807b58:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807b5c:	0f b7 c0             	movzwl %ax,%eax
  807b5f:	89 04 24             	mov    %eax,(%esp)
  807b62:	e8 1f fb ff ff       	call   807686 <htons>
  807b67:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807b6b:	83 c4 0c             	add    $0xc,%esp
  807b6e:	ff 75 cc             	push   -0x34(%ebp)
  807b71:	ff 75 1c             	push   0x1c(%ebp)
  807b74:	ff 73 08             	push   0x8(%ebx)
  807b77:	e8 07 72 00 00       	call   80ed83 <memcpy>
  807b7c:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807b7f:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  807b83:	0f b7 c2             	movzwl %dx,%eax
  807b86:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807b89:	01 45 d0             	add    %eax,-0x30(%ebp)
  while (queue == NULL || left > 0) {
  807b8c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807b90:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807b94:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807b98:	66 29 55 de          	sub    %dx,-0x22(%ebp)
  807b9c:	0f 85 5b fe ff ff    	jne    8079fd <tcp_enqueue+0x122>
  807ba2:	84 c0                	test   %al,%al
  807ba4:	0f 85 53 fe ff ff    	jne    8079fd <tcp_enqueue+0x122>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807baa:	8b 77 74             	mov    0x74(%edi),%esi
  807bad:	85 f6                	test   %esi,%esi
  807baf:	0f 84 bb 03 00 00    	je     807f70 <tcp_enqueue+0x695>
  807bb5:	89 f0                	mov    %esi,%eax
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807bb7:	8b 36                	mov    (%esi),%esi
  807bb9:	85 f6                	test   %esi,%esi
  807bbb:	75 f8                	jne    807bb5 <tcp_enqueue+0x2da>
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  807bbd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807bc0:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  807bc4:	66 89 55 de          	mov    %dx,-0x22(%ebp)
  807bc8:	83 ec 0c             	sub    $0xc,%esp
  807bcb:	8b 40 10             	mov    0x10(%eax),%eax
  807bce:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807bd2:	50                   	push   %eax
  807bd3:	e8 bb fa ff ff       	call   807693 <ntohs>
  807bd8:	83 c4 10             	add    $0x10,%esp
  807bdb:	a8 01                	test   $0x1,%al
  807bdd:	0f 84 59 02 00 00    	je     807e3c <tcp_enqueue+0x561>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807be3:	83 ec 0c             	sub    $0xc,%esp
  807be6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807be9:	8b 40 10             	mov    0x10(%eax),%eax
  807bec:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807bf0:	50                   	push   %eax
  807bf1:	e8 9d fa ff ff       	call   807693 <ntohs>
    TCP_TCPLEN(useg) != 0 &&
  807bf6:	83 c4 10             	add    $0x10,%esp
  807bf9:	a8 03                	test   $0x3,%al
  807bfb:	0f 85 63 02 00 00    	jne    807e64 <tcp_enqueue+0x589>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807c01:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807c05:	0f 85 59 02 00 00    	jne    807e64 <tcp_enqueue+0x589>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  807c0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807c0e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807c12:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807c15:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  807c19:	01 d0                	add    %edx,%eax
  807c1b:	0f b7 57 34          	movzwl 0x34(%edi),%edx
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807c1f:	39 d0                	cmp    %edx,%eax
  807c21:	0f 8f 3d 02 00 00    	jg     807e64 <tcp_enqueue+0x589>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807c27:	83 ec 08             	sub    $0x8,%esp
  807c2a:	6a ec                	push   $0xffffffec
  807c2c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807c2f:	ff 70 04             	push   0x4(%eax)
  807c32:	e8 46 cb ff ff       	call   80477d <pbuf_header>
  807c37:	83 c4 10             	add    $0x10,%esp
  807c3a:	84 c0                	test   %al,%al
  807c3c:	0f 85 c5 02 00 00    	jne    807f07 <tcp_enqueue+0x62c>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  807c42:	83 ec 08             	sub    $0x8,%esp
  807c45:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807c48:	ff 72 04             	push   0x4(%edx)
  807c4b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807c4e:	ff 71 04             	push   0x4(%ecx)
  807c51:	e8 58 d0 ff ff       	call   804cae <pbuf_cat>
    useg->len += queue->len;
  807c56:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807c59:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807c5d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807c60:	66 01 41 0c          	add    %ax,0xc(%ecx)
    useg->next = queue->next;
  807c64:	8b 02                	mov    (%edx),%eax
  807c66:	89 01                	mov    %eax,(%ecx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  807c68:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807c6b:	39 da                	cmp    %ebx,%edx
  807c6d:	0f 44 de             	cmove  %esi,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  807c70:	52                   	push   %edx
  807c71:	6a 04                	push   $0x4
  807c73:	e8 83 c8 ff ff       	call   8044fb <memp_free>
  807c78:	83 c4 10             	add    $0x10,%esp
  807c7b:	e9 00 02 00 00       	jmp    807e80 <tcp_enqueue+0x5a5>
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807c80:	83 ec 04             	sub    $0x4,%esp
  807c83:	68 08 1f 81 00       	push   $0x811f08
  807c88:	68 b0 00 00 00       	push   $0xb0
  807c8d:	68 e6 1f 81 00       	push   $0x811fe6
  807c92:	e8 3f 68 00 00       	call   80e4d6 <_panic>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807c97:	83 ec 04             	sub    $0x4,%esp
  807c9a:	68 fe 1f 81 00       	push   $0x811ffe
  807c9f:	68 ce 00 00 00       	push   $0xce
  807ca4:	68 e6 1f 81 00       	push   $0x811fe6
  807ca9:	e8 28 68 00 00       	call   80e4d6 <_panic>
    seg = memp_malloc(MEMP_TCP_SEG);
  807cae:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807cb1:	e9 93 fd ff ff       	jmp    807a49 <tcp_enqueue+0x16e>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807cb6:	83 ec 04             	sub    $0x4,%esp
  807cb9:	68 3c 1f 81 00       	push   $0x811f3c
  807cbe:	68 de 00 00 00       	push   $0xde
  807cc3:	68 e6 1f 81 00       	push   $0x811fe6
  807cc8:	e8 09 68 00 00       	call   80e4d6 <_panic>
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807ccd:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807cd1:	74 7f                	je     807d52 <tcp_enqueue+0x477>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807cd3:	83 ec 04             	sub    $0x4,%esp
  807cd6:	6a 00                	push   $0x0
  807cd8:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807cdc:	0f b7 c6             	movzwl %si,%eax
  807cdf:	50                   	push   %eax
  807ce0:	6a 00                	push   $0x0
  807ce2:	e8 2b cc ff ff       	call   804912 <pbuf_alloc>
  807ce7:	89 43 04             	mov    %eax,0x4(%ebx)
  807cea:	83 c4 10             	add    $0x10,%esp
  807ced:	85 c0                	test   %eax,%eax
  807cef:	0f 84 d7 00 00 00    	je     807dcc <tcp_enqueue+0x4f1>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807cf5:	66 39 70 0a          	cmp    %si,0xa(%eax)
  807cf9:	72 40                	jb     807d3b <tcp_enqueue+0x460>
      queuelen += pbuf_clen(seg->p);
  807cfb:	83 ec 0c             	sub    $0xc,%esp
  807cfe:	50                   	push   %eax
  807cff:	e8 7f cf ff ff       	call   804c83 <pbuf_clen>
  807d04:	0f b6 c0             	movzbl %al,%eax
  807d07:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807d0b:	83 c4 10             	add    $0x10,%esp
  807d0e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807d12:	74 19                	je     807d2d <tcp_enqueue+0x452>
        MEMCPY(seg->p->payload, ptr, seglen);
  807d14:	83 ec 04             	sub    $0x4,%esp
  807d17:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807d1b:	50                   	push   %eax
  807d1c:	ff 75 d0             	push   -0x30(%ebp)
  807d1f:	8b 43 04             	mov    0x4(%ebx),%eax
  807d22:	ff 70 04             	push   0x4(%eax)
  807d25:	e8 59 70 00 00       	call   80ed83 <memcpy>
  807d2a:	83 c4 10             	add    $0x10,%esp
      seg->dataptr = seg->p->payload;
  807d2d:	8b 43 04             	mov    0x4(%ebx),%eax
  807d30:	8b 40 04             	mov    0x4(%eax),%eax
  807d33:	89 43 08             	mov    %eax,0x8(%ebx)
  807d36:	e9 5f fd ff ff       	jmp    807a9a <tcp_enqueue+0x1bf>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807d3b:	83 ec 04             	sub    $0x4,%esp
  807d3e:	68 64 1f 81 00       	push   $0x811f64
  807d43:	68 e9 00 00 00       	push   $0xe9
  807d48:	68 e6 1f 81 00       	push   $0x811fe6
  807d4d:	e8 84 67 00 00       	call   80e4d6 <_panic>
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807d52:	83 ec 04             	sub    $0x4,%esp
  807d55:	6a 01                	push   $0x1
  807d57:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807d5b:	50                   	push   %eax
  807d5c:	6a 00                	push   $0x0
  807d5e:	e8 af cb ff ff       	call   804912 <pbuf_alloc>
  807d63:	89 c6                	mov    %eax,%esi
  807d65:	83 c4 10             	add    $0x10,%esp
  807d68:	85 c0                	test   %eax,%eax
  807d6a:	74 60                	je     807dcc <tcp_enqueue+0x4f1>
      ++queuelen;
  807d6c:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807d70:	83 c0 01             	add    $0x1,%eax
  807d73:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      p->payload = ptr;
  807d77:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807d7a:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807d7d:	89 43 08             	mov    %eax,0x8(%ebx)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807d80:	83 ec 04             	sub    $0x4,%esp
  807d83:	6a 00                	push   $0x0
  807d85:	6a 00                	push   $0x0
  807d87:	6a 00                	push   $0x0
  807d89:	e8 84 cb ff ff       	call   804912 <pbuf_alloc>
  807d8e:	89 43 04             	mov    %eax,0x4(%ebx)
  807d91:	83 c4 10             	add    $0x10,%esp
  807d94:	85 c0                	test   %eax,%eax
  807d96:	74 28                	je     807dc0 <tcp_enqueue+0x4e5>
      queuelen += pbuf_clen(seg->p);
  807d98:	83 ec 0c             	sub    $0xc,%esp
  807d9b:	50                   	push   %eax
  807d9c:	e8 e2 ce ff ff       	call   804c83 <pbuf_clen>
  807da1:	0f b6 c0             	movzbl %al,%eax
  807da4:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807da8:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807dac:	83 c4 08             	add    $0x8,%esp
  807daf:	56                   	push   %esi
  807db0:	ff 73 04             	push   0x4(%ebx)
  807db3:	e8 f6 ce ff ff       	call   804cae <pbuf_cat>
  807db8:	83 c4 10             	add    $0x10,%esp
  807dbb:	e9 da fc ff ff       	jmp    807a9a <tcp_enqueue+0x1bf>
        pbuf_free(p);
  807dc0:	83 ec 0c             	sub    $0xc,%esp
  807dc3:	56                   	push   %esi
  807dc4:	e8 83 ca ff ff       	call   80484c <pbuf_free>
        goto memerr;
  807dc9:	83 c4 10             	add    $0x10,%esp
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807dcc:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807dd0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807dd3:	85 c0                	test   %eax,%eax
  807dd5:	74 0c                	je     807de3 <tcp_enqueue+0x508>
    tcp_segs_free(queue);
  807dd7:	83 ec 0c             	sub    $0xc,%esp
  807dda:	50                   	push   %eax
  807ddb:	e8 8c d9 ff ff       	call   80576c <tcp_segs_free>
  807de0:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807de3:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807de8:	0f 84 6e 01 00 00    	je     807f5c <tcp_enqueue+0x681>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807dee:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807df2:	0f 85 6e 01 00 00    	jne    807f66 <tcp_enqueue+0x68b>
  807df8:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807dfc:	0f 84 39 01 00 00    	je     807f3b <tcp_enqueue+0x660>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807e02:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  807e07:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807e0a:	5b                   	pop    %ebx
  807e0b:	5e                   	pop    %esi
  807e0c:	5f                   	pop    %edi
  807e0d:	5d                   	pop    %ebp
  807e0e:	c3                   	ret    
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807e0f:	83 ec 0c             	sub    $0xc,%esp
  807e12:	8b 43 10             	mov    0x10(%ebx),%eax
  807e15:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e19:	50                   	push   %eax
  807e1a:	e8 74 f8 ff ff       	call   807693 <ntohs>
  807e1f:	8b 73 10             	mov    0x10(%ebx),%esi
  807e22:	83 e0 3f             	and    $0x3f,%eax
  807e25:	80 cc 50             	or     $0x50,%ah
  807e28:	89 04 24             	mov    %eax,(%esp)
  807e2b:	e8 56 f8 ff ff       	call   807686 <htons>
  807e30:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807e34:	83 c4 10             	add    $0x10,%esp
  807e37:	e9 43 fd ff ff       	jmp    807b7f <tcp_enqueue+0x2a4>
    TCP_TCPLEN(useg) != 0 &&
  807e3c:	83 ec 0c             	sub    $0xc,%esp
  807e3f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807e42:	8b 40 10             	mov    0x10(%eax),%eax
  807e45:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e49:	50                   	push   %eax
  807e4a:	e8 44 f8 ff ff       	call   807693 <ntohs>
  807e4f:	66 d1 e8             	shr    %ax
  807e52:	83 e0 01             	and    $0x1,%eax
  807e55:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  if (useg != NULL &&
  807e59:	83 c4 10             	add    $0x10,%esp
  807e5c:	01 d0                	add    %edx,%eax
  807e5e:	0f 85 7f fd ff ff    	jne    807be3 <tcp_enqueue+0x308>
      useg->next = queue;
  807e64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807e67:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e6a:	89 10                	mov    %edx,(%eax)
    ++len;
  807e6c:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807e70:	83 c0 01             	add    $0x1,%eax
  807e73:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807e77:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  807e7c:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  if (flags & TCP_FIN) {
  807e80:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  807e84:	74 04                	je     807e8a <tcp_enqueue+0x5af>
    pcb->flags |= TF_FIN;
  807e86:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  pcb->snd_lbb += len;
  807e8a:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  807e8e:	0f b7 c2             	movzwl %dx,%eax
  807e91:	01 47 68             	add    %eax,0x68(%edi)
  pcb->snd_buf -= len;
  807e94:	66 29 57 6e          	sub    %dx,0x6e(%edi)
  pcb->snd_queuelen = queuelen;
  807e98:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807e9c:	66 89 47 70          	mov    %ax,0x70(%edi)
  if (pcb->snd_queuelen != 0) {
  807ea0:	66 85 c0             	test   %ax,%ax
  807ea3:	74 06                	je     807eab <tcp_enqueue+0x5d0>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807ea5:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807ea9:	74 73                	je     807f1e <tcp_enqueue+0x643>
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807eab:	85 db                	test   %ebx,%ebx
  807ead:	0f 84 9f 00 00 00    	je     807f52 <tcp_enqueue+0x677>
  807eb3:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  807eb8:	0f 84 94 00 00 00    	je     807f52 <tcp_enqueue+0x677>
  807ebe:	8b 53 10             	mov    0x10(%ebx),%edx
  return ERR_OK;
  807ec1:	b8 00 00 00 00       	mov    $0x0,%eax
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807ec6:	85 d2                	test   %edx,%edx
  807ec8:	0f 84 39 ff ff ff    	je     807e07 <tcp_enqueue+0x52c>
  807ece:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  807ed2:	0f 85 2f ff ff ff    	jne    807e07 <tcp_enqueue+0x52c>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  807ed8:	83 ec 0c             	sub    $0xc,%esp
  807edb:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807edf:	50                   	push   %eax
  807ee0:	e8 ae f7 ff ff       	call   807693 <ntohs>
  807ee5:	8b 5b 10             	mov    0x10(%ebx),%ebx
  807ee8:	83 c8 08             	or     $0x8,%eax
  807eeb:	0f b7 c0             	movzwl %ax,%eax
  807eee:	89 04 24             	mov    %eax,(%esp)
  807ef1:	e8 90 f7 ff ff       	call   807686 <htons>
  807ef6:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  807efa:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  807efd:	b8 00 00 00 00       	mov    $0x0,%eax
  807f02:	e9 00 ff ff ff       	jmp    807e07 <tcp_enqueue+0x52c>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  807f07:	83 ec 04             	sub    $0x4,%esp
  807f0a:	68 0b 20 81 00       	push   $0x81200b
  807f0f:	68 52 01 00 00       	push   $0x152
  807f14:	68 e6 1f 81 00       	push   $0x811fe6
  807f19:	e8 b8 65 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807f1e:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807f22:	75 87                	jne    807eab <tcp_enqueue+0x5d0>
  807f24:	83 ec 04             	sub    $0x4,%esp
  807f27:	68 98 1f 81 00       	push   $0x811f98
  807f2c:	68 79 01 00 00       	push   $0x179
  807f31:	68 e6 1f 81 00       	push   $0x811fe6
  807f36:	e8 9b 65 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807f3b:	83 ec 04             	sub    $0x4,%esp
  807f3e:	68 98 1f 81 00       	push   $0x811f98
  807f43:	68 8c 01 00 00       	push   $0x18c
  807f48:	68 e6 1f 81 00       	push   $0x811fe6
  807f4d:	e8 84 65 00 00       	call   80e4d6 <_panic>
  return ERR_OK;
  807f52:	b8 00 00 00 00       	mov    $0x0,%eax
  807f57:	e9 ab fe ff ff       	jmp    807e07 <tcp_enqueue+0x52c>
  return ERR_MEM;
  807f5c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f61:	e9 a1 fe ff ff       	jmp    807e07 <tcp_enqueue+0x52c>
  807f66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f6b:	e9 97 fe ff ff       	jmp    807e07 <tcp_enqueue+0x52c>
      pcb->unsent = queue;
  807f70:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807f73:	89 47 74             	mov    %eax,0x74(%edi)
  807f76:	e9 f1 fe ff ff       	jmp    807e6c <tcp_enqueue+0x591>

00807f7b <tcp_send_ctrl>:
{
  807f7b:	55                   	push   %ebp
  807f7c:	89 e5                	mov    %esp,%ebp
  807f7e:	83 ec 0c             	sub    $0xc,%esp
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  807f81:	6a 00                	push   $0x0
  807f83:	6a 00                	push   $0x0
  807f85:	6a 01                	push   $0x1
  807f87:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  807f8b:	50                   	push   %eax
  807f8c:	6a 00                	push   $0x0
  807f8e:	6a 00                	push   $0x0
  807f90:	ff 75 08             	push   0x8(%ebp)
  807f93:	e8 43 f9 ff ff       	call   8078db <tcp_enqueue>
}
  807f98:	c9                   	leave  
  807f99:	c3                   	ret    

00807f9a <tcp_write>:
{
  807f9a:	55                   	push   %ebp
  807f9b:	89 e5                	mov    %esp,%ebp
  807f9d:	56                   	push   %esi
  807f9e:	53                   	push   %ebx
  807f9f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807fa2:	8b 55 10             	mov    0x10(%ebp),%edx
  807fa5:	8b 75 14             	mov    0x14(%ebp),%esi
  if (pcb->state == ESTABLISHED ||
  807fa8:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
  807fab:	8d 58 fe             	lea    -0x2(%eax),%ebx
     pcb->state == SYN_SENT ||
  807fae:	83 fb 02             	cmp    $0x2,%ebx
  807fb1:	76 05                	jbe    807fb8 <tcp_write+0x1e>
  807fb3:	83 f8 07             	cmp    $0x7,%eax
  807fb6:	75 32                	jne    807fea <tcp_write+0x50>
    return ERR_OK;
  807fb8:	b8 00 00 00 00       	mov    $0x0,%eax
    if (len > 0) {
  807fbd:	66 85 d2             	test   %dx,%dx
  807fc0:	75 07                	jne    807fc9 <tcp_write+0x2f>
}
  807fc2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  807fc5:	5b                   	pop    %ebx
  807fc6:	5e                   	pop    %esi
  807fc7:	5d                   	pop    %ebp
  807fc8:	c3                   	ret    
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  807fc9:	83 ec 04             	sub    $0x4,%esp
  807fcc:	6a 00                	push   $0x0
  807fce:	6a 00                	push   $0x0
  807fd0:	89 f0                	mov    %esi,%eax
  807fd2:	0f b6 f0             	movzbl %al,%esi
  807fd5:	56                   	push   %esi
  807fd6:	6a 00                	push   $0x0
  807fd8:	0f b7 d2             	movzwl %dx,%edx
  807fdb:	52                   	push   %edx
  807fdc:	ff 75 0c             	push   0xc(%ebp)
  807fdf:	51                   	push   %ecx
  807fe0:	e8 f6 f8 ff ff       	call   8078db <tcp_enqueue>
  807fe5:	83 c4 20             	add    $0x20,%esp
  807fe8:	eb d8                	jmp    807fc2 <tcp_write+0x28>
    return ERR_CONN;
  807fea:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  807fef:	eb d1                	jmp    807fc2 <tcp_write+0x28>

00807ff1 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  807ff1:	55                   	push   %ebp
  807ff2:	89 e5                	mov    %esp,%ebp
  807ff4:	57                   	push   %edi
  807ff5:	56                   	push   %esi
  807ff6:	53                   	push   %ebx
  807ff7:	83 ec 1c             	sub    $0x1c,%esp
  807ffa:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  807ffd:	39 3d f8 b1 b3 00    	cmp    %edi,0xb3b1f8
  808003:	0f 84 63 04 00 00    	je     80846c <tcp_output+0x47b>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  808009:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80800d:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  808011:	66 39 d0             	cmp    %dx,%ax
  808014:	0f 47 c2             	cmova  %edx,%eax
  808017:	0f b7 c0             	movzwl %ax,%eax
  80801a:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  80801d:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  808020:	8b 47 78             	mov    0x78(%edi),%eax
  808023:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (useg != NULL) {
  808026:	85 c0                	test   %eax,%eax
  808028:	74 0b                	je     808035 <tcp_output+0x44>
  80802a:	89 c2                	mov    %eax,%edx
    for (; useg->next != NULL; useg = useg->next);
  80802c:	8b 00                	mov    (%eax),%eax
  80802e:	85 c0                	test   %eax,%eax
  808030:	75 f8                	jne    80802a <tcp_output+0x39>
  808032:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  808035:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  808039:	0f 84 eb 03 00 00    	je     80842a <tcp_output+0x439>
  80803f:	85 db                	test   %ebx,%ebx
  808041:	74 25                	je     808068 <tcp_output+0x77>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  808043:	83 ec 0c             	sub    $0xc,%esp
  808046:	8b 43 10             	mov    0x10(%ebx),%eax
  808049:	ff 70 04             	push   0x4(%eax)
  80804c:	e8 77 f8 ff ff       	call   8078c8 <ntohl>
  808051:	89 c2                	mov    %eax,%edx
  808053:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808057:	2b 47 48             	sub    0x48(%edi),%eax
  80805a:	01 d0                	add    %edx,%eax
     (seg == NULL ||
  80805c:	83 c4 10             	add    $0x10,%esp
  80805f:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  808062:	0f 86 c2 03 00 00    	jbe    80842a <tcp_output+0x439>
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808068:	83 ec 04             	sub    $0x4,%esp
  80806b:	6a 00                	push   $0x0
  80806d:	6a 14                	push   $0x14
  80806f:	6a 01                	push   $0x1
  808071:	e8 9c c8 ff ff       	call   804912 <pbuf_alloc>
  808076:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  808078:	83 c4 10             	add    $0x10,%esp
  80807b:	85 c0                	test   %eax,%eax
  80807d:	0f 84 f0 03 00 00    	je     808473 <tcp_output+0x482>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808083:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  808087:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  80808a:	83 ec 0c             	sub    $0xc,%esp
  80808d:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  808091:	50                   	push   %eax
  808092:	e8 ef f5 ff ff       	call   807686 <htons>
  808097:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  80809a:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  80809e:	89 04 24             	mov    %eax,(%esp)
  8080a1:	e8 e0 f5 ff ff       	call   807686 <htons>
  8080a6:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8080aa:	83 c4 04             	add    $0x4,%esp
  8080ad:	ff 77 54             	push   0x54(%edi)
  8080b0:	e8 eb f5 ff ff       	call   8076a0 <htonl>
  8080b5:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  8080b8:	83 c4 04             	add    $0x4,%esp
  8080bb:	ff 77 24             	push   0x24(%edi)
  8080be:	e8 dd f5 ff ff       	call   8076a0 <htonl>
  8080c3:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  8080c6:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8080ca:	89 04 24             	mov    %eax,(%esp)
  8080cd:	e8 c1 f5 ff ff       	call   807693 <ntohs>
  8080d2:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8080d7:	83 c8 10             	or     $0x10,%eax
  8080da:	89 04 24             	mov    %eax,(%esp)
  8080dd:	e8 a4 f5 ff ff       	call   807686 <htons>
  8080e2:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8080e6:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8080ea:	89 04 24             	mov    %eax,(%esp)
  8080ed:	e8 94 f5 ff ff       	call   807686 <htons>
  8080f2:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  8080f6:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  8080fc:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808100:	89 04 24             	mov    %eax,(%esp)
  808103:	e8 8b f5 ff ff       	call   807693 <ntohs>
  808108:	83 e0 3f             	and    $0x3f,%eax
  80810b:	80 cc 50             	or     $0x50,%ah
  80810e:	89 04 24             	mov    %eax,(%esp)
  808111:	e8 70 f5 ff ff       	call   807686 <htons>
  808116:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80811a:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  808120:	8d 47 04             	lea    0x4(%edi),%eax
  808123:	89 c1                	mov    %eax,%ecx
  808125:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808129:	89 04 24             	mov    %eax,(%esp)
  80812c:	6a 06                	push   $0x6
  80812e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808131:	51                   	push   %ecx
  808132:	57                   	push   %edi
  808133:	56                   	push   %esi
  808134:	e8 31 f2 ff ff       	call   80736a <inet_chksum_pseudo>
  808139:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80813d:	83 c4 18             	add    $0x18,%esp
  808140:	6a 06                	push   $0x6
  808142:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808146:	50                   	push   %eax
  808147:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80814b:	50                   	push   %eax
  80814c:	ff 75 e4             	push   -0x1c(%ebp)
  80814f:	57                   	push   %edi
  808150:	56                   	push   %esi
  808151:	e8 2f e8 ff ff       	call   806985 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  808156:	83 c4 14             	add    $0x14,%esp
  808159:	56                   	push   %esi
  80815a:	e8 ed c6 ff ff       	call   80484c <pbuf_free>

    return ERR_OK;
  80815f:	83 c4 10             	add    $0x10,%esp
  808162:	b8 00 00 00 00       	mov    $0x0,%eax
  808167:	e9 20 03 00 00       	jmp    80848c <tcp_output+0x49b>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80816c:	83 ec 04             	sub    $0x4,%esp
  80816f:	68 1f 20 81 00       	push   $0x81201f
  808174:	68 04 02 00 00       	push   $0x204
  808179:	68 e6 1f 81 00       	push   $0x811fe6
  80817e:	e8 53 63 00 00       	call   80e4d6 <_panic>
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  808183:	83 ec 0c             	sub    $0xc,%esp
  808186:	8b 43 10             	mov    0x10(%ebx),%eax
  808189:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80818d:	50                   	push   %eax
  80818e:	e8 00 f5 ff ff       	call   807693 <ntohs>
  808193:	8b 73 10             	mov    0x10(%ebx),%esi
  808196:	83 c8 10             	or     $0x10,%eax
  808199:	0f b7 c0             	movzwl %ax,%eax
  80819c:	89 04 24             	mov    %eax,(%esp)
  80819f:	e8 e2 f4 ff ff       	call   807686 <htons>
  8081a4:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8081a8:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  8081ac:	83 c4 10             	add    $0x10,%esp
  8081af:	e9 06 01 00 00       	jmp    8082ba <tcp_output+0x2c9>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
    pcb->rtime = 0;
  8081b4:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)
  8081ba:	e9 49 01 00 00       	jmp    808308 <tcp_output+0x317>

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
  8081bf:	a1 58 44 b3 00       	mov    0xb34458,%eax
  8081c4:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8081c7:	83 ec 0c             	sub    $0xc,%esp
  8081ca:	8b 43 10             	mov    0x10(%ebx),%eax
  8081cd:	ff 70 04             	push   0x4(%eax)
  8081d0:	e8 f3 f6 ff ff       	call   8078c8 <ntohl>
  8081d5:	89 47 3c             	mov    %eax,0x3c(%edi)
  8081d8:	83 c4 10             	add    $0x10,%esp
  8081db:	e9 32 01 00 00       	jmp    808312 <tcp_output+0x321>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8081e0:	83 ec 0c             	sub    $0xc,%esp
  8081e3:	8b 43 10             	mov    0x10(%ebx),%eax
  8081e6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8081ea:	50                   	push   %eax
  8081eb:	e8 a3 f4 ff ff       	call   807693 <ntohs>
  8081f0:	66 d1 e8             	shr    %ax
  8081f3:	83 e0 01             	and    $0x1,%eax
  8081f6:	83 c4 10             	add    $0x10,%esp
  8081f9:	e9 aa 01 00 00       	jmp    8083a8 <tcp_output+0x3b7>
      pcb->snd_max = pcb->snd_nxt;
  8081fe:	89 77 58             	mov    %esi,0x58(%edi)
  808201:	e9 b3 01 00 00       	jmp    8083b9 <tcp_output+0x3c8>
    if (TCP_TCPLEN(seg) > 0) {
  808206:	83 ec 0c             	sub    $0xc,%esp
  808209:	8b 43 10             	mov    0x10(%ebx),%eax
  80820c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808210:	50                   	push   %eax
  808211:	e8 7d f4 ff ff       	call   807693 <ntohs>
  808216:	66 d1 e8             	shr    %ax
  808219:	83 e0 01             	and    $0x1,%eax
  80821c:	0f b7 f6             	movzwl %si,%esi
  80821f:	83 c4 10             	add    $0x10,%esp
  808222:	01 f0                	add    %esi,%eax
  808224:	0f 85 ae 01 00 00    	jne    8083d8 <tcp_output+0x3e7>
      tcp_seg_free(seg);
  80822a:	83 ec 0c             	sub    $0xc,%esp
  80822d:	53                   	push   %ebx
  80822e:	e8 fc d4 ff ff       	call   80572f <tcp_seg_free>
  808233:	83 c4 10             	add    $0x10,%esp
  808236:	eb 06                	jmp    80823e <tcp_output+0x24d>
        pcb->unacked = seg;
  808238:	89 5f 78             	mov    %ebx,0x78(%edi)
  80823b:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    seg = pcb->unsent;
  80823e:	8b 5f 74             	mov    0x74(%edi),%ebx
  while (seg != NULL &&
  808241:	85 db                	test   %ebx,%ebx
  808243:	0f 84 3a 02 00 00    	je     808483 <tcp_output+0x492>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808249:	83 ec 0c             	sub    $0xc,%esp
  80824c:	8b 43 10             	mov    0x10(%ebx),%eax
  80824f:	ff 70 04             	push   0x4(%eax)
  808252:	e8 71 f6 ff ff       	call   8078c8 <ntohl>
  808257:	89 c2                	mov    %eax,%edx
  808259:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80825d:	2b 47 48             	sub    0x48(%edi),%eax
  808260:	01 d0                	add    %edx,%eax
  while (seg != NULL &&
  808262:	83 c4 10             	add    $0x10,%esp
  808265:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  808268:	0f 87 0c 02 00 00    	ja     80847a <tcp_output+0x489>
    LWIP_ASSERT("RST not expected here!", 
  80826e:	83 ec 0c             	sub    $0xc,%esp
  808271:	8b 43 10             	mov    0x10(%ebx),%eax
  808274:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808278:	50                   	push   %eax
  808279:	e8 15 f4 ff ff       	call   807693 <ntohs>
  80827e:	83 c4 10             	add    $0x10,%esp
  808281:	a8 04                	test   $0x4,%al
  808283:	0f 85 e3 fe ff ff    	jne    80816c <tcp_output+0x17b>
    if((tcp_do_output_nagle(pcb) == 0) &&
  808289:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80828d:	74 1c                	je     8082ab <tcp_output+0x2ba>
  80828f:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  808293:	a8 40                	test   $0x40,%al
  808295:	75 14                	jne    8082ab <tcp_output+0x2ba>
  808297:	8b 57 74             	mov    0x74(%edi),%edx
  80829a:	85 d2                	test   %edx,%edx
  80829c:	74 05                	je     8082a3 <tcp_output+0x2b2>
  80829e:	83 3a 00             	cmpl   $0x0,(%edx)
  8082a1:	75 08                	jne    8082ab <tcp_output+0x2ba>
  8082a3:	a8 a0                	test   $0xa0,%al
  8082a5:	0f 84 cf 01 00 00    	je     80847a <tcp_output+0x489>
    pcb->unsent = seg->next;
  8082ab:	8b 03                	mov    (%ebx),%eax
  8082ad:	89 47 74             	mov    %eax,0x74(%edi)
    if (pcb->state != SYN_SENT) {
  8082b0:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  8082b4:	0f 85 c9 fe ff ff    	jne    808183 <tcp_output+0x192>
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8082ba:	8b 73 10             	mov    0x10(%ebx),%esi
  8082bd:	83 ec 0c             	sub    $0xc,%esp
  8082c0:	ff 77 24             	push   0x24(%edi)
  8082c3:	e8 d8 f3 ff ff       	call   8076a0 <htonl>
  8082c8:	89 46 08             	mov    %eax,0x8(%esi)
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8082cb:	8b 73 10             	mov    0x10(%ebx),%esi
  8082ce:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8082d2:	89 04 24             	mov    %eax,(%esp)
  8082d5:	e8 ac f3 ff ff       	call   807686 <htons>
  8082da:	66 89 46 0e          	mov    %ax,0xe(%esi)
  if (ip_addr_isany(&(pcb->local_ip))) {
  8082de:	83 c4 10             	add    $0x10,%esp
  8082e1:	83 3f 00             	cmpl   $0x0,(%edi)
  8082e4:	75 17                	jne    8082fd <tcp_output+0x30c>
    netif = ip_route(&(pcb->remote_ip));
  8082e6:	83 ec 0c             	sub    $0xc,%esp
  8082e9:	ff 75 e4             	push   -0x1c(%ebp)
  8082ec:	e8 9e e1 ff ff       	call   80648f <ip_route>
    if (netif == NULL) {
  8082f1:	83 c4 10             	add    $0x10,%esp
  8082f4:	85 c0                	test   %eax,%eax
  8082f6:	74 79                	je     808371 <tcp_output+0x380>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8082f8:	8b 40 04             	mov    0x4(%eax),%eax
  8082fb:	89 07                	mov    %eax,(%edi)
  if(pcb->rtime == -1)
  8082fd:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  808302:	0f 84 ac fe ff ff    	je     8081b4 <tcp_output+0x1c3>
  if (pcb->rttest == 0) {
  808308:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  80830c:	0f 84 ad fe ff ff    	je     8081bf <tcp_output+0x1ce>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808312:	8b 53 04             	mov    0x4(%ebx),%edx
  808315:	8b 43 10             	mov    0x10(%ebx),%eax
  808318:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  80831b:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  80831f:	8b 53 04             	mov    0x4(%ebx),%edx
  808322:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  808326:	8b 53 04             	mov    0x4(%ebx),%edx
  808329:	8b 43 10             	mov    0x10(%ebx),%eax
  80832c:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  80832f:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  808335:	8b 43 04             	mov    0x4(%ebx),%eax
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808338:	8b 73 10             	mov    0x10(%ebx),%esi
  80833b:	83 ec 0c             	sub    $0xc,%esp
  80833e:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808342:	52                   	push   %edx
  808343:	6a 06                	push   $0x6
  808345:	ff 75 e4             	push   -0x1c(%ebp)
  808348:	57                   	push   %edi
  808349:	50                   	push   %eax
  80834a:	e8 1b f0 ff ff       	call   80736a <inet_chksum_pseudo>
  80834f:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808353:	83 c4 18             	add    $0x18,%esp
  808356:	6a 06                	push   $0x6
  808358:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80835c:	50                   	push   %eax
  80835d:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808361:	50                   	push   %eax
  808362:	ff 75 e4             	push   -0x1c(%ebp)
  808365:	57                   	push   %edi
  808366:	ff 73 04             	push   0x4(%ebx)
  808369:	e8 17 e6 ff ff       	call   806985 <ip_output>
  80836e:	83 c4 20             	add    $0x20,%esp
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808371:	83 ec 0c             	sub    $0xc,%esp
  808374:	8b 43 10             	mov    0x10(%ebx),%eax
  808377:	ff 70 04             	push   0x4(%eax)
  80837a:	e8 49 f5 ff ff       	call   8078c8 <ntohl>
  80837f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808382:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808386:	8b 43 10             	mov    0x10(%ebx),%eax
  808389:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80838d:	89 04 24             	mov    %eax,(%esp)
  808390:	e8 fe f2 ff ff       	call   807693 <ntohs>
  808395:	89 c2                	mov    %eax,%edx
  808397:	83 c4 10             	add    $0x10,%esp
  80839a:	b8 01 00 00 00       	mov    $0x1,%eax
  80839f:	f6 c2 01             	test   $0x1,%dl
  8083a2:	0f 84 38 fe ff ff    	je     8081e0 <tcp_output+0x1ef>
  8083a8:	01 c6                	add    %eax,%esi
  8083aa:	03 75 e0             	add    -0x20(%ebp),%esi
  8083ad:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8083b0:	39 77 58             	cmp    %esi,0x58(%edi)
  8083b3:	0f 88 45 fe ff ff    	js     8081fe <tcp_output+0x20d>
    if (TCP_TCPLEN(seg) > 0) {
  8083b9:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8083bd:	83 ec 0c             	sub    $0xc,%esp
  8083c0:	8b 43 10             	mov    0x10(%ebx),%eax
  8083c3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8083c7:	50                   	push   %eax
  8083c8:	e8 c6 f2 ff ff       	call   807693 <ntohs>
  8083cd:	83 c4 10             	add    $0x10,%esp
  8083d0:	a8 01                	test   $0x1,%al
  8083d2:	0f 84 2e fe ff ff    	je     808206 <tcp_output+0x215>
      seg->next = NULL;
  8083d8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      if (pcb->unacked == NULL) {
  8083de:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8083e2:	0f 84 50 fe ff ff    	je     808238 <tcp_output+0x247>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  8083e8:	83 ec 0c             	sub    $0xc,%esp
  8083eb:	8b 43 10             	mov    0x10(%ebx),%eax
  8083ee:	ff 70 04             	push   0x4(%eax)
  8083f1:	e8 d2 f4 ff ff       	call   8078c8 <ntohl>
  8083f6:	89 c6                	mov    %eax,%esi
  8083f8:	83 c4 04             	add    $0x4,%esp
  8083fb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8083fe:	8b 40 10             	mov    0x10(%eax),%eax
  808401:	ff 70 04             	push   0x4(%eax)
  808404:	e8 bf f4 ff ff       	call   8078c8 <ntohl>
  808409:	83 c4 10             	add    $0x10,%esp
  80840c:	39 c6                	cmp    %eax,%esi
  80840e:	78 0d                	js     80841d <tcp_output+0x42c>
          useg->next = seg;
  808410:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808413:	89 18                	mov    %ebx,(%eax)
  808415:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808418:	e9 21 fe ff ff       	jmp    80823e <tcp_output+0x24d>
          seg->next = pcb->unacked;
  80841d:	8b 47 78             	mov    0x78(%edi),%eax
  808420:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  808422:	89 5f 78             	mov    %ebx,0x78(%edi)
  808425:	e9 14 fe ff ff       	jmp    80823e <tcp_output+0x24d>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80842a:	8d 47 04             	lea    0x4(%edi),%eax
  80842d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808430:	e9 0c fe ff ff       	jmp    808241 <tcp_output+0x250>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808435:	83 ec 0c             	sub    $0xc,%esp
  808438:	8b 43 10             	mov    0x10(%ebx),%eax
  80843b:	ff 70 04             	push   0x4(%eax)
  80843e:	e8 85 f4 ff ff       	call   8078c8 <ntohl>
  808443:	89 c2                	mov    %eax,%edx
  808445:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808449:	2b 47 48             	sub    0x48(%edi),%eax
  80844c:	01 d0                	add    %edx,%eax
  80844e:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  if (seg != NULL && pcb->persist_backoff == 0 && 
  808452:	83 c4 10             	add    $0x10,%esp
  808455:	39 d0                	cmp    %edx,%eax
  808457:	76 2a                	jbe    808483 <tcp_output+0x492>
    pcb->persist_cnt = 0;
  808459:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808460:	00 00 00 
    pcb->persist_backoff = 1;
  808463:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  80846a:	eb 17                	jmp    808483 <tcp_output+0x492>
    return ERR_OK;
  80846c:	b8 00 00 00 00       	mov    $0x0,%eax
  808471:	eb 19                	jmp    80848c <tcp_output+0x49b>
      return ERR_BUF;
  808473:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808478:	eb 12                	jmp    80848c <tcp_output+0x49b>
  if (seg != NULL && pcb->persist_backoff == 0 && 
  80847a:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  808481:	74 b2                	je     808435 <tcp_output+0x444>
  pcb->flags &= ~TF_NAGLEMEMERR;
  808483:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  808487:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80848c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80848f:	5b                   	pop    %ebx
  808490:	5e                   	pop    %esi
  808491:	5f                   	pop    %edi
  808492:	5d                   	pop    %ebp
  808493:	c3                   	ret    

00808494 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  808494:	55                   	push   %ebp
  808495:	89 e5                	mov    %esp,%ebp
  808497:	57                   	push   %edi
  808498:	56                   	push   %esi
  808499:	53                   	push   %ebx
  80849a:	83 ec 20             	sub    $0x20,%esp
  80849d:	8b 7d 18             	mov    0x18(%ebp),%edi
  8084a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8084a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8084a6:	6a 00                	push   $0x0
  8084a8:	6a 14                	push   $0x14
  8084aa:	6a 01                	push   $0x1
  8084ac:	e8 61 c4 ff ff       	call   804912 <pbuf_alloc>
  if (p == NULL) {
  8084b1:	83 c4 10             	add    $0x10,%esp
  8084b4:	85 c0                	test   %eax,%eax
  8084b6:	0f 84 e2 00 00 00    	je     80859e <tcp_rst+0x10a>
  8084bc:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8084be:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8084c3:	0f 86 dd 00 00 00    	jbe    8085a6 <tcp_rst+0x112>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8084c9:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8084cc:	83 ec 0c             	sub    $0xc,%esp
  8084cf:	0f b7 ff             	movzwl %di,%edi
  8084d2:	57                   	push   %edi
  8084d3:	e8 ae f1 ff ff       	call   807686 <htons>
  8084d8:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  8084db:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8084df:	89 04 24             	mov    %eax,(%esp)
  8084e2:	e8 9f f1 ff ff       	call   807686 <htons>
  8084e7:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  8084eb:	83 c4 04             	add    $0x4,%esp
  8084ee:	ff 75 08             	push   0x8(%ebp)
  8084f1:	e8 aa f1 ff ff       	call   8076a0 <htonl>
  8084f6:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  8084f9:	83 c4 04             	add    $0x4,%esp
  8084fc:	ff 75 0c             	push   0xc(%ebp)
  8084ff:	e8 9c f1 ff ff       	call   8076a0 <htonl>
  808504:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808507:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80850b:	89 04 24             	mov    %eax,(%esp)
  80850e:	e8 80 f1 ff ff       	call   807693 <ntohs>
  808513:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808518:	83 c8 14             	or     $0x14,%eax
  80851b:	89 04 24             	mov    %eax,(%esp)
  80851e:	e8 63 f1 ff ff       	call   807686 <htons>
  808523:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808527:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80852e:	e8 53 f1 ff ff       	call   807686 <htons>
  808533:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808537:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80853d:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808541:	89 04 24             	mov    %eax,(%esp)
  808544:	e8 4a f1 ff ff       	call   807693 <ntohs>
  808549:	83 e0 3f             	and    $0x3f,%eax
  80854c:	80 cc 50             	or     $0x50,%ah
  80854f:	89 04 24             	mov    %eax,(%esp)
  808552:	e8 2f f1 ff ff       	call   807686 <htons>
  808557:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80855b:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808561:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808565:	89 04 24             	mov    %eax,(%esp)
  808568:	6a 06                	push   $0x6
  80856a:	ff 75 14             	push   0x14(%ebp)
  80856d:	ff 75 10             	push   0x10(%ebp)
  808570:	56                   	push   %esi
  808571:	e8 f4 ed ff ff       	call   80736a <inet_chksum_pseudo>
  808576:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80857a:	83 c4 18             	add    $0x18,%esp
  80857d:	6a 06                	push   $0x6
  80857f:	6a 00                	push   $0x0
  808581:	68 ff 00 00 00       	push   $0xff
  808586:	ff 75 14             	push   0x14(%ebp)
  808589:	ff 75 10             	push   0x10(%ebp)
  80858c:	56                   	push   %esi
  80858d:	e8 f3 e3 ff ff       	call   806985 <ip_output>
  pbuf_free(p);
  808592:	83 c4 14             	add    $0x14,%esp
  808595:	56                   	push   %esi
  808596:	e8 b1 c2 ff ff       	call   80484c <pbuf_free>
  80859b:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80859e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8085a1:	5b                   	pop    %ebx
  8085a2:	5e                   	pop    %esi
  8085a3:	5f                   	pop    %edi
  8085a4:	5d                   	pop    %ebp
  8085a5:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8085a6:	83 ec 04             	sub    $0x4,%esp
  8085a9:	68 b8 1f 81 00       	push   $0x811fb8
  8085ae:	68 bd 02 00 00       	push   $0x2bd
  8085b3:	68 e6 1f 81 00       	push   $0x811fe6
  8085b8:	e8 19 5f 00 00       	call   80e4d6 <_panic>

008085bd <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  8085bd:	55                   	push   %ebp
  8085be:	89 e5                	mov    %esp,%ebp
  8085c0:	53                   	push   %ebx
  8085c1:	83 ec 04             	sub    $0x4,%esp
  8085c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8085c7:	8b 43 78             	mov    0x78(%ebx),%eax
  8085ca:	85 c0                	test   %eax,%eax
  8085cc:	74 41                	je     80860f <tcp_rexmit_rto+0x52>
  8085ce:	89 c2                	mov    %eax,%edx
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8085d0:	8b 00                	mov    (%eax),%eax
  8085d2:	85 c0                	test   %eax,%eax
  8085d4:	75 f8                	jne    8085ce <tcp_rexmit_rto+0x11>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  8085d6:	8b 43 74             	mov    0x74(%ebx),%eax
  8085d9:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8085db:	8b 43 78             	mov    0x78(%ebx),%eax
  8085de:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8085e1:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8085e8:	83 ec 0c             	sub    $0xc,%esp
  8085eb:	8b 40 10             	mov    0x10(%eax),%eax
  8085ee:	ff 70 04             	push   0x4(%eax)
  8085f1:	e8 d2 f2 ff ff       	call   8078c8 <ntohl>
  8085f6:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8085f9:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8085fd:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808604:	89 1c 24             	mov    %ebx,(%esp)
  808607:	e8 e5 f9 ff ff       	call   807ff1 <tcp_output>
  80860c:	83 c4 10             	add    $0x10,%esp
}
  80860f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808612:	c9                   	leave  
  808613:	c3                   	ret    

00808614 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808614:	55                   	push   %ebp
  808615:	89 e5                	mov    %esp,%ebp
  808617:	53                   	push   %ebx
  808618:	83 ec 04             	sub    $0x4,%esp
  80861b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80861e:	8b 43 78             	mov    0x78(%ebx),%eax
  808621:	85 c0                	test   %eax,%eax
  808623:	74 37                	je     80865c <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808625:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808627:	8b 4b 74             	mov    0x74(%ebx),%ecx
  80862a:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  80862c:	8b 43 78             	mov    0x78(%ebx),%eax
  80862f:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808632:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808635:	83 ec 0c             	sub    $0xc,%esp
  808638:	8b 40 10             	mov    0x10(%eax),%eax
  80863b:	ff 70 04             	push   0x4(%eax)
  80863e:	e8 85 f2 ff ff       	call   8078c8 <ntohl>
  808643:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808646:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80864a:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808651:	89 1c 24             	mov    %ebx,(%esp)
  808654:	e8 98 f9 ff ff       	call   807ff1 <tcp_output>
  808659:	83 c4 10             	add    $0x10,%esp
}
  80865c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80865f:	c9                   	leave  
  808660:	c3                   	ret    

00808661 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808661:	55                   	push   %ebp
  808662:	89 e5                	mov    %esp,%ebp
  808664:	57                   	push   %edi
  808665:	56                   	push   %esi
  808666:	53                   	push   %ebx
  808667:	83 ec 20             	sub    $0x20,%esp
  80866a:	8b 7d 08             	mov    0x8(%ebp),%edi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80866d:	6a 00                	push   $0x0
  80866f:	6a 14                	push   $0x14
  808671:	6a 01                	push   $0x1
  808673:	e8 9a c2 ff ff       	call   804912 <pbuf_alloc>
   
  if(p == NULL) {
  808678:	83 c4 10             	add    $0x10,%esp
  80867b:	85 c0                	test   %eax,%eax
  80867d:	0f 84 e5 00 00 00    	je     808768 <tcp_keepalive+0x107>
  808683:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808685:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80868a:	0f 86 e0 00 00 00    	jbe    808770 <tcp_keepalive+0x10f>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808690:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808693:	83 ec 0c             	sub    $0xc,%esp
  808696:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80869a:	50                   	push   %eax
  80869b:	e8 e6 ef ff ff       	call   807686 <htons>
  8086a0:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8086a3:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8086a7:	89 04 24             	mov    %eax,(%esp)
  8086aa:	e8 d7 ef ff ff       	call   807686 <htons>
  8086af:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8086b3:	8b 47 54             	mov    0x54(%edi),%eax
  8086b6:	83 e8 01             	sub    $0x1,%eax
  8086b9:	89 04 24             	mov    %eax,(%esp)
  8086bc:	e8 df ef ff ff       	call   8076a0 <htonl>
  8086c1:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8086c4:	83 c4 04             	add    $0x4,%esp
  8086c7:	ff 77 24             	push   0x24(%edi)
  8086ca:	e8 d1 ef ff ff       	call   8076a0 <htonl>
  8086cf:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8086d2:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8086d6:	89 04 24             	mov    %eax,(%esp)
  8086d9:	e8 b5 ef ff ff       	call   807693 <ntohs>
  8086de:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8086e3:	89 04 24             	mov    %eax,(%esp)
  8086e6:	e8 9b ef ff ff       	call   807686 <htons>
  8086eb:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8086ef:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8086f3:	89 04 24             	mov    %eax,(%esp)
  8086f6:	e8 8b ef ff ff       	call   807686 <htons>
  8086fb:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  8086ff:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808705:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808709:	89 04 24             	mov    %eax,(%esp)
  80870c:	e8 82 ef ff ff       	call   807693 <ntohs>
  808711:	83 e0 3f             	and    $0x3f,%eax
  808714:	80 cc 50             	or     $0x50,%ah
  808717:	89 04 24             	mov    %eax,(%esp)
  80871a:	e8 67 ef ff ff       	call   807686 <htons>
  80871f:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808723:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808729:	8d 47 04             	lea    0x4(%edi),%eax
  80872c:	89 c2                	mov    %eax,%edx
  80872e:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808732:	89 04 24             	mov    %eax,(%esp)
  808735:	6a 06                	push   $0x6
  808737:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80873a:	52                   	push   %edx
  80873b:	57                   	push   %edi
  80873c:	56                   	push   %esi
  80873d:	e8 28 ec ff ff       	call   80736a <inet_chksum_pseudo>
  808742:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808746:	83 c4 18             	add    $0x18,%esp
  808749:	6a 06                	push   $0x6
  80874b:	6a 00                	push   $0x0
  80874d:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808751:	50                   	push   %eax
  808752:	ff 75 e4             	push   -0x1c(%ebp)
  808755:	57                   	push   %edi
  808756:	56                   	push   %esi
  808757:	e8 29 e2 ff ff       	call   806985 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80875c:	83 c4 14             	add    $0x14,%esp
  80875f:	56                   	push   %esi
  808760:	e8 e7 c0 ff ff       	call   80484c <pbuf_free>
  808765:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808768:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80876b:	5b                   	pop    %ebx
  80876c:	5e                   	pop    %esi
  80876d:	5f                   	pop    %edi
  80876e:	5d                   	pop    %ebp
  80876f:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808770:	83 ec 04             	sub    $0x4,%esp
  808773:	68 b8 1f 81 00       	push   $0x811fb8
  808778:	68 39 03 00 00       	push   $0x339
  80877d:	68 e6 1f 81 00       	push   $0x811fe6
  808782:	e8 4f 5d 00 00       	call   80e4d6 <_panic>

00808787 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  808787:	55                   	push   %ebp
  808788:	89 e5                	mov    %esp,%ebp
  80878a:	57                   	push   %edi
  80878b:	56                   	push   %esi
  80878c:	53                   	push   %ebx
  80878d:	83 ec 1c             	sub    $0x1c,%esp
  808790:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  808793:	8b 46 78             	mov    0x78(%esi),%eax
  808796:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808799:	85 c0                	test   %eax,%eax
  80879b:	0f 84 10 01 00 00    	je     8088b1 <tcp_zero_window_probe+0x12a>
    seg = pcb->unsent;

  if(seg == NULL)
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  8087a1:	83 ec 04             	sub    $0x4,%esp
  8087a4:	6a 00                	push   $0x0
  8087a6:	6a 15                	push   $0x15
  8087a8:	6a 01                	push   $0x1
  8087aa:	e8 63 c1 ff ff       	call   804912 <pbuf_alloc>
  8087af:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  8087b1:	83 c4 10             	add    $0x10,%esp
  8087b4:	85 c0                	test   %eax,%eax
  8087b6:	0f 84 ed 00 00 00    	je     8088a9 <tcp_zero_window_probe+0x122>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8087bc:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8087c1:	0f 86 f9 00 00 00    	jbe    8088c0 <tcp_zero_window_probe+0x139>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8087c7:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8087ca:	83 ec 0c             	sub    $0xc,%esp
  8087cd:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8087d1:	50                   	push   %eax
  8087d2:	e8 af ee ff ff       	call   807686 <htons>
  8087d7:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8087da:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8087de:	89 04 24             	mov    %eax,(%esp)
  8087e1:	e8 a0 ee ff ff       	call   807686 <htons>
  8087e6:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  8087ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8087ed:	8b 40 10             	mov    0x10(%eax),%eax
  8087f0:	8b 40 04             	mov    0x4(%eax),%eax
  8087f3:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8087f6:	83 c4 04             	add    $0x4,%esp
  8087f9:	ff 76 24             	push   0x24(%esi)
  8087fc:	e8 9f ee ff ff       	call   8076a0 <htonl>
  808801:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808804:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808808:	89 04 24             	mov    %eax,(%esp)
  80880b:	e8 83 ee ff ff       	call   807693 <ntohs>
  808810:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808815:	89 04 24             	mov    %eax,(%esp)
  808818:	e8 69 ee ff ff       	call   807686 <htons>
  80881d:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808821:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808825:	89 04 24             	mov    %eax,(%esp)
  808828:	e8 59 ee ff ff       	call   807686 <htons>
  80882d:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808831:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808837:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80883b:	89 04 24             	mov    %eax,(%esp)
  80883e:	e8 50 ee ff ff       	call   807693 <ntohs>
  808843:	83 e0 3f             	and    $0x3f,%eax
  808846:	80 cc 50             	or     $0x50,%ah
  808849:	89 04 24             	mov    %eax,(%esp)
  80884c:	e8 35 ee ff ff       	call   807686 <htons>
  808851:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808855:	8b 47 04             	mov    0x4(%edi),%eax
  808858:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80885b:	8b 51 08             	mov    0x8(%ecx),%edx
  80885e:	0f b6 12             	movzbl (%edx),%edx
  808861:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808864:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80886a:	8d 46 04             	lea    0x4(%esi),%eax
  80886d:	89 c1                	mov    %eax,%ecx
  80886f:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808873:	89 04 24             	mov    %eax,(%esp)
  808876:	6a 06                	push   $0x6
  808878:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80887b:	51                   	push   %ecx
  80887c:	56                   	push   %esi
  80887d:	57                   	push   %edi
  80887e:	e8 e7 ea ff ff       	call   80736a <inet_chksum_pseudo>
  808883:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808887:	83 c4 18             	add    $0x18,%esp
  80888a:	6a 06                	push   $0x6
  80888c:	6a 00                	push   $0x0
  80888e:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808892:	50                   	push   %eax
  808893:	ff 75 e4             	push   -0x1c(%ebp)
  808896:	56                   	push   %esi
  808897:	57                   	push   %edi
  808898:	e8 e8 e0 ff ff       	call   806985 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80889d:	83 c4 14             	add    $0x14,%esp
  8088a0:	57                   	push   %edi
  8088a1:	e8 a6 bf ff ff       	call   80484c <pbuf_free>
  8088a6:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8088a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8088ac:	5b                   	pop    %ebx
  8088ad:	5e                   	pop    %esi
  8088ae:	5f                   	pop    %edi
  8088af:	5d                   	pop    %ebp
  8088b0:	c3                   	ret    
    seg = pcb->unsent;
  8088b1:	8b 46 74             	mov    0x74(%esi),%eax
  8088b4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(seg == NULL)
  8088b7:	85 c0                	test   %eax,%eax
  8088b9:	74 ee                	je     8088a9 <tcp_zero_window_probe+0x122>
  8088bb:	e9 e1 fe ff ff       	jmp    8087a1 <tcp_zero_window_probe+0x1a>
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8088c0:	83 ec 04             	sub    $0x4,%esp
  8088c3:	68 b8 1f 81 00       	push   $0x811fb8
  8088c8:	68 8c 03 00 00       	push   $0x38c
  8088cd:	68 e6 1f 81 00       	push   $0x811fe6
  8088d2:	e8 ff 5b 00 00       	call   80e4d6 <_panic>

008088d7 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  8088d7:	55                   	push   %ebp
  8088d8:	89 e5                	mov    %esp,%ebp
  8088da:	57                   	push   %edi
  8088db:	56                   	push   %esi
  8088dc:	53                   	push   %ebx
  8088dd:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  8088e0:	8b 45 08             	mov    0x8(%ebp),%eax
  8088e3:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  8088e6:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  8088ea:	0f b7 07             	movzwl (%edi),%eax
  8088ed:	50                   	push   %eax
  8088ee:	e8 a0 ed ff ff       	call   807693 <ntohs>
  8088f3:	66 c1 e8 08          	shr    $0x8,%ax
  8088f7:	83 e0 0f             	and    $0xf,%eax
  8088fa:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808901:	83 c4 10             	add    $0x10,%esp
  808904:	39 c3                	cmp    %eax,%ebx
  808906:	7c 29                	jl     808931 <udp_input+0x5a>
  808908:	83 ec 0c             	sub    $0xc,%esp
  80890b:	0f b7 07             	movzwl (%edi),%eax
  80890e:	50                   	push   %eax
  80890f:	e8 7f ed ff ff       	call   807693 <ntohs>
  808914:	83 c4 08             	add    $0x8,%esp
  808917:	66 c1 e8 06          	shr    $0x6,%ax
  80891b:	83 e0 3c             	and    $0x3c,%eax
  80891e:	f7 d8                	neg    %eax
  808920:	98                   	cwtl   
  808921:	50                   	push   %eax
  808922:	ff 75 08             	push   0x8(%ebp)
  808925:	e8 53 be ff ff       	call   80477d <pbuf_header>
  80892a:	83 c4 10             	add    $0x10,%esp
  80892d:	84 c0                	test   %al,%al
  80892f:	74 16                	je     808947 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808931:	83 ec 0c             	sub    $0xc,%esp
  808934:	ff 75 08             	push   0x8(%ebp)
  808937:	e8 10 bf ff ff       	call   80484c <pbuf_free>
    goto end;
  80893c:	83 c4 10             	add    $0x10,%esp
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80893f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808942:	5b                   	pop    %ebx
  808943:	5e                   	pop    %esi
  808944:	5f                   	pop    %edi
  808945:	5d                   	pop    %ebp
  808946:	c3                   	ret    
  udphdr = (struct udp_hdr *)p->payload;
  808947:	8b 45 08             	mov    0x8(%ebp),%eax
  80894a:	8b 70 04             	mov    0x4(%eax),%esi
  80894d:	89 75 d8             	mov    %esi,-0x28(%ebp)
  src = ntohs(udphdr->src);
  808950:	83 ec 0c             	sub    $0xc,%esp
  808953:	0f b7 06             	movzwl (%esi),%eax
  808956:	50                   	push   %eax
  808957:	e8 37 ed ff ff       	call   807693 <ntohs>
  80895c:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  808960:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808964:	89 04 24             	mov    %eax,(%esp)
  808967:	e8 27 ed ff ff       	call   807693 <ntohs>
  80896c:	89 c6                	mov    %eax,%esi
  if (dest == DHCP_CLIENT_PORT) {
  80896e:	83 c4 10             	add    $0x10,%esp
  808971:	66 83 f8 44          	cmp    $0x44,%ax
  808975:	74 1f                	je     808996 <udp_input+0xbf>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808977:	8b 1d 54 4a b3 00    	mov    0xb34a54,%ebx
    uncon_pcb = NULL;
  80897d:	b9 00 00 00 00       	mov    $0x0,%ecx
    prev = NULL;
  808982:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808989:	8d 47 10             	lea    0x10(%edi),%eax
  80898c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80898f:	89 7d dc             	mov    %edi,-0x24(%ebp)
  808992:	89 cf                	mov    %ecx,%edi
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808994:	eb 51                	jmp    8089e7 <udp_input+0x110>
    if (src == DHCP_SERVER_PORT) {
  808996:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  80899b:	0f 85 c5 01 00 00    	jne    808b66 <udp_input+0x28f>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  8089a1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8089a4:	8b 40 20             	mov    0x20(%eax),%eax
  8089a7:	85 c0                	test   %eax,%eax
  8089a9:	0f 84 b7 01 00 00    	je     808b66 <udp_input+0x28f>
  8089af:	8b 58 08             	mov    0x8(%eax),%ebx
  8089b2:	85 db                	test   %ebx,%ebx
  8089b4:	0f 84 ac 01 00 00    	je     808b66 <udp_input+0x28f>
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  8089ba:	8b 43 04             	mov    0x4(%ebx),%eax
  8089bd:	85 c0                	test   %eax,%eax
  8089bf:	0f 84 b1 01 00 00    	je     808b76 <udp_input+0x29f>
  8089c5:	3b 47 0c             	cmp    0xc(%edi),%eax
  8089c8:	0f 85 98 01 00 00    	jne    808b66 <udp_input+0x28f>
  8089ce:	e9 a3 01 00 00       	jmp    808b76 <udp_input+0x29f>
        if ((uncon_pcb == NULL) && 
  8089d3:	85 ff                	test   %edi,%edi
  8089d5:	74 43                	je     808a1a <udp_input+0x143>
      if ((local_match != 0) &&
  8089d7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8089db:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  8089df:	74 42                	je     808a23 <udp_input+0x14c>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8089e1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  8089e4:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8089e7:	85 db                	test   %ebx,%ebx
  8089e9:	0f 84 6a 01 00 00    	je     808b59 <udp_input+0x282>
      if ((pcb->local_port == dest) &&
  8089ef:	66 3b 73 12          	cmp    0x12(%ebx),%si
  8089f3:	75 ec                	jne    8089e1 <udp_input+0x10a>
          (ip_addr_isany(&pcb->local_ip) ||
  8089f5:	8b 03                	mov    (%ebx),%eax
  8089f7:	85 c0                	test   %eax,%eax
  8089f9:	74 d8                	je     8089d3 <udp_input+0xfc>
  8089fb:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  8089fe:	3b 41 10             	cmp    0x10(%ecx),%eax
  808a01:	74 d0                	je     8089d3 <udp_input+0xfc>
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808a03:	83 ec 08             	sub    $0x8,%esp
  808a06:	ff 75 0c             	push   0xc(%ebp)
  808a09:	ff 75 d4             	push   -0x2c(%ebp)
  808a0c:	e8 39 da ff ff       	call   80644a <ip_addr_isbroadcast>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  808a11:	83 c4 10             	add    $0x10,%esp
  808a14:	84 c0                	test   %al,%al
  808a16:	74 c9                	je     8089e1 <udp_input+0x10a>
  808a18:	eb b9                	jmp    8089d3 <udp_input+0xfc>
        if ((uncon_pcb == NULL) && 
  808a1a:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  808a1e:	0f 44 fb             	cmove  %ebx,%edi
  808a21:	eb b4                	jmp    8089d7 <udp_input+0x100>
          (ip_addr_isany(&pcb->remote_ip) ||
  808a23:	8b 43 04             	mov    0x4(%ebx),%eax
  808a26:	85 c0                	test   %eax,%eax
  808a28:	74 08                	je     808a32 <udp_input+0x15b>
  808a2a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808a2d:	3b 42 0c             	cmp    0xc(%edx),%eax
  808a30:	75 af                	jne    8089e1 <udp_input+0x10a>
        if (prev != NULL) {
  808a32:	8b 7d dc             	mov    -0x24(%ebp),%edi
  808a35:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808a38:	85 d2                	test   %edx,%edx
  808a3a:	0f 84 36 01 00 00    	je     808b76 <udp_input+0x29f>
          prev->next = pcb->next;
  808a40:	8b 43 0c             	mov    0xc(%ebx),%eax
  808a43:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  808a46:	a1 54 4a b3 00       	mov    0xb34a54,%eax
  808a4b:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808a4e:	89 1d 54 4a b3 00    	mov    %ebx,0xb34a54
  808a54:	e9 1d 01 00 00       	jmp    808b76 <udp_input+0x29f>
  808a59:	89 c3                	mov    %eax,%ebx
  808a5b:	e9 16 01 00 00       	jmp    808b76 <udp_input+0x29f>
          pbuf_free(p);
  808a60:	83 ec 0c             	sub    $0xc,%esp
  808a63:	ff 75 08             	push   0x8(%ebp)
  808a66:	e8 e1 bd ff ff       	call   80484c <pbuf_free>
          goto end;
  808a6b:	83 c4 10             	add    $0x10,%esp
  808a6e:	e9 cc fe ff ff       	jmp    80893f <udp_input+0x68>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808a73:	83 ec 04             	sub    $0x4,%esp
  808a76:	68 0b 20 81 00       	push   $0x81200b
  808a7b:	68 0a 01 00 00       	push   $0x10a
  808a80:	68 36 20 81 00       	push   $0x812036
  808a85:	e8 4c 5a 00 00       	call   80e4d6 <_panic>
        pbuf_free(p);
  808a8a:	83 ec 0c             	sub    $0xc,%esp
  808a8d:	ff 75 08             	push   0x8(%ebp)
  808a90:	e8 b7 bd ff ff       	call   80484c <pbuf_free>
        goto end;
  808a95:	83 c4 10             	add    $0x10,%esp
  808a98:	e9 a2 fe ff ff       	jmp    80893f <udp_input+0x68>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808a9d:	83 ec 08             	sub    $0x8,%esp
  808aa0:	ff 75 0c             	push   0xc(%ebp)
  808aa3:	8d 47 10             	lea    0x10(%edi),%eax
  808aa6:	50                   	push   %eax
  808aa7:	e8 9e d9 ff ff       	call   80644a <ip_addr_isbroadcast>
  808aac:	83 c4 10             	add    $0x10,%esp
  808aaf:	84 c0                	test   %al,%al
  808ab1:	75 25                	jne    808ad8 <udp_input+0x201>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808ab3:	8b 5f 10             	mov    0x10(%edi),%ebx
  808ab6:	83 ec 0c             	sub    $0xc,%esp
  808ab9:	68 00 00 00 f0       	push   $0xf0000000
  808abe:	e8 05 ee ff ff       	call   8078c8 <ntohl>
  808ac3:	21 c3                	and    %eax,%ebx
  808ac5:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808acc:	e8 f7 ed ff ff       	call   8078c8 <ntohl>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808ad1:	83 c4 10             	add    $0x10,%esp
  808ad4:	39 c3                	cmp    %eax,%ebx
  808ad6:	75 13                	jne    808aeb <udp_input+0x214>
      pbuf_free(p);
  808ad8:	83 ec 0c             	sub    $0xc,%esp
  808adb:	ff 75 08             	push   0x8(%ebp)
  808ade:	e8 69 bd ff ff       	call   80484c <pbuf_free>
  808ae3:	83 c4 10             	add    $0x10,%esp
  808ae6:	e9 54 fe ff ff       	jmp    80893f <udp_input+0x68>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808aeb:	83 ec 0c             	sub    $0xc,%esp
  808aee:	0f b7 07             	movzwl (%edi),%eax
  808af1:	50                   	push   %eax
  808af2:	e8 9c eb ff ff       	call   807693 <ntohs>
  808af7:	83 c4 08             	add    $0x8,%esp
  808afa:	66 c1 e8 08          	shr    $0x8,%ax
  808afe:	83 e0 0f             	and    $0xf,%eax
  808b01:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808b08:	98                   	cwtl   
  808b09:	50                   	push   %eax
  808b0a:	ff 75 08             	push   0x8(%ebp)
  808b0d:	e8 6b bc ff ff       	call   80477d <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808b12:	83 c4 10             	add    $0x10,%esp
  808b15:	8b 45 08             	mov    0x8(%ebp),%eax
  808b18:	3b 78 04             	cmp    0x4(%eax),%edi
  808b1b:	75 12                	jne    808b2f <udp_input+0x258>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808b1d:	83 ec 08             	sub    $0x8,%esp
  808b20:	6a 03                	push   $0x3
  808b22:	ff 75 08             	push   0x8(%ebp)
  808b25:	e8 86 57 00 00       	call   80e2b0 <icmp_dest_unreach>
  808b2a:	83 c4 10             	add    $0x10,%esp
  808b2d:	eb a9                	jmp    808ad8 <udp_input+0x201>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808b2f:	83 ec 04             	sub    $0x4,%esp
  808b32:	68 4a 20 81 00       	push   $0x81204a
  808b37:	68 25 01 00 00       	push   $0x125
  808b3c:	68 36 20 81 00       	push   $0x812036
  808b41:	e8 90 59 00 00       	call   80e4d6 <_panic>
    pbuf_free(p);
  808b46:	83 ec 0c             	sub    $0xc,%esp
  808b49:	ff 75 08             	push   0x8(%ebp)
  808b4c:	e8 fb bc ff ff       	call   80484c <pbuf_free>
  808b51:	83 c4 10             	add    $0x10,%esp
}
  808b54:	e9 e6 fd ff ff       	jmp    80893f <udp_input+0x68>
  808b59:	89 f8                	mov    %edi,%eax
  808b5b:	8b 7d dc             	mov    -0x24(%ebp),%edi
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808b5e:	85 c0                	test   %eax,%eax
  808b60:	0f 85 f3 fe ff ff    	jne    808a59 <udp_input+0x182>
  808b66:	8b 45 0c             	mov    0xc(%ebp),%eax
  808b69:	8b 57 10             	mov    0x10(%edi),%edx
  808b6c:	bb 00 00 00 00       	mov    $0x0,%ebx
  808b71:	39 50 04             	cmp    %edx,0x4(%eax)
  808b74:	75 d0                	jne    808b46 <udp_input+0x26f>
      if (udphdr->chksum != 0) {
  808b76:	8b 45 d8             	mov    -0x28(%ebp),%eax
  808b79:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808b7e:	74 29                	je     808ba9 <udp_input+0x2d2>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808b80:	83 ec 0c             	sub    $0xc,%esp
  808b83:	8b 45 08             	mov    0x8(%ebp),%eax
  808b86:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808b8a:	50                   	push   %eax
  808b8b:	6a 11                	push   $0x11
  808b8d:	8d 47 10             	lea    0x10(%edi),%eax
  808b90:	50                   	push   %eax
  808b91:	8d 47 0c             	lea    0xc(%edi),%eax
  808b94:	50                   	push   %eax
  808b95:	ff 75 08             	push   0x8(%ebp)
  808b98:	e8 cd e7 ff ff       	call   80736a <inet_chksum_pseudo>
  808b9d:	83 c4 20             	add    $0x20,%esp
  808ba0:	66 85 c0             	test   %ax,%ax
  808ba3:	0f 85 b7 fe ff ff    	jne    808a60 <udp_input+0x189>
    if(pbuf_header(p, -UDP_HLEN)) {
  808ba9:	83 ec 08             	sub    $0x8,%esp
  808bac:	6a f8                	push   $0xfffffff8
  808bae:	ff 75 08             	push   0x8(%ebp)
  808bb1:	e8 c7 bb ff ff       	call   80477d <pbuf_header>
  808bb6:	83 c4 10             	add    $0x10,%esp
  808bb9:	84 c0                	test   %al,%al
  808bbb:	0f 85 b2 fe ff ff    	jne    808a73 <udp_input+0x19c>
    if (pcb != NULL) {
  808bc1:	85 db                	test   %ebx,%ebx
  808bc3:	0f 84 d4 fe ff ff    	je     808a9d <udp_input+0x1c6>
      if (pcb->recv != NULL) {
  808bc9:	8b 43 18             	mov    0x18(%ebx),%eax
  808bcc:	85 c0                	test   %eax,%eax
  808bce:	0f 84 b6 fe ff ff    	je     808a8a <udp_input+0x1b3>
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808bd4:	83 ec 0c             	sub    $0xc,%esp
  808bd7:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  808bdb:	52                   	push   %edx
  808bdc:	83 c7 0c             	add    $0xc,%edi
  808bdf:	57                   	push   %edi
  808be0:	ff 75 08             	push   0x8(%ebp)
  808be3:	53                   	push   %ebx
  808be4:	ff 73 1c             	push   0x1c(%ebx)
  808be7:	ff d0                	call   *%eax
  808be9:	83 c4 20             	add    $0x20,%esp
  808bec:	e9 4e fd ff ff       	jmp    80893f <udp_input+0x68>

00808bf1 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808bf1:	55                   	push   %ebp
  808bf2:	89 e5                	mov    %esp,%ebp
  808bf4:	57                   	push   %edi
  808bf5:	56                   	push   %esi
  808bf6:	53                   	push   %ebx
  808bf7:	83 ec 0c             	sub    $0xc,%esp
  808bfa:	8b 55 08             	mov    0x8(%ebp),%edx
  808bfd:	8b 7d 10             	mov    0x10(%ebp),%edi
  808c00:	89 f9                	mov    %edi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c02:	a1 54 4a b3 00       	mov    0xb34a54,%eax
  rebind = 0;
  808c07:	bb 00 00 00 00       	mov    $0x0,%ebx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  808c0c:	be 01 00 00 00       	mov    $0x1,%esi
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c11:	eb 1a                	jmp    808c2d <udp_bind+0x3c>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808c13:	83 ec 04             	sub    $0x4,%esp
  808c16:	68 5e 20 81 00       	push   $0x81205e
  808c1b:	68 41 02 00 00       	push   $0x241
  808c20:	68 36 20 81 00       	push   $0x812036
  808c25:	e8 ac 58 00 00       	call   80e4d6 <_panic>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c2a:	8b 40 0c             	mov    0xc(%eax),%eax
  808c2d:	85 c0                	test   %eax,%eax
  808c2f:	74 0c                	je     808c3d <udp_bind+0x4c>
    if (pcb == ipcb) {
  808c31:	39 d0                	cmp    %edx,%eax
  808c33:	75 f5                	jne    808c2a <udp_bind+0x39>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808c35:	84 db                	test   %bl,%bl
  808c37:	75 da                	jne    808c13 <udp_bind+0x22>
      rebind = 1;
  808c39:	89 f3                	mov    %esi,%ebx
  808c3b:	eb ed                	jmp    808c2a <udp_bind+0x39>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808c3d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808c41:	74 05                	je     808c48 <udp_bind+0x57>
  808c43:	8b 45 0c             	mov    0xc(%ebp),%eax
  808c46:	8b 00                	mov    (%eax),%eax
  808c48:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808c4a:	66 85 ff             	test   %di,%di
  808c4d:	75 2e                	jne    808c7d <udp_bind+0x8c>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808c4f:	8b 35 54 4a b3 00    	mov    0xb34a54,%esi
  808c55:	89 f0                	mov    %esi,%eax
    port = UDP_LOCAL_PORT_RANGE_START;
  808c57:	b9 00 10 00 00       	mov    $0x1000,%ecx
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808c5c:	eb 05                	jmp    808c63 <udp_bind+0x72>
      if (ipcb->local_port == port) {
        /* port is already used by another udp_pcb */
        port++;
  808c5e:	83 c1 01             	add    $0x1,%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  808c61:	89 f0                	mov    %esi,%eax
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808c63:	85 c0                	test   %eax,%eax
  808c65:	74 12                	je     808c79 <udp_bind+0x88>
  808c67:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808c6c:	74 0b                	je     808c79 <udp_bind+0x88>
      if (ipcb->local_port == port) {
  808c6e:	66 39 48 12          	cmp    %cx,0x12(%eax)
  808c72:	74 ea                	je     808c5e <udp_bind+0x6d>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808c74:	8b 40 0c             	mov    0xc(%eax),%eax
  808c77:	eb ea                	jmp    808c63 <udp_bind+0x72>
    }
    if (ipcb != NULL) {
  808c79:	85 c0                	test   %eax,%eax
  808c7b:	75 28                	jne    808ca5 <udp_bind+0xb4>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808c7d:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808c81:	b8 00 00 00 00       	mov    $0x0,%eax
  if (rebind == 0) {
  808c86:	84 db                	test   %bl,%bl
  808c88:	75 13                	jne    808c9d <udp_bind+0xac>
    pcb->next = udp_pcbs;
  808c8a:	a1 54 4a b3 00       	mov    0xb34a54,%eax
  808c8f:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808c92:	89 15 54 4a b3 00    	mov    %edx,0xb34a54
  return ERR_OK;
  808c98:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808c9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808ca0:	5b                   	pop    %ebx
  808ca1:	5e                   	pop    %esi
  808ca2:	5f                   	pop    %edi
  808ca3:	5d                   	pop    %ebp
  808ca4:	c3                   	ret    
      return ERR_USE;
  808ca5:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808caa:	eb f1                	jmp    808c9d <udp_bind+0xac>

00808cac <udp_sendto_if>:
{
  808cac:	55                   	push   %ebp
  808cad:	89 e5                	mov    %esp,%ebp
  808caf:	57                   	push   %edi
  808cb0:	56                   	push   %esi
  808cb1:	53                   	push   %ebx
  808cb2:	83 ec 1c             	sub    $0x1c,%esp
  808cb5:	8b 7d 08             	mov    0x8(%ebp),%edi
  808cb8:	8b 45 14             	mov    0x14(%ebp),%eax
  808cbb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (pcb->local_port == 0) {
  808cbe:	66 83 7f 12 00       	cmpw   $0x0,0x12(%edi)
  808cc3:	75 19                	jne    808cde <udp_sendto_if+0x32>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808cc5:	83 ec 04             	sub    $0x4,%esp
  808cc8:	6a 00                	push   $0x0
  808cca:	57                   	push   %edi
  808ccb:	57                   	push   %edi
  808ccc:	e8 20 ff ff ff       	call   808bf1 <udp_bind>
  808cd1:	89 c6                	mov    %eax,%esi
    if (err != ERR_OK) {
  808cd3:	83 c4 10             	add    $0x10,%esp
  808cd6:	84 c0                	test   %al,%al
  808cd8:	0f 85 b7 00 00 00    	jne    808d95 <udp_sendto_if+0xe9>
  if (pbuf_header(p, UDP_HLEN)) {
  808cde:	83 ec 08             	sub    $0x8,%esp
  808ce1:	6a 08                	push   $0x8
  808ce3:	ff 75 0c             	push   0xc(%ebp)
  808ce6:	e8 92 ba ff ff       	call   80477d <pbuf_header>
  808ceb:	83 c4 10             	add    $0x10,%esp
    q = p;
  808cee:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (pbuf_header(p, UDP_HLEN)) {
  808cf1:	84 c0                	test   %al,%al
  808cf3:	0f 85 a6 00 00 00    	jne    808d9f <udp_sendto_if+0xf3>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808cf9:	66 83 7b 0a 07       	cmpw   $0x7,0xa(%ebx)
  808cfe:	0f 86 ca 00 00 00    	jbe    808dce <udp_sendto_if+0x122>
  udphdr = q->payload;
  808d04:	8b 73 04             	mov    0x4(%ebx),%esi
  udphdr->src = htons(pcb->local_port);
  808d07:	83 ec 0c             	sub    $0xc,%esp
  808d0a:	0f b7 47 12          	movzwl 0x12(%edi),%eax
  808d0e:	50                   	push   %eax
  808d0f:	e8 72 e9 ff ff       	call   807686 <htons>
  808d14:	66 89 06             	mov    %ax,(%esi)
  udphdr->dest = htons(dst_port);
  808d17:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808d1b:	89 04 24             	mov    %eax,(%esp)
  808d1e:	e8 63 e9 ff ff       	call   807686 <htons>
  808d23:	66 89 46 02          	mov    %ax,0x2(%esi)
  udphdr->chksum = 0x0000; 
  808d27:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
  if (ip_addr_isany(&pcb->local_ip)) {
  808d2d:	8b 07                	mov    (%edi),%eax
  808d2f:	83 c4 10             	add    $0x10,%esp
  808d32:	85 c0                	test   %eax,%eax
  808d34:	0f 85 ab 00 00 00    	jne    808de5 <udp_sendto_if+0x139>
    src_ip = &(netif->ip_addr);
  808d3a:	8b 45 18             	mov    0x18(%ebp),%eax
  808d3d:	83 c0 04             	add    $0x4,%eax
  808d40:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    udphdr->len = htons(q->tot_len);
  808d43:	83 ec 0c             	sub    $0xc,%esp
  808d46:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808d4a:	50                   	push   %eax
  808d4b:	e8 36 e9 ff ff       	call   807686 <htons>
  808d50:	66 89 46 04          	mov    %ax,0x4(%esi)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808d54:	83 c4 10             	add    $0x10,%esp
  808d57:	f6 47 10 01          	testb  $0x1,0x10(%edi)
  808d5b:	0f 84 ac 00 00 00    	je     808e0d <udp_sendto_if+0x161>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808d61:	83 ec 04             	sub    $0x4,%esp
  808d64:	ff 75 18             	push   0x18(%ebp)
  808d67:	6a 11                	push   $0x11
  808d69:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808d6d:	50                   	push   %eax
  808d6e:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808d72:	50                   	push   %eax
  808d73:	ff 75 10             	push   0x10(%ebp)
  808d76:	ff 75 e4             	push   -0x1c(%ebp)
  808d79:	53                   	push   %ebx
  808d7a:	e8 8f da ff ff       	call   80680e <ip_output_if>
  808d7f:	89 c6                	mov    %eax,%esi
  if (q != p) {
  808d81:	83 c4 20             	add    $0x20,%esp
  808d84:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808d87:	74 0c                	je     808d95 <udp_sendto_if+0xe9>
    pbuf_free(q);
  808d89:	83 ec 0c             	sub    $0xc,%esp
  808d8c:	53                   	push   %ebx
  808d8d:	e8 ba ba ff ff       	call   80484c <pbuf_free>
  808d92:	83 c4 10             	add    $0x10,%esp
}
  808d95:	89 f0                	mov    %esi,%eax
  808d97:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808d9a:	5b                   	pop    %ebx
  808d9b:	5e                   	pop    %esi
  808d9c:	5f                   	pop    %edi
  808d9d:	5d                   	pop    %ebp
  808d9e:	c3                   	ret    
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808d9f:	83 ec 04             	sub    $0x4,%esp
  808da2:	6a 00                	push   $0x0
  808da4:	6a 08                	push   $0x8
  808da6:	6a 01                	push   $0x1
  808da8:	e8 65 bb ff ff       	call   804912 <pbuf_alloc>
  808dad:	89 c3                	mov    %eax,%ebx
    if (q == NULL) {
  808daf:	83 c4 10             	add    $0x10,%esp
  808db2:	85 c0                	test   %eax,%eax
  808db4:	0f 84 80 00 00 00    	je     808e3a <udp_sendto_if+0x18e>
    pbuf_chain(q, p);
  808dba:	83 ec 08             	sub    $0x8,%esp
  808dbd:	ff 75 0c             	push   0xc(%ebp)
  808dc0:	50                   	push   %eax
  808dc1:	e8 54 bf ff ff       	call   804d1a <pbuf_chain>
  808dc6:	83 c4 10             	add    $0x10,%esp
  808dc9:	e9 2b ff ff ff       	jmp    808cf9 <udp_sendto_if+0x4d>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808dce:	83 ec 04             	sub    $0x4,%esp
  808dd1:	68 6c 20 81 00       	push   $0x81206c
  808dd6:	68 b1 01 00 00       	push   $0x1b1
  808ddb:	68 36 20 81 00       	push   $0x812036
  808de0:	e8 f1 56 00 00       	call   80e4d6 <_panic>
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808de5:	8b 4d 18             	mov    0x18(%ebp),%ecx
  808de8:	3b 41 04             	cmp    0x4(%ecx),%eax
  808deb:	75 08                	jne    808df5 <udp_sendto_if+0x149>
  if (ip_addr_isany(&pcb->local_ip)) {
  808ded:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  808df0:	e9 4e ff ff ff       	jmp    808d43 <udp_sendto_if+0x97>
      return ERR_VAL;
  808df5:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
      if (q != p) {
  808dfa:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808dfd:	74 96                	je     808d95 <udp_sendto_if+0xe9>
        pbuf_free(q);
  808dff:	83 ec 0c             	sub    $0xc,%esp
  808e02:	53                   	push   %ebx
  808e03:	e8 44 ba ff ff       	call   80484c <pbuf_free>
  808e08:	83 c4 10             	add    $0x10,%esp
  808e0b:	eb 88                	jmp    808d95 <udp_sendto_if+0xe9>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808e0d:	83 ec 0c             	sub    $0xc,%esp
  808e10:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808e14:	50                   	push   %eax
  808e15:	6a 11                	push   $0x11
  808e17:	ff 75 10             	push   0x10(%ebp)
  808e1a:	ff 75 e4             	push   -0x1c(%ebp)
  808e1d:	53                   	push   %ebx
  808e1e:	e8 47 e5 ff ff       	call   80736a <inet_chksum_pseudo>
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  808e23:	83 c4 20             	add    $0x20,%esp
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808e26:	66 85 c0             	test   %ax,%ax
  808e29:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  808e2e:	0f 44 c2             	cmove  %edx,%eax
  808e31:	66 89 46 06          	mov    %ax,0x6(%esi)
  808e35:	e9 27 ff ff ff       	jmp    808d61 <udp_sendto_if+0xb5>
      return ERR_MEM;
  808e3a:	be ff ff ff ff       	mov    $0xffffffff,%esi
  808e3f:	e9 51 ff ff ff       	jmp    808d95 <udp_sendto_if+0xe9>

00808e44 <udp_sendto>:
{
  808e44:	55                   	push   %ebp
  808e45:	89 e5                	mov    %esp,%ebp
  808e47:	56                   	push   %esi
  808e48:	53                   	push   %ebx
  808e49:	8b 75 10             	mov    0x10(%ebp),%esi
  808e4c:	8b 5d 14             	mov    0x14(%ebp),%ebx
  netif = ip_route(dst_ip);
  808e4f:	83 ec 0c             	sub    $0xc,%esp
  808e52:	56                   	push   %esi
  808e53:	e8 37 d6 ff ff       	call   80648f <ip_route>
  if (netif == NULL) {
  808e58:	83 c4 10             	add    $0x10,%esp
  808e5b:	85 c0                	test   %eax,%eax
  808e5d:	74 1e                	je     808e7d <udp_sendto+0x39>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  808e5f:	83 ec 0c             	sub    $0xc,%esp
  808e62:	50                   	push   %eax
  808e63:	0f b7 db             	movzwl %bx,%ebx
  808e66:	53                   	push   %ebx
  808e67:	56                   	push   %esi
  808e68:	ff 75 0c             	push   0xc(%ebp)
  808e6b:	ff 75 08             	push   0x8(%ebp)
  808e6e:	e8 39 fe ff ff       	call   808cac <udp_sendto_if>
  808e73:	83 c4 20             	add    $0x20,%esp
}
  808e76:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808e79:	5b                   	pop    %ebx
  808e7a:	5e                   	pop    %esi
  808e7b:	5d                   	pop    %ebp
  808e7c:	c3                   	ret    
    return ERR_RTE;
  808e7d:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  808e82:	eb f2                	jmp    808e76 <udp_sendto+0x32>

00808e84 <udp_send>:
{
  808e84:	55                   	push   %ebp
  808e85:	89 e5                	mov    %esp,%ebp
  808e87:	83 ec 08             	sub    $0x8,%esp
  808e8a:	8b 45 08             	mov    0x8(%ebp),%eax
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  808e8d:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  808e91:	52                   	push   %edx
  808e92:	8d 50 04             	lea    0x4(%eax),%edx
  808e95:	52                   	push   %edx
  808e96:	ff 75 0c             	push   0xc(%ebp)
  808e99:	50                   	push   %eax
  808e9a:	e8 a5 ff ff ff       	call   808e44 <udp_sendto>
}
  808e9f:	c9                   	leave  
  808ea0:	c3                   	ret    

00808ea1 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808ea1:	55                   	push   %ebp
  808ea2:	89 e5                	mov    %esp,%ebp
  808ea4:	57                   	push   %edi
  808ea5:	56                   	push   %esi
  808ea6:	53                   	push   %ebx
  808ea7:	83 ec 0c             	sub    $0xc,%esp
  808eaa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808ead:	8b 75 0c             	mov    0xc(%ebp),%esi
  808eb0:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  808eb3:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808eb8:	74 2b                	je     808ee5 <udp_connect+0x44>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK)
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  808eba:	b8 00 00 00 00       	mov    $0x0,%eax
  808ebf:	85 f6                	test   %esi,%esi
  808ec1:	74 02                	je     808ec5 <udp_connect+0x24>
  808ec3:	8b 06                	mov    (%esi),%eax
  808ec5:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  808ec8:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  808ecc:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808ed0:	8b 15 54 4a b3 00    	mov    0xb34a54,%edx
  808ed6:	89 d0                	mov    %edx,%eax
  808ed8:	85 c0                	test   %eax,%eax
  808eda:	74 1e                	je     808efa <udp_connect+0x59>
    if (pcb == ipcb) {
  808edc:	39 d8                	cmp    %ebx,%eax
  808ede:	74 2b                	je     808f0b <udp_connect+0x6a>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808ee0:	8b 40 0c             	mov    0xc(%eax),%eax
  808ee3:	eb f3                	jmp    808ed8 <udp_connect+0x37>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808ee5:	83 ec 04             	sub    $0x4,%esp
  808ee8:	6a 00                	push   $0x0
  808eea:	53                   	push   %ebx
  808eeb:	53                   	push   %ebx
  808eec:	e8 00 fd ff ff       	call   808bf1 <udp_bind>
    if (err != ERR_OK)
  808ef1:	83 c4 10             	add    $0x10,%esp
  808ef4:	84 c0                	test   %al,%al
  808ef6:	74 c2                	je     808eba <udp_connect+0x19>
  808ef8:	eb 09                	jmp    808f03 <udp_connect+0x62>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  808efa:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  808efd:	89 1d 54 4a b3 00    	mov    %ebx,0xb34a54
  return ERR_OK;
}
  808f03:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808f06:	5b                   	pop    %ebx
  808f07:	5e                   	pop    %esi
  808f08:	5f                   	pop    %edi
  808f09:	5d                   	pop    %ebp
  808f0a:	c3                   	ret    
      return ERR_OK;
  808f0b:	b8 00 00 00 00       	mov    $0x0,%eax
  808f10:	eb f1                	jmp    808f03 <udp_connect+0x62>

00808f12 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  808f12:	55                   	push   %ebp
  808f13:	89 e5                	mov    %esp,%ebp
  808f15:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  808f18:	8b 15 a8 1c 81 00    	mov    0x811ca8,%edx
  808f1e:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  808f21:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  808f27:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  808f2b:	5d                   	pop    %ebp
  808f2c:	c3                   	ret    

00808f2d <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  808f2d:	55                   	push   %ebp
  808f2e:	89 e5                	mov    %esp,%ebp
  808f30:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  808f33:	8b 55 0c             	mov    0xc(%ebp),%edx
  808f36:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  808f39:	8b 55 10             	mov    0x10(%ebp),%edx
  808f3c:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  808f3f:	5d                   	pop    %ebp
  808f40:	c3                   	ret    

00808f41 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  808f41:	55                   	push   %ebp
  808f42:	89 e5                	mov    %esp,%ebp
  808f44:	83 ec 08             	sub    $0x8,%esp
  808f47:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  808f4a:	a1 54 4a b3 00       	mov    0xb34a54,%eax
  808f4f:	39 c8                	cmp    %ecx,%eax
  808f51:	75 1b                	jne    808f6e <udp_remove+0x2d>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  808f53:	8b 41 0c             	mov    0xc(%ecx),%eax
  808f56:	a3 54 4a b3 00       	mov    %eax,0xb34a54
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  808f5b:	83 ec 08             	sub    $0x8,%esp
  808f5e:	51                   	push   %ecx
  808f5f:	6a 01                	push   $0x1
  808f61:	e8 95 b5 ff ff       	call   8044fb <memp_free>
}
  808f66:	83 c4 10             	add    $0x10,%esp
  808f69:	c9                   	leave  
  808f6a:	c3                   	ret    
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  808f6b:	8b 40 0c             	mov    0xc(%eax),%eax
  808f6e:	85 c0                	test   %eax,%eax
  808f70:	74 e9                	je     808f5b <udp_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  808f72:	8b 50 0c             	mov    0xc(%eax),%edx
  808f75:	39 ca                	cmp    %ecx,%edx
  808f77:	75 f2                	jne    808f6b <udp_remove+0x2a>
  808f79:	85 d2                	test   %edx,%edx
  808f7b:	74 ee                	je     808f6b <udp_remove+0x2a>
        pcb2->next = pcb->next;
  808f7d:	8b 51 0c             	mov    0xc(%ecx),%edx
  808f80:	89 50 0c             	mov    %edx,0xc(%eax)
  808f83:	eb e6                	jmp    808f6b <udp_remove+0x2a>

00808f85 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  808f85:	55                   	push   %ebp
  808f86:	89 e5                	mov    %esp,%ebp
  808f88:	53                   	push   %ebx
  808f89:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  808f8c:	6a 01                	push   $0x1
  808f8e:	e8 12 b5 ff ff       	call   8044a5 <memp_malloc>
  808f93:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  808f95:	83 c4 10             	add    $0x10,%esp
  808f98:	85 c0                	test   %eax,%eax
  808f9a:	74 14                	je     808fb0 <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  808f9c:	83 ec 04             	sub    $0x4,%esp
  808f9f:	6a 20                	push   $0x20
  808fa1:	6a 00                	push   $0x0
  808fa3:	50                   	push   %eax
  808fa4:	e8 32 5d 00 00       	call   80ecdb <memset>
    pcb->ttl = UDP_TTL;
  808fa9:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  808fad:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  808fb0:	89 d8                	mov    %ebx,%eax
  808fb2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808fb5:	c9                   	leave  
  808fb6:	c3                   	ret    

00808fb7 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  808fb7:	55                   	push   %ebp
  808fb8:	89 e5                	mov    %esp,%ebp
  808fba:	56                   	push   %esi
  808fbb:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  808fbc:	85 c0                	test   %eax,%eax
  808fbe:	74 35                	je     808ff5 <free_etharp_q+0x3e>
  808fc0:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  808fc2:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  808fc6:	74 44                	je     80900c <free_etharp_q+0x55>
  808fc8:	89 de                	mov    %ebx,%esi
  while (q) {
    r = q;
    q = q->next;
  808fca:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  808fcc:	8b 46 04             	mov    0x4(%esi),%eax
  808fcf:	85 c0                	test   %eax,%eax
  808fd1:	74 50                	je     809023 <free_etharp_q+0x6c>
    pbuf_free(r->p);
  808fd3:	83 ec 0c             	sub    $0xc,%esp
  808fd6:	50                   	push   %eax
  808fd7:	e8 70 b8 ff ff       	call   80484c <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  808fdc:	83 c4 08             	add    $0x8,%esp
  808fdf:	56                   	push   %esi
  808fe0:	6a 0a                	push   $0xa
  808fe2:	e8 14 b5 ff ff       	call   8044fb <memp_free>
  while (q) {
  808fe7:	83 c4 10             	add    $0x10,%esp
  808fea:	85 db                	test   %ebx,%ebx
  808fec:	75 da                	jne    808fc8 <free_etharp_q+0x11>
  }
}
  808fee:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808ff1:	5b                   	pop    %ebx
  808ff2:	5e                   	pop    %esi
  808ff3:	5d                   	pop    %ebp
  808ff4:	c3                   	ret    
  LWIP_ASSERT("q != NULL", q != NULL);
  808ff5:	83 ec 04             	sub    $0x4,%esp
  808ff8:	68 ac 17 81 00       	push   $0x8117ac
  808ffd:	68 93 00 00 00       	push   $0x93
  809002:	68 9a 20 81 00       	push   $0x81209a
  809007:	e8 ca 54 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80900c:	83 ec 04             	sub    $0x4,%esp
  80900f:	68 b2 20 81 00       	push   $0x8120b2
  809014:	68 94 00 00 00       	push   $0x94
  809019:	68 9a 20 81 00       	push   $0x81209a
  80901e:	e8 b3 54 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  809023:	83 ec 04             	sub    $0x4,%esp
  809026:	68 bf 20 81 00       	push   $0x8120bf
  80902b:	68 98 00 00 00       	push   $0x98
  809030:	68 9a 20 81 00       	push   $0x81209a
  809035:	e8 9c 54 00 00       	call   80e4d6 <_panic>

0080903a <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80903a:	55                   	push   %ebp
  80903b:	89 e5                	mov    %esp,%ebp
  80903d:	57                   	push   %edi
  80903e:	56                   	push   %esi
  80903f:	53                   	push   %ebx
  809040:	83 ec 1c             	sub    $0x1c,%esp
  809043:	89 c3                	mov    %eax,%ebx
  809045:	89 55 e0             	mov    %edx,-0x20(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809048:	85 c0                	test   %eax,%eax
  80904a:	0f 84 86 00 00 00    	je     8090d6 <find_entry+0x9c>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809050:	0f b6 05 60 4a b3 00 	movzbl 0xb34a60,%eax
  809057:	0f b6 d0             	movzbl %al,%edx
  80905a:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80905d:	83 b9 90 4a b3 00 02 	cmpl   $0x2,0xb34a90(%ecx)
  809064:	74 42                	je     8090a8 <find_entry+0x6e>
  809066:	bf 00 00 00 00       	mov    $0x0,%edi
  80906b:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  80906f:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809073:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809077:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  80907b:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80907f:	b8 00 00 00 00       	mov    $0x0,%eax
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  809084:	0f b6 d0             	movzbl %al,%edx
  809087:	6b d2 1c             	imul   $0x1c,%edx,%edx
  80908a:	83 ba 90 4a b3 00 00 	cmpl   $0x0,0xb34a90(%edx)
  809091:	75 63                	jne    8090f6 <find_entry+0xbc>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  809093:	89 c2                	mov    %eax,%edx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809095:	83 c0 01             	add    $0x1,%eax
  809098:	3c 09                	cmp    $0x9,%al
  80909a:	0f 87 07 01 00 00    	ja     8091a7 <find_entry+0x16d>
  8090a0:	88 55 e7             	mov    %dl,-0x19(%ebp)
  8090a3:	e9 98 00 00 00       	jmp    809140 <find_entry+0x106>
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  8090a8:	8b b9 84 4a b3 00    	mov    0xb34a84(%ecx),%edi
  8090ae:	39 3b                	cmp    %edi,(%ebx)
  8090b0:	0f 84 3e 01 00 00    	je     8091f4 <find_entry+0x1ba>
  8090b6:	bf 00 00 00 00       	mov    $0x0,%edi
  8090bb:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  8090bf:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8090c3:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8090c7:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  8090cb:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8090cf:	b8 00 00 00 00       	mov    $0x0,%eax
  8090d4:	eb ae                	jmp    809084 <find_entry+0x4a>
  8090d6:	bf 00 00 00 00       	mov    $0x0,%edi
  8090db:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  8090df:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8090e3:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8090e7:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  8090eb:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8090ef:	b8 00 00 00 00       	mov    $0x0,%eax
  8090f4:	eb 8e                	jmp    809084 <find_entry+0x4a>
  8090f6:	ba 0a 00 00 00       	mov    $0xa,%edx
  8090fb:	88 55 e7             	mov    %dl,-0x19(%ebp)
  8090fe:	eb 40                	jmp    809140 <find_entry+0x106>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809100:	85 db                	test   %ebx,%ebx
  809102:	74 0d                	je     809111 <find_entry+0xd7>
  809104:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  809107:	8b 96 84 4a b3 00    	mov    0xb34a84(%esi),%edx
  80910d:	39 13                	cmp    %edx,(%ebx)
  80910f:	74 6d                	je     80917e <find_entry+0x144>
        etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  809111:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  809114:	83 be 80 4a b3 00 00 	cmpl   $0x0,0xb34a80(%esi)
  80911b:	74 68                	je     809185 <find_entry+0x14b>
        if (arp_table[i].ctime >= age_queue) {
  80911d:	0f b6 8e 94 4a b3 00 	movzbl 0xb34a94(%esi),%ecx
  809124:	89 fa                	mov    %edi,%edx
  809126:	38 d1                	cmp    %dl,%cl
  809128:	72 05                	jb     80912f <find_entry+0xf5>
          old_queue = i;
  80912a:	88 45 df             	mov    %al,-0x21(%ebp)
          age_queue = arp_table[i].ctime;
  80912d:	89 cf                	mov    %ecx,%edi
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80912f:	83 c0 01             	add    $0x1,%eax
  809132:	3c 09                	cmp    $0x9,%al
  809134:	77 6d                	ja     8091a3 <find_entry+0x169>
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  809136:	80 7d e7 0a          	cmpb   $0xa,-0x19(%ebp)
  80913a:	0f 84 44 ff ff ff    	je     809084 <find_entry+0x4a>
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809140:	0f b6 c8             	movzbl %al,%ecx
  809143:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  809146:	8b b6 90 4a b3 00    	mov    0xb34a90(%esi),%esi
  80914c:	83 fe 01             	cmp    $0x1,%esi
  80914f:	74 af                	je     809100 <find_entry+0xc6>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809151:	83 fe 02             	cmp    $0x2,%esi
  809154:	75 d9                	jne    80912f <find_entry+0xf5>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809156:	85 db                	test   %ebx,%ebx
  809158:	74 0d                	je     809167 <find_entry+0x12d>
  80915a:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  80915d:	8b 96 84 4a b3 00    	mov    0xb34a84(%esi),%edx
  809163:	39 13                	cmp    %edx,(%ebx)
  809165:	74 35                	je     80919c <find_entry+0x162>
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  809167:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  80916a:	0f b6 89 94 4a b3 00 	movzbl 0xb34a94(%ecx),%ecx
  809171:	3a 4d e6             	cmp    -0x1a(%ebp),%cl
  809174:	72 b9                	jb     80912f <find_entry+0xf5>
        old_stable = i;
  809176:	88 45 e5             	mov    %al,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  809179:	88 4d e6             	mov    %cl,-0x1a(%ebp)
  80917c:	eb b1                	jmp    80912f <find_entry+0xf5>
        etharp_cached_entry = i;
  80917e:	a2 60 4a b3 00       	mov    %al,0xb34a60
        return i;
  809183:	eb 6f                	jmp    8091f4 <find_entry+0x1ba>
        if (arp_table[i].ctime >= age_pending) {
  809185:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  809188:	0f b6 89 94 4a b3 00 	movzbl 0xb34a94(%ecx),%ecx
  80918f:	3a 4d e4             	cmp    -0x1c(%ebp),%cl
  809192:	72 9b                	jb     80912f <find_entry+0xf5>
          old_pending = i;
  809194:	88 45 de             	mov    %al,-0x22(%ebp)
          age_pending = arp_table[i].ctime;
  809197:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  80919a:	eb 93                	jmp    80912f <find_entry+0xf5>
        etharp_cached_entry = i;
  80919c:	a2 60 4a b3 00       	mov    %al,0xb34a60
        return i;
  8091a1:	eb 51                	jmp    8091f4 <find_entry+0x1ba>
  8091a3:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8091a7:	80 fa 0a             	cmp    $0xa,%dl
  8091aa:	74 50                	je     8091fc <find_entry+0x1c2>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8091ac:	f6 45 e0 02          	testb  $0x2,-0x20(%ebp)
  8091b0:	0f 85 e3 00 00 00    	jne    809299 <find_entry+0x25f>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  8091b6:	89 d6                	mov    %edx,%esi
  if (empty < ARP_TABLE_SIZE) {
  8091b8:	80 fa 09             	cmp    $0x9,%dl
  8091bb:	7f 53                	jg     809210 <find_entry+0x1d6>
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8091bd:	89 f0                	mov    %esi,%eax
  8091bf:	3c 09                	cmp    $0x9,%al
  8091c1:	0f 87 b1 00 00 00    	ja     809278 <find_entry+0x23e>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  8091c7:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  8091ca:	6b d0 1c             	imul   $0x1c,%eax,%edx
  8091cd:	c7 82 90 4a b3 00 00 	movl   $0x0,0xb34a90(%edx)
  8091d4:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  8091d7:	85 db                	test   %ebx,%ebx
  8091d9:	74 08                	je     8091e3 <find_entry+0x1a9>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  8091db:	8b 0b                	mov    (%ebx),%ecx
  8091dd:	89 8a 84 4a b3 00    	mov    %ecx,0xb34a84(%edx)
  }
  arp_table[i].ctime = 0;
  8091e3:	6b c0 1c             	imul   $0x1c,%eax,%eax
  8091e6:	c6 80 94 4a b3 00 00 	movb   $0x0,0xb34a94(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  8091ed:	89 f0                	mov    %esi,%eax
  8091ef:	a2 60 4a b3 00       	mov    %al,0xb34a60
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  8091f4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8091f7:	5b                   	pop    %ebx
  8091f8:	5e                   	pop    %esi
  8091f9:	5f                   	pop    %edi
  8091fa:	5d                   	pop    %ebp
  8091fb:	c3                   	ret    
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8091fc:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  809200:	0f 84 89 00 00 00    	je     80928f <find_entry+0x255>
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809206:	f6 45 e0 02          	testb  $0x2,-0x20(%ebp)
  80920a:	0f 85 9d 00 00 00    	jne    8092ad <find_entry+0x273>
  else if (old_stable < ARP_TABLE_SIZE) {
  809210:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  809214:	3c 09                	cmp    $0x9,%al
  809216:	7f 28                	jg     809240 <find_entry+0x206>
    i = old_stable;
  809218:	89 c6                	mov    %eax,%esi
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80921a:	0f b6 c0             	movzbl %al,%eax
  80921d:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809220:	83 b8 80 4a b3 00 00 	cmpl   $0x0,0xb34a80(%eax)
  809227:	74 94                	je     8091bd <find_entry+0x183>
  809229:	83 ec 04             	sub    $0x4,%esp
  80922c:	68 cc 20 81 00       	push   $0x8120cc
  809231:	68 75 01 00 00       	push   $0x175
  809236:	68 9a 20 81 00       	push   $0x81209a
  80923b:	e8 96 52 00 00       	call   80e4d6 <_panic>
  } else if (old_pending < ARP_TABLE_SIZE) {
  809240:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
    i = old_pending;
  809244:	89 c6                	mov    %eax,%esi
  } else if (old_pending < ARP_TABLE_SIZE) {
  809246:	3c 09                	cmp    $0x9,%al
  809248:	0f 8e 6f ff ff ff    	jle    8091bd <find_entry+0x183>
  } else if (old_queue < ARP_TABLE_SIZE) {
  80924e:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  809252:	3c 09                	cmp    $0x9,%al
  809254:	7f 4d                	jg     8092a3 <find_entry+0x269>
    i = old_queue;
  809256:	89 c6                	mov    %eax,%esi
    free_etharp_q(arp_table[i].q);
  809258:	0f b6 f8             	movzbl %al,%edi
  80925b:	6b ff 1c             	imul   $0x1c,%edi,%edi
  80925e:	8b 87 80 4a b3 00    	mov    0xb34a80(%edi),%eax
  809264:	e8 4e fd ff ff       	call   808fb7 <free_etharp_q>
    arp_table[i].q = NULL;
  809269:	c7 87 80 4a b3 00 00 	movl   $0x0,0xb34a80(%edi)
  809270:	00 00 00 
  809273:	e9 45 ff ff ff       	jmp    8091bd <find_entry+0x183>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809278:	83 ec 04             	sub    $0x4,%esp
  80927b:	68 e3 20 81 00       	push   $0x8120e3
  809280:	68 8b 01 00 00       	push   $0x18b
  809285:	68 9a 20 81 00       	push   $0x81209a
  80928a:	e8 47 52 00 00       	call   80e4d6 <_panic>
    return (s8_t)ERR_MEM;
  80928f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809294:	e9 5b ff ff ff       	jmp    8091f4 <find_entry+0x1ba>
  809299:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80929e:	e9 51 ff ff ff       	jmp    8091f4 <find_entry+0x1ba>
    return (s8_t)ERR_MEM;
  8092a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8092a8:	e9 47 ff ff ff       	jmp    8091f4 <find_entry+0x1ba>
    return (s8_t)ERR_MEM;
  8092ad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8092b2:	e9 3d ff ff ff       	jmp    8091f4 <find_entry+0x1ba>

008092b7 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  8092b7:	55                   	push   %ebp
  8092b8:	89 e5                	mov    %esp,%ebp
  8092ba:	57                   	push   %edi
  8092bb:	56                   	push   %esi
  8092bc:	53                   	push   %ebx
  8092bd:	83 ec 1c             	sub    $0x1c,%esp
  8092c0:	89 d7                	mov    %edx,%edi
  8092c2:	89 ca                	mov    %ecx,%edx
  8092c4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct eth_hdr *ethhdr = p->payload;
  8092c7:	8b 5f 04             	mov    0x4(%edi),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8092ca:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8092ce:	75 45                	jne    809315 <etharp_send_ip+0x5e>
  8092d0:	89 c6                	mov    %eax,%esi
  8092d2:	b8 05 00 00 00       	mov    $0x5,%eax
  8092d7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
  8092da:	0f b6 14 01          	movzbl (%ecx,%eax,1),%edx
  8092de:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  8092e1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8092e4:	0f b6 14 02          	movzbl (%edx,%eax,1),%edx
  8092e8:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  while(k > 0) {
  8092ec:	83 e8 01             	sub    $0x1,%eax
  8092ef:	83 f8 ff             	cmp    $0xffffffff,%eax
  8092f2:	75 e6                	jne    8092da <etharp_send_ip+0x23>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  8092f4:	83 ec 0c             	sub    $0xc,%esp
  8092f7:	68 00 08 00 00       	push   $0x800
  8092fc:	e8 85 e3 ff ff       	call   807686 <htons>
  809301:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809305:	83 c4 08             	add    $0x8,%esp
  809308:	57                   	push   %edi
  809309:	56                   	push   %esi
  80930a:	ff 56 18             	call   *0x18(%esi)
}
  80930d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809310:	5b                   	pop    %ebx
  809311:	5e                   	pop    %esi
  809312:	5f                   	pop    %edi
  809313:	5d                   	pop    %ebp
  809314:	c3                   	ret    
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809315:	83 ec 04             	sub    $0x4,%esp
  809318:	68 10 21 81 00       	push   $0x812110
  80931d:	68 b2 01 00 00       	push   $0x1b2
  809322:	68 9a 20 81 00       	push   $0x81209a
  809327:	e8 aa 51 00 00       	call   80e4d6 <_panic>

0080932c <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80932c:	55                   	push   %ebp
  80932d:	89 e5                	mov    %esp,%ebp
  80932f:	57                   	push   %edi
  809330:	56                   	push   %esi
  809331:	53                   	push   %ebx
  809332:	83 ec 1c             	sub    $0x1c,%esp
  809335:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809338:	89 cb                	mov    %ecx,%ebx
  80933a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80933d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809340:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809344:	0f 85 ae 00 00 00    	jne    8093f8 <update_arp_entry+0xcc>
  80934a:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80934c:	85 d2                	test   %edx,%edx
  80934e:	0f 84 fe 00 00 00    	je     809452 <update_arp_entry+0x126>
  809354:	83 3a 00             	cmpl   $0x0,(%edx)
  809357:	0f 84 fc 00 00 00    	je     809459 <update_arp_entry+0x12d>
      ip_addr_isbroadcast(ipaddr, netif) ||
  80935d:	83 ec 08             	sub    $0x8,%esp
  809360:	ff 75 e4             	push   -0x1c(%ebp)
  809363:	52                   	push   %edx
  809364:	e8 e1 d0 ff ff       	call   80644a <ip_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
  809369:	83 c4 10             	add    $0x10,%esp
  80936c:	84 c0                	test   %al,%al
  80936e:	0f 85 ec 00 00 00    	jne    809460 <update_arp_entry+0x134>
      ip_addr_ismulticast(ipaddr)) {
  809374:	8b 3e                	mov    (%esi),%edi
  809376:	83 ec 0c             	sub    $0xc,%esp
  809379:	68 00 00 00 f0       	push   $0xf0000000
  80937e:	e8 45 e5 ff ff       	call   8078c8 <ntohl>
  809383:	21 c7                	and    %eax,%edi
  809385:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80938c:	e8 37 e5 ff ff       	call   8078c8 <ntohl>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809391:	83 c4 10             	add    $0x10,%esp
  809394:	39 c7                	cmp    %eax,%edi
  809396:	0f 84 cb 00 00 00    	je     809467 <update_arp_entry+0x13b>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80939c:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  8093a0:	89 f0                	mov    %esi,%eax
  8093a2:	e8 93 fc ff ff       	call   80903a <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  8093a7:	84 c0                	test   %al,%al
  8093a9:	0f 88 9b 00 00 00    	js     80944a <update_arp_entry+0x11e>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8093af:	0f be c0             	movsbl %al,%eax
  8093b2:	6b f0 1c             	imul   $0x1c,%eax,%esi
  8093b5:	c7 86 90 4a b3 00 02 	movl   $0x2,0xb34a90(%esi)
  8093bc:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  8093bf:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8093c2:	89 8e 98 4a b3 00    	mov    %ecx,0xb34a98(%esi)
  8093c8:	ba 00 00 00 00       	mov    $0x0,%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8093cd:	0f b6 4c 13 05       	movzbl 0x5(%ebx,%edx,1),%ecx
  8093d2:	88 8c 32 8d 4a b3 00 	mov    %cl,0xb34a8d(%edx,%esi,1)
  while (k > 0) {
  8093d9:	83 ea 01             	sub    $0x1,%edx
  8093dc:	83 fa fa             	cmp    $0xfffffffa,%edx
  8093df:	75 ec                	jne    8093cd <update_arp_entry+0xa1>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  8093e1:	6b d0 1c             	imul   $0x1c,%eax,%edx
  8093e4:	c6 82 94 4a b3 00 00 	movb   $0x0,0xb34a94(%edx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8093eb:	89 d6                	mov    %edx,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  8093ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8093f0:	83 c0 25             	add    $0x25,%eax
  8093f3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
  8093f6:	eb 48                	jmp    809440 <update_arp_entry+0x114>
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  8093f8:	83 ec 04             	sub    $0x4,%esp
  8093fb:	68 54 21 81 00       	push   $0x812154
  809400:	68 d9 01 00 00       	push   $0x1d9
  809405:	68 9a 20 81 00       	push   $0x81209a
  80940a:	e8 c7 50 00 00       	call   80e4d6 <_panic>
    arp_table[i].q = q->next;
  80940f:	8b 10                	mov    (%eax),%edx
  809411:	89 96 80 4a b3 00    	mov    %edx,0xb34a80(%esi)
    p = q->p;
  809417:	8b 78 04             	mov    0x4(%eax),%edi
    memp_free(MEMP_ARP_QUEUE, q);
  80941a:	83 ec 08             	sub    $0x8,%esp
  80941d:	50                   	push   %eax
  80941e:	6a 0a                	push   $0xa
  809420:	e8 d6 b0 ff ff       	call   8044fb <memp_free>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809425:	89 1c 24             	mov    %ebx,(%esp)
  809428:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80942b:	89 fa                	mov    %edi,%edx
  80942d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809430:	e8 82 fe ff ff       	call   8092b7 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809435:	89 3c 24             	mov    %edi,(%esp)
  809438:	e8 0f b4 ff ff       	call   80484c <pbuf_free>
  80943d:	83 c4 10             	add    $0x10,%esp
  while (arp_table[i].q != NULL) {
  809440:	8b 86 80 4a b3 00    	mov    0xb34a80(%esi),%eax
  809446:	85 c0                	test   %eax,%eax
  809448:	75 c5                	jne    80940f <update_arp_entry+0xe3>
  }
#endif
  return ERR_OK;
}
  80944a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80944d:	5b                   	pop    %ebx
  80944e:	5e                   	pop    %esi
  80944f:	5f                   	pop    %edi
  809450:	5d                   	pop    %ebp
  809451:	c3                   	ret    
    return ERR_ARG;
  809452:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809457:	eb f1                	jmp    80944a <update_arp_entry+0x11e>
  809459:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80945e:	eb ea                	jmp    80944a <update_arp_entry+0x11e>
  809460:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809465:	eb e3                	jmp    80944a <update_arp_entry+0x11e>
  809467:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80946c:	eb dc                	jmp    80944a <update_arp_entry+0x11e>

0080946e <etharp_tmr>:
{
  80946e:	55                   	push   %ebp
  80946f:	89 e5                	mov    %esp,%ebp
  809471:	57                   	push   %edi
  809472:	56                   	push   %esi
  809473:	53                   	push   %ebx
  809474:	83 ec 0c             	sub    $0xc,%esp
  809477:	bb 80 4a b3 00       	mov    $0xb34a80,%ebx
  80947c:	bf 98 4b b3 00       	mov    $0xb34b98,%edi
  809481:	eb 1f                	jmp    8094a2 <etharp_tmr+0x34>
      if (arp_table[i].q != NULL) {
  809483:	8b 06                	mov    (%esi),%eax
  809485:	85 c0                	test   %eax,%eax
  809487:	74 0b                	je     809494 <etharp_tmr+0x26>
        free_etharp_q(arp_table[i].q);
  809489:	e8 29 fb ff ff       	call   808fb7 <free_etharp_q>
        arp_table[i].q = NULL;
  80948e:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      arp_table[i].state = ETHARP_STATE_EMPTY;
  809494:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80949b:	83 c3 1c             	add    $0x1c,%ebx
  80949e:	39 fb                	cmp    %edi,%ebx
  8094a0:	74 23                	je     8094c5 <etharp_tmr+0x57>
  8094a2:	89 de                	mov    %ebx,%esi
    arp_table[i].ctime++;
  8094a4:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  8094a8:	83 c0 01             	add    $0x1,%eax
  8094ab:	88 43 14             	mov    %al,0x14(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8094ae:	8b 53 10             	mov    0x10(%ebx),%edx
  8094b1:	3c ef                	cmp    $0xef,%al
  8094b3:	76 05                	jbe    8094ba <etharp_tmr+0x4c>
  8094b5:	83 fa 02             	cmp    $0x2,%edx
  8094b8:	74 c9                	je     809483 <etharp_tmr+0x15>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  8094ba:	3c 01                	cmp    $0x1,%al
  8094bc:	76 dd                	jbe    80949b <etharp_tmr+0x2d>
  8094be:	83 fa 01             	cmp    $0x1,%edx
  8094c1:	75 d8                	jne    80949b <etharp_tmr+0x2d>
  8094c3:	eb be                	jmp    809483 <etharp_tmr+0x15>
}
  8094c5:	83 c4 0c             	add    $0xc,%esp
  8094c8:	5b                   	pop    %ebx
  8094c9:	5e                   	pop    %esi
  8094ca:	5f                   	pop    %edi
  8094cb:	5d                   	pop    %ebp
  8094cc:	c3                   	ret    

008094cd <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  8094cd:	55                   	push   %ebp
  8094ce:	89 e5                	mov    %esp,%ebp
  8094d0:	53                   	push   %ebx
  8094d1:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  8094d4:	ba 02 00 00 00       	mov    $0x2,%edx
  8094d9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8094dc:	e8 59 fb ff ff       	call   80903a <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  8094e1:	84 c0                	test   %al,%al
  8094e3:	78 30                	js     809515 <etharp_find_addr+0x48>
  8094e5:	0f be d0             	movsbl %al,%edx
  8094e8:	6b d2 1c             	imul   $0x1c,%edx,%edx
  8094eb:	83 ba 90 4a b3 00 02 	cmpl   $0x2,0xb34a90(%edx)
  8094f2:	75 28                	jne    80951c <etharp_find_addr+0x4f>
  8094f4:	0f be d0             	movsbl %al,%edx
  8094f7:	6b d2 1c             	imul   $0x1c,%edx,%edx
      *eth_ret = &arp_table[i].ethaddr;
  8094fa:	8d 9a 88 4a b3 00    	lea    0xb34a88(%edx),%ebx
  809500:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809503:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809505:	81 c2 84 4a b3 00    	add    $0xb34a84,%edx
  80950b:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80950e:	89 11                	mov    %edx,(%ecx)
      return i;
  }
  return -1;
}
  809510:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809513:	c9                   	leave  
  809514:	c3                   	ret    
  return -1;
  809515:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80951a:	eb f4                	jmp    809510 <etharp_find_addr+0x43>
  80951c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809521:	eb ed                	jmp    809510 <etharp_find_addr+0x43>

00809523 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809523:	55                   	push   %ebp
  809524:	89 e5                	mov    %esp,%ebp
  809526:	53                   	push   %ebx
  809527:	83 ec 04             	sub    $0x4,%esp
  80952a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80952d:	85 db                	test   %ebx,%ebx
  80952f:	74 16                	je     809547 <etharp_ip_input+0x24>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809531:	8b 45 0c             	mov    0xc(%ebp),%eax
  809534:	8b 50 04             	mov    0x4(%eax),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809537:	8b 42 1c             	mov    0x1c(%edx),%eax
  80953a:	33 43 04             	xor    0x4(%ebx),%eax
  80953d:	23 43 08             	and    0x8(%ebx),%eax
  809540:	74 1c                	je     80955e <etharp_ip_input+0x3b>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  809542:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809545:	c9                   	leave  
  809546:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809547:	83 ec 04             	sub    $0x4,%esp
  80954a:	68 22 14 81 00       	push   $0x811422
  80954f:	68 48 02 00 00       	push   $0x248
  809554:	68 9a 20 81 00       	push   $0x81209a
  809559:	e8 78 4f 00 00       	call   80e4d6 <_panic>
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80955e:	8d 4a 06             	lea    0x6(%edx),%ecx
  809561:	83 c2 1c             	add    $0x1c,%edx
  809564:	83 ec 0c             	sub    $0xc,%esp
  809567:	6a 00                	push   $0x0
  809569:	89 d8                	mov    %ebx,%eax
  80956b:	e8 bc fd ff ff       	call   80932c <update_arp_entry>
  809570:	83 c4 10             	add    $0x10,%esp
  809573:	eb cd                	jmp    809542 <etharp_ip_input+0x1f>

00809575 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  809575:	55                   	push   %ebp
  809576:	89 e5                	mov    %esp,%ebp
  809578:	57                   	push   %edi
  809579:	56                   	push   %esi
  80957a:	53                   	push   %ebx
  80957b:	83 ec 1c             	sub    $0x1c,%esp
  80957e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809581:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  809585:	74 4d                	je     8095d4 <etharp_arp_input+0x5f>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  809587:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  80958c:	76 5d                	jbe    8095eb <etharp_arp_input+0x76>
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }

  hdr = p->payload;
  80958e:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809591:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  809595:	83 ec 0c             	sub    $0xc,%esp
  809598:	6a 01                	push   $0x1
  80959a:	e8 e7 e0 ff ff       	call   807686 <htons>
  80959f:	83 c4 10             	add    $0x10,%esp
  8095a2:	66 39 c7             	cmp    %ax,%di
  8095a5:	75 19                	jne    8095c0 <etharp_arp_input+0x4b>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8095a7:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  8095ab:	83 ec 0c             	sub    $0xc,%esp
  8095ae:	68 04 06 00 00       	push   $0x604
  8095b3:	e8 ce e0 ff ff       	call   807686 <htons>
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8095b8:	83 c4 10             	add    $0x10,%esp
  8095bb:	66 39 c7             	cmp    %ax,%di
  8095be:	74 39                	je     8095f9 <etharp_arp_input+0x84>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8095c0:	83 ec 0c             	sub    $0xc,%esp
  8095c3:	53                   	push   %ebx
  8095c4:	e8 83 b2 ff ff       	call   80484c <pbuf_free>
    return;
  8095c9:	83 c4 10             	add    $0x10,%esp
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
  8095cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8095cf:	5b                   	pop    %ebx
  8095d0:	5e                   	pop    %esi
  8095d1:	5f                   	pop    %edi
  8095d2:	5d                   	pop    %ebp
  8095d3:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8095d4:	83 ec 04             	sub    $0x4,%esp
  8095d7:	68 22 14 81 00       	push   $0x811422
  8095dc:	68 75 02 00 00       	push   $0x275
  8095e1:	68 9a 20 81 00       	push   $0x81209a
  8095e6:	e8 eb 4e 00 00       	call   80e4d6 <_panic>
    pbuf_free(p);
  8095eb:	83 ec 0c             	sub    $0xc,%esp
  8095ee:	53                   	push   %ebx
  8095ef:	e8 58 b2 ff ff       	call   80484c <pbuf_free>
    return;
  8095f4:	83 c4 10             	add    $0x10,%esp
  8095f7:	eb d3                	jmp    8095cc <etharp_arp_input+0x57>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8095f9:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  8095fd:	83 ec 0c             	sub    $0xc,%esp
  809600:	68 00 08 00 00       	push   $0x800
  809605:	e8 7c e0 ff ff       	call   807686 <htons>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80960a:	83 c4 10             	add    $0x10,%esp
  80960d:	66 39 c7             	cmp    %ax,%di
  809610:	75 ae                	jne    8095c0 <etharp_arp_input+0x4b>
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809612:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  809616:	83 ec 0c             	sub    $0xc,%esp
  809619:	68 06 08 00 00       	push   $0x806
  80961e:	e8 63 e0 ff ff       	call   807686 <htons>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809623:	83 c4 10             	add    $0x10,%esp
  809626:	66 39 c7             	cmp    %ax,%di
  809629:	75 95                	jne    8095c0 <etharp_arp_input+0x4b>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80962b:	83 ec 04             	sub    $0x4,%esp
  80962e:	6a 04                	push   $0x4
  809630:	8d 46 1c             	lea    0x1c(%esi),%eax
  809633:	50                   	push   %eax
  809634:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809637:	50                   	push   %eax
  809638:	e8 46 57 00 00       	call   80ed83 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80963d:	83 c4 0c             	add    $0xc,%esp
  809640:	6a 04                	push   $0x4
  809642:	8d 46 26             	lea    0x26(%esi),%eax
  809645:	50                   	push   %eax
  809646:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809649:	50                   	push   %eax
  80964a:	e8 34 57 00 00       	call   80ed83 <memcpy>
  if (netif->ip_addr.addr == 0) {
  80964f:	8b 45 08             	mov    0x8(%ebp),%eax
  809652:	8b 40 04             	mov    0x4(%eax),%eax
  809655:	83 c4 10             	add    $0x10,%esp
  809658:	85 c0                	test   %eax,%eax
  80965a:	74 05                	je     809661 <etharp_arp_input+0xec>
  if (for_us) {
  80965c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80965f:	74 3f                	je     8096a0 <etharp_arp_input+0x12b>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  809661:	8d 4e 16             	lea    0x16(%esi),%ecx
  809664:	83 ec 0c             	sub    $0xc,%esp
  809667:	6a 00                	push   $0x0
  809669:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80966c:	8b 45 08             	mov    0x8(%ebp),%eax
  80966f:	e8 b8 fc ff ff       	call   80932c <update_arp_entry>
  switch (htons(hdr->opcode)) {
  809674:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809678:	89 04 24             	mov    %eax,(%esp)
  80967b:	e8 06 e0 ff ff       	call   807686 <htons>
  809680:	83 c4 10             	add    $0x10,%esp
  809683:	66 83 f8 01          	cmp    $0x1,%ax
  809687:	74 06                	je     80968f <etharp_arp_input+0x11a>
  809689:	66 83 f8 02          	cmp    $0x2,%ax
  80968d:	74 3f                	je     8096ce <etharp_arp_input+0x159>
  pbuf_free(p);
  80968f:	83 ec 0c             	sub    $0xc,%esp
  809692:	53                   	push   %ebx
  809693:	e8 b4 b1 ff ff       	call   80484c <pbuf_free>
  809698:	83 c4 10             	add    $0x10,%esp
  80969b:	e9 2c ff ff ff       	jmp    8095cc <etharp_arp_input+0x57>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  8096a0:	8d 4e 16             	lea    0x16(%esi),%ecx
  8096a3:	83 ec 0c             	sub    $0xc,%esp
  8096a6:	6a 01                	push   $0x1
  8096a8:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8096ab:	8b 45 08             	mov    0x8(%ebp),%eax
  8096ae:	e8 79 fc ff ff       	call   80932c <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8096b3:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8096b7:	89 04 24             	mov    %eax,(%esp)
  8096ba:	e8 c7 df ff ff       	call   807686 <htons>
  8096bf:	83 c4 10             	add    $0x10,%esp
  8096c2:	66 83 f8 01          	cmp    $0x1,%ax
  8096c6:	74 1a                	je     8096e2 <etharp_arp_input+0x16d>
  8096c8:	66 83 f8 02          	cmp    $0x2,%ax
  8096cc:	75 c1                	jne    80968f <etharp_arp_input+0x11a>
    dhcp_arp_reply(netif, &sipaddr);
  8096ce:	83 ec 08             	sub    $0x8,%esp
  8096d1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8096d4:	50                   	push   %eax
  8096d5:	ff 75 08             	push   0x8(%ebp)
  8096d8:	e8 1a a2 ff ff       	call   8038f7 <dhcp_arp_reply>
    break;
  8096dd:	83 c4 10             	add    $0x10,%esp
  8096e0:	eb ad                	jmp    80968f <etharp_arp_input+0x11a>
      hdr->opcode = htons(ARP_REPLY);
  8096e2:	83 ec 0c             	sub    $0xc,%esp
  8096e5:	6a 02                	push   $0x2
  8096e7:	e8 9a df ff ff       	call   807686 <htons>
  8096ec:	66 89 46 14          	mov    %ax,0x14(%esi)
      hdr->dipaddr = hdr->sipaddr;
  8096f0:	8b 46 1c             	mov    0x1c(%esi),%eax
  8096f3:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  8096f6:	8b 45 08             	mov    0x8(%ebp),%eax
  8096f9:	8b 40 04             	mov    0x4(%eax),%eax
  8096fc:	89 46 1c             	mov    %eax,0x1c(%esi)
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8096ff:	83 c4 10             	add    $0x10,%esp
  809702:	8b 45 08             	mov    0x8(%ebp),%eax
  809705:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809709:	75 3c                	jne    809747 <etharp_arp_input+0x1d2>
  80970b:	8d 46 05             	lea    0x5(%esi),%eax
  80970e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  809711:	8d 79 05             	lea    0x5(%ecx),%edi
  809714:	89 c1                	mov    %eax,%ecx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809716:	0f b6 50 16          	movzbl 0x16(%eax),%edx
  80971a:	88 50 20             	mov    %dl,0x20(%eax)
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80971d:	88 10                	mov    %dl,(%eax)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80971f:	0f b6 17             	movzbl (%edi),%edx
  809722:	88 50 16             	mov    %dl,0x16(%eax)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809725:	88 50 06             	mov    %dl,0x6(%eax)
      while(i > 0) {
  809728:	83 e8 01             	sub    $0x1,%eax
  80972b:	83 ef 01             	sub    $0x1,%edi
  80972e:	39 f1                	cmp    %esi,%ecx
  809730:	75 e2                	jne    809714 <etharp_arp_input+0x19f>
      netif->linkoutput(netif, p);
  809732:	83 ec 08             	sub    $0x8,%esp
  809735:	53                   	push   %ebx
  809736:	ff 75 08             	push   0x8(%ebp)
  809739:	8b 45 08             	mov    0x8(%ebp),%eax
  80973c:	ff 50 18             	call   *0x18(%eax)
  80973f:	83 c4 10             	add    $0x10,%esp
  809742:	e9 48 ff ff ff       	jmp    80968f <etharp_arp_input+0x11a>
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809747:	83 ec 04             	sub    $0x4,%esp
  80974a:	68 10 21 81 00       	push   $0x812110
  80974f:	68 c6 02 00 00       	push   $0x2c6
  809754:	68 9a 20 81 00       	push   $0x81209a
  809759:	e8 78 4d 00 00       	call   80e4d6 <_panic>

0080975e <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80975e:	55                   	push   %ebp
  80975f:	89 e5                	mov    %esp,%ebp
  809761:	57                   	push   %edi
  809762:	56                   	push   %esi
  809763:	53                   	push   %ebx
  809764:	83 ec 10             	sub    $0x10,%esp
  809767:	8b 75 08             	mov    0x8(%ebp),%esi
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80976a:	6a 00                	push   $0x0
  80976c:	6a 2a                	push   $0x2a
  80976e:	6a 02                	push   $0x2
  809770:	e8 9d b1 ff ff       	call   804912 <pbuf_alloc>
  if (p == NULL) {
  809775:	83 c4 10             	add    $0x10,%esp
  809778:	85 c0                	test   %eax,%eax
  80977a:	0f 84 f8 00 00 00    	je     809878 <etharp_request+0x11a>
  809780:	89 c7                	mov    %eax,%edi
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809782:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  809787:	0f 86 bd 00 00 00    	jbe    80984a <etharp_request+0xec>
  hdr = p->payload;
  80978d:	8b 58 04             	mov    0x4(%eax),%ebx
  hdr->opcode = htons(opcode);
  809790:	83 ec 0c             	sub    $0xc,%esp
  809793:	6a 01                	push   $0x1
  809795:	e8 ec de ff ff       	call   807686 <htons>
  80979a:	66 89 43 14          	mov    %ax,0x14(%ebx)
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80979e:	83 c4 10             	add    $0x10,%esp
  8097a1:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  8097a5:	0f 85 b6 00 00 00    	jne    809861 <etharp_request+0x103>
  8097ab:	b8 05 00 00 00       	mov    $0x5,%eax
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  8097b0:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  8097b5:	88 54 03 16          	mov    %dl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  8097b9:	0f b6 90 fc 21 81 00 	movzbl 0x8121fc(%eax),%edx
  8097c0:	88 54 03 20          	mov    %dl,0x20(%ebx,%eax,1)
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  8097c4:	0f b6 90 04 22 81 00 	movzbl 0x812204(%eax),%edx
  8097cb:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  8097ce:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  8097d3:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  while(k > 0) {
  8097d7:	83 e8 01             	sub    $0x1,%eax
  8097da:	83 f8 ff             	cmp    $0xffffffff,%eax
  8097dd:	75 d1                	jne    8097b0 <etharp_request+0x52>
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  8097df:	8b 46 04             	mov    0x4(%esi),%eax
  8097e2:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  8097e5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8097e8:	8b 00                	mov    (%eax),%eax
  8097ea:	89 43 26             	mov    %eax,0x26(%ebx)
  hdr->hwtype = htons(HWTYPE_ETHERNET);
  8097ed:	83 ec 0c             	sub    $0xc,%esp
  8097f0:	6a 01                	push   $0x1
  8097f2:	e8 8f de ff ff       	call   807686 <htons>
  8097f7:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  8097fb:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809802:	e8 7f de ff ff       	call   807686 <htons>
  809807:	66 89 43 10          	mov    %ax,0x10(%ebx)
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80980b:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809812:	e8 6f de ff ff       	call   807686 <htons>
  809817:	66 89 43 12          	mov    %ax,0x12(%ebx)
  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80981b:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809822:	e8 5f de ff ff       	call   807686 <htons>
  809827:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  result = netif->linkoutput(netif, p);
  80982b:	83 c4 08             	add    $0x8,%esp
  80982e:	57                   	push   %edi
  80982f:	56                   	push   %esi
  809830:	ff 56 18             	call   *0x18(%esi)
  809833:	89 c3                	mov    %eax,%ebx
  pbuf_free(p);
  809835:	89 3c 24             	mov    %edi,(%esp)
  809838:	e8 0f b0 ff ff       	call   80484c <pbuf_free>
  return result;
  80983d:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809840:	89 d8                	mov    %ebx,%eax
  809842:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809845:	5b                   	pop    %ebx
  809846:	5e                   	pop    %esi
  809847:	5f                   	pop    %edi
  809848:	5d                   	pop    %ebp
  809849:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80984a:	83 ec 04             	sub    $0x4,%esp
  80984d:	68 7c 21 81 00       	push   $0x81217c
  809852:	68 1b 04 00 00       	push   $0x41b
  809857:	68 9a 20 81 00       	push   $0x81209a
  80985c:	e8 75 4c 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809861:	83 ec 04             	sub    $0x4,%esp
  809864:	68 10 21 81 00       	push   $0x812110
  809869:	68 22 04 00 00       	push   $0x422
  80986e:	68 9a 20 81 00       	push   $0x81209a
  809873:	e8 5e 4c 00 00       	call   80e4d6 <_panic>
    return ERR_MEM;
  809878:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  80987d:	eb c1                	jmp    809840 <etharp_request+0xe2>

0080987f <etharp_query>:
{
  80987f:	55                   	push   %ebp
  809880:	89 e5                	mov    %esp,%ebp
  809882:	57                   	push   %edi
  809883:	56                   	push   %esi
  809884:	53                   	push   %ebx
  809885:	83 ec 14             	sub    $0x14,%esp
  809888:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80988b:	ff 75 08             	push   0x8(%ebp)
  80988e:	56                   	push   %esi
  80988f:	e8 b6 cb ff ff       	call   80644a <ip_addr_isbroadcast>
  809894:	83 c4 10             	add    $0x10,%esp
  809897:	84 c0                	test   %al,%al
  809899:	0f 85 9f 01 00 00    	jne    809a3e <etharp_query+0x1bf>
      ip_addr_ismulticast(ipaddr) ||
  80989f:	8b 3e                	mov    (%esi),%edi
  8098a1:	83 ec 0c             	sub    $0xc,%esp
  8098a4:	68 00 00 00 f0       	push   $0xf0000000
  8098a9:	e8 1a e0 ff ff       	call   8078c8 <ntohl>
  8098ae:	21 c7                	and    %eax,%edi
  8098b0:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8098b7:	e8 0c e0 ff ff       	call   8078c8 <ntohl>
  8098bc:	83 c4 10             	add    $0x10,%esp
  8098bf:	39 c7                	cmp    %eax,%edi
  8098c1:	0f 84 81 01 00 00    	je     809a48 <etharp_query+0x1c9>
      ip_addr_isany(ipaddr)) {
  8098c7:	83 3e 00             	cmpl   $0x0,(%esi)
  8098ca:	0f 84 82 01 00 00    	je     809a52 <etharp_query+0x1d3>
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  8098d0:	ba 01 00 00 00       	mov    $0x1,%edx
  8098d5:	89 f0                	mov    %esi,%eax
  8098d7:	e8 5e f7 ff ff       	call   80903a <find_entry>
  8098dc:	89 c3                	mov    %eax,%ebx
  if (i < 0) {
  8098de:	84 c0                	test   %al,%al
  8098e0:	0f 88 76 01 00 00    	js     809a5c <etharp_query+0x1dd>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  8098e6:	0f be f8             	movsbl %al,%edi
  8098e9:	6b c7 1c             	imul   $0x1c,%edi,%eax
  8098ec:	8b 80 90 4a b3 00    	mov    0xb34a90(%eax),%eax
  8098f2:	85 c0                	test   %eax,%eax
  8098f4:	75 26                	jne    80991c <etharp_query+0x9d>
    arp_table[i].state = ETHARP_STATE_PENDING;
  8098f6:	6b c7 1c             	imul   $0x1c,%edi,%eax
  8098f9:	c7 80 90 4a b3 00 01 	movl   $0x1,0xb34a90(%eax)
  809900:	00 00 00 
    result = etharp_request(netif, ipaddr);
  809903:	83 ec 08             	sub    $0x8,%esp
  809906:	56                   	push   %esi
  809907:	ff 75 08             	push   0x8(%ebp)
  80990a:	e8 4f fe ff ff       	call   80975e <etharp_request>
  80990f:	89 c6                	mov    %eax,%esi
  if (q != NULL) {
  809911:	83 c4 10             	add    $0x10,%esp
  809914:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809918:	74 2d                	je     809947 <etharp_query+0xc8>
  80991a:	eb 18                	jmp    809934 <etharp_query+0xb5>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80991c:	8d 50 ff             	lea    -0x1(%eax),%edx
  80991f:	83 fa 01             	cmp    $0x1,%edx
  809922:	77 2d                	ja     809951 <etharp_query+0xd2>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809924:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809928:	74 d9                	je     809903 <etharp_query+0x84>
  80992a:	83 f8 01             	cmp    $0x1,%eax
  80992d:	74 d4                	je     809903 <etharp_query+0x84>
  err_t result = ERR_MEM;
  80992f:	be ff ff ff ff       	mov    $0xffffffff,%esi
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809934:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809937:	8b 80 90 4a b3 00    	mov    0xb34a90(%eax),%eax
  80993d:	83 f8 02             	cmp    $0x2,%eax
  809940:	74 26                	je     809968 <etharp_query+0xe9>
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809942:	83 f8 01             	cmp    $0x1,%eax
  809945:	74 48                	je     80998f <etharp_query+0x110>
}
  809947:	89 f0                	mov    %esi,%eax
  809949:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80994c:	5b                   	pop    %ebx
  80994d:	5e                   	pop    %esi
  80994e:	5f                   	pop    %edi
  80994f:	5d                   	pop    %ebp
  809950:	c3                   	ret    
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809951:	83 ec 04             	sub    $0x4,%esp
  809954:	68 b0 21 81 00       	push   $0x8121b0
  809959:	68 90 03 00 00       	push   $0x390
  80995e:	68 9a 20 81 00       	push   $0x81209a
  809963:	e8 6e 4b 00 00       	call   80e4d6 <_panic>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  809968:	8b 45 08             	mov    0x8(%ebp),%eax
  80996b:	8d 48 25             	lea    0x25(%eax),%ecx
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80996e:	83 ec 0c             	sub    $0xc,%esp
  809971:	0f be c3             	movsbl %bl,%eax
  809974:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809977:	05 88 4a b3 00       	add    $0xb34a88,%eax
  80997c:	50                   	push   %eax
  80997d:	8b 55 10             	mov    0x10(%ebp),%edx
  809980:	8b 45 08             	mov    0x8(%ebp),%eax
  809983:	e8 2f f9 ff ff       	call   8092b7 <etharp_send_ip>
  809988:	89 c6                	mov    %eax,%esi
  80998a:	83 c4 10             	add    $0x10,%esp
  80998d:	eb b8                	jmp    809947 <etharp_query+0xc8>
      p = q;
  80998f:	8b 45 10             	mov    0x10(%ebp),%eax
  809992:	eb 27                	jmp    8099bb <etharp_query+0x13c>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809994:	83 ec 04             	sub    $0x4,%esp
  809997:	68 f6 20 81 00       	push   $0x8120f6
  80999c:	68 b1 03 00 00       	push   $0x3b1
  8099a1:	68 9a 20 81 00       	push   $0x81209a
  8099a6:	e8 2b 4b 00 00       	call   80e4d6 <_panic>
        if(p->type != PBUF_ROM) {
  8099ab:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  8099af:	75 23                	jne    8099d4 <etharp_query+0x155>
        p = p->next;
  8099b1:	8b 00                	mov    (%eax),%eax
      while (p) {
  8099b3:	85 c0                	test   %eax,%eax
  8099b5:	0f 84 a8 00 00 00    	je     809a63 <etharp_query+0x1e4>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  8099bb:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  8099bf:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  8099c3:	75 e6                	jne    8099ab <etharp_query+0x12c>
  8099c5:	83 38 00             	cmpl   $0x0,(%eax)
  8099c8:	75 ca                	jne    809994 <etharp_query+0x115>
        if(p->type != PBUF_ROM) {
  8099ca:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  8099ce:	0f 84 8f 00 00 00    	je     809a63 <etharp_query+0x1e4>
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  8099d4:	83 ec 04             	sub    $0x4,%esp
  8099d7:	6a 00                	push   $0x0
  8099d9:	0f b7 d2             	movzwl %dx,%edx
  8099dc:	52                   	push   %edx
  8099dd:	6a 03                	push   $0x3
  8099df:	e8 2e af ff ff       	call   804912 <pbuf_alloc>
  8099e4:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  8099e6:	83 c4 10             	add    $0x10,%esp
  8099e9:	85 c0                	test   %eax,%eax
  8099eb:	0f 84 56 ff ff ff    	je     809947 <etharp_query+0xc8>
          if (pbuf_copy(p, q) != ERR_OK) {
  8099f1:	83 ec 08             	sub    $0x8,%esp
  8099f4:	ff 75 10             	push   0x10(%ebp)
  8099f7:	53                   	push   %ebx
  8099f8:	e8 e4 b3 ff ff       	call   804de1 <pbuf_copy>
  8099fd:	83 c4 10             	add    $0x10,%esp
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809a00:	89 5d 10             	mov    %ebx,0x10(%ebp)
          if (pbuf_copy(p, q) != ERR_OK) {
  809a03:	84 c0                	test   %al,%al
  809a05:	74 6a                	je     809a71 <etharp_query+0x1f2>
            pbuf_free(p);
  809a07:	83 ec 0c             	sub    $0xc,%esp
  809a0a:	53                   	push   %ebx
  809a0b:	e8 3c ae ff ff       	call   80484c <pbuf_free>
  809a10:	83 c4 10             	add    $0x10,%esp
  809a13:	e9 2f ff ff ff       	jmp    809947 <etharp_query+0xc8>
            arp_table[i].q = new_entry;
  809a18:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809a1b:	89 97 80 4a b3 00    	mov    %edx,0xb34a80(%edi)
          result = ERR_OK;
  809a21:	be 00 00 00 00       	mov    $0x0,%esi
  809a26:	e9 1c ff ff ff       	jmp    809947 <etharp_query+0xc8>
          pbuf_free(p);
  809a2b:	83 ec 0c             	sub    $0xc,%esp
  809a2e:	ff 75 10             	push   0x10(%ebp)
  809a31:	e8 16 ae ff ff       	call   80484c <pbuf_free>
  809a36:	83 c4 10             	add    $0x10,%esp
  809a39:	e9 09 ff ff ff       	jmp    809947 <etharp_query+0xc8>
    return ERR_ARG;
  809a3e:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809a43:	e9 ff fe ff ff       	jmp    809947 <etharp_query+0xc8>
  809a48:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809a4d:	e9 f5 fe ff ff       	jmp    809947 <etharp_query+0xc8>
  809a52:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809a57:	e9 eb fe ff ff       	jmp    809947 <etharp_query+0xc8>
    return (err_t)i;
  809a5c:	89 c6                	mov    %eax,%esi
  809a5e:	e9 e4 fe ff ff       	jmp    809947 <etharp_query+0xc8>
        pbuf_ref(p);
  809a63:	83 ec 0c             	sub    $0xc,%esp
  809a66:	ff 75 10             	push   0x10(%ebp)
  809a69:	e8 2f b2 ff ff       	call   804c9d <pbuf_ref>
  809a6e:	83 c4 10             	add    $0x10,%esp
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809a71:	83 ec 0c             	sub    $0xc,%esp
  809a74:	6a 0a                	push   $0xa
  809a76:	e8 2a aa ff ff       	call   8044a5 <memp_malloc>
  809a7b:	89 c2                	mov    %eax,%edx
        if (new_entry != NULL) {
  809a7d:	83 c4 10             	add    $0x10,%esp
  809a80:	85 c0                	test   %eax,%eax
  809a82:	74 a7                	je     809a2b <etharp_query+0x1ac>
          new_entry->next = 0;
  809a84:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
          new_entry->p = p;
  809a8a:	8b 45 10             	mov    0x10(%ebp),%eax
  809a8d:	89 42 04             	mov    %eax,0x4(%edx)
          if(arp_table[i].q != NULL) {
  809a90:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809a93:	8b 80 80 4a b3 00    	mov    0xb34a80(%eax),%eax
  809a99:	85 c0                	test   %eax,%eax
  809a9b:	0f 84 77 ff ff ff    	je     809a18 <etharp_query+0x199>
  809aa1:	89 c1                	mov    %eax,%ecx
            while (r->next != NULL) {
  809aa3:	8b 00                	mov    (%eax),%eax
  809aa5:	85 c0                	test   %eax,%eax
  809aa7:	75 f8                	jne    809aa1 <etharp_query+0x222>
            r->next = new_entry;
  809aa9:	89 11                	mov    %edx,(%ecx)
          result = ERR_OK;
  809aab:	be 00 00 00 00       	mov    $0x0,%esi
  809ab0:	e9 92 fe ff ff       	jmp    809947 <etharp_query+0xc8>

00809ab5 <etharp_output>:
{
  809ab5:	55                   	push   %ebp
  809ab6:	89 e5                	mov    %esp,%ebp
  809ab8:	57                   	push   %edi
  809ab9:	56                   	push   %esi
  809aba:	53                   	push   %ebx
  809abb:	83 ec 24             	sub    $0x24,%esp
  809abe:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809ac1:	8b 75 10             	mov    0x10(%ebp),%esi
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809ac4:	6a 0e                	push   $0xe
  809ac6:	ff 75 0c             	push   0xc(%ebp)
  809ac9:	e8 af ac ff ff       	call   80477d <pbuf_header>
  809ace:	83 c4 10             	add    $0x10,%esp
  809ad1:	84 c0                	test   %al,%al
  809ad3:	0f 85 c0 00 00 00    	jne    809b99 <etharp_output+0xe4>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809ad9:	83 ec 08             	sub    $0x8,%esp
  809adc:	53                   	push   %ebx
  809add:	56                   	push   %esi
  809ade:	e8 67 c9 ff ff       	call   80644a <ip_addr_isbroadcast>
  809ae3:	83 c4 10             	add    $0x10,%esp
  809ae6:	84 c0                	test   %al,%al
  809ae8:	0f 85 8a 00 00 00    	jne    809b78 <etharp_output+0xc3>
  } else if (ip_addr_ismulticast(ipaddr)) {
  809aee:	8b 3e                	mov    (%esi),%edi
  809af0:	83 ec 0c             	sub    $0xc,%esp
  809af3:	68 00 00 00 f0       	push   $0xf0000000
  809af8:	e8 cb dd ff ff       	call   8078c8 <ntohl>
  809afd:	21 c7                	and    %eax,%edi
  809aff:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809b06:	e8 bd dd ff ff       	call   8078c8 <ntohl>
  809b0b:	83 c4 10             	add    $0x10,%esp
  809b0e:	39 c7                	cmp    %eax,%edi
  809b10:	74 25                	je     809b37 <etharp_output+0x82>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809b12:	8b 06                	mov    (%esi),%eax
  809b14:	33 43 04             	xor    0x4(%ebx),%eax
  809b17:	23 43 08             	and    0x8(%ebx),%eax
  809b1a:	74 09                	je     809b25 <etharp_output+0x70>
      if (netif->gw.addr != 0) {
  809b1c:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809b20:	74 7e                	je     809ba0 <etharp_output+0xeb>
        ipaddr = &(netif->gw);
  809b22:	8d 73 0c             	lea    0xc(%ebx),%esi
    return etharp_query(netif, ipaddr, q);
  809b25:	83 ec 04             	sub    $0x4,%esp
  809b28:	ff 75 0c             	push   0xc(%ebp)
  809b2b:	56                   	push   %esi
  809b2c:	53                   	push   %ebx
  809b2d:	e8 4d fd ff ff       	call   80987f <etharp_query>
  809b32:	83 c4 10             	add    $0x10,%esp
  809b35:	eb 5a                	jmp    809b91 <etharp_output+0xdc>
    mcastaddr.addr[0] = 0x01;
  809b37:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809b3b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809b3f:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809b43:	83 ec 0c             	sub    $0xc,%esp
  809b46:	ff 36                	push   (%esi)
  809b48:	e8 7b dd ff ff       	call   8078c8 <ntohl>
  809b4d:	c1 e8 10             	shr    $0x10,%eax
  809b50:	83 e0 7f             	and    $0x7f,%eax
  809b53:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809b56:	83 c4 04             	add    $0x4,%esp
  809b59:	ff 36                	push   (%esi)
  809b5b:	e8 68 dd ff ff       	call   8078c8 <ntohl>
  809b60:	88 65 e6             	mov    %ah,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809b63:	83 c4 04             	add    $0x4,%esp
  809b66:	ff 36                	push   (%esi)
  809b68:	e8 5b dd ff ff       	call   8078c8 <ntohl>
  809b6d:	88 45 e7             	mov    %al,-0x19(%ebp)
  809b70:	83 c4 10             	add    $0x10,%esp
    dest = &mcastaddr;
  809b73:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809b76:	eb 05                	jmp    809b7d <etharp_output+0xc8>
    dest = (struct eth_addr *)&ethbroadcast;
  809b78:	b8 04 22 81 00       	mov    $0x812204,%eax
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809b7d:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809b80:	83 ec 0c             	sub    $0xc,%esp
  809b83:	50                   	push   %eax
  809b84:	8b 55 0c             	mov    0xc(%ebp),%edx
  809b87:	89 d8                	mov    %ebx,%eax
  809b89:	e8 29 f7 ff ff       	call   8092b7 <etharp_send_ip>
  809b8e:	83 c4 10             	add    $0x10,%esp
}
  809b91:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809b94:	5b                   	pop    %ebx
  809b95:	5e                   	pop    %esi
  809b96:	5f                   	pop    %edi
  809b97:	5d                   	pop    %ebp
  809b98:	c3                   	ret    
    return ERR_BUF;
  809b99:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809b9e:	eb f1                	jmp    809b91 <etharp_output+0xdc>
        return ERR_RTE;
  809ba0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809ba5:	eb ea                	jmp    809b91 <etharp_output+0xdc>

00809ba7 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809ba7:	55                   	push   %ebp
  809ba8:	89 e5                	mov    %esp,%ebp
  809baa:	56                   	push   %esi
  809bab:	53                   	push   %ebx
  809bac:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809baf:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809bb2:	83 ec 0c             	sub    $0xc,%esp
  809bb5:	8b 43 04             	mov    0x4(%ebx),%eax
  809bb8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809bbc:	50                   	push   %eax
  809bbd:	e8 c4 da ff ff       	call   807686 <htons>
  809bc2:	83 c4 10             	add    $0x10,%esp
  809bc5:	66 3d 00 08          	cmp    $0x800,%ax
  809bc9:	74 14                	je     809bdf <ethernet_input+0x38>
  809bcb:	66 3d 06 08          	cmp    $0x806,%ax
  809bcf:	74 50                	je     809c21 <ethernet_input+0x7a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809bd1:	83 ec 0c             	sub    $0xc,%esp
  809bd4:	53                   	push   %ebx
  809bd5:	e8 72 ac ff ff       	call   80484c <pbuf_free>
      p = NULL;
      break;
  809bda:	83 c4 10             	add    $0x10,%esp
  809bdd:	eb 53                	jmp    809c32 <ethernet_input+0x8b>
      etharp_ip_input(netif, p);
  809bdf:	83 ec 08             	sub    $0x8,%esp
  809be2:	53                   	push   %ebx
  809be3:	56                   	push   %esi
  809be4:	e8 3a f9 ff ff       	call   809523 <etharp_ip_input>
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809be9:	83 c4 08             	add    $0x8,%esp
  809bec:	6a f2                	push   $0xfffffff2
  809bee:	53                   	push   %ebx
  809bef:	e8 89 ab ff ff       	call   80477d <pbuf_header>
  809bf4:	83 c4 10             	add    $0x10,%esp
  809bf7:	84 c0                	test   %al,%al
  809bf9:	75 0f                	jne    809c0a <ethernet_input+0x63>
        ip_input(p, netif);
  809bfb:	83 ec 08             	sub    $0x8,%esp
  809bfe:	56                   	push   %esi
  809bff:	53                   	push   %ebx
  809c00:	e8 e7 c8 ff ff       	call   8064ec <ip_input>
      break;
  809c05:	83 c4 10             	add    $0x10,%esp
  809c08:	eb 28                	jmp    809c32 <ethernet_input+0x8b>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809c0a:	83 ec 04             	sub    $0x4,%esp
  809c0d:	68 d8 21 81 00       	push   $0x8121d8
  809c12:	68 7e 04 00 00       	push   $0x47e
  809c17:	68 9a 20 81 00       	push   $0x81209a
  809c1c:	e8 b5 48 00 00       	call   80e4d6 <_panic>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809c21:	83 ec 04             	sub    $0x4,%esp
  809c24:	53                   	push   %ebx
  809c25:	8d 46 25             	lea    0x25(%esi),%eax
  809c28:	50                   	push   %eax
  809c29:	56                   	push   %esi
  809c2a:	e8 46 f9 ff ff       	call   809575 <etharp_arp_input>
      break;
  809c2f:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809c32:	b8 00 00 00 00       	mov    $0x0,%eax
  809c37:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809c3a:	5b                   	pop    %ebx
  809c3b:	5e                   	pop    %esi
  809c3c:	5d                   	pop    %ebp
  809c3d:	c3                   	ret    

00809c3e <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809c3e:	55                   	push   %ebp
  809c3f:	89 e5                	mov    %esp,%ebp
  809c41:	53                   	push   %ebx
  809c42:	83 ec 10             	sub    $0x10,%esp
  809c45:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809c48:	ff 73 04             	push   0x4(%ebx)
  809c4b:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809c4d:	89 1c 24             	mov    %ebx,(%esp)
  809c50:	e8 46 65 00 00       	call   81019b <free>
}
  809c55:	83 c4 10             	add    $0x10,%esp
  809c58:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809c5b:	c9                   	leave  
  809c5c:	c3                   	ret    

00809c5d <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809c5d:	55                   	push   %ebp
  809c5e:	89 e5                	mov    %esp,%ebp
  809c60:	83 ec 08             	sub    $0x8,%esp
  809c63:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809c66:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809c6b:	89 c8                	mov    %ecx,%eax
  809c6d:	f7 e2                	mul    %edx
  809c6f:	89 d0                	mov    %edx,%eax
  809c71:	c1 e8 08             	shr    $0x8,%eax
  809c74:	b2 00                	mov    $0x0,%dl
  809c76:	01 c2                	add    %eax,%edx
  809c78:	89 c8                	mov    %ecx,%eax
  809c7a:	29 d0                	sub    %edx,%eax
  809c7c:	8b 04 85 a0 4b b3 00 	mov    0xb34ba0(,%eax,4),%eax
  809c83:	eb 03                	jmp    809c88 <timeout_cleanup+0x2b>
  809c85:	8b 40 08             	mov    0x8(%eax),%eax
  809c88:	85 c0                	test   %eax,%eax
  809c8a:	74 25                	je     809cb1 <timeout_cleanup+0x54>
	if (t->tid == tid) {
  809c8c:	39 08                	cmp    %ecx,(%eax)
  809c8e:	75 f5                	jne    809c85 <timeout_cleanup+0x28>
	    LIST_REMOVE(t, link);
  809c90:	8b 50 08             	mov    0x8(%eax),%edx
  809c93:	85 d2                	test   %edx,%edx
  809c95:	74 06                	je     809c9d <timeout_cleanup+0x40>
  809c97:	8b 48 0c             	mov    0xc(%eax),%ecx
  809c9a:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809c9d:	8b 50 0c             	mov    0xc(%eax),%edx
  809ca0:	8b 48 08             	mov    0x8(%eax),%ecx
  809ca3:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809ca5:	83 ec 0c             	sub    $0xc,%esp
  809ca8:	50                   	push   %eax
  809ca9:	e8 ed 64 00 00       	call   81019b <free>
	    goto done;
  809cae:	83 c4 10             	add    $0x10,%esp
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809cb1:	c9                   	leave  
  809cb2:	c3                   	ret    

00809cb3 <sys_init>:
{
  809cb3:	55                   	push   %ebp
  809cb4:	89 e5                	mov    %esp,%ebp
  809cb6:	56                   	push   %esi
  809cb7:	53                   	push   %ebx
  809cb8:	8b 0d c0 9d b3 00    	mov    0xb39dc0,%ecx
  809cbe:	b8 e0 9d b3 00       	mov    $0xb39de0,%eax
  809cc3:	be e0 b1 b3 00       	mov    $0xb3b1e0,%esi
  809cc8:	eb 0e                	jmp    809cd8 <sys_init+0x25>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809cca:	c7 41 10 c0 9d b3 00 	movl   $0xb39dc0,0x10(%ecx)
    for (i = 0; i < NSEM; i++) {
  809cd1:	83 c0 14             	add    $0x14,%eax
  809cd4:	39 f0                	cmp    %esi,%eax
  809cd6:	74 19                	je     809cf1 <sys_init+0x3e>
  809cd8:	89 ca                	mov    %ecx,%edx
  809cda:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
  809cdc:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809ce2:	89 50 0c             	mov    %edx,0xc(%eax)
  809ce5:	85 d2                	test   %edx,%edx
  809ce7:	74 e1                	je     809cca <sys_init+0x17>
  809ce9:	8d 58 0c             	lea    0xc(%eax),%ebx
  809cec:	89 5a 10             	mov    %ebx,0x10(%edx)
  809cef:	eb d9                	jmp    809cca <sys_init+0x17>
  809cf1:	c7 05 c0 9d b3 00 cc 	movl   $0xb3b1cc,0xb39dc0
  809cf8:	b1 b3 00 
  809cfb:	c7 05 dc b1 b3 00 c0 	movl   $0xb39dc0,0xb3b1dc
  809d02:	9d b3 00 
  809d05:	8b 0d a4 4f b3 00    	mov    0xb34fa4,%ecx
  809d0b:	b8 c0 4f b3 00       	mov    $0xb34fc0,%eax
  809d10:	be c0 9d b3 00       	mov    $0xb39dc0,%esi
  809d15:	eb 13                	jmp    809d2a <sys_init+0x77>
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809d17:	c7 81 98 00 00 00 a4 	movl   $0xb34fa4,0x98(%ecx)
  809d1e:	4f b3 00 
    for (i = 0; i < NMBOX; i++) {
  809d21:	05 9c 00 00 00       	add    $0x9c,%eax
  809d26:	39 f0                	cmp    %esi,%eax
  809d28:	74 22                	je     809d4c <sys_init+0x99>
  809d2a:	89 ca                	mov    %ecx,%edx
  809d2c:	89 c1                	mov    %eax,%ecx
	mboxes[i].freed = 1;
  809d2e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809d34:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809d3a:	85 d2                	test   %edx,%edx
  809d3c:	74 d9                	je     809d17 <sys_init+0x64>
  809d3e:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809d44:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809d4a:	eb cb                	jmp    809d17 <sys_init+0x64>
  809d4c:	c7 05 a4 4f b3 00 24 	movl   $0xb39d24,0xb34fa4
  809d53:	9d b3 00 
  809d56:	c7 05 bc 9d b3 00 a4 	movl   $0xb34fa4,0xb39dbc
  809d5d:	4f b3 00 
}
  809d60:	5b                   	pop    %ebx
  809d61:	5e                   	pop    %esi
  809d62:	5d                   	pop    %ebp
  809d63:	c3                   	ret    

00809d64 <sys_sem_new>:
{
  809d64:	55                   	push   %ebp
  809d65:	89 e5                	mov    %esp,%ebp
  809d67:	53                   	push   %ebx
  809d68:	83 ec 04             	sub    $0x4,%esp
  809d6b:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809d6e:	a1 c0 9d b3 00       	mov    0xb39dc0,%eax
    if (!se) {
  809d73:	85 c0                	test   %eax,%eax
  809d75:	74 3e                	je     809db5 <sys_sem_new+0x51>
    LIST_REMOVE(se, link);
  809d77:	8b 48 0c             	mov    0xc(%eax),%ecx
  809d7a:	85 c9                	test   %ecx,%ecx
  809d7c:	74 06                	je     809d84 <sys_sem_new+0x20>
  809d7e:	8b 58 10             	mov    0x10(%eax),%ebx
  809d81:	89 59 10             	mov    %ebx,0x10(%ecx)
  809d84:	8b 48 10             	mov    0x10(%eax),%ecx
  809d87:	8b 58 0c             	mov    0xc(%eax),%ebx
  809d8a:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809d8c:	83 38 00             	cmpl   $0x0,(%eax)
  809d8f:	74 3b                	je     809dcc <sys_sem_new+0x68>
    se->freed = 0;
  809d91:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    se->counter = count;
  809d97:	0f b6 d2             	movzbl %dl,%edx
  809d9a:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809d9e:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809da2:	2d e0 9d b3 00       	sub    $0xb39de0,%eax
  809da7:	c1 f8 02             	sar    $0x2,%eax
  809daa:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809db0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809db3:	c9                   	leave  
  809db4:	c3                   	ret    
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809db5:	83 ec 0c             	sub    $0xc,%esp
  809db8:	68 0c 22 81 00       	push   $0x81220c
  809dbd:	e8 ef 47 00 00       	call   80e5b1 <cprintf>
	return SYS_SEM_NULL;
  809dc2:	83 c4 10             	add    $0x10,%esp
  809dc5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809dca:	eb e4                	jmp    809db0 <sys_sem_new+0x4c>
    assert(se->freed);
  809dcc:	68 81 23 81 00       	push   $0x812381
  809dd1:	68 8b 23 81 00       	push   $0x81238b
  809dd6:	68 8d 00 00 00       	push   $0x8d
  809ddb:	68 a0 23 81 00       	push   $0x8123a0
  809de0:	e8 f1 46 00 00       	call   80e4d6 <_panic>

00809de5 <sys_sem_free>:
{
  809de5:	55                   	push   %ebp
  809de6:	89 e5                	mov    %esp,%ebp
  809de8:	83 ec 08             	sub    $0x8,%esp
  809deb:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809dee:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809df1:	83 3c 95 e0 9d b3 00 	cmpl   $0x0,0xb39de0(,%edx,4)
  809df8:	00 
  809df9:	75 5a                	jne    809e55 <sys_sem_free+0x70>
    sems[sem].freed = 1;
  809dfb:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809dfe:	c1 e2 02             	shl    $0x2,%edx
  809e01:	c7 82 e0 9d b3 00 01 	movl   $0x1,0xb39de0(%edx)
  809e08:	00 00 00 
    sems[sem].gen++;
  809e0b:	83 82 e4 9d b3 00 01 	addl   $0x1,0xb39de4(%edx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  809e12:	8b 0d c0 9d b3 00    	mov    0xb39dc0,%ecx
  809e18:	89 8a ec 9d b3 00    	mov    %ecx,0xb39dec(%edx)
  809e1e:	85 c9                	test   %ecx,%ecx
  809e20:	74 0d                	je     809e2f <sys_sem_free+0x4a>
  809e22:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809e25:	8d 14 95 ec 9d b3 00 	lea    0xb39dec(,%edx,4),%edx
  809e2c:	89 51 10             	mov    %edx,0x10(%ecx)
  809e2f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809e36:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809e39:	8d 0c 8d e0 9d b3 00 	lea    0xb39de0(,%ecx,4),%ecx
  809e40:	89 0d c0 9d b3 00    	mov    %ecx,0xb39dc0
  809e46:	01 c2                	add    %eax,%edx
  809e48:	c7 04 95 f0 9d b3 00 	movl   $0xb39dc0,0xb39df0(,%edx,4)
  809e4f:	c0 9d b3 00 
}
  809e53:	c9                   	leave  
  809e54:	c3                   	ret    
    assert(!sems[sem].freed);
  809e55:	68 bd 23 81 00       	push   $0x8123bd
  809e5a:	68 8b 23 81 00       	push   $0x81238b
  809e5f:	68 98 00 00 00       	push   $0x98
  809e64:	68 a0 23 81 00       	push   $0x8123a0
  809e69:	e8 68 46 00 00       	call   80e4d6 <_panic>

00809e6e <sys_mbox_free>:
{
  809e6e:	55                   	push   %ebp
  809e6f:	89 e5                	mov    %esp,%ebp
  809e71:	56                   	push   %esi
  809e72:	53                   	push   %ebx
  809e73:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  809e76:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  809e7c:	83 b8 c0 4f b3 00 00 	cmpl   $0x0,0xb34fc0(%eax)
  809e83:	75 72                	jne    809ef7 <sys_mbox_free+0x89>
    sys_sem_free(mboxes[mbox].queued_msg);
  809e85:	83 ec 0c             	sub    $0xc,%esp
  809e88:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  809e8e:	ff b6 4c 50 b3 00    	push   0xb3504c(%esi)
  809e94:	e8 4c ff ff ff       	call   809de5 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  809e99:	83 c4 04             	add    $0x4,%esp
  809e9c:	ff b6 50 50 b3 00    	push   0xb35050(%esi)
  809ea2:	e8 3e ff ff ff       	call   809de5 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  809ea7:	a1 a4 4f b3 00       	mov    0xb34fa4,%eax
  809eac:	89 86 54 50 b3 00    	mov    %eax,0xb35054(%esi)
  809eb2:	83 c4 10             	add    $0x10,%esp
  809eb5:	85 c0                	test   %eax,%eax
  809eb7:	74 12                	je     809ecb <sys_mbox_free+0x5d>
  809eb9:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  809ebf:	81 c2 54 50 b3 00    	add    $0xb35054,%edx
  809ec5:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809ecb:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  809ed1:	8d 83 c0 4f b3 00    	lea    0xb34fc0(%ebx),%eax
  809ed7:	a3 a4 4f b3 00       	mov    %eax,0xb34fa4
  809edc:	c7 83 58 50 b3 00 a4 	movl   $0xb34fa4,0xb35058(%ebx)
  809ee3:	4f b3 00 
    mboxes[mbox].freed = 1;
  809ee6:	c7 83 c0 4f b3 00 01 	movl   $0x1,0xb34fc0(%ebx)
  809eed:	00 00 00 
}
  809ef0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809ef3:	5b                   	pop    %ebx
  809ef4:	5e                   	pop    %esi
  809ef5:	5d                   	pop    %ebp
  809ef6:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  809ef7:	68 ce 23 81 00       	push   $0x8123ce
  809efc:	68 8b 23 81 00       	push   $0x81238b
  809f01:	6a 62                	push   $0x62
  809f03:	68 a0 23 81 00       	push   $0x8123a0
  809f08:	e8 c9 45 00 00       	call   80e4d6 <_panic>

00809f0d <sys_mbox_new>:
{
  809f0d:	55                   	push   %ebp
  809f0e:	89 e5                	mov    %esp,%ebp
  809f10:	57                   	push   %edi
  809f11:	56                   	push   %esi
  809f12:	53                   	push   %ebx
  809f13:	83 ec 0c             	sub    $0xc,%esp
    assert(size < MBOXSLOTS);
  809f16:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  809f1a:	0f 8f 9f 00 00 00    	jg     809fbf <sys_mbox_new+0xb2>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  809f20:	8b 1d a4 4f b3 00    	mov    0xb34fa4,%ebx
    if (!mbe) {
  809f26:	85 db                	test   %ebx,%ebx
  809f28:	0f 84 a7 00 00 00    	je     809fd5 <sys_mbox_new+0xc8>
    LIST_REMOVE(mbe, link);
  809f2e:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  809f34:	85 c0                	test   %eax,%eax
  809f36:	74 0c                	je     809f44 <sys_mbox_new+0x37>
  809f38:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  809f3e:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809f44:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  809f4a:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  809f50:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  809f52:	83 3b 00             	cmpl   $0x0,(%ebx)
  809f55:	0f 84 91 00 00 00    	je     809fec <sys_mbox_new+0xdf>
    mbe->freed = 0;
  809f5b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    int i = mbe - &mboxes[0];
  809f61:	89 de                	mov    %ebx,%esi
  809f63:	81 ee c0 4f b3 00    	sub    $0xb34fc0,%esi
  809f69:	c1 fe 02             	sar    $0x2,%esi
  809f6c:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
  809f72:	89 f7                	mov    %esi,%edi
    mbe->head = -1;
  809f74:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  809f7b:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  809f82:	83 ec 0c             	sub    $0xc,%esp
  809f85:	6a 00                	push   $0x0
  809f87:	e8 d8 fd ff ff       	call   809d64 <sys_sem_new>
  809f8c:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  809f92:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  809f99:	e8 c6 fd ff ff       	call   809d64 <sys_sem_new>
  809f9e:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    if (mbe->queued_msg == SYS_SEM_NULL ||
  809fa4:	83 c4 10             	add    $0x10,%esp
  809fa7:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  809fae:	74 52                	je     80a002 <sys_mbox_new+0xf5>
  809fb0:	83 f8 ff             	cmp    $0xffffffff,%eax
  809fb3:	74 4d                	je     80a002 <sys_mbox_new+0xf5>
}
  809fb5:	89 f8                	mov    %edi,%eax
  809fb7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809fba:	5b                   	pop    %ebx
  809fbb:	5e                   	pop    %esi
  809fbc:	5f                   	pop    %edi
  809fbd:	5d                   	pop    %ebp
  809fbe:	c3                   	ret    
    assert(size < MBOXSLOTS);
  809fbf:	68 e2 23 81 00       	push   $0x8123e2
  809fc4:	68 8b 23 81 00       	push   $0x81238b
  809fc9:	6a 45                	push   $0x45
  809fcb:	68 a0 23 81 00       	push   $0x8123a0
  809fd0:	e8 01 45 00 00       	call   80e4d6 <_panic>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  809fd5:	83 ec 0c             	sub    $0xc,%esp
  809fd8:	68 34 22 81 00       	push   $0x812234
  809fdd:	e8 cf 45 00 00       	call   80e5b1 <cprintf>
	return SYS_MBOX_NULL;
  809fe2:	83 c4 10             	add    $0x10,%esp
  809fe5:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  809fea:	eb c9                	jmp    809fb5 <sys_mbox_new+0xa8>
    assert(mbe->freed);
  809fec:	68 f3 23 81 00       	push   $0x8123f3
  809ff1:	68 8b 23 81 00       	push   $0x81238b
  809ff6:	6a 4c                	push   $0x4c
  809ff8:	68 a0 23 81 00       	push   $0x8123a0
  809ffd:	e8 d4 44 00 00       	call   80e4d6 <_panic>
	sys_mbox_free(i);
  80a002:	83 ec 0c             	sub    $0xc,%esp
  80a005:	56                   	push   %esi
  80a006:	e8 63 fe ff ff       	call   809e6e <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a00b:	c7 04 24 5c 22 81 00 	movl   $0x81225c,(%esp)
  80a012:	e8 9a 45 00 00       	call   80e5b1 <cprintf>
	return SYS_MBOX_NULL;
  80a017:	83 c4 10             	add    $0x10,%esp
  80a01a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a01f:	eb 94                	jmp    809fb5 <sys_mbox_new+0xa8>

0080a021 <sys_sem_signal>:
{
  80a021:	55                   	push   %ebp
  80a022:	89 e5                	mov    %esp,%ebp
  80a024:	83 ec 08             	sub    $0x8,%esp
  80a027:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a02a:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a02d:	83 3c 95 e0 9d b3 00 	cmpl   $0x0,0xb39de0(,%edx,4)
  80a034:	00 
  80a035:	75 18                	jne    80a04f <sys_sem_signal+0x2e>
    sems[sem].counter++;
  80a037:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a03a:	8d 14 95 e0 9d b3 00 	lea    0xb39de0(,%edx,4),%edx
  80a041:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a046:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a04b:	75 1b                	jne    80a068 <sys_sem_signal+0x47>
}
  80a04d:	c9                   	leave  
  80a04e:	c3                   	ret    
    assert(!sems[sem].freed);
  80a04f:	68 bd 23 81 00       	push   $0x8123bd
  80a054:	68 8b 23 81 00       	push   $0x81238b
  80a059:	68 a1 00 00 00       	push   $0xa1
  80a05e:	68 a0 23 81 00       	push   $0x8123a0
  80a063:	e8 6e 44 00 00       	call   80e4d6 <_panic>
	sems[sem].waiters = 0;
  80a068:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a06f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a072:	66 c7 04 8d ea 9d b3 	movw   $0x0,0xb39dea(,%ecx,4)
  80a079:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a07c:	83 ec 0c             	sub    $0xc,%esp
  80a07f:	8d 04 8d e8 9d b3 00 	lea    0xb39de8(,%ecx,4),%eax
  80a086:	50                   	push   %eax
  80a087:	e8 cf 04 00 00       	call   80a55b <thread_wakeup>
  80a08c:	83 c4 10             	add    $0x10,%esp
}
  80a08f:	eb bc                	jmp    80a04d <sys_sem_signal+0x2c>

0080a091 <sys_arch_sem_wait>:
{
  80a091:	55                   	push   %ebp
  80a092:	89 e5                	mov    %esp,%ebp
  80a094:	57                   	push   %edi
  80a095:	56                   	push   %esi
  80a096:	53                   	push   %ebx
  80a097:	83 ec 1c             	sub    $0x1c,%esp
  80a09a:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!sems[sem].freed);
  80a09d:	8b 45 08             	mov    0x8(%ebp),%eax
  80a0a0:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a0a3:	83 3c 85 e0 9d b3 00 	cmpl   $0x0,0xb39de0(,%eax,4)
  80a0aa:	00 
  80a0ab:	75 3c                	jne    80a0e9 <sys_arch_sem_wait+0x58>
    int gen = sems[sem].gen;
  80a0ad:	8b 45 08             	mov    0x8(%ebp),%eax
  80a0b0:	c1 e0 02             	shl    $0x2,%eax
  80a0b3:	89 c2                	mov    %eax,%edx
  80a0b5:	03 55 08             	add    0x8(%ebp),%edx
  80a0b8:	8b 14 95 e4 9d b3 00 	mov    0xb39de4(,%edx,4),%edx
  80a0bf:	89 55 dc             	mov    %edx,-0x24(%ebp)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a0c2:	03 45 08             	add    0x8(%ebp),%eax
  80a0c5:	8d 04 85 e8 9d b3 00 	lea    0xb39de8(,%eax,4),%eax
  80a0cc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    u32_t waited = 0;
  80a0cf:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (sems[sem].counter > 0) {
  80a0d4:	8b 45 08             	mov    0x8(%ebp),%eax
  80a0d7:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a0da:	8d 34 85 e0 9d b3 00 	lea    0xb39de0(,%eax,4),%esi
    while (tm_msec == 0 || waited < tm_msec) {
  80a0e1:	8d 47 ff             	lea    -0x1(%edi),%eax
  80a0e4:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80a0e7:	eb 7e                	jmp    80a167 <sys_arch_sem_wait+0xd6>
    assert(!sems[sem].freed);
  80a0e9:	68 bd 23 81 00       	push   $0x8123bd
  80a0ee:	68 8b 23 81 00       	push   $0x81238b
  80a0f3:	68 ac 00 00 00       	push   $0xac
  80a0f8:	68 a0 23 81 00       	push   $0x8123a0
  80a0fd:	e8 d4 43 00 00       	call   80e4d6 <_panic>
	    sems[sem].counter--;
  80a102:	8b 55 08             	mov    0x8(%ebp),%edx
  80a105:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a108:	83 e8 01             	sub    $0x1,%eax
  80a10b:	66 89 04 95 e8 9d b3 	mov    %ax,0xb39de8(,%edx,4)
  80a112:	00 
	    return waited;
  80a113:	e9 a9 00 00 00       	jmp    80a1c1 <sys_arch_sem_wait+0x130>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a118:	83 ec 0c             	sub    $0xc,%esp
  80a11b:	68 88 22 81 00       	push   $0x812288
  80a120:	e8 8c 44 00 00       	call   80e5b1 <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a125:	83 c4 10             	add    $0x10,%esp
  80a128:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80a12d:	e9 8f 00 00 00       	jmp    80a1c1 <sys_arch_sem_wait+0x130>
	    return SYS_ARCH_TIMEOUT;
  80a132:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80a137:	e9 85 00 00 00       	jmp    80a1c1 <sys_arch_sem_wait+0x130>
	    sems[sem].waiters = 1;
  80a13c:	66 c7 46 0a 01 00    	movw   $0x1,0xa(%esi)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a142:	83 ec 04             	sub    $0x4,%esp
  80a145:	6a ff                	push   $0xffffffff
  80a147:	ff 76 08             	push   0x8(%esi)
  80a14a:	ff 75 e0             	push   -0x20(%ebp)
  80a14d:	e8 1a 06 00 00       	call   80a76c <thread_wait>
	    if (gen != sems[sem].gen) {
  80a152:	83 c4 10             	add    $0x10,%esp
  80a155:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a158:	3b 46 04             	cmp    0x4(%esi),%eax
  80a15b:	75 bb                	jne    80a118 <sys_arch_sem_wait+0x87>
	    uint32_t b = sys_time_msec();
  80a15d:	e8 16 50 00 00       	call   80f178 <sys_time_msec>
	    waited += (b - a);
  80a162:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80a165:	01 c3                	add    %eax,%ebx
	if (sems[sem].counter > 0) {
  80a167:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80a16b:	66 85 c0             	test   %ax,%ax
  80a16e:	75 92                	jne    80a102 <sys_arch_sem_wait+0x71>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a170:	83 ff fe             	cmp    $0xfffffffe,%edi
  80a173:	74 bd                	je     80a132 <sys_arch_sem_wait+0xa1>
	    uint32_t a = sys_time_msec();
  80a175:	e8 fe 4f 00 00       	call   80f178 <sys_time_msec>
  80a17a:	89 c1                	mov    %eax,%ecx
  80a17c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a17f:	85 ff                	test   %edi,%edi
  80a181:	74 b9                	je     80a13c <sys_arch_sem_wait+0xab>
	    sems[sem].waiters = 1;
  80a183:	66 c7 46 0a 01 00    	movw   $0x1,0xa(%esi)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a189:	83 ec 04             	sub    $0x4,%esp
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a18c:	89 f8                	mov    %edi,%eax
  80a18e:	29 d8                	sub    %ebx,%eax
  80a190:	01 c8                	add    %ecx,%eax
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a192:	50                   	push   %eax
  80a193:	ff 76 08             	push   0x8(%esi)
  80a196:	ff 75 e0             	push   -0x20(%ebp)
  80a199:	e8 ce 05 00 00       	call   80a76c <thread_wait>
	    if (gen != sems[sem].gen) {
  80a19e:	83 c4 10             	add    $0x10,%esp
  80a1a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a1a4:	39 46 04             	cmp    %eax,0x4(%esi)
  80a1a7:	0f 85 6b ff ff ff    	jne    80a118 <sys_arch_sem_wait+0x87>
	    uint32_t b = sys_time_msec();
  80a1ad:	e8 c6 4f 00 00       	call   80f178 <sys_time_msec>
	    waited += (b - a);
  80a1b2:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80a1b5:	01 c3                	add    %eax,%ebx
    while (tm_msec == 0 || waited < tm_msec) {
  80a1b7:	39 5d d8             	cmp    %ebx,-0x28(%ebp)
  80a1ba:	73 ab                	jae    80a167 <sys_arch_sem_wait+0xd6>
    return SYS_ARCH_TIMEOUT;
  80a1bc:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}
  80a1c1:	89 d8                	mov    %ebx,%eax
  80a1c3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a1c6:	5b                   	pop    %ebx
  80a1c7:	5e                   	pop    %esi
  80a1c8:	5f                   	pop    %edi
  80a1c9:	5d                   	pop    %ebp
  80a1ca:	c3                   	ret    

0080a1cb <sys_mbox_trypost>:
{
  80a1cb:	55                   	push   %ebp
  80a1cc:	89 e5                	mov    %esp,%ebp
  80a1ce:	57                   	push   %edi
  80a1cf:	56                   	push   %esi
  80a1d0:	53                   	push   %ebx
  80a1d1:	83 ec 0c             	sub    $0xc,%esp
  80a1d4:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a1d7:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a1dd:	83 b8 c0 4f b3 00 00 	cmpl   $0x0,0xb34fc0(%eax)
  80a1e4:	75 7e                	jne    80a264 <sys_mbox_trypost+0x99>
    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a1e6:	83 ec 08             	sub    $0x8,%esp
  80a1e9:	6a 00                	push   $0x0
  80a1eb:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a1f1:	ff b6 50 50 b3 00    	push   0xb35050(%esi)
  80a1f7:	e8 95 fe ff ff       	call   80a091 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a1fc:	8b 8e c8 4f b3 00    	mov    0xb34fc8(%esi),%ecx
    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a202:	81 c6 c0 4f b3 00    	add    $0xb34fc0,%esi
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a208:	8b 76 04             	mov    0x4(%esi),%esi
  80a20b:	83 c4 10             	add    $0x10,%esp
  80a20e:	39 f1                	cmp    %esi,%ecx
  80a210:	74 70                	je     80a282 <sys_mbox_trypost+0xb7>
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a212:	69 fb 9c 00 00 00    	imul   $0x9c,%ebx,%edi
  80a218:	8d 41 01             	lea    0x1(%ecx),%eax
  80a21b:	99                   	cltd   
  80a21c:	c1 ea 1b             	shr    $0x1b,%edx
  80a21f:	01 d0                	add    %edx,%eax
  80a221:	83 e0 1f             	and    $0x1f,%eax
  80a224:	29 d0                	sub    %edx,%eax
  80a226:	89 87 c8 4f b3 00    	mov    %eax,0xb34fc8(%edi)
    mboxes[mbox].msg[slot] = msg;
  80a22c:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a22f:	01 c8                	add    %ecx,%eax
  80a231:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a234:	89 14 85 cc 4f b3 00 	mov    %edx,0xb34fcc(,%eax,4)
    if (mboxes[mbox].head == -1)
  80a23b:	83 fe ff             	cmp    $0xffffffff,%esi
  80a23e:	74 3a                	je     80a27a <sys_mbox_trypost+0xaf>
    sys_sem_signal(mboxes[mbox].queued_msg);
  80a240:	83 ec 0c             	sub    $0xc,%esp
  80a243:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a249:	ff b3 4c 50 b3 00    	push   0xb3504c(%ebx)
  80a24f:	e8 cd fd ff ff       	call   80a021 <sys_sem_signal>
    return ERR_OK;
  80a254:	83 c4 10             	add    $0x10,%esp
  80a257:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a25c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a25f:	5b                   	pop    %ebx
  80a260:	5e                   	pop    %esi
  80a261:	5f                   	pop    %edi
  80a262:	5d                   	pop    %ebp
  80a263:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a264:	68 ce 23 81 00       	push   $0x8123ce
  80a269:	68 8b 23 81 00       	push   $0x81238b
  80a26e:	6a 72                	push   $0x72
  80a270:	68 a0 23 81 00       	push   $0x8123a0
  80a275:	e8 5c 42 00 00       	call   80e4d6 <_panic>
	mboxes[mbox].head = slot;
  80a27a:	89 8f c4 4f b3 00    	mov    %ecx,0xb34fc4(%edi)
  80a280:	eb be                	jmp    80a240 <sys_mbox_trypost+0x75>
	return ERR_MEM;
  80a282:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a287:	eb d3                	jmp    80a25c <sys_mbox_trypost+0x91>

0080a289 <sys_mbox_post>:
{
  80a289:	55                   	push   %ebp
  80a28a:	89 e5                	mov    %esp,%ebp
  80a28c:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a28f:	ff 75 0c             	push   0xc(%ebp)
  80a292:	ff 75 08             	push   0x8(%ebp)
  80a295:	e8 31 ff ff ff       	call   80a1cb <sys_mbox_trypost>
  80a29a:	83 c4 10             	add    $0x10,%esp
  80a29d:	84 c0                	test   %al,%al
  80a29f:	75 02                	jne    80a2a3 <sys_mbox_post+0x1a>
}
  80a2a1:	c9                   	leave  
  80a2a2:	c3                   	ret    
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a2a3:	68 b4 22 81 00       	push   $0x8122b4
  80a2a8:	68 8b 23 81 00       	push   $0x81238b
  80a2ad:	6a 6c                	push   $0x6c
  80a2af:	68 a0 23 81 00       	push   $0x8123a0
  80a2b4:	e8 1d 42 00 00       	call   80e4d6 <_panic>

0080a2b9 <sys_arch_mbox_fetch>:
{
  80a2b9:	55                   	push   %ebp
  80a2ba:	89 e5                	mov    %esp,%ebp
  80a2bc:	57                   	push   %edi
  80a2bd:	56                   	push   %esi
  80a2be:	53                   	push   %ebx
  80a2bf:	83 ec 0c             	sub    $0xc,%esp
  80a2c2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a2c5:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a2c8:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a2ce:	83 b8 c0 4f b3 00 00 	cmpl   $0x0,0xb34fc0(%eax)
  80a2d5:	0f 85 a5 00 00 00    	jne    80a380 <sys_arch_mbox_fetch+0xc7>
    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a2db:	83 ec 08             	sub    $0x8,%esp
  80a2de:	ff 75 10             	push   0x10(%ebp)
  80a2e1:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a2e7:	ff b0 4c 50 b3 00    	push   0xb3504c(%eax)
  80a2ed:	e8 9f fd ff ff       	call   80a091 <sys_arch_sem_wait>
  80a2f2:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a2f4:	83 c4 10             	add    $0x10,%esp
  80a2f7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a2fa:	74 7a                	je     80a376 <sys_arch_mbox_fetch+0xbd>
    int slot = mboxes[mbox].head;
  80a2fc:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a302:	8b 80 c4 4f b3 00    	mov    0xb34fc4(%eax),%eax
    if (slot == -1)
  80a308:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a30b:	0f 84 88 00 00 00    	je     80a399 <sys_arch_mbox_fetch+0xe0>
    if (msg)
  80a311:	85 ff                	test   %edi,%edi
  80a313:	74 0e                	je     80a323 <sys_arch_mbox_fetch+0x6a>
	*msg = mboxes[mbox].msg[slot];
  80a315:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a318:	01 c2                	add    %eax,%edx
  80a31a:	8b 14 95 cc 4f b3 00 	mov    0xb34fcc(,%edx,4),%edx
  80a321:	89 17                	mov    %edx,(%edi)
    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a323:	83 c0 01             	add    $0x1,%eax
  80a326:	99                   	cltd   
  80a327:	c1 ea 1b             	shr    $0x1b,%edx
  80a32a:	01 d0                	add    %edx,%eax
  80a32c:	83 e0 1f             	and    $0x1f,%eax
  80a32f:	29 d0                	sub    %edx,%eax
  80a331:	69 cb 9c 00 00 00    	imul   $0x9c,%ebx,%ecx
  80a337:	89 81 c4 4f b3 00    	mov    %eax,0xb34fc4(%ecx)
  80a33d:	81 c1 c0 4f b3 00    	add    $0xb34fc0,%ecx
	mboxes[mbox].head = -1;
  80a343:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a348:	3b 41 08             	cmp    0x8(%ecx),%eax
  80a34b:	74 0c                	je     80a359 <sys_arch_mbox_fetch+0xa0>
	mboxes[mbox].head = -1;
  80a34d:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a353:	8b 90 c4 4f b3 00    	mov    0xb34fc4(%eax),%edx
  80a359:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a35f:	89 93 c4 4f b3 00    	mov    %edx,0xb34fc4(%ebx)
    sys_sem_signal(mboxes[mbox].free_msg);
  80a365:	83 ec 0c             	sub    $0xc,%esp
  80a368:	ff b3 50 50 b3 00    	push   0xb35050(%ebx)
  80a36e:	e8 ae fc ff ff       	call   80a021 <sys_sem_signal>
    return waited;
  80a373:	83 c4 10             	add    $0x10,%esp
}
  80a376:	89 f0                	mov    %esi,%eax
  80a378:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a37b:	5b                   	pop    %ebx
  80a37c:	5e                   	pop    %esi
  80a37d:	5f                   	pop    %edi
  80a37e:	5d                   	pop    %ebp
  80a37f:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a380:	68 ce 23 81 00       	push   $0x8123ce
  80a385:	68 8b 23 81 00       	push   $0x81238b
  80a38a:	68 ce 00 00 00       	push   $0xce
  80a38f:	68 a0 23 81 00       	push   $0x8123a0
  80a394:	e8 3d 41 00 00       	call   80e4d6 <_panic>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a399:	83 ec 04             	sub    $0x4,%esp
  80a39c:	68 dc 22 81 00       	push   $0x8122dc
  80a3a1:	68 d6 00 00 00       	push   $0xd6
  80a3a6:	68 a0 23 81 00       	push   $0x8123a0
  80a3ab:	e8 26 41 00 00       	call   80e4d6 <_panic>

0080a3b0 <sys_arch_mbox_tryfetch>:
{
  80a3b0:	55                   	push   %ebp
  80a3b1:	89 e5                	mov    %esp,%ebp
  80a3b3:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a3b6:	6a fe                	push   $0xfffffffe
  80a3b8:	ff 75 0c             	push   0xc(%ebp)
  80a3bb:	ff 75 08             	push   0x8(%ebp)
  80a3be:	e8 f6 fe ff ff       	call   80a2b9 <sys_arch_mbox_fetch>
}
  80a3c3:	c9                   	leave  
  80a3c4:	c3                   	ret    

0080a3c5 <sys_thread_new>:
{
  80a3c5:	55                   	push   %ebp
  80a3c6:	89 e5                	mov    %esp,%ebp
  80a3c8:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a3cb:	6a 08                	push   $0x8
  80a3cd:	e8 75 5e 00 00       	call   810247 <malloc>
    if (lt == 0)
  80a3d2:	83 c4 10             	add    $0x10,%esp
  80a3d5:	85 c0                	test   %eax,%eax
  80a3d7:	74 32                	je     80a40b <sys_thread_new+0x46>
    if (stacksize > PGSIZE)
  80a3d9:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a3e0:	7f 40                	jg     80a422 <sys_thread_new+0x5d>
    lt->func = thread;
  80a3e2:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a3e5:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a3e7:	8b 55 10             	mov    0x10(%ebp),%edx
  80a3ea:	89 50 04             	mov    %edx,0x4(%eax)
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a3ed:	50                   	push   %eax
  80a3ee:	68 3e 9c 80 00       	push   $0x809c3e
  80a3f3:	ff 75 08             	push   0x8(%ebp)
  80a3f6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a3f9:	50                   	push   %eax
  80a3fa:	e8 c7 01 00 00       	call   80a5c6 <thread_create>
    if (r < 0)
  80a3ff:	83 c4 10             	add    $0x10,%esp
  80a402:	85 c0                	test   %eax,%eax
  80a404:	78 33                	js     80a439 <sys_thread_new+0x74>
}
  80a406:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a409:	c9                   	leave  
  80a40a:	c3                   	ret    
	panic("sys_thread_new: cannot allocate thread struct");
  80a40b:	83 ec 04             	sub    $0x4,%esp
  80a40e:	68 04 23 81 00       	push   $0x812304
  80a413:	68 fd 00 00 00       	push   $0xfd
  80a418:	68 a0 23 81 00       	push   $0x8123a0
  80a41d:	e8 b4 40 00 00       	call   80e4d6 <_panic>
	panic("large stack %d", stacksize);
  80a422:	ff 75 14             	push   0x14(%ebp)
  80a425:	68 fe 23 81 00       	push   $0x8123fe
  80a42a:	68 00 01 00 00       	push   $0x100
  80a42f:	68 a0 23 81 00       	push   $0x8123a0
  80a434:	e8 9d 40 00 00       	call   80e4d6 <_panic>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a439:	83 ec 0c             	sub    $0xc,%esp
  80a43c:	50                   	push   %eax
  80a43d:	e8 b7 04 00 00       	call   80a8f9 <e2s>
  80a442:	50                   	push   %eax
  80a443:	68 34 23 81 00       	push   $0x812334
  80a448:	68 09 01 00 00       	push   $0x109
  80a44d:	68 a0 23 81 00       	push   $0x8123a0
  80a452:	e8 7f 40 00 00       	call   80e4d6 <_panic>

0080a457 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a457:	55                   	push   %ebp
  80a458:	89 e5                	mov    %esp,%ebp
  80a45a:	57                   	push   %edi
  80a45b:	56                   	push   %esi
  80a45c:	53                   	push   %ebx
  80a45d:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a460:	e8 ee 00 00 00       	call   80a553 <thread_id>
  80a465:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a467:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a46c:	f7 e2                	mul    %edx
  80a46e:	89 d7                	mov    %edx,%edi
  80a470:	c1 ef 08             	shr    $0x8,%edi
  80a473:	b2 00                	mov    $0x0,%dl
  80a475:	01 fa                	add    %edi,%edx
  80a477:	89 f7                	mov    %esi,%edi
  80a479:	29 d7                	sub    %edx,%edi
  80a47b:	8b 1c bd a0 4b b3 00 	mov    0xb34ba0(,%edi,4),%ebx
  80a482:	eb 03                	jmp    80a487 <sys_arch_timeouts+0x30>
  80a484:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a487:	85 db                	test   %ebx,%ebx
  80a489:	74 06                	je     80a491 <sys_arch_timeouts+0x3a>
	if (t->tid == tid)
  80a48b:	39 33                	cmp    %esi,(%ebx)
  80a48d:	75 f5                	jne    80a484 <sys_arch_timeouts+0x2d>
  80a48f:	eb 61                	jmp    80a4f2 <sys_arch_timeouts+0x9b>
	    goto out;

    t = malloc(sizeof(*t));
  80a491:	83 ec 0c             	sub    $0xc,%esp
  80a494:	6a 10                	push   $0x10
  80a496:	e8 ac 5d 00 00       	call   810247 <malloc>
  80a49b:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a49d:	83 c4 10             	add    $0x10,%esp
  80a4a0:	85 c0                	test   %eax,%eax
  80a4a2:	74 59                	je     80a4fd <sys_arch_timeouts+0xa6>
	panic("sys_arch_timeouts: cannot malloc");

    int r = thread_onhalt(timeout_cleanup);
  80a4a4:	83 ec 0c             	sub    $0xc,%esp
  80a4a7:	68 5d 9c 80 00       	push   $0x809c5d
  80a4ac:	e8 eb 00 00 00       	call   80a59c <thread_onhalt>
    if (r < 0)
  80a4b1:	83 c4 10             	add    $0x10,%esp
  80a4b4:	85 c0                	test   %eax,%eax
  80a4b6:	78 5c                	js     80a514 <sys_arch_timeouts+0xbd>
	panic("thread_onhalt failed: %s", e2s(r));

    t->tid = tid;
  80a4b8:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a4ba:	83 ec 04             	sub    $0x4,%esp
  80a4bd:	6a 04                	push   $0x4
  80a4bf:	6a 00                	push   $0x0
  80a4c1:	8d 43 04             	lea    0x4(%ebx),%eax
  80a4c4:	50                   	push   %eax
  80a4c5:	e8 11 48 00 00       	call   80ecdb <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a4ca:	8b 04 bd a0 4b b3 00 	mov    0xb34ba0(,%edi,4),%eax
  80a4d1:	89 43 08             	mov    %eax,0x8(%ebx)
  80a4d4:	83 c4 10             	add    $0x10,%esp
  80a4d7:	85 c0                	test   %eax,%eax
  80a4d9:	74 06                	je     80a4e1 <sys_arch_timeouts+0x8a>
  80a4db:	8d 53 08             	lea    0x8(%ebx),%edx
  80a4de:	89 50 0c             	mov    %edx,0xc(%eax)
  80a4e1:	89 1c bd a0 4b b3 00 	mov    %ebx,0xb34ba0(,%edi,4)
  80a4e8:	8d 04 bd a0 4b b3 00 	lea    0xb34ba0(,%edi,4),%eax
  80a4ef:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a4f2:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a4f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a4f8:	5b                   	pop    %ebx
  80a4f9:	5e                   	pop    %esi
  80a4fa:	5f                   	pop    %edi
  80a4fb:	5d                   	pop    %ebp
  80a4fc:	c3                   	ret    
	panic("sys_arch_timeouts: cannot malloc");
  80a4fd:	83 ec 04             	sub    $0x4,%esp
  80a500:	68 60 23 81 00       	push   $0x812360
  80a505:	68 2c 01 00 00       	push   $0x12c
  80a50a:	68 a0 23 81 00       	push   $0x8123a0
  80a50f:	e8 c2 3f 00 00       	call   80e4d6 <_panic>
	panic("thread_onhalt failed: %s", e2s(r));
  80a514:	83 ec 0c             	sub    $0xc,%esp
  80a517:	50                   	push   %eax
  80a518:	e8 dc 03 00 00       	call   80a8f9 <e2s>
  80a51d:	50                   	push   %eax
  80a51e:	68 0d 24 81 00       	push   $0x81240d
  80a523:	68 30 01 00 00       	push   $0x130
  80a528:	68 a0 23 81 00       	push   $0x8123a0
  80a52d:	e8 a4 3f 00 00       	call   80e4d6 <_panic>

0080a532 <lwip_core_lock>:

void
lwip_core_lock(void)
{
}
  80a532:	c3                   	ret    

0080a533 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
}
  80a533:	c3                   	ret    

0080a534 <thread_init>:
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a534:	c7 05 e8 b1 b3 00 00 	movl   $0x0,0xb3b1e8
  80a53b:	00 00 00 
    tq->tq_last = 0;
  80a53e:	c7 05 ec b1 b3 00 00 	movl   $0x0,0xb3b1ec
  80a545:	00 00 00 
static struct thread_queue kill_queue;

void
thread_init(void) {
    threadq_init(&thread_queue);
    max_tid = 0;
  80a548:	c7 05 f4 b1 b3 00 00 	movl   $0x0,0xb3b1f4
  80a54f:	00 00 00 
}
  80a552:	c3                   	ret    

0080a553 <thread_id>:

uint32_t
thread_id(void) {
    return cur_tc->tc_tid;
  80a553:	a1 f0 b1 b3 00       	mov    0xb3b1f0,%eax
  80a558:	8b 00                	mov    (%eax),%eax
}
  80a55a:	c3                   	ret    

0080a55b <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a55b:	55                   	push   %ebp
  80a55c:	89 e5                	mov    %esp,%ebp
  80a55e:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a561:	a1 e8 b1 b3 00       	mov    0xb3b1e8,%eax
    while (tc) {
  80a566:	eb 03                	jmp    80a56b <thread_wakeup+0x10>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
  80a568:	8b 40 64             	mov    0x64(%eax),%eax
    while (tc) {
  80a56b:	85 c0                	test   %eax,%eax
  80a56d:	74 0b                	je     80a57a <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80a56f:	39 50 48             	cmp    %edx,0x48(%eax)
  80a572:	75 f4                	jne    80a568 <thread_wakeup+0xd>
	    tc->tc_wakeup = 1;
  80a574:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
  80a578:	eb ee                	jmp    80a568 <thread_wakeup+0xd>
    }
}
  80a57a:	5d                   	pop    %ebp
  80a57b:	c3                   	ret    

0080a57c <thread_wakeups_pending>:
}

int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
  80a57c:	a1 e8 b1 b3 00       	mov    0xb3b1e8,%eax
    int n = 0;
  80a581:	ba 00 00 00 00       	mov    $0x0,%edx
    while (tc) {
  80a586:	eb 0d                	jmp    80a595 <thread_wakeups_pending+0x19>
	if (tc->tc_wakeup)
  80a588:	0f b6 48 4c          	movzbl 0x4c(%eax),%ecx
	    ++n;
  80a58c:	80 f9 01             	cmp    $0x1,%cl
  80a58f:	83 da ff             	sbb    $0xffffffff,%edx
	tc = tc->tc_queue_link;
  80a592:	8b 40 64             	mov    0x64(%eax),%eax
    while (tc) {
  80a595:	85 c0                	test   %eax,%eax
  80a597:	75 ef                	jne    80a588 <thread_wakeups_pending+0xc>
    }
    return n;
}
  80a599:	89 d0                	mov    %edx,%eax
  80a59b:	c3                   	ret    

0080a59c <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a59c:	a1 f0 b1 b3 00       	mov    0xb3b1f0,%eax
  80a5a1:	8b 50 60             	mov    0x60(%eax),%edx
  80a5a4:	83 fa 03             	cmp    $0x3,%edx
  80a5a7:	7f 17                	jg     80a5c0 <thread_onhalt+0x24>
thread_onhalt(void (*fun)(thread_id_t)) {
  80a5a9:	55                   	push   %ebp
  80a5aa:	89 e5                	mov    %esp,%ebp
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a5ac:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a5af:	89 48 60             	mov    %ecx,0x60(%eax)
  80a5b2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a5b5:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a5b9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a5be:	5d                   	pop    %ebp
  80a5bf:	c3                   	ret    
	return -E_NO_MEM;
  80a5c0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  80a5c5:	c3                   	ret    

0080a5c6 <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a5c6:	55                   	push   %ebp
  80a5c7:	89 e5                	mov    %esp,%ebp
  80a5c9:	57                   	push   %edi
  80a5ca:	56                   	push   %esi
  80a5cb:	53                   	push   %ebx
  80a5cc:	83 ec 18             	sub    $0x18,%esp
  80a5cf:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a5d2:	6a 68                	push   $0x68
  80a5d4:	e8 6e 5c 00 00       	call   810247 <malloc>
    if (!tc)
  80a5d9:	83 c4 10             	add    $0x10,%esp
  80a5dc:	85 c0                	test   %eax,%eax
  80a5de:	0f 84 fe 00 00 00    	je     80a6e2 <thread_create+0x11c>
  80a5e4:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a5e6:	83 ec 04             	sub    $0x4,%esp
  80a5e9:	6a 68                	push   $0x68
  80a5eb:	6a 00                	push   $0x0
  80a5ed:	50                   	push   %eax
  80a5ee:	e8 e8 46 00 00       	call   80ecdb <memset>
    strncpy(tc->tc_name, name, name_size - 1);
  80a5f3:	83 c4 0c             	add    $0xc,%esp
  80a5f6:	6a 1f                	push   $0x1f
  80a5f8:	ff 75 0c             	push   0xc(%ebp)
  80a5fb:	8d 43 08             	lea    0x8(%ebx),%eax
  80a5fe:	50                   	push   %eax
  80a5ff:	e8 d0 45 00 00       	call   80ebd4 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a604:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    int tid = max_tid++;
  80a608:	a1 f4 b1 b3 00       	mov    0xb3b1f4,%eax
  80a60d:	8d 50 01             	lea    0x1(%eax),%edx
  80a610:	89 15 f4 b1 b3 00    	mov    %edx,0xb3b1f4
    if (max_tid == (uint32_t)~0)
  80a616:	83 c4 10             	add    $0x10,%esp
  80a619:	83 fa ff             	cmp    $0xffffffff,%edx
  80a61c:	0f 84 91 00 00 00    	je     80a6b3 <thread_create+0xed>
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a622:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a624:	83 ec 0c             	sub    $0xc,%esp
  80a627:	68 00 10 00 00       	push   $0x1000
  80a62c:	e8 16 5c 00 00       	call   810247 <malloc>
  80a631:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a634:	83 c4 10             	add    $0x10,%esp
  80a637:	85 c0                	test   %eax,%eax
  80a639:	0f 84 88 00 00 00    	je     80a6c7 <thread_create+0x101>
	return -E_NO_MEM;
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a63f:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a645:	83 ec 04             	sub    $0x4,%esp
  80a648:	6a 04                	push   $0x4
  80a64a:	6a 00                	push   $0x0
  80a64c:	57                   	push   %edi
  80a64d:	e8 89 46 00 00       	call   80ecdb <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a652:	83 c4 0c             	add    $0xc,%esp
  80a655:	6a 18                	push   $0x18
  80a657:	6a 00                	push   $0x0
  80a659:	8d 43 30             	lea    0x30(%ebx),%eax
  80a65c:	50                   	push   %eax
  80a65d:	e8 79 46 00 00       	call   80ecdb <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a662:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a665:	c7 43 30 68 a8 80 00 	movl   $0x80a868,0x30(%ebx)
    tc->tc_entry = entry;
  80a66c:	8b 45 10             	mov    0x10(%ebp),%eax
  80a66f:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a672:	8b 45 14             	mov    0x14(%ebp),%eax
  80a675:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a678:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a67f:	83 c4 10             	add    $0x10,%esp
  80a682:	83 3d e8 b1 b3 00 00 	cmpl   $0x0,0xb3b1e8
  80a689:	74 4f                	je     80a6da <thread_create+0x114>
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a68b:	a1 ec b1 b3 00       	mov    0xb3b1ec,%eax
  80a690:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a693:	89 1d ec b1 b3 00    	mov    %ebx,0xb3b1ec

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a699:	b8 00 00 00 00       	mov    $0x0,%eax
    if (tid)
  80a69e:	85 f6                	test   %esi,%esi
  80a6a0:	74 09                	je     80a6ab <thread_create+0xe5>
	*tid = tc->tc_tid;
  80a6a2:	8b 03                	mov    (%ebx),%eax
  80a6a4:	89 06                	mov    %eax,(%esi)
    return 0;
  80a6a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a6ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a6ae:	5b                   	pop    %ebx
  80a6af:	5e                   	pop    %esi
  80a6b0:	5f                   	pop    %edi
  80a6b1:	5d                   	pop    %ebp
  80a6b2:	c3                   	ret    
	panic("alloc_tid: no more thread ids");
  80a6b3:	83 ec 04             	sub    $0x4,%esp
  80a6b6:	68 26 24 81 00       	push   $0x812426
  80a6bb:	6a 54                	push   $0x54
  80a6bd:	68 44 24 81 00       	push   $0x812444
  80a6c2:	e8 0f 3e 00 00       	call   80e4d6 <_panic>
	free(tc);
  80a6c7:	83 ec 0c             	sub    $0xc,%esp
  80a6ca:	53                   	push   %ebx
  80a6cb:	e8 cb 5a 00 00       	call   81019b <free>
	return -E_NO_MEM;
  80a6d0:	83 c4 10             	add    $0x10,%esp
  80a6d3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a6d8:	eb d1                	jmp    80a6ab <thread_create+0xe5>
	tq->tq_first = tc;
  80a6da:	89 1d e8 b1 b3 00    	mov    %ebx,0xb3b1e8
  80a6e0:	eb b1                	jmp    80a693 <thread_create+0xcd>
	return -E_NO_MEM;
  80a6e2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a6e7:	eb c2                	jmp    80a6ab <thread_create+0xe5>

0080a6e9 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a6e9:	55                   	push   %ebp
  80a6ea:	89 e5                	mov    %esp,%ebp
  80a6ec:	53                   	push   %ebx
  80a6ed:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a6f0:	8b 1d e8 b1 b3 00    	mov    0xb3b1e8,%ebx
  80a6f6:	85 db                	test   %ebx,%ebx
  80a6f8:	74 2b                	je     80a725 <thread_yield+0x3c>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a6fa:	8b 43 64             	mov    0x64(%ebx),%eax
  80a6fd:	a3 e8 b1 b3 00       	mov    %eax,0xb3b1e8
    tc->tc_queue_link = 0;
  80a702:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a709:	a1 f0 b1 b3 00       	mov    0xb3b1f0,%eax
  80a70e:	85 c0                	test   %eax,%eax
  80a710:	74 3b                	je     80a74d <thread_yield+0x64>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a712:	83 ec 0c             	sub    $0xc,%esp
  80a715:	83 c0 30             	add    $0x30,%eax
  80a718:	50                   	push   %eax
  80a719:	e8 72 01 00 00       	call   80a890 <jos_setjmp>
  80a71e:	83 c4 10             	add    $0x10,%esp
  80a721:	85 c0                	test   %eax,%eax
  80a723:	74 05                	je     80a72a <thread_yield+0x41>
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  80a725:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a728:	c9                   	leave  
  80a729:	c3                   	ret    
	threadq_push(&thread_queue, cur_tc);
  80a72a:	a1 f0 b1 b3 00       	mov    0xb3b1f0,%eax
    tc->tc_queue_link = 0;
  80a72f:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a736:	83 3d e8 b1 b3 00 00 	cmpl   $0x0,0xb3b1e8
  80a73d:	74 21                	je     80a760 <thread_yield+0x77>
	tq->tq_last->tc_queue_link = tc;
  80a73f:	8b 15 ec b1 b3 00    	mov    0xb3b1ec,%edx
  80a745:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a748:	a3 ec b1 b3 00       	mov    %eax,0xb3b1ec
    cur_tc = next_tc;
  80a74d:	89 1d f0 b1 b3 00    	mov    %ebx,0xb3b1f0
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a753:	8d 43 30             	lea    0x30(%ebx),%eax
  80a756:	ba 01 00 00 00       	mov    $0x1,%edx
  80a75b:	e8 60 01 00 00       	call   80a8c0 <jos_longjmp>
	tq->tq_first = tc;
  80a760:	a3 e8 b1 b3 00       	mov    %eax,0xb3b1e8
	tq->tq_last = tc;
  80a765:	a3 ec b1 b3 00       	mov    %eax,0xb3b1ec
  80a76a:	eb e1                	jmp    80a74d <thread_yield+0x64>

0080a76c <thread_wait>:
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a76c:	55                   	push   %ebp
  80a76d:	89 e5                	mov    %esp,%ebp
  80a76f:	57                   	push   %edi
  80a770:	56                   	push   %esi
  80a771:	53                   	push   %ebx
  80a772:	83 ec 0c             	sub    $0xc,%esp
  80a775:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a778:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a77b:	e8 f8 49 00 00       	call   80f178 <sys_time_msec>
  80a780:	89 c6                	mov    %eax,%esi
    cur_tc->tc_wait_addr = addr;
  80a782:	a1 f0 b1 b3 00       	mov    0xb3b1f0,%eax
  80a787:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a78a:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
    uint32_t p = s;
  80a78e:	89 f0                	mov    %esi,%eax
    while (p < msec) {
  80a790:	eb 17                	jmp    80a7a9 <thread_wait+0x3d>
	if (cur_tc->tc_wakeup)
  80a792:	a1 f0 b1 b3 00       	mov    0xb3b1f0,%eax
  80a797:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a79b:	84 c0                	test   %al,%al
  80a79d:	75 1d                	jne    80a7bc <thread_wait+0x50>
	thread_yield();
  80a79f:	e8 45 ff ff ff       	call   80a6e9 <thread_yield>
	p = sys_time_msec();
  80a7a4:	e8 cf 49 00 00       	call   80f178 <sys_time_msec>
	if (p < s)
  80a7a9:	39 f0                	cmp    %esi,%eax
  80a7ab:	72 0f                	jb     80a7bc <thread_wait+0x50>
  80a7ad:	39 f8                	cmp    %edi,%eax
  80a7af:	73 0b                	jae    80a7bc <thread_wait+0x50>
	if (addr && *addr != val)
  80a7b1:	85 db                	test   %ebx,%ebx
  80a7b3:	74 dd                	je     80a792 <thread_wait+0x26>
  80a7b5:	8b 03                	mov    (%ebx),%eax
  80a7b7:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a7ba:	74 d6                	je     80a792 <thread_wait+0x26>
    cur_tc->tc_wait_addr = 0;
  80a7bc:	a1 f0 b1 b3 00       	mov    0xb3b1f0,%eax
  80a7c1:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a7c8:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a7cc:	83 c4 0c             	add    $0xc,%esp
  80a7cf:	5b                   	pop    %ebx
  80a7d0:	5e                   	pop    %esi
  80a7d1:	5f                   	pop    %edi
  80a7d2:	5d                   	pop    %ebp
  80a7d3:	c3                   	ret    

0080a7d4 <thread_halt>:
thread_halt() {
  80a7d4:	55                   	push   %ebp
  80a7d5:	89 e5                	mov    %esp,%ebp
  80a7d7:	56                   	push   %esi
  80a7d8:	53                   	push   %ebx
    if (!tq->tq_first)
  80a7d9:	8b 1d e0 b1 b3 00    	mov    0xb3b1e0,%ebx
  80a7df:	85 db                	test   %ebx,%ebx
  80a7e1:	74 40                	je     80a823 <thread_halt+0x4f>
    tq->tq_first = tc->tc_queue_link;
  80a7e3:	8b 43 64             	mov    0x64(%ebx),%eax
  80a7e6:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    tc->tc_queue_link = 0;
  80a7eb:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80a7f2:	be 00 00 00 00       	mov    $0x0,%esi
  80a7f7:	eb 0f                	jmp    80a808 <thread_halt+0x34>
	tc->tc_onhalt[i](tc->tc_tid);
  80a7f9:	83 ec 0c             	sub    $0xc,%esp
  80a7fc:	ff 33                	push   (%ebx)
  80a7fe:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a802:	83 c6 01             	add    $0x1,%esi
  80a805:	83 c4 10             	add    $0x10,%esp
  80a808:	3b 73 60             	cmp    0x60(%ebx),%esi
  80a80b:	7c ec                	jl     80a7f9 <thread_halt+0x25>
    free(tc->tc_stack_bottom);
  80a80d:	83 ec 0c             	sub    $0xc,%esp
  80a810:	ff 73 04             	push   0x4(%ebx)
  80a813:	e8 83 59 00 00       	call   81019b <free>
    free(tc);
  80a818:	89 1c 24             	mov    %ebx,(%esp)
  80a81b:	e8 7b 59 00 00       	call   81019b <free>
  80a820:	83 c4 10             	add    $0x10,%esp
    threadq_push(&kill_queue, cur_tc);
  80a823:	a1 f0 b1 b3 00       	mov    0xb3b1f0,%eax
    tc->tc_queue_link = 0;
  80a828:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a82f:	83 3d e0 b1 b3 00 00 	cmpl   $0x0,0xb3b1e0
  80a836:	74 29                	je     80a861 <thread_halt+0x8d>
	tq->tq_last->tc_queue_link = tc;
  80a838:	8b 15 e4 b1 b3 00    	mov    0xb3b1e4,%edx
  80a83e:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a841:	a3 e4 b1 b3 00       	mov    %eax,0xb3b1e4
    cur_tc = NULL;
  80a846:	c7 05 f0 b1 b3 00 00 	movl   $0x0,0xb3b1f0
  80a84d:	00 00 00 
    thread_yield();
  80a850:	e8 94 fe ff ff       	call   80a6e9 <thread_yield>
    exit();
  80a855:	e8 62 3c 00 00       	call   80e4bc <exit>
}
  80a85a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a85d:	5b                   	pop    %ebx
  80a85e:	5e                   	pop    %esi
  80a85f:	5d                   	pop    %ebp
  80a860:	c3                   	ret    
	tq->tq_first = tc;
  80a861:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  80a866:	eb d9                	jmp    80a841 <thread_halt+0x6d>

0080a868 <thread_entry>:
thread_entry(void) {
  80a868:	55                   	push   %ebp
  80a869:	89 e5                	mov    %esp,%ebp
  80a86b:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80a86e:	a1 f0 b1 b3 00       	mov    0xb3b1f0,%eax
  80a873:	ff 70 2c             	push   0x2c(%eax)
  80a876:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80a879:	e8 56 ff ff ff       	call   80a7d4 <thread_halt>
}
  80a87e:	83 c4 10             	add    $0x10,%esp
  80a881:	c9                   	leave  
  80a882:	c3                   	ret    
  80a883:	66 90                	xchg   %ax,%ax
  80a885:	66 90                	xchg   %ax,%ax
  80a887:	66 90                	xchg   %ax,%ax
  80a889:	66 90                	xchg   %ax,%ax
  80a88b:	66 90                	xchg   %ax,%ax
  80a88d:	66 90                	xchg   %ax,%ax
  80a88f:	90                   	nop

0080a890 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80a890:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80a894:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80a897:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80a899:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80a89d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80a8a0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80a8a3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80a8a6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80a8a9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80a8ac:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80a8b1:	c3                   	ret    
  80a8b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80a8b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0080a8c0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80a8c0:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80a8c2:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80a8c5:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80a8c8:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80a8cb:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80a8ce:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80a8d1:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80a8d3:	ff e1                	jmp    *%ecx

0080a8d5 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80a8d5:	55                   	push   %ebp
  80a8d6:	89 e5                	mov    %esp,%ebp
  80a8d8:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80a8db:	a1 34 50 81 00       	mov    0x815034,%eax
	cprintf("%s: %s\n", s, e2s(err));
  80a8e0:	ff 34 85 20 40 81 00 	push   0x814020(,%eax,4)
  80a8e7:	ff 75 08             	push   0x8(%ebp)
  80a8ea:	68 5f 24 81 00       	push   $0x81245f
  80a8ef:	e8 bd 3c 00 00       	call   80e5b1 <cprintf>
}
  80a8f4:	83 c4 10             	add    $0x10,%esp
  80a8f7:	c9                   	leave  
  80a8f8:	c3                   	ret    

0080a8f9 <e2s>:
e2s(int err) {
  80a8f9:	55                   	push   %ebp
  80a8fa:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80a8fc:	8b 45 08             	mov    0x8(%ebp),%eax
  80a8ff:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80a906:	5d                   	pop    %ebp
  80a907:	c3                   	ret    

0080a908 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80a908:	55                   	push   %ebp
  80a909:	89 e5                	mov    %esp,%ebp
  80a90b:	57                   	push   %edi
  80a90c:	56                   	push   %esi
  80a90d:	53                   	push   %ebx
  80a90e:	83 ec 10             	sub    $0x10,%esp
  80a911:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80a914:	6a 07                	push   $0x7
  80a916:	68 00 00 00 10       	push   $0x10000000
  80a91b:	6a 00                	push   $0x0
  80a91d:	e8 65 46 00 00       	call   80ef87 <sys_page_alloc>
    if (r < 0)
  80a922:	83 c4 10             	add    $0x10,%esp
  80a925:	85 c0                	test   %eax,%eax
  80a927:	78 44                	js     80a96d <low_level_output+0x65>
	panic("jif: could not allocate page of memory");
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80a929:	8b 45 08             	mov    0x8(%ebp),%eax
  80a92c:	8b 78 1c             	mov    0x1c(%eax),%edi

    char *txbuf = pkt->jp_data;
    int txsize = 0;
  80a92f:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a934:	85 db                	test   %ebx,%ebx
  80a936:	74 5f                	je     80a997 <low_level_output+0x8f>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80a938:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a93c:	0f b7 d0             	movzwl %ax,%edx
  80a93f:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80a942:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80a948:	7f 37                	jg     80a981 <low_level_output+0x79>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
  80a94a:	83 ec 04             	sub    $0x4,%esp
  80a94d:	0f b7 c0             	movzwl %ax,%eax
  80a950:	50                   	push   %eax
  80a951:	ff 73 04             	push   0x4(%ebx)
  80a954:	8d 86 04 00 00 10    	lea    0x10000004(%esi),%eax
  80a95a:	50                   	push   %eax
  80a95b:	e8 23 44 00 00       	call   80ed83 <memcpy>
	txsize += q->len;
  80a960:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a964:	01 c6                	add    %eax,%esi
    for (q = p; q != NULL; q = q->next) {
  80a966:	8b 1b                	mov    (%ebx),%ebx
  80a968:	83 c4 10             	add    $0x10,%esp
  80a96b:	eb c7                	jmp    80a934 <low_level_output+0x2c>
	panic("jif: could not allocate page of memory");
  80a96d:	83 ec 04             	sub    $0x4,%esp
  80a970:	68 44 29 81 00       	push   $0x812944
  80a975:	6a 55                	push   $0x55
  80a977:	68 95 29 81 00       	push   $0x812995
  80a97c:	e8 55 3b 00 00       	call   80e4d6 <_panic>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80a981:	83 ec 0c             	sub    $0xc,%esp
  80a984:	56                   	push   %esi
  80a985:	52                   	push   %edx
  80a986:	68 6c 29 81 00       	push   $0x81296c
  80a98b:	6a 64                	push   $0x64
  80a98d:	68 95 29 81 00       	push   $0x812995
  80a992:	e8 3f 3b 00 00       	call   80e4d6 <_panic>
    }

    pkt->jp_len = txsize;
  80a997:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80a99d:	6a 07                	push   $0x7
  80a99f:	68 00 00 00 10       	push   $0x10000000
  80a9a4:	6a 0b                	push   $0xb
  80a9a6:	ff 77 04             	push   0x4(%edi)
  80a9a9:	e8 10 4b 00 00       	call   80f4be <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80a9ae:	83 c4 08             	add    $0x8,%esp
  80a9b1:	68 00 00 00 10       	push   $0x10000000
  80a9b6:	6a 00                	push   $0x0
  80a9b8:	e8 4f 46 00 00       	call   80f00c <sys_page_unmap>

    return ERR_OK;
}
  80a9bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80a9c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a9c5:	5b                   	pop    %ebx
  80a9c6:	5e                   	pop    %esi
  80a9c7:	5f                   	pop    %edi
  80a9c8:	5d                   	pop    %ebp
  80a9c9:	c3                   	ret    

0080a9ca <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80a9ca:	55                   	push   %ebp
  80a9cb:	89 e5                	mov    %esp,%ebp
  80a9cd:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80a9d0:	ff 75 10             	push   0x10(%ebp)
  80a9d3:	ff 75 0c             	push   0xc(%ebp)
  80a9d6:	ff 75 08             	push   0x8(%ebp)
  80a9d9:	e8 d7 f0 ff ff       	call   809ab5 <etharp_output>
}
  80a9de:	c9                   	leave  
  80a9df:	c3                   	ret    

0080a9e0 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80a9e0:	55                   	push   %ebp
  80a9e1:	89 e5                	mov    %esp,%ebp
  80a9e3:	57                   	push   %edi
  80a9e4:	56                   	push   %esi
  80a9e5:	53                   	push   %ebx
  80a9e6:	83 ec 20             	sub    $0x20,%esp
  80a9e9:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80a9ec:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9ef:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a9f2:	89 45 d8             	mov    %eax,-0x28(%ebp)
    s16_t len = pkt->jp_len;
  80a9f5:	8b 06                	mov    (%esi),%eax
  80a9f7:	89 c3                	mov    %eax,%ebx
    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80a9f9:	6a 03                	push   $0x3
  80a9fb:	0f b7 c0             	movzwl %ax,%eax
  80a9fe:	50                   	push   %eax
  80a9ff:	6a 03                	push   $0x3
  80aa01:	e8 0c 9f ff ff       	call   804912 <pbuf_alloc>
  80aa06:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80aa09:	83 c4 10             	add    $0x10,%esp
  80aa0c:	85 c0                	test   %eax,%eax
  80aa0e:	0f 84 9a 00 00 00    	je     80aaae <jif_input+0xce>
    void *rxbuf = (void *) pkt->jp_data;
  80aa14:	8d 56 04             	lea    0x4(%esi),%edx
  80aa17:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    for (q = p; q != NULL; q = q->next) {
  80aa1a:	89 c6                	mov    %eax,%esi
    int copied = 0;
  80aa1c:	bf 00 00 00 00       	mov    $0x0,%edi
	if (bytes > (len - copied))
  80aa21:	0f bf c3             	movswl %bx,%eax
  80aa24:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int bytes = q->len;
  80aa27:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
	if (bytes > (len - copied))
  80aa2b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80aa2e:	29 f8                	sub    %edi,%eax
  80aa30:	39 c3                	cmp    %eax,%ebx
  80aa32:	0f 4f d8             	cmovg  %eax,%ebx
	memcpy(q->payload, rxbuf + copied, bytes);
  80aa35:	83 ec 04             	sub    $0x4,%esp
  80aa38:	53                   	push   %ebx
  80aa39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80aa3c:	01 f8                	add    %edi,%eax
  80aa3e:	50                   	push   %eax
  80aa3f:	ff 76 04             	push   0x4(%esi)
  80aa42:	e8 3c 43 00 00       	call   80ed83 <memcpy>
	copied += bytes;
  80aa47:	01 df                	add    %ebx,%edi
    for (q = p; q != NULL; q = q->next) {
  80aa49:	8b 36                	mov    (%esi),%esi
  80aa4b:	83 c4 10             	add    $0x10,%esp
  80aa4e:	85 f6                	test   %esi,%esi
  80aa50:	75 d5                	jne    80aa27 <jif_input+0x47>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80aa52:	83 ec 0c             	sub    $0xc,%esp
  80aa55:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80aa58:	8b 40 04             	mov    0x4(%eax),%eax
  80aa5b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80aa5f:	50                   	push   %eax
  80aa60:	e8 21 cc ff ff       	call   807686 <htons>
  80aa65:	83 c4 10             	add    $0x10,%esp
  80aa68:	66 3d 00 08          	cmp    $0x800,%ax
  80aa6c:	74 16                	je     80aa84 <jif_input+0xa4>
  80aa6e:	66 3d 06 08          	cmp    $0x806,%ax
  80aa72:	74 42                	je     80aab6 <jif_input+0xd6>
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
	break;

    default:
	pbuf_free(p);
  80aa74:	83 ec 0c             	sub    $0xc,%esp
  80aa77:	ff 75 dc             	push   -0x24(%ebp)
  80aa7a:	e8 cd 9d ff ff       	call   80484c <pbuf_free>
  80aa7f:	83 c4 10             	add    $0x10,%esp
  80aa82:	eb 2a                	jmp    80aaae <jif_input+0xce>
	etharp_ip_input(netif, p);
  80aa84:	83 ec 08             	sub    $0x8,%esp
  80aa87:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80aa8a:	57                   	push   %edi
  80aa8b:	ff 75 08             	push   0x8(%ebp)
  80aa8e:	e8 90 ea ff ff       	call   809523 <etharp_ip_input>
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80aa93:	83 c4 08             	add    $0x8,%esp
  80aa96:	6a f2                	push   $0xfffffff2
  80aa98:	57                   	push   %edi
  80aa99:	e8 df 9c ff ff       	call   80477d <pbuf_header>
	netif->input(p, netif);
  80aa9e:	83 c4 08             	add    $0x8,%esp
  80aaa1:	ff 75 08             	push   0x8(%ebp)
  80aaa4:	57                   	push   %edi
  80aaa5:	8b 45 08             	mov    0x8(%ebp),%eax
  80aaa8:	ff 50 10             	call   *0x10(%eax)
	break;
  80aaab:	83 c4 10             	add    $0x10,%esp
    }
}
  80aaae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aab1:	5b                   	pop    %ebx
  80aab2:	5e                   	pop    %esi
  80aab3:	5f                   	pop    %edi
  80aab4:	5d                   	pop    %ebp
  80aab5:	c3                   	ret    
	etharp_arp_input(netif, jif->ethaddr, p);
  80aab6:	83 ec 04             	sub    $0x4,%esp
  80aab9:	ff 75 dc             	push   -0x24(%ebp)
  80aabc:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80aabf:	ff 30                	push   (%eax)
  80aac1:	ff 75 08             	push   0x8(%ebp)
  80aac4:	e8 ac ea ff ff       	call   809575 <etharp_arp_input>
	break;
  80aac9:	83 c4 10             	add    $0x10,%esp
  80aacc:	eb e0                	jmp    80aaae <jif_input+0xce>

0080aace <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80aace:	55                   	push   %ebp
  80aacf:	89 e5                	mov    %esp,%ebp
  80aad1:	57                   	push   %edi
  80aad2:	56                   	push   %esi
  80aad3:	53                   	push   %ebx
  80aad4:	83 ec 28             	sub    $0x28,%esp
  80aad7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80aada:	6a 08                	push   $0x8
  80aadc:	e8 70 97 ff ff       	call   804251 <mem_malloc>

    if (jif == NULL) {
  80aae1:	83 c4 10             	add    $0x10,%esp
  80aae4:	85 c0                	test   %eax,%eax
  80aae6:	0f 84 87 00 00 00    	je     80ab73 <jif_init+0xa5>
  80aaec:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80aaee:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80aaf1:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80aaf4:	c7 43 14 ca a9 80 00 	movl   $0x80a9ca,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80aafb:	c7 43 18 08 a9 80 00 	movl   $0x80a908,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80ab02:	83 ec 04             	sub    $0x4,%esp
  80ab05:	6a 02                	push   $0x2
  80ab07:	68 a4 36 81 00       	push   $0x8136a4
  80ab0c:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80ab0f:	50                   	push   %eax
  80ab10:	e8 6e 42 00 00       	call   80ed83 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80ab15:	8d 43 25             	lea    0x25(%ebx),%eax
  80ab18:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80ab1a:	8b 07                	mov    (%edi),%eax
  80ab1c:	89 46 04             	mov    %eax,0x4(%esi)
    netif->hwaddr_len = 6;
  80ab1f:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80ab23:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80ab29:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    netif->hwaddr[0] = 0x52;
  80ab2d:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80ab31:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80ab35:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80ab39:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80ab3d:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80ab41:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80ab45:	c7 04 24 ab 0d 81 00 	movl   $0x810dab,(%esp)
  80ab4c:	e8 55 cd ff ff       	call   8078a6 <inet_addr>
  80ab51:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80ab54:	83 c4 0c             	add    $0xc,%esp
  80ab57:	6a 00                	push   $0x0
  80ab59:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ab5c:	50                   	push   %eax
  80ab5d:	53                   	push   %ebx
  80ab5e:	e8 1c ed ff ff       	call   80987f <etharp_query>

    return ERR_OK;
  80ab63:	83 c4 10             	add    $0x10,%esp
  80ab66:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ab6b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ab6e:	5b                   	pop    %ebx
  80ab6f:	5e                   	pop    %esi
  80ab70:	5f                   	pop    %edi
  80ab71:	5d                   	pop    %ebp
  80ab72:	c3                   	ret    
	return ERR_MEM;
  80ab73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ab78:	eb f1                	jmp    80ab6b <jif_init+0x9d>

0080ab7a <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80ab7a:	55                   	push   %ebp
  80ab7b:	89 e5                	mov    %esp,%ebp
  80ab7d:	56                   	push   %esi
  80ab7e:	53                   	push   %ebx
  80ab7f:	83 ec 28             	sub    $0x28,%esp
  80ab82:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80ab85:	ff 75 10             	push   0x10(%ebp)
  80ab88:	ff 75 08             	push   0x8(%ebp)
  80ab8b:	e8 45 0f 00 00       	call   80bad5 <netconn_alloc>
  80ab90:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80ab92:	83 c4 10             	add    $0x10,%esp
  80ab95:	85 c0                	test   %eax,%eax
  80ab97:	74 63                	je     80abfc <netconn_new_with_proto_and_callback+0x82>
    msg.function = do_newconn;
  80ab99:	c7 45 e4 cc b9 80 00 	movl   $0x80b9cc,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80aba0:	89 f0                	mov    %esi,%eax
  80aba2:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80aba5:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80aba8:	83 ec 0c             	sub    $0xc,%esp
  80abab:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80abae:	50                   	push   %eax
  80abaf:	e8 20 78 ff ff       	call   8023d4 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80abb4:	83 c4 10             	add    $0x10,%esp
  80abb7:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80abbb:	74 3f                	je     80abfc <netconn_new_with_proto_and_callback+0x82>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80abbd:	8b 73 08             	mov    0x8(%ebx),%esi
  80abc0:	85 f6                	test   %esi,%esi
  80abc2:	75 41                	jne    80ac05 <netconn_new_with_proto_and_callback+0x8b>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80abc4:	8b 43 10             	mov    0x10(%ebx),%eax
  80abc7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80abca:	74 4d                	je     80ac19 <netconn_new_with_proto_and_callback+0x9f>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80abcc:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80abd0:	74 5b                	je     80ac2d <netconn_new_with_proto_and_callback+0xb3>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80abd2:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80abd6:	75 69                	jne    80ac41 <netconn_new_with_proto_and_callback+0xc7>
      sys_sem_free(conn->op_completed);
  80abd8:	83 ec 0c             	sub    $0xc,%esp
  80abdb:	50                   	push   %eax
  80abdc:	e8 04 f2 ff ff       	call   809de5 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80abe1:	83 c4 04             	add    $0x4,%esp
  80abe4:	ff 73 14             	push   0x14(%ebx)
  80abe7:	e8 82 f2 ff ff       	call   809e6e <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80abec:	83 c4 08             	add    $0x8,%esp
  80abef:	53                   	push   %ebx
  80abf0:	6a 07                	push   $0x7
  80abf2:	e8 04 99 ff ff       	call   8044fb <memp_free>
      return NULL;
  80abf7:	83 c4 10             	add    $0x10,%esp
  80abfa:	89 f3                	mov    %esi,%ebx
    }
  }
  return conn;
}
  80abfc:	89 d8                	mov    %ebx,%eax
  80abfe:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ac01:	5b                   	pop    %ebx
  80ac02:	5e                   	pop    %esi
  80ac03:	5d                   	pop    %ebp
  80ac04:	c3                   	ret    
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ac05:	83 ec 04             	sub    $0x4,%esp
  80ac08:	68 ac 29 81 00       	push   $0x8129ac
  80ac0d:	6a 52                	push   $0x52
  80ac0f:	68 5e 2a 81 00       	push   $0x812a5e
  80ac14:	e8 bd 38 00 00       	call   80e4d6 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ac19:	83 ec 04             	sub    $0x4,%esp
  80ac1c:	68 75 2a 81 00       	push   $0x812a75
  80ac21:	6a 53                	push   $0x53
  80ac23:	68 5e 2a 81 00       	push   $0x812a5e
  80ac28:	e8 a9 38 00 00       	call   80e4d6 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ac2d:	83 ec 04             	sub    $0x4,%esp
  80ac30:	68 8e 2a 81 00       	push   $0x812a8e
  80ac35:	6a 54                	push   $0x54
  80ac37:	68 5e 2a 81 00       	push   $0x812a5e
  80ac3c:	e8 95 38 00 00       	call   80e4d6 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ac41:	83 ec 04             	sub    $0x4,%esp
  80ac44:	68 d0 29 81 00       	push   $0x8129d0
  80ac49:	6a 55                	push   $0x55
  80ac4b:	68 5e 2a 81 00       	push   $0x812a5e
  80ac50:	e8 81 38 00 00       	call   80e4d6 <_panic>

0080ac55 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80ac55:	55                   	push   %ebp
  80ac56:	89 e5                	mov    %esp,%ebp
  80ac58:	53                   	push   %ebx
  80ac59:	83 ec 24             	sub    $0x24,%esp
  80ac5c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80ac5f:	85 db                	test   %ebx,%ebx
  80ac61:	74 28                	je     80ac8b <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80ac63:	c7 45 e4 14 bd 80 00 	movl   $0x80bd14,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ac6a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80ac6d:	83 ec 0c             	sub    $0xc,%esp
  80ac70:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac73:	50                   	push   %eax
  80ac74:	e8 5b 77 ff ff       	call   8023d4 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ac79:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80ac80:	89 1c 24             	mov    %ebx,(%esp)
  80ac83:	e8 fb 0e 00 00       	call   80bb83 <netconn_free>

  return ERR_OK;
  80ac88:	83 c4 10             	add    $0x10,%esp
}
  80ac8b:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac90:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ac93:	c9                   	leave  
  80ac94:	c3                   	ret    

0080ac95 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80ac95:	55                   	push   %ebp
  80ac96:	89 e5                	mov    %esp,%ebp
  80ac98:	83 ec 08             	sub    $0x8,%esp
  80ac9b:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ac9e:	85 c0                	test   %eax,%eax
  80aca0:	74 04                	je     80aca6 <netconn_type+0x11>
  return conn->type;
}
  80aca2:	8b 00                	mov    (%eax),%eax
  80aca4:	c9                   	leave  
  80aca5:	c3                   	ret    
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80aca6:	83 ec 04             	sub    $0x4,%esp
  80aca9:	68 a3 2a 81 00       	push   $0x812aa3
  80acae:	68 84 00 00 00       	push   $0x84
  80acb3:	68 5e 2a 81 00       	push   $0x812a5e
  80acb8:	e8 19 38 00 00       	call   80e4d6 <_panic>

0080acbd <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80acbd:	55                   	push   %ebp
  80acbe:	89 e5                	mov    %esp,%ebp
  80acc0:	53                   	push   %ebx
  80acc1:	83 ec 24             	sub    $0x24,%esp
  80acc4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80acc7:	8b 55 0c             	mov    0xc(%ebp),%edx
  80acca:	8b 45 10             	mov    0x10(%ebp),%eax
  80accd:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80acd0:	85 db                	test   %ebx,%ebx
  80acd2:	74 30                	je     80ad04 <netconn_getaddr+0x47>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80acd4:	85 d2                	test   %edx,%edx
  80acd6:	74 43                	je     80ad1b <netconn_getaddr+0x5e>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80acd8:	85 c0                	test   %eax,%eax
  80acda:	74 56                	je     80ad32 <netconn_getaddr+0x75>

  msg.function = do_getaddr;
  80acdc:	c7 45 e4 63 c1 80 00 	movl   $0x80c163,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ace3:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80ace6:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80ace9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80acec:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80acef:	83 ec 0c             	sub    $0xc,%esp
  80acf2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80acf5:	50                   	push   %eax
  80acf6:	e8 d9 76 ff ff       	call   8023d4 <tcpip_apimsg>

  return conn->err;
  80acfb:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80acff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad02:	c9                   	leave  
  80ad03:	c3                   	ret    
  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad04:	83 ec 04             	sub    $0x4,%esp
  80ad07:	68 be 2a 81 00       	push   $0x812abe
  80ad0c:	68 98 00 00 00       	push   $0x98
  80ad11:	68 5e 2a 81 00       	push   $0x812a5e
  80ad16:	e8 bb 37 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80ad1b:	83 ec 04             	sub    $0x4,%esp
  80ad1e:	68 dc 2a 81 00       	push   $0x812adc
  80ad23:	68 99 00 00 00       	push   $0x99
  80ad28:	68 5e 2a 81 00       	push   $0x812a5e
  80ad2d:	e8 a4 37 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80ad32:	83 ec 04             	sub    $0x4,%esp
  80ad35:	68 fa 2a 81 00       	push   $0x812afa
  80ad3a:	68 9a 00 00 00       	push   $0x9a
  80ad3f:	68 5e 2a 81 00       	push   $0x812a5e
  80ad44:	e8 8d 37 00 00       	call   80e4d6 <_panic>

0080ad49 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ad49:	55                   	push   %ebp
  80ad4a:	89 e5                	mov    %esp,%ebp
  80ad4c:	53                   	push   %ebx
  80ad4d:	83 ec 24             	sub    $0x24,%esp
  80ad50:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ad53:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad56:	85 db                	test   %ebx,%ebx
  80ad58:	74 29                	je     80ad83 <netconn_bind+0x3a>

  msg.function = do_bind;
  80ad5a:	c7 45 e4 bd bd 80 00 	movl   $0x80bdbd,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad61:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ad64:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ad67:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ad6a:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80ad6e:	83 ec 0c             	sub    $0xc,%esp
  80ad71:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad74:	50                   	push   %eax
  80ad75:	e8 5a 76 ff ff       	call   8023d4 <tcpip_apimsg>
  return conn->err;
  80ad7a:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad81:	c9                   	leave  
  80ad82:	c3                   	ret    
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad83:	83 ec 04             	sub    $0x4,%esp
  80ad86:	68 18 2b 81 00       	push   $0x812b18
  80ad8b:	68 b5 00 00 00       	push   $0xb5
  80ad90:	68 5e 2a 81 00       	push   $0x812a5e
  80ad95:	e8 3c 37 00 00       	call   80e4d6 <_panic>

0080ad9a <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ad9a:	55                   	push   %ebp
  80ad9b:	89 e5                	mov    %esp,%ebp
  80ad9d:	53                   	push   %ebx
  80ad9e:	83 ec 24             	sub    $0x24,%esp
  80ada1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ada4:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ada7:	85 db                	test   %ebx,%ebx
  80ada9:	74 29                	je     80add4 <netconn_connect+0x3a>

  msg.function = do_connect;
  80adab:	c7 45 e4 4d be 80 00 	movl   $0x80be4d,-0x1c(%ebp)
  msg.msg.conn = conn;
  80adb2:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80adb5:	8b 55 0c             	mov    0xc(%ebp),%edx
  80adb8:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80adbb:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80adbf:	83 ec 0c             	sub    $0xc,%esp
  80adc2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80adc5:	50                   	push   %eax
  80adc6:	e8 09 76 ff ff       	call   8023d4 <tcpip_apimsg>
  return conn->err;
  80adcb:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80adcf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80add2:	c9                   	leave  
  80add3:	c3                   	ret    
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80add4:	83 ec 04             	sub    $0x4,%esp
  80add7:	68 33 2b 81 00       	push   $0x812b33
  80addc:	68 cc 00 00 00       	push   $0xcc
  80ade1:	68 5e 2a 81 00       	push   $0x812a5e
  80ade6:	e8 eb 36 00 00       	call   80e4d6 <_panic>

0080adeb <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80adeb:	55                   	push   %ebp
  80adec:	89 e5                	mov    %esp,%ebp
  80adee:	53                   	push   %ebx
  80adef:	83 ec 24             	sub    $0x24,%esp
  80adf2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80adf5:	85 db                	test   %ebx,%ebx
  80adf7:	74 1f                	je     80ae18 <netconn_disconnect+0x2d>

  msg.function = do_disconnect;
  80adf9:	c7 45 e4 02 bf 80 00 	movl   $0x80bf02,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae00:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80ae03:	83 ec 0c             	sub    $0xc,%esp
  80ae06:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae09:	50                   	push   %eax
  80ae0a:	e8 c5 75 ff ff       	call   8023d4 <tcpip_apimsg>
  return conn->err;
  80ae0f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae13:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae16:	c9                   	leave  
  80ae17:	c3                   	ret    
  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae18:	83 ec 04             	sub    $0x4,%esp
  80ae1b:	68 f4 29 81 00       	push   $0x8129f4
  80ae20:	68 e2 00 00 00       	push   $0xe2
  80ae25:	68 5e 2a 81 00       	push   $0x812a5e
  80ae2a:	e8 a7 36 00 00       	call   80e4d6 <_panic>

0080ae2f <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80ae2f:	55                   	push   %ebp
  80ae30:	89 e5                	mov    %esp,%ebp
  80ae32:	53                   	push   %ebx
  80ae33:	83 ec 24             	sub    $0x24,%esp
  80ae36:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae39:	85 db                	test   %ebx,%ebx
  80ae3b:	74 1f                	je     80ae5c <netconn_listen_with_backlog+0x2d>

  msg.function = do_listen;
  80ae3d:	c7 45 e4 3f bf 80 00 	movl   $0x80bf3f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae44:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80ae47:	83 ec 0c             	sub    $0xc,%esp
  80ae4a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae4d:	50                   	push   %eax
  80ae4e:	e8 81 75 ff ff       	call   8023d4 <tcpip_apimsg>
  return conn->err;
  80ae53:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae57:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae5a:	c9                   	leave  
  80ae5b:	c3                   	ret    
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae5c:	83 ec 04             	sub    $0x4,%esp
  80ae5f:	68 51 2b 81 00       	push   $0x812b51
  80ae64:	68 fa 00 00 00       	push   $0xfa
  80ae69:	68 5e 2a 81 00       	push   $0x812a5e
  80ae6e:	e8 63 36 00 00       	call   80e4d6 <_panic>

0080ae73 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80ae73:	55                   	push   %ebp
  80ae74:	89 e5                	mov    %esp,%ebp
  80ae76:	53                   	push   %ebx
  80ae77:	83 ec 14             	sub    $0x14,%esp
  80ae7a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80ae7d:	85 db                	test   %ebx,%ebx
  80ae7f:	74 36                	je     80aeb7 <netconn_accept+0x44>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80ae81:	8b 43 18             	mov    0x18(%ebx),%eax
  80ae84:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ae87:	74 45                	je     80aece <netconn_accept+0x5b>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80ae89:	83 ec 04             	sub    $0x4,%esp
  80ae8c:	6a 00                	push   $0x0
  80ae8e:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80ae91:	52                   	push   %edx
  80ae92:	50                   	push   %eax
  80ae93:	e8 21 f4 ff ff       	call   80a2b9 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80ae98:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ae9b:	83 c4 10             	add    $0x10,%esp
  80ae9e:	85 c0                	test   %eax,%eax
  80aea0:	74 0d                	je     80aeaf <netconn_accept+0x3c>
  80aea2:	83 ec 04             	sub    $0x4,%esp
  80aea5:	6a 00                	push   $0x0
  80aea7:	6a 01                	push   $0x1
  80aea9:	53                   	push   %ebx
  80aeaa:	ff d0                	call   *%eax
  80aeac:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80aeaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80aeb2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aeb5:	c9                   	leave  
  80aeb6:	c3                   	ret    
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80aeb7:	83 ec 04             	sub    $0x4,%esp
  80aeba:	68 6e 2b 81 00       	push   $0x812b6e
  80aebf:	68 10 01 00 00       	push   $0x110
  80aec4:	68 5e 2a 81 00       	push   $0x812a5e
  80aec9:	e8 08 36 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80aece:	83 ec 04             	sub    $0x4,%esp
  80aed1:	68 18 2a 81 00       	push   $0x812a18
  80aed6:	68 11 01 00 00       	push   $0x111
  80aedb:	68 5e 2a 81 00       	push   $0x812a5e
  80aee0:	e8 f1 35 00 00       	call   80e4d6 <_panic>

0080aee5 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80aee5:	55                   	push   %ebp
  80aee6:	89 e5                	mov    %esp,%ebp
  80aee8:	53                   	push   %ebx
  80aee9:	83 ec 24             	sub    $0x24,%esp
  80aeec:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80aeef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80aef6:	85 db                	test   %ebx,%ebx
  80aef8:	0f 84 cc 00 00 00    	je     80afca <netconn_recv+0xe5>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80aefe:	8b 43 14             	mov    0x14(%ebx),%eax
  80af01:	83 f8 ff             	cmp    $0xffffffff,%eax
  80af04:	0f 84 d7 00 00 00    	je     80afe1 <netconn_recv+0xfc>
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  80af0a:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80af0e:	0f 8c 27 01 00 00    	jl     80b03b <netconn_recv+0x156>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80af14:	83 3b 10             	cmpl   $0x10,(%ebx)
  80af17:	0f 85 e0 00 00 00    	jne    80affd <netconn_recv+0x118>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80af1d:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80af21:	0f 84 c5 00 00 00    	je     80afec <netconn_recv+0x107>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
      return NULL;
    }

    buf = memp_malloc(MEMP_NETBUF);
  80af27:	83 ec 0c             	sub    $0xc,%esp
  80af2a:	6a 06                	push   $0x6
  80af2c:	e8 74 95 ff ff       	call   8044a5 <memp_malloc>
  80af31:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80af34:	83 c4 10             	add    $0x10,%esp
  80af37:	85 c0                	test   %eax,%eax
  80af39:	0f 84 b8 00 00 00    	je     80aff7 <netconn_recv+0x112>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80af3f:	83 ec 04             	sub    $0x4,%esp
  80af42:	6a 00                	push   $0x0
  80af44:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80af47:	50                   	push   %eax
  80af48:	ff 73 14             	push   0x14(%ebx)
  80af4b:	e8 69 f3 ff ff       	call   80a2b9 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80af50:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80af53:	83 c4 10             	add    $0x10,%esp
  80af56:	85 c0                	test   %eax,%eax
  80af58:	0f 84 e4 00 00 00    	je     80b042 <netconn_recv+0x15d>
      len = p->tot_len;
  80af5e:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80af62:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80af66:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80af69:	85 c9                	test   %ecx,%ecx
  80af6b:	74 1a                	je     80af87 <netconn_recv+0xa2>
  80af6d:	83 ec 04             	sub    $0x4,%esp
  80af70:	0f b7 d2             	movzwl %dx,%edx
  80af73:	52                   	push   %edx
  80af74:	6a 01                	push   $0x1
  80af76:	53                   	push   %ebx
  80af77:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80af79:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80af7c:	83 c4 10             	add    $0x10,%esp
  80af7f:	85 c0                	test   %eax,%eax
  80af81:	0f 84 cb 00 00 00    	je     80b052 <netconn_recv+0x16d>
        conn->err = ERR_CLSD;
      }
      return NULL;
    }

    buf->p = p;
  80af87:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80af8a:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80af8c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80af8f:	89 42 04             	mov    %eax,0x4(%edx)
    buf->port = 0;
  80af92:	66 c7 42 0c 00 00    	movw   $0x0,0xc(%edx)
    buf->addr = NULL;
  80af98:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80af9f:	c7 45 e4 cd c0 80 00 	movl   $0x80c0cd,-0x1c(%ebp)
    msg.msg.conn = conn;
  80afa6:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
      msg.msg.msg.r.len = buf->p->tot_len;
  80afa9:	8b 02                	mov    (%edx),%eax
  80afab:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80afaf:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    } else {
      msg.msg.msg.r.len = 1;
    }
    TCPIP_APIMSG(&msg);
  80afb3:	83 ec 0c             	sub    $0xc,%esp
  80afb6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80afb9:	50                   	push   %eax
  80afba:	e8 15 74 ff ff       	call   8023d4 <tcpip_apimsg>
  80afbf:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80afc2:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  80afc5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80afc8:	c9                   	leave  
  80afc9:	c3                   	ret    
  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80afca:	83 ec 04             	sub    $0x4,%esp
  80afcd:	68 8b 2b 81 00       	push   $0x812b8b
  80afd2:	68 3a 01 00 00       	push   $0x13a
  80afd7:	68 5e 2a 81 00       	push   $0x812a5e
  80afdc:	e8 f5 34 00 00       	call   80e4d6 <_panic>
    conn->err = ERR_CONN;
  80afe1:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80afe5:	b8 00 00 00 00       	mov    $0x0,%eax
  80afea:	eb d9                	jmp    80afc5 <netconn_recv+0xe0>
      conn->err = ERR_CONN;
  80afec:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80aff0:	b8 00 00 00 00       	mov    $0x0,%eax
  80aff5:	eb ce                	jmp    80afc5 <netconn_recv+0xe0>
      conn->err = ERR_MEM;
  80aff7:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80affb:	eb c8                	jmp    80afc5 <netconn_recv+0xe0>
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80affd:	83 ec 04             	sub    $0x4,%esp
  80b000:	6a 00                	push   $0x0
  80b002:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b005:	52                   	push   %edx
  80b006:	50                   	push   %eax
  80b007:	e8 ad f2 ff ff       	call   80a2b9 <sys_arch_mbox_fetch>
    if (buf!=NULL) {
  80b00c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b00f:	83 c4 10             	add    $0x10,%esp
  80b012:	85 c0                	test   %eax,%eax
  80b014:	74 ac                	je     80afc2 <netconn_recv+0xdd>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b016:	8b 10                	mov    (%eax),%edx
  80b018:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b01c:	66 29 53 20          	sub    %dx,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b020:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b023:	85 d2                	test   %edx,%edx
  80b025:	74 9b                	je     80afc2 <netconn_recv+0xdd>
  80b027:	83 ec 04             	sub    $0x4,%esp
  80b02a:	8b 00                	mov    (%eax),%eax
  80b02c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b030:	50                   	push   %eax
  80b031:	6a 01                	push   $0x1
  80b033:	53                   	push   %ebx
  80b034:	ff d2                	call   *%edx
  80b036:	83 c4 10             	add    $0x10,%esp
  80b039:	eb 87                	jmp    80afc2 <netconn_recv+0xdd>
    return NULL;
  80b03b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b040:	eb 83                	jmp    80afc5 <netconn_recv+0xe0>
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b042:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
      len = 0;
  80b045:	ba 00 00 00 00       	mov    $0x0,%edx
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b04a:	85 c9                	test   %ecx,%ecx
  80b04c:	0f 85 1b ff ff ff    	jne    80af6d <netconn_recv+0x88>
      memp_free(MEMP_NETBUF, buf);
  80b052:	83 ec 08             	sub    $0x8,%esp
  80b055:	ff 75 e0             	push   -0x20(%ebp)
  80b058:	6a 06                	push   $0x6
  80b05a:	e8 9c 94 ff ff       	call   8044fb <memp_free>
      if (conn->err == ERR_OK) {
  80b05f:	83 c4 10             	add    $0x10,%esp
      return NULL;
  80b062:	b8 00 00 00 00       	mov    $0x0,%eax
      if (conn->err == ERR_OK) {
  80b067:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b06b:	0f 85 54 ff ff ff    	jne    80afc5 <netconn_recv+0xe0>
        conn->err = ERR_CLSD;
  80b071:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80b075:	e9 4b ff ff ff       	jmp    80afc5 <netconn_recv+0xe0>

0080b07a <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b07a:	55                   	push   %ebp
  80b07b:	89 e5                	mov    %esp,%ebp
  80b07d:	53                   	push   %ebx
  80b07e:	83 ec 24             	sub    $0x24,%esp
  80b081:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b084:	85 db                	test   %ebx,%ebx
  80b086:	74 25                	je     80b0ad <netconn_send+0x33>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b088:	c7 45 e4 27 c0 80 00 	movl   $0x80c027,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b08f:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b092:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b095:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b098:	83 ec 0c             	sub    $0xc,%esp
  80b09b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b09e:	50                   	push   %eax
  80b09f:	e8 30 73 ff ff       	call   8023d4 <tcpip_apimsg>
  return conn->err;
  80b0a4:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b0a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b0ab:	c9                   	leave  
  80b0ac:	c3                   	ret    
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b0ad:	83 ec 04             	sub    $0x4,%esp
  80b0b0:	68 a6 2b 81 00       	push   $0x812ba6
  80b0b5:	68 b9 01 00 00       	push   $0x1b9
  80b0ba:	68 5e 2a 81 00       	push   $0x812a5e
  80b0bf:	e8 12 34 00 00       	call   80e4d6 <_panic>

0080b0c4 <netconn_sendto>:
{
  80b0c4:	55                   	push   %ebp
  80b0c5:	89 e5                	mov    %esp,%ebp
  80b0c7:	83 ec 08             	sub    $0x8,%esp
  80b0ca:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b0cd:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b0d0:	85 c0                	test   %eax,%eax
  80b0d2:	74 1b                	je     80b0ef <netconn_sendto+0x2b>
    buf->addr = addr;
  80b0d4:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b0d7:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b0da:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b0de:	83 ec 08             	sub    $0x8,%esp
  80b0e1:	50                   	push   %eax
  80b0e2:	ff 75 08             	push   0x8(%ebp)
  80b0e5:	e8 90 ff ff ff       	call   80b07a <netconn_send>
  80b0ea:	83 c4 10             	add    $0x10,%esp
}
  80b0ed:	c9                   	leave  
  80b0ee:	c3                   	ret    
  return ERR_VAL;
  80b0ef:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b0f4:	eb f7                	jmp    80b0ed <netconn_sendto+0x29>

0080b0f6 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b0f6:	55                   	push   %ebp
  80b0f7:	89 e5                	mov    %esp,%ebp
  80b0f9:	53                   	push   %ebx
  80b0fa:	83 ec 24             	sub    $0x24,%esp
  80b0fd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b100:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b103:	85 db                	test   %ebx,%ebx
  80b105:	74 33                	je     80b13a <netconn_write+0x44>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b107:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b10a:	75 45                	jne    80b151 <netconn_write+0x5b>

  msg.function = do_write;
  80b10c:	c7 45 e4 13 c1 80 00 	movl   $0x80c113,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b113:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b116:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b119:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b11c:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b11f:	8b 45 10             	mov    0x10(%ebp),%eax
  80b122:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b125:	83 ec 0c             	sub    $0xc,%esp
  80b128:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b12b:	50                   	push   %eax
  80b12c:	e8 a3 72 ff ff       	call   8023d4 <tcpip_apimsg>
  return conn->err;
  80b131:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b135:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b138:	c9                   	leave  
  80b139:	c3                   	ret    
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b13a:	83 ec 04             	sub    $0x4,%esp
  80b13d:	68 c1 2b 81 00       	push   $0x812bc1
  80b142:	68 d3 01 00 00       	push   $0x1d3
  80b147:	68 5e 2a 81 00       	push   $0x812a5e
  80b14c:	e8 85 33 00 00       	call   80e4d6 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b151:	83 ec 04             	sub    $0x4,%esp
  80b154:	68 3c 2a 81 00       	push   $0x812a3c
  80b159:	68 d4 01 00 00       	push   $0x1d4
  80b15e:	68 5e 2a 81 00       	push   $0x812a5e
  80b163:	e8 6e 33 00 00       	call   80e4d6 <_panic>

0080b168 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b168:	55                   	push   %ebp
  80b169:	89 e5                	mov    %esp,%ebp
  80b16b:	53                   	push   %ebx
  80b16c:	83 ec 24             	sub    $0x24,%esp
  80b16f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b172:	85 db                	test   %ebx,%ebx
  80b174:	74 1f                	je     80b195 <netconn_close+0x2d>

  msg.function = do_close;
  80b176:	c7 45 e4 2a c2 80 00 	movl   $0x80c22a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b17d:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b180:	83 ec 0c             	sub    $0xc,%esp
  80b183:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b186:	50                   	push   %eax
  80b187:	e8 48 72 ff ff       	call   8023d4 <tcpip_apimsg>
  return conn->err;
  80b18c:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b190:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b193:	c9                   	leave  
  80b194:	c3                   	ret    
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b195:	83 ec 04             	sub    $0x4,%esp
  80b198:	68 dd 2b 81 00       	push   $0x812bdd
  80b19d:	68 ed 01 00 00       	push   $0x1ed
  80b1a2:	68 5e 2a 81 00       	push   $0x812a5e
  80b1a7:	e8 2a 33 00 00       	call   80e4d6 <_panic>

0080b1ac <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b1ac:	55                   	push   %ebp
  80b1ad:	89 e5                	mov    %esp,%ebp
  80b1af:	56                   	push   %esi
  80b1b0:	53                   	push   %ebx
  80b1b1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b1b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b1b7:	8b 75 10             	mov    0x10(%ebp),%esi
  80b1ba:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b1bd:	85 c0                	test   %eax,%eax
  80b1bf:	74 57                	je     80b218 <recv_tcp+0x6c>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b1c1:	85 db                	test   %ebx,%ebx
  80b1c3:	74 6a                	je     80b22f <recv_tcp+0x83>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b1c5:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b1c8:	75 7c                	jne    80b246 <recv_tcp+0x9a>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b1ca:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b1ce:	0f 84 89 00 00 00    	je     80b25d <recv_tcp+0xb1>
    return ERR_VAL;
  }

  conn->err = err;
  80b1d4:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  80b1d7:	b8 00 00 00 00       	mov    $0x0,%eax
  if (p != NULL) {
  80b1dc:	85 f6                	test   %esi,%esi
  80b1de:	74 08                	je     80b1e8 <recv_tcp+0x3c>
    len = p->tot_len;
  80b1e0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b1e4:	66 01 43 20          	add    %ax,0x20(%ebx)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b1e8:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b1eb:	85 d2                	test   %edx,%edx
  80b1ed:	74 0f                	je     80b1fe <recv_tcp+0x52>
  80b1ef:	83 ec 04             	sub    $0x4,%esp
  80b1f2:	0f b7 c0             	movzwl %ax,%eax
  80b1f5:	50                   	push   %eax
  80b1f6:	6a 00                	push   $0x0
  80b1f8:	53                   	push   %ebx
  80b1f9:	ff d2                	call   *%edx
  80b1fb:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b1fe:	83 ec 08             	sub    $0x8,%esp
  80b201:	56                   	push   %esi
  80b202:	ff 73 14             	push   0x14(%ebx)
  80b205:	e8 c1 ef ff ff       	call   80a1cb <sys_mbox_trypost>
  80b20a:	83 c4 10             	add    $0x10,%esp
  80b20d:	f6 d8                	neg    %al
  80b20f:	18 c0                	sbb    %al,%al
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b211:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b214:	5b                   	pop    %ebx
  80b215:	5e                   	pop    %esi
  80b216:	5d                   	pop    %ebp
  80b217:	c3                   	ret    
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b218:	83 ec 04             	sub    $0x4,%esp
  80b21b:	68 fc 2b 81 00       	push   $0x812bfc
  80b220:	68 c1 00 00 00       	push   $0xc1
  80b225:	68 46 2d 81 00       	push   $0x812d46
  80b22a:	e8 a7 32 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b22f:	83 ec 04             	sub    $0x4,%esp
  80b232:	68 20 2c 81 00       	push   $0x812c20
  80b237:	68 c2 00 00 00       	push   $0xc2
  80b23c:	68 46 2d 81 00       	push   $0x812d46
  80b241:	e8 90 32 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b246:	83 ec 04             	sub    $0x4,%esp
  80b249:	68 5d 2d 81 00       	push   $0x812d5d
  80b24e:	68 c4 00 00 00       	push   $0xc4
  80b253:	68 46 2d 81 00       	push   $0x812d46
  80b258:	e8 79 32 00 00       	call   80e4d6 <_panic>
    return ERR_VAL;
  80b25d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b262:	eb ad                	jmp    80b211 <recv_tcp+0x65>

0080b264 <recv_udp>:
{
  80b264:	55                   	push   %ebp
  80b265:	89 e5                	mov    %esp,%ebp
  80b267:	57                   	push   %edi
  80b268:	56                   	push   %esi
  80b269:	53                   	push   %ebx
  80b26a:	83 ec 1c             	sub    $0x1c,%esp
  80b26d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b270:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b273:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b276:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b279:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b27c:	85 c0                	test   %eax,%eax
  80b27e:	74 7f                	je     80b2ff <recv_udp+0x9b>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b280:	85 db                	test   %ebx,%ebx
  80b282:	0f 84 8e 00 00 00    	je     80b316 <recv_udp+0xb2>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b288:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b28b:	0f 85 9c 00 00 00    	jne    80b32d <recv_udp+0xc9>
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b291:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b295:	0f 84 a9 00 00 00    	je     80b344 <recv_udp+0xe0>
  buf = memp_malloc(MEMP_NETBUF);
  80b29b:	83 ec 0c             	sub    $0xc,%esp
  80b29e:	6a 06                	push   $0x6
  80b2a0:	e8 00 92 ff ff       	call   8044a5 <memp_malloc>
  80b2a5:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b2a7:	83 c4 10             	add    $0x10,%esp
  80b2aa:	85 c0                	test   %eax,%eax
  80b2ac:	0f 84 a0 00 00 00    	je     80b352 <recv_udp+0xee>
    buf->p = p;
  80b2b2:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b2b4:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b2b7:	8b 45 14             	mov    0x14(%ebp),%eax
  80b2ba:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b2bd:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b2c1:	66 89 46 0c          	mov    %ax,0xc(%esi)
  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b2c5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b2c9:	66 01 43 20          	add    %ax,0x20(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b2cd:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b2d0:	85 c0                	test   %eax,%eax
  80b2d2:	74 10                	je     80b2e4 <recv_udp+0x80>
  80b2d4:	83 ec 04             	sub    $0x4,%esp
  80b2d7:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b2db:	52                   	push   %edx
  80b2dc:	6a 00                	push   $0x0
  80b2de:	53                   	push   %ebx
  80b2df:	ff d0                	call   *%eax
  80b2e1:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b2e4:	83 ec 08             	sub    $0x8,%esp
  80b2e7:	56                   	push   %esi
  80b2e8:	ff 73 14             	push   0x14(%ebx)
  80b2eb:	e8 db ee ff ff       	call   80a1cb <sys_mbox_trypost>
  80b2f0:	83 c4 10             	add    $0x10,%esp
  80b2f3:	84 c0                	test   %al,%al
  80b2f5:	75 69                	jne    80b360 <recv_udp+0xfc>
}
  80b2f7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b2fa:	5b                   	pop    %ebx
  80b2fb:	5e                   	pop    %esi
  80b2fc:	5f                   	pop    %edi
  80b2fd:	5d                   	pop    %ebp
  80b2fe:	c3                   	ret    
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b2ff:	83 ec 04             	sub    $0x4,%esp
  80b302:	68 40 2c 81 00       	push   $0x812c40
  80b307:	68 8e 00 00 00       	push   $0x8e
  80b30c:	68 46 2d 81 00       	push   $0x812d46
  80b311:	e8 c0 31 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b316:	83 ec 04             	sub    $0x4,%esp
  80b319:	68 64 2c 81 00       	push   $0x812c64
  80b31e:	68 8f 00 00 00       	push   $0x8f
  80b323:	68 46 2d 81 00       	push   $0x812d46
  80b328:	e8 a9 31 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b32d:	83 ec 04             	sub    $0x4,%esp
  80b330:	68 7b 2d 81 00       	push   $0x812d7b
  80b335:	68 91 00 00 00       	push   $0x91
  80b33a:	68 46 2d 81 00       	push   $0x812d46
  80b33f:	e8 92 31 00 00       	call   80e4d6 <_panic>
    pbuf_free(p);
  80b344:	83 ec 0c             	sub    $0xc,%esp
  80b347:	57                   	push   %edi
  80b348:	e8 ff 94 ff ff       	call   80484c <pbuf_free>
    return;
  80b34d:	83 c4 10             	add    $0x10,%esp
  80b350:	eb a5                	jmp    80b2f7 <recv_udp+0x93>
    pbuf_free(p);
  80b352:	83 ec 0c             	sub    $0xc,%esp
  80b355:	57                   	push   %edi
  80b356:	e8 f1 94 ff ff       	call   80484c <pbuf_free>
    return;
  80b35b:	83 c4 10             	add    $0x10,%esp
  80b35e:	eb 97                	jmp    80b2f7 <recv_udp+0x93>
    netbuf_delete(buf);
  80b360:	83 ec 0c             	sub    $0xc,%esp
  80b363:	56                   	push   %esi
  80b364:	e8 5b 71 ff ff       	call   8024c4 <netbuf_delete>
    return;
  80b369:	83 c4 10             	add    $0x10,%esp
  80b36c:	eb 89                	jmp    80b2f7 <recv_udp+0x93>

0080b36e <recv_raw>:
{
  80b36e:	55                   	push   %ebp
  80b36f:	89 e5                	mov    %esp,%ebp
  80b371:	57                   	push   %edi
  80b372:	56                   	push   %esi
  80b373:	53                   	push   %ebx
  80b374:	83 ec 0c             	sub    $0xc,%esp
  80b377:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b37a:	85 db                	test   %ebx,%ebx
  80b37c:	74 06                	je     80b384 <recv_raw+0x16>
  80b37e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b382:	75 0d                	jne    80b391 <recv_raw+0x23>
}
  80b384:	b8 00 00 00 00       	mov    $0x0,%eax
  80b389:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b38c:	5b                   	pop    %ebx
  80b38d:	5e                   	pop    %esi
  80b38e:	5f                   	pop    %edi
  80b38f:	5d                   	pop    %ebp
  80b390:	c3                   	ret    
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b391:	83 ec 04             	sub    $0x4,%esp
  80b394:	6a 00                	push   $0x0
  80b396:	8b 45 10             	mov    0x10(%ebp),%eax
  80b399:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b39d:	50                   	push   %eax
  80b39e:	6a 03                	push   $0x3
  80b3a0:	e8 6d 95 ff ff       	call   804912 <pbuf_alloc>
  80b3a5:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b3a7:	83 c4 10             	add    $0x10,%esp
  80b3aa:	85 c0                	test   %eax,%eax
  80b3ac:	74 d6                	je     80b384 <recv_raw+0x16>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b3ae:	83 ec 08             	sub    $0x8,%esp
  80b3b1:	ff 75 10             	push   0x10(%ebp)
  80b3b4:	50                   	push   %eax
  80b3b5:	e8 27 9a ff ff       	call   804de1 <pbuf_copy>
  80b3ba:	83 c4 10             	add    $0x10,%esp
  80b3bd:	84 c0                	test   %al,%al
  80b3bf:	75 73                	jne    80b434 <recv_raw+0xc6>
      buf = memp_malloc(MEMP_NETBUF);
  80b3c1:	83 ec 0c             	sub    $0xc,%esp
  80b3c4:	6a 06                	push   $0x6
  80b3c6:	e8 da 90 ff ff       	call   8044a5 <memp_malloc>
  80b3cb:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b3cd:	83 c4 10             	add    $0x10,%esp
  80b3d0:	85 c0                	test   %eax,%eax
  80b3d2:	74 71                	je     80b445 <recv_raw+0xd7>
      buf->p = q;
  80b3d4:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b3d6:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b3d9:	8b 46 04             	mov    0x4(%esi),%eax
  80b3dc:	83 c0 0c             	add    $0xc,%eax
  80b3df:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b3e2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b3e5:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b3e9:	66 89 47 0c          	mov    %ax,0xc(%edi)
      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b3ed:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b3f1:	66 01 43 20          	add    %ax,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b3f5:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b3f8:	85 c0                	test   %eax,%eax
  80b3fa:	74 10                	je     80b40c <recv_raw+0x9e>
  80b3fc:	83 ec 04             	sub    $0x4,%esp
  80b3ff:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b403:	52                   	push   %edx
  80b404:	6a 00                	push   $0x0
  80b406:	53                   	push   %ebx
  80b407:	ff d0                	call   *%eax
  80b409:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b40c:	83 ec 08             	sub    $0x8,%esp
  80b40f:	57                   	push   %edi
  80b410:	ff 73 14             	push   0x14(%ebx)
  80b413:	e8 b3 ed ff ff       	call   80a1cb <sys_mbox_trypost>
  80b418:	83 c4 10             	add    $0x10,%esp
  80b41b:	84 c0                	test   %al,%al
  80b41d:	0f 84 61 ff ff ff    	je     80b384 <recv_raw+0x16>
        netbuf_delete(buf);
  80b423:	83 ec 0c             	sub    $0xc,%esp
  80b426:	57                   	push   %edi
  80b427:	e8 98 70 ff ff       	call   8024c4 <netbuf_delete>
  80b42c:	83 c4 10             	add    $0x10,%esp
  80b42f:	e9 50 ff ff ff       	jmp    80b384 <recv_raw+0x16>
        pbuf_free(q);
  80b434:	83 ec 0c             	sub    $0xc,%esp
  80b437:	56                   	push   %esi
  80b438:	e8 0f 94 ff ff       	call   80484c <pbuf_free>
  80b43d:	83 c4 10             	add    $0x10,%esp
  80b440:	e9 3f ff ff ff       	jmp    80b384 <recv_raw+0x16>
        pbuf_free(q);
  80b445:	83 ec 0c             	sub    $0xc,%esp
  80b448:	56                   	push   %esi
  80b449:	e8 fe 93 ff ff       	call   80484c <pbuf_free>
        return 0;
  80b44e:	83 c4 10             	add    $0x10,%esp
  80b451:	e9 2e ff ff ff       	jmp    80b384 <recv_raw+0x16>

0080b456 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b456:	55                   	push   %ebp
  80b457:	89 e5                	mov    %esp,%ebp
  80b459:	53                   	push   %ebx
  80b45a:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b45d:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b460:	50                   	push   %eax
  80b461:	53                   	push   %ebx
  80b462:	e8 7b a3 ff ff       	call   8057e2 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b467:	83 c4 08             	add    $0x8,%esp
  80b46a:	68 ac b1 80 00       	push   $0x80b1ac
  80b46f:	53                   	push   %ebx
  80b470:	e8 7b a3 ff ff       	call   8057f0 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b475:	83 c4 08             	add    $0x8,%esp
  80b478:	68 39 b9 80 00       	push   $0x80b939
  80b47d:	53                   	push   %ebx
  80b47e:	e8 7e a3 ff ff       	call   805801 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b483:	83 c4 0c             	add    $0xc,%esp
  80b486:	6a 04                	push   $0x4
  80b488:	68 f3 b8 80 00       	push   $0x80b8f3
  80b48d:	53                   	push   %ebx
  80b48e:	e8 9e a3 ff ff       	call   805831 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b493:	83 c4 08             	add    $0x8,%esp
  80b496:	68 f5 b4 80 00       	push   $0x80b4f5
  80b49b:	53                   	push   %ebx
  80b49c:	e8 71 a3 ff ff       	call   805812 <tcp_err>
}
  80b4a1:	83 c4 10             	add    $0x10,%esp
  80b4a4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b4a7:	c9                   	leave  
  80b4a8:	c3                   	ret    

0080b4a9 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b4a9:	55                   	push   %ebp
  80b4aa:	89 e5                	mov    %esp,%ebp
  80b4ac:	53                   	push   %ebx
  80b4ad:	83 ec 04             	sub    $0x4,%esp
  80b4b0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b4b3:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b4b6:	85 db                	test   %ebx,%ebx
  80b4b8:	74 34                	je     80b4ee <do_connected+0x45>
    return ERR_VAL;
  }

  conn->err = err;
  80b4ba:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b4bd:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b4c0:	75 04                	jne    80b4c6 <do_connected+0x1d>
  80b4c2:	84 c0                	test   %al,%al
  80b4c4:	74 1f                	je     80b4e5 <do_connected+0x3c>
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  80b4c6:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b4cd:	83 ec 0c             	sub    $0xc,%esp
  80b4d0:	ff 73 10             	push   0x10(%ebx)
  80b4d3:	e8 49 eb ff ff       	call   80a021 <sys_sem_signal>
  return ERR_OK;
  80b4d8:	83 c4 10             	add    $0x10,%esp
  80b4db:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b4e0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b4e3:	c9                   	leave  
  80b4e4:	c3                   	ret    
    setup_tcp(conn);
  80b4e5:	89 d8                	mov    %ebx,%eax
  80b4e7:	e8 6a ff ff ff       	call   80b456 <setup_tcp>
  80b4ec:	eb d8                	jmp    80b4c6 <do_connected+0x1d>
    return ERR_VAL;
  80b4ee:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b4f3:	eb eb                	jmp    80b4e0 <do_connected+0x37>

0080b4f5 <err_tcp>:
{
  80b4f5:	55                   	push   %ebp
  80b4f6:	89 e5                	mov    %esp,%ebp
  80b4f8:	53                   	push   %ebx
  80b4f9:	83 ec 04             	sub    $0x4,%esp
  80b4fc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b4ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b502:	85 db                	test   %ebx,%ebx
  80b504:	74 7e                	je     80b584 <err_tcp+0x8f>
  conn->pcb.tcp = NULL;
  80b506:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  conn->err = err;
  80b50d:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b510:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b514:	74 24                	je     80b53a <err_tcp+0x45>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b516:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b519:	85 c0                	test   %eax,%eax
  80b51b:	74 0d                	je     80b52a <err_tcp+0x35>
  80b51d:	83 ec 04             	sub    $0x4,%esp
  80b520:	6a 00                	push   $0x0
  80b522:	6a 00                	push   $0x0
  80b524:	53                   	push   %ebx
  80b525:	ff d0                	call   *%eax
  80b527:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b52a:	83 ec 08             	sub    $0x8,%esp
  80b52d:	6a 00                	push   $0x0
  80b52f:	ff 73 14             	push   0x14(%ebx)
  80b532:	e8 52 ed ff ff       	call   80a289 <sys_mbox_post>
  80b537:	83 c4 10             	add    $0x10,%esp
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b53a:	8b 43 10             	mov    0x10(%ebx),%eax
  80b53d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b540:	74 06                	je     80b548 <err_tcp+0x53>
  80b542:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b546:	74 53                	je     80b59b <err_tcp+0xa6>
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b548:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b54c:	74 24                	je     80b572 <err_tcp+0x7d>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b54e:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b551:	85 c0                	test   %eax,%eax
  80b553:	74 0d                	je     80b562 <err_tcp+0x6d>
  80b555:	83 ec 04             	sub    $0x4,%esp
  80b558:	6a 00                	push   $0x0
  80b55a:	6a 00                	push   $0x0
  80b55c:	53                   	push   %ebx
  80b55d:	ff d0                	call   *%eax
  80b55f:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b562:	83 ec 08             	sub    $0x8,%esp
  80b565:	6a 00                	push   $0x0
  80b567:	ff 73 18             	push   0x18(%ebx)
  80b56a:	e8 1a ed ff ff       	call   80a289 <sys_mbox_post>
  80b56f:	83 c4 10             	add    $0x10,%esp
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b572:	8b 43 04             	mov    0x4(%ebx),%eax
  80b575:	83 f8 01             	cmp    $0x1,%eax
  80b578:	74 36                	je     80b5b0 <err_tcp+0xbb>
  80b57a:	83 f8 04             	cmp    $0x4,%eax
  80b57d:	74 31                	je     80b5b0 <err_tcp+0xbb>
}
  80b57f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b582:	c9                   	leave  
  80b583:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b584:	83 ec 04             	sub    $0x4,%esp
  80b587:	68 99 2d 81 00       	push   $0x812d99
  80b58c:	68 22 01 00 00       	push   $0x122
  80b591:	68 46 2d 81 00       	push   $0x812d46
  80b596:	e8 3b 2f 00 00       	call   80e4d6 <_panic>
    conn->state = NETCONN_NONE;
  80b59b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b5a2:	83 ec 0c             	sub    $0xc,%esp
  80b5a5:	50                   	push   %eax
  80b5a6:	e8 76 ea ff ff       	call   80a021 <sys_sem_signal>
  80b5ab:	83 c4 10             	add    $0x10,%esp
  80b5ae:	eb 98                	jmp    80b548 <err_tcp+0x53>
    conn->state = NETCONN_NONE;
  80b5b0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b5b7:	83 ec 0c             	sub    $0xc,%esp
  80b5ba:	ff 73 10             	push   0x10(%ebx)
  80b5bd:	e8 5f ea ff ff       	call   80a021 <sys_sem_signal>
  80b5c2:	83 c4 10             	add    $0x10,%esp
}
  80b5c5:	eb b8                	jmp    80b57f <err_tcp+0x8a>

0080b5c7 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b5c7:	55                   	push   %ebp
  80b5c8:	89 e5                	mov    %esp,%ebp
  80b5ca:	57                   	push   %edi
  80b5cb:	56                   	push   %esi
  80b5cc:	53                   	push   %ebx
  80b5cd:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b5d0:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b5d4:	0f 85 ca 00 00 00    	jne    80b6a4 <do_writemore+0xdd>
  80b5da:	89 c3                	mov    %eax,%ebx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b5dc:	8b 40 24             	mov    0x24(%eax),%eax
  80b5df:	8b 53 28             	mov    0x28(%ebx),%edx
  80b5e2:	89 d1                	mov    %edx,%ecx
  80b5e4:	03 48 04             	add    0x4(%eax),%ecx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b5e7:	8b 70 08             	mov    0x8(%eax),%esi
  80b5ea:	89 f7                	mov    %esi,%edi
  80b5ec:	29 d7                	sub    %edx,%edi
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b5ee:	29 d6                	sub    %edx,%esi
  80b5f0:	81 ff 00 00 01 00    	cmp    $0x10000,%edi
  80b5f6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80b5fb:	0f 4d f2             	cmovge %edx,%esi
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b5fe:	8b 53 08             	mov    0x8(%ebx),%edx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b601:	0f b7 7a 6e          	movzwl 0x6e(%edx),%edi
  80b605:	66 39 fe             	cmp    %di,%si
  80b608:	0f 47 f7             	cmova  %edi,%esi
  80b60b:	0f b7 f6             	movzwl %si,%esi
  80b60e:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80b612:	50                   	push   %eax
  80b613:	56                   	push   %esi
  80b614:	51                   	push   %ecx
  80b615:	52                   	push   %edx
  80b616:	e8 7f c9 ff ff       	call   807f9a <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b61b:	89 f2                	mov    %esi,%edx
  80b61d:	03 53 28             	add    0x28(%ebx),%edx
  80b620:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80b623:	83 c4 10             	add    $0x10,%esp
  80b626:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b629:	0f 8f 8c 00 00 00    	jg     80b6bb <do_writemore+0xf4>
  if (err == ERR_OK) {
  80b62f:	84 c0                	test   %al,%al
  80b631:	0f 85 bf 00 00 00    	jne    80b6f6 <do_writemore+0x12f>
    conn->write_offset += len;
  80b637:	89 53 28             	mov    %edx,0x28(%ebx)
  u8_t write_finished = 0;
  80b63a:	bf 00 00 00 00       	mov    $0x0,%edi
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b63f:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b642:	0f 84 8a 00 00 00    	je     80b6d2 <do_writemore+0x10b>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b648:	8b 43 08             	mov    0x8(%ebx),%eax
  80b64b:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b64f:	74 1a                	je     80b66b <do_writemore+0xa4>
  80b651:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b655:	75 14                	jne    80b66b <do_writemore+0xa4>
  80b657:	8b 50 74             	mov    0x74(%eax),%edx
  80b65a:	85 d2                	test   %edx,%edx
  80b65c:	0f 84 88 00 00 00    	je     80b6ea <do_writemore+0x123>
  80b662:	83 3a 00             	cmpl   $0x0,(%edx)
  80b665:	0f 84 85 00 00 00    	je     80b6f0 <do_writemore+0x129>
  80b66b:	83 ec 0c             	sub    $0xc,%esp
  80b66e:	50                   	push   %eax
  80b66f:	e8 7d c9 ff ff       	call   807ff1 <tcp_output>
    conn->err = err;
  80b674:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b677:	83 c4 10             	add    $0x10,%esp
  80b67a:	84 c0                	test   %al,%al
  80b67c:	75 1e                	jne    80b69c <do_writemore+0xd5>
  80b67e:	8b 43 08             	mov    0x8(%ebx),%eax
  80b681:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b687:	77 13                	ja     80b69c <do_writemore+0xd5>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b689:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b68c:	85 c0                	test   %eax,%eax
  80b68e:	74 0c                	je     80b69c <do_writemore+0xd5>
  80b690:	83 ec 04             	sub    $0x4,%esp
  80b693:	56                   	push   %esi
  80b694:	6a 03                	push   $0x3
  80b696:	53                   	push   %ebx
  80b697:	ff d0                	call   *%eax
  80b699:	83 c4 10             	add    $0x10,%esp
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
  80b69c:	89 f8                	mov    %edi,%eax
  80b69e:	84 c0                	test   %al,%al
  80b6a0:	74 70                	je     80b712 <do_writemore+0x14b>
  80b6a2:	eb 59                	jmp    80b6fd <do_writemore+0x136>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b6a4:	83 ec 04             	sub    $0x4,%esp
  80b6a7:	68 a6 2d 81 00       	push   $0x812da6
  80b6ac:	68 b8 03 00 00       	push   $0x3b8
  80b6b1:	68 46 2d 81 00       	push   $0x812d46
  80b6b6:	e8 1b 2e 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b6bb:	83 ec 04             	sub    $0x4,%esp
  80b6be:	68 c3 2d 81 00       	push   $0x812dc3
  80b6c3:	68 cd 03 00 00       	push   $0x3cd
  80b6c8:	68 46 2d 81 00       	push   $0x812d46
  80b6cd:	e8 04 2e 00 00       	call   80e4d6 <_panic>
      conn->write_msg = NULL;
  80b6d2:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80b6d9:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
      write_finished = 1;
  80b6e0:	bf 01 00 00 00       	mov    $0x1,%edi
  80b6e5:	e9 5e ff ff ff       	jmp    80b648 <do_writemore+0x81>
    conn->err = err;
  80b6ea:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80b6ee:	eb 8e                	jmp    80b67e <do_writemore+0xb7>
  80b6f0:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80b6f4:	eb 88                	jmp    80b67e <do_writemore+0xb7>
  } else if (err == ERR_MEM) {
  80b6f6:	3c ff                	cmp    $0xff,%al
  80b6f8:	74 25                	je     80b71f <do_writemore+0x158>
    conn->err = err;
  80b6fa:	88 43 0c             	mov    %al,0xc(%ebx)
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b6fd:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b704:	83 ec 0c             	sub    $0xc,%esp
  80b707:	ff 73 10             	push   0x10(%ebx)
  80b70a:	e8 12 e9 ff ff       	call   80a021 <sys_sem_signal>
  80b70f:	83 c4 10             	add    $0x10,%esp
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b712:	b8 00 00 00 00       	mov    $0x0,%eax
  80b717:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b71a:	5b                   	pop    %ebx
  80b71b:	5e                   	pop    %esi
  80b71c:	5f                   	pop    %edi
  80b71d:	5d                   	pop    %ebp
  80b71e:	c3                   	ret    
    err = tcp_output(conn->pcb.tcp);
  80b71f:	83 ec 0c             	sub    $0xc,%esp
  80b722:	ff 73 08             	push   0x8(%ebx)
  80b725:	e8 c7 c8 ff ff       	call   807ff1 <tcp_output>
  80b72a:	83 c4 10             	add    $0x10,%esp
  80b72d:	eb e3                	jmp    80b712 <do_writemore+0x14b>

0080b72f <do_close_internal>:
{
  80b72f:	55                   	push   %ebp
  80b730:	89 e5                	mov    %esp,%ebp
  80b732:	53                   	push   %ebx
  80b733:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b736:	85 c0                	test   %eax,%eax
  80b738:	0f 84 e2 00 00 00    	je     80b820 <do_close_internal+0xf1>
  80b73e:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b740:	83 38 10             	cmpl   $0x10,(%eax)
  80b743:	0f 85 ee 00 00 00    	jne    80b837 <do_close_internal+0x108>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b749:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b74d:	0f 85 fb 00 00 00    	jne    80b84e <do_close_internal+0x11f>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b753:	8b 40 08             	mov    0x8(%eax),%eax
  80b756:	85 c0                	test   %eax,%eax
  80b758:	0f 84 07 01 00 00    	je     80b865 <do_close_internal+0x136>
  tcp_arg(conn->pcb.tcp, NULL);
  80b75e:	83 ec 08             	sub    $0x8,%esp
  80b761:	6a 00                	push   $0x0
  80b763:	50                   	push   %eax
  80b764:	e8 79 a0 ff ff       	call   8057e2 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b769:	8b 43 08             	mov    0x8(%ebx),%eax
  80b76c:	83 c4 10             	add    $0x10,%esp
  80b76f:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b773:	0f 84 03 01 00 00    	je     80b87c <do_close_internal+0x14d>
    tcp_recv(conn->pcb.tcp, NULL);
  80b779:	83 ec 08             	sub    $0x8,%esp
  80b77c:	6a 00                	push   $0x0
  80b77e:	50                   	push   %eax
  80b77f:	e8 6c a0 ff ff       	call   8057f0 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b784:	83 c4 08             	add    $0x8,%esp
  80b787:	6a 00                	push   $0x0
  80b789:	ff 73 08             	push   0x8(%ebx)
  80b78c:	e8 92 a0 ff ff       	call   805823 <tcp_accept>
    tcp_sent(conn->pcb.tcp, NULL);
  80b791:	83 c4 08             	add    $0x8,%esp
  80b794:	6a 00                	push   $0x0
  80b796:	ff 73 08             	push   0x8(%ebx)
  80b799:	e8 63 a0 ff ff       	call   805801 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b79e:	83 c4 0c             	add    $0xc,%esp
  80b7a1:	6a 04                	push   $0x4
  80b7a3:	6a 00                	push   $0x0
  80b7a5:	ff 73 08             	push   0x8(%ebx)
  80b7a8:	e8 84 a0 ff ff       	call   805831 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b7ad:	83 c4 08             	add    $0x8,%esp
  80b7b0:	6a 00                	push   $0x0
  80b7b2:	ff 73 08             	push   0x8(%ebx)
  80b7b5:	e8 58 a0 ff ff       	call   805812 <tcp_err>
  80b7ba:	83 c4 10             	add    $0x10,%esp
  err = tcp_close(conn->pcb.tcp);
  80b7bd:	83 ec 0c             	sub    $0xc,%esp
  80b7c0:	ff 73 08             	push   0x8(%ebx)
  80b7c3:	e8 0c a2 ff ff       	call   8059d4 <tcp_close>
  if (err == ERR_OK) {
  80b7c8:	83 c4 10             	add    $0x10,%esp
  80b7cb:	84 c0                	test   %al,%al
  80b7cd:	0f 85 bc 00 00 00    	jne    80b88f <do_close_internal+0x160>
    conn->state = NETCONN_NONE;
  80b7d3:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    conn->pcb.tcp = NULL;
  80b7da:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80b7e1:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b7e5:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7e8:	85 c0                	test   %eax,%eax
  80b7ea:	74 21                	je     80b80d <do_close_internal+0xde>
  80b7ec:	83 ec 04             	sub    $0x4,%esp
  80b7ef:	6a 00                	push   $0x0
  80b7f1:	6a 00                	push   $0x0
  80b7f3:	53                   	push   %ebx
  80b7f4:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80b7f6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7f9:	83 c4 10             	add    $0x10,%esp
  80b7fc:	85 c0                	test   %eax,%eax
  80b7fe:	74 0d                	je     80b80d <do_close_internal+0xde>
  80b800:	83 ec 04             	sub    $0x4,%esp
  80b803:	6a 00                	push   $0x0
  80b805:	6a 02                	push   $0x2
  80b807:	53                   	push   %ebx
  80b808:	ff d0                	call   *%eax
  80b80a:	83 c4 10             	add    $0x10,%esp
    sys_sem_signal(conn->op_completed);
  80b80d:	83 ec 0c             	sub    $0xc,%esp
  80b810:	ff 73 10             	push   0x10(%ebx)
  80b813:	e8 09 e8 ff ff       	call   80a021 <sys_sem_signal>
  80b818:	83 c4 10             	add    $0x10,%esp
}
  80b81b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b81e:	c9                   	leave  
  80b81f:	c3                   	ret    
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b820:	83 ec 04             	sub    $0x4,%esp
  80b823:	68 b4 2b 81 00       	push   $0x812bb4
  80b828:	68 53 02 00 00       	push   $0x253
  80b82d:	68 46 2d 81 00       	push   $0x812d46
  80b832:	e8 9f 2c 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b837:	83 ec 04             	sub    $0x4,%esp
  80b83a:	68 e1 2d 81 00       	push   $0x812de1
  80b83f:	68 54 02 00 00       	push   $0x254
  80b844:	68 46 2d 81 00       	push   $0x812d46
  80b849:	e8 88 2c 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b84e:	83 ec 04             	sub    $0x4,%esp
  80b851:	68 84 2c 81 00       	push   $0x812c84
  80b856:	68 55 02 00 00       	push   $0x255
  80b85b:	68 46 2d 81 00       	push   $0x812d46
  80b860:	e8 71 2c 00 00       	call   80e4d6 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b865:	83 ec 04             	sub    $0x4,%esp
  80b868:	68 ff 2d 81 00       	push   $0x812dff
  80b86d:	68 56 02 00 00       	push   $0x256
  80b872:	68 46 2d 81 00       	push   $0x812d46
  80b877:	e8 5a 2c 00 00       	call   80e4d6 <_panic>
    tcp_accept(conn->pcb.tcp, NULL);
  80b87c:	83 ec 08             	sub    $0x8,%esp
  80b87f:	6a 00                	push   $0x0
  80b881:	50                   	push   %eax
  80b882:	e8 9c 9f ff ff       	call   805823 <tcp_accept>
  80b887:	83 c4 10             	add    $0x10,%esp
  80b88a:	e9 2e ff ff ff       	jmp    80b7bd <do_close_internal+0x8e>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b88f:	8b 43 08             	mov    0x8(%ebx),%eax
  80b892:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b896:	74 44                	je     80b8dc <do_close_internal+0x1ad>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80b898:	83 ec 08             	sub    $0x8,%esp
  80b89b:	68 39 b9 80 00       	push   $0x80b939
  80b8a0:	50                   	push   %eax
  80b8a1:	e8 5b 9f ff ff       	call   805801 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80b8a6:	83 c4 0c             	add    $0xc,%esp
  80b8a9:	6a 04                	push   $0x4
  80b8ab:	68 f3 b8 80 00       	push   $0x80b8f3
  80b8b0:	ff 73 08             	push   0x8(%ebx)
  80b8b3:	e8 79 9f ff ff       	call   805831 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80b8b8:	83 c4 08             	add    $0x8,%esp
  80b8bb:	68 f5 b4 80 00       	push   $0x80b4f5
  80b8c0:	ff 73 08             	push   0x8(%ebx)
  80b8c3:	e8 4a 9f ff ff       	call   805812 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80b8c8:	83 c4 08             	add    $0x8,%esp
  80b8cb:	53                   	push   %ebx
  80b8cc:	ff 73 08             	push   0x8(%ebx)
  80b8cf:	e8 0e 9f ff ff       	call   8057e2 <tcp_arg>
  80b8d4:	83 c4 10             	add    $0x10,%esp
}
  80b8d7:	e9 3f ff ff ff       	jmp    80b81b <do_close_internal+0xec>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b8dc:	83 ec 04             	sub    $0x4,%esp
  80b8df:	68 a8 2c 81 00       	push   $0x812ca8
  80b8e4:	68 75 02 00 00       	push   $0x275
  80b8e9:	68 46 2d 81 00       	push   $0x812d46
  80b8ee:	e8 e3 2b 00 00       	call   80e4d6 <_panic>

0080b8f3 <poll_tcp>:
{
  80b8f3:	55                   	push   %ebp
  80b8f4:	89 e5                	mov    %esp,%ebp
  80b8f6:	83 ec 08             	sub    $0x8,%esp
  80b8f9:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b8fc:	85 c0                	test   %eax,%eax
  80b8fe:	74 14                	je     80b914 <poll_tcp+0x21>
  if (conn->state == NETCONN_WRITE) {
  80b900:	8b 50 04             	mov    0x4(%eax),%edx
  80b903:	83 fa 01             	cmp    $0x1,%edx
  80b906:	74 23                	je     80b92b <poll_tcp+0x38>
  } else if (conn->state == NETCONN_CLOSE) {
  80b908:	83 fa 04             	cmp    $0x4,%edx
  80b90b:	74 25                	je     80b932 <poll_tcp+0x3f>
}
  80b90d:	b8 00 00 00 00       	mov    $0x0,%eax
  80b912:	c9                   	leave  
  80b913:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b914:	83 ec 04             	sub    $0x4,%esp
  80b917:	68 99 2d 81 00       	push   $0x812d99
  80b91c:	68 eb 00 00 00       	push   $0xeb
  80b921:	68 46 2d 81 00       	push   $0x812d46
  80b926:	e8 ab 2b 00 00       	call   80e4d6 <_panic>
    do_writemore(conn);
  80b92b:	e8 97 fc ff ff       	call   80b5c7 <do_writemore>
  80b930:	eb db                	jmp    80b90d <poll_tcp+0x1a>
    do_close_internal(conn);
  80b932:	e8 f8 fd ff ff       	call   80b72f <do_close_internal>
  80b937:	eb d4                	jmp    80b90d <poll_tcp+0x1a>

0080b939 <sent_tcp>:
{
  80b939:	55                   	push   %ebp
  80b93a:	89 e5                	mov    %esp,%ebp
  80b93c:	56                   	push   %esi
  80b93d:	53                   	push   %ebx
  80b93e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b941:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b944:	85 db                	test   %ebx,%ebx
  80b946:	74 3e                	je     80b986 <sent_tcp+0x4d>
  if (conn->state == NETCONN_WRITE) {
  80b948:	8b 43 04             	mov    0x4(%ebx),%eax
  80b94b:	83 f8 01             	cmp    $0x1,%eax
  80b94e:	74 4d                	je     80b99d <sent_tcp+0x64>
  } else if (conn->state == NETCONN_CLOSE) {
  80b950:	83 f8 04             	cmp    $0x4,%eax
  80b953:	74 6e                	je     80b9c3 <sent_tcp+0x8a>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b955:	8b 43 08             	mov    0x8(%ebx),%eax
  80b958:	85 c0                	test   %eax,%eax
  80b95a:	74 1e                	je     80b97a <sent_tcp+0x41>
  80b95c:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b962:	76 16                	jbe    80b97a <sent_tcp+0x41>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80b964:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b967:	85 c0                	test   %eax,%eax
  80b969:	74 0f                	je     80b97a <sent_tcp+0x41>
  80b96b:	83 ec 04             	sub    $0x4,%esp
  80b96e:	0f b7 f6             	movzwl %si,%esi
  80b971:	56                   	push   %esi
  80b972:	6a 02                	push   $0x2
  80b974:	53                   	push   %ebx
  80b975:	ff d0                	call   *%eax
  80b977:	83 c4 10             	add    $0x10,%esp
}
  80b97a:	b8 00 00 00 00       	mov    $0x0,%eax
  80b97f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b982:	5b                   	pop    %ebx
  80b983:	5e                   	pop    %esi
  80b984:	5d                   	pop    %ebp
  80b985:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b986:	83 ec 04             	sub    $0x4,%esp
  80b989:	68 99 2d 81 00       	push   $0x812d99
  80b98e:	68 03 01 00 00       	push   $0x103
  80b993:	68 46 2d 81 00       	push   $0x812d46
  80b998:	e8 39 2b 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80b99d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b9a1:	74 09                	je     80b9ac <sent_tcp+0x73>
    do_writemore(conn);
  80b9a3:	89 d8                	mov    %ebx,%eax
  80b9a5:	e8 1d fc ff ff       	call   80b5c7 <do_writemore>
  80b9aa:	eb a9                	jmp    80b955 <sent_tcp+0x1c>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80b9ac:	83 ec 04             	sub    $0x4,%esp
  80b9af:	68 12 2e 81 00       	push   $0x812e12
  80b9b4:	68 06 01 00 00       	push   $0x106
  80b9b9:	68 46 2d 81 00       	push   $0x812d46
  80b9be:	e8 13 2b 00 00       	call   80e4d6 <_panic>
    do_close_internal(conn);
  80b9c3:	89 d8                	mov    %ebx,%eax
  80b9c5:	e8 65 fd ff ff       	call   80b72f <do_close_internal>
  80b9ca:	eb 89                	jmp    80b955 <sent_tcp+0x1c>

0080b9cc <do_newconn>:
{
  80b9cc:	55                   	push   %ebp
  80b9cd:	89 e5                	mov    %esp,%ebp
  80b9cf:	56                   	push   %esi
  80b9d0:	53                   	push   %ebx
  80b9d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80b9d4:	8b 03                	mov    (%ebx),%eax
  80b9d6:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b9da:	74 17                	je     80b9f3 <do_newconn+0x27>
   TCPIP_APIMSG_ACK(msg);
  80b9dc:	83 ec 0c             	sub    $0xc,%esp
  80b9df:	8b 03                	mov    (%ebx),%eax
  80b9e1:	ff 70 10             	push   0x10(%eax)
  80b9e4:	e8 38 e6 ff ff       	call   80a021 <sys_sem_signal>
}
  80b9e9:	83 c4 10             	add    $0x10,%esp
  80b9ec:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b9ef:	5b                   	pop    %ebx
  80b9f0:	5e                   	pop    %esi
  80b9f1:	5d                   	pop    %ebp
  80b9f2:	c3                   	ret    
   msg->conn->err = ERR_OK;
  80b9f3:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80b9f7:	8b 33                	mov    (%ebx),%esi
  80b9f9:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80b9fd:	75 20                	jne    80ba1f <do_newconn+0x53>
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80b9ff:	8b 06                	mov    (%esi),%eax
  80ba01:	25 f0 00 00 00       	and    $0xf0,%eax
  80ba06:	83 f8 20             	cmp    $0x20,%eax
  80ba09:	74 67                	je     80ba72 <do_newconn+0xa6>
  80ba0b:	83 f8 40             	cmp    $0x40,%eax
  80ba0e:	74 26                	je     80ba36 <do_newconn+0x6a>
  80ba10:	83 f8 10             	cmp    $0x10,%eax
  80ba13:	0f 84 99 00 00 00    	je     80bab2 <do_newconn+0xe6>
     msg->conn->err = ERR_VAL;
  80ba19:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
     break;
  80ba1d:	eb bd                	jmp    80b9dc <do_newconn+0x10>
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80ba1f:	83 ec 04             	sub    $0x4,%esp
  80ba22:	68 cc 2c 81 00       	push   $0x812ccc
  80ba27:	68 8a 01 00 00       	push   $0x18a
  80ba2c:	68 46 2d 81 00       	push   $0x812d46
  80ba31:	e8 a0 2a 00 00       	call   80e4d6 <_panic>
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80ba36:	83 ec 0c             	sub    $0xc,%esp
  80ba39:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80ba3d:	50                   	push   %eax
  80ba3e:	e8 07 25 00 00       	call   80df4a <raw_new>
  80ba43:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80ba46:	8b 03                	mov    (%ebx),%eax
  80ba48:	8b 50 08             	mov    0x8(%eax),%edx
  80ba4b:	83 c4 10             	add    $0x10,%esp
  80ba4e:	85 d2                	test   %edx,%edx
  80ba50:	74 17                	je     80ba69 <do_newconn+0x9d>
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80ba52:	83 ec 04             	sub    $0x4,%esp
  80ba55:	50                   	push   %eax
  80ba56:	68 6e b3 80 00       	push   $0x80b36e
  80ba5b:	52                   	push   %edx
  80ba5c:	e8 6d 23 00 00       	call   80ddce <raw_recv>
     break;
  80ba61:	83 c4 10             	add    $0x10,%esp
  80ba64:	e9 73 ff ff ff       	jmp    80b9dc <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80ba69:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80ba6d:	e9 6a ff ff ff       	jmp    80b9dc <do_newconn+0x10>
     msg->conn->pcb.udp = udp_new();
  80ba72:	e8 0e d5 ff ff       	call   808f85 <udp_new>
  80ba77:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80ba7a:	8b 03                	mov    (%ebx),%eax
  80ba7c:	8b 50 08             	mov    0x8(%eax),%edx
  80ba7f:	85 d2                	test   %edx,%edx
  80ba81:	74 20                	je     80baa3 <do_newconn+0xd7>
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80ba83:	83 38 22             	cmpl   $0x22,(%eax)
  80ba86:	74 24                	je     80baac <do_newconn+0xe0>
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80ba88:	8b 03                	mov    (%ebx),%eax
  80ba8a:	83 ec 04             	sub    $0x4,%esp
  80ba8d:	50                   	push   %eax
  80ba8e:	68 64 b2 80 00       	push   $0x80b264
  80ba93:	ff 70 08             	push   0x8(%eax)
  80ba96:	e8 92 d4 ff ff       	call   808f2d <udp_recv>
     break;
  80ba9b:	83 c4 10             	add    $0x10,%esp
  80ba9e:	e9 39 ff ff ff       	jmp    80b9dc <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80baa3:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80baa7:	e9 30 ff ff ff       	jmp    80b9dc <do_newconn+0x10>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80baac:	c6 42 10 01          	movb   $0x1,0x10(%edx)
  80bab0:	eb d6                	jmp    80ba88 <do_newconn+0xbc>
     msg->conn->pcb.tcp = tcp_new();
  80bab2:	e8 cf a7 ff ff       	call   806286 <tcp_new>
  80bab7:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80baba:	8b 03                	mov    (%ebx),%eax
  80babc:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bac0:	74 0a                	je     80bacc <do_newconn+0x100>
     setup_tcp(msg->conn);
  80bac2:	e8 8f f9 ff ff       	call   80b456 <setup_tcp>
     break;
  80bac7:	e9 10 ff ff ff       	jmp    80b9dc <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bacc:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80bad0:	e9 07 ff ff ff       	jmp    80b9dc <do_newconn+0x10>

0080bad5 <netconn_alloc>:
{
  80bad5:	55                   	push   %ebp
  80bad6:	89 e5                	mov    %esp,%ebp
  80bad8:	53                   	push   %ebx
  80bad9:	83 ec 10             	sub    $0x10,%esp
  conn = memp_malloc(MEMP_NETCONN);
  80badc:	6a 07                	push   $0x7
  80bade:	e8 c2 89 ff ff       	call   8044a5 <memp_malloc>
  80bae3:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80bae5:	83 c4 10             	add    $0x10,%esp
  80bae8:	85 c0                	test   %eax,%eax
  80baea:	74 5b                	je     80bb47 <netconn_alloc+0x72>
  conn->err = ERR_OK;
  80baec:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80baf0:	8b 45 08             	mov    0x8(%ebp),%eax
  80baf3:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80baf5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80bafc:	83 ec 0c             	sub    $0xc,%esp
  80baff:	6a 00                	push   $0x0
  80bb01:	e8 5e e2 ff ff       	call   809d64 <sys_sem_new>
  80bb06:	89 43 10             	mov    %eax,0x10(%ebx)
  80bb09:	83 c4 10             	add    $0x10,%esp
  80bb0c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bb0f:	74 3d                	je     80bb4e <netconn_alloc+0x79>
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80bb11:	83 ec 0c             	sub    $0xc,%esp
  80bb14:	6a 00                	push   $0x0
  80bb16:	e8 f2 e3 ff ff       	call   809f0d <sys_mbox_new>
  80bb1b:	89 43 14             	mov    %eax,0x14(%ebx)
  80bb1e:	83 c4 10             	add    $0x10,%esp
  80bb21:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bb24:	74 3d                	je     80bb63 <netconn_alloc+0x8e>
  conn->acceptmbox   = SYS_MBOX_NULL;
  80bb26:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80bb2d:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  conn->socket       = -1;
  80bb34:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80bb3b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bb3e:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80bb41:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
}
  80bb47:	89 d8                	mov    %ebx,%eax
  80bb49:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bb4c:	c9                   	leave  
  80bb4d:	c3                   	ret    
    memp_free(MEMP_NETCONN, conn);
  80bb4e:	83 ec 08             	sub    $0x8,%esp
  80bb51:	53                   	push   %ebx
  80bb52:	6a 07                	push   $0x7
  80bb54:	e8 a2 89 ff ff       	call   8044fb <memp_free>
    return NULL;
  80bb59:	83 c4 10             	add    $0x10,%esp
  80bb5c:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bb61:	eb e4                	jmp    80bb47 <netconn_alloc+0x72>
    sys_sem_free(conn->op_completed);
  80bb63:	83 ec 0c             	sub    $0xc,%esp
  80bb66:	ff 73 10             	push   0x10(%ebx)
  80bb69:	e8 77 e2 ff ff       	call   809de5 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80bb6e:	83 c4 08             	add    $0x8,%esp
  80bb71:	53                   	push   %ebx
  80bb72:	6a 07                	push   $0x7
  80bb74:	e8 82 89 ff ff       	call   8044fb <memp_free>
    return NULL;
  80bb79:	83 c4 10             	add    $0x10,%esp
  80bb7c:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bb81:	eb c4                	jmp    80bb47 <netconn_alloc+0x72>

0080bb83 <netconn_free>:
{
  80bb83:	55                   	push   %ebp
  80bb84:	89 e5                	mov    %esp,%ebp
  80bb86:	56                   	push   %esi
  80bb87:	53                   	push   %ebx
  80bb88:	83 ec 10             	sub    $0x10,%esp
  80bb8b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bb8e:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bb92:	75 0b                	jne    80bb9f <netconn_free+0x1c>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb94:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bb97:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bb9b:	75 27                	jne    80bbc4 <netconn_free+0x41>
  80bb9d:	eb 68                	jmp    80bc07 <netconn_free+0x84>
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bb9f:	83 ec 04             	sub    $0x4,%esp
  80bba2:	68 ec 2c 81 00       	push   $0x812cec
  80bba7:	68 26 02 00 00       	push   $0x226
  80bbac:	68 46 2d 81 00       	push   $0x812d46
  80bbb1:	e8 20 29 00 00       	call   80e4d6 <_panic>
        netbuf_delete((struct netbuf *)mem);
  80bbb6:	83 ec 0c             	sub    $0xc,%esp
  80bbb9:	ff 75 f4             	push   -0xc(%ebp)
  80bbbc:	e8 03 69 ff ff       	call   8024c4 <netbuf_delete>
  80bbc1:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bbc4:	83 ec 08             	sub    $0x8,%esp
  80bbc7:	56                   	push   %esi
  80bbc8:	ff 73 14             	push   0x14(%ebx)
  80bbcb:	e8 e0 e7 ff ff       	call   80a3b0 <sys_arch_mbox_tryfetch>
  80bbd0:	83 c4 10             	add    $0x10,%esp
  80bbd3:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bbd6:	74 1a                	je     80bbf2 <netconn_free+0x6f>
      if (conn->type == NETCONN_TCP) {
  80bbd8:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bbdb:	75 d9                	jne    80bbb6 <netconn_free+0x33>
        if(mem != NULL) {
  80bbdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80bbe0:	85 c0                	test   %eax,%eax
  80bbe2:	74 e0                	je     80bbc4 <netconn_free+0x41>
          pbuf_free((struct pbuf *)mem);
  80bbe4:	83 ec 0c             	sub    $0xc,%esp
  80bbe7:	50                   	push   %eax
  80bbe8:	e8 5f 8c ff ff       	call   80484c <pbuf_free>
  80bbed:	83 c4 10             	add    $0x10,%esp
  80bbf0:	eb d2                	jmp    80bbc4 <netconn_free+0x41>
    sys_mbox_free(conn->recvmbox);
  80bbf2:	83 ec 0c             	sub    $0xc,%esp
  80bbf5:	ff 73 14             	push   0x14(%ebx)
  80bbf8:	e8 71 e2 ff ff       	call   809e6e <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bbfd:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80bc04:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bc07:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bc0a:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bc0e:	75 10                	jne    80bc20 <netconn_free+0x9d>
  80bc10:	eb 37                	jmp    80bc49 <netconn_free+0xc6>
      netconn_delete((struct netconn *)mem);
  80bc12:	83 ec 0c             	sub    $0xc,%esp
  80bc15:	ff 75 f4             	push   -0xc(%ebp)
  80bc18:	e8 38 f0 ff ff       	call   80ac55 <netconn_delete>
  80bc1d:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bc20:	83 ec 08             	sub    $0x8,%esp
  80bc23:	56                   	push   %esi
  80bc24:	ff 73 18             	push   0x18(%ebx)
  80bc27:	e8 84 e7 ff ff       	call   80a3b0 <sys_arch_mbox_tryfetch>
  80bc2c:	83 c4 10             	add    $0x10,%esp
  80bc2f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bc32:	75 de                	jne    80bc12 <netconn_free+0x8f>
    sys_mbox_free(conn->acceptmbox);
  80bc34:	83 ec 0c             	sub    $0xc,%esp
  80bc37:	ff 73 18             	push   0x18(%ebx)
  80bc3a:	e8 2f e2 ff ff       	call   809e6e <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80bc3f:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80bc46:	83 c4 10             	add    $0x10,%esp
  sys_sem_free(conn->op_completed);
  80bc49:	83 ec 0c             	sub    $0xc,%esp
  80bc4c:	ff 73 10             	push   0x10(%ebx)
  80bc4f:	e8 91 e1 ff ff       	call   809de5 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80bc54:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
  memp_free(MEMP_NETCONN, conn);
  80bc5b:	83 c4 08             	add    $0x8,%esp
  80bc5e:	53                   	push   %ebx
  80bc5f:	6a 07                	push   $0x7
  80bc61:	e8 95 88 ff ff       	call   8044fb <memp_free>
}
  80bc66:	83 c4 10             	add    $0x10,%esp
  80bc69:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bc6c:	5b                   	pop    %ebx
  80bc6d:	5e                   	pop    %esi
  80bc6e:	5d                   	pop    %ebp
  80bc6f:	c3                   	ret    

0080bc70 <accept_function>:
{
  80bc70:	55                   	push   %ebp
  80bc71:	89 e5                	mov    %esp,%ebp
  80bc73:	57                   	push   %edi
  80bc74:	56                   	push   %esi
  80bc75:	53                   	push   %ebx
  80bc76:	83 ec 0c             	sub    $0xc,%esp
  80bc79:	8b 75 08             	mov    0x8(%ebp),%esi
  80bc7c:	8b 7d 10             	mov    0x10(%ebp),%edi
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bc7f:	83 7e 18 ff          	cmpl   $0xffffffff,0x18(%esi)
  80bc83:	74 57                	je     80bcdc <accept_function+0x6c>
  newconn = netconn_alloc(conn->type, conn->callback);
  80bc85:	83 ec 08             	sub    $0x8,%esp
  80bc88:	ff 76 2c             	push   0x2c(%esi)
  80bc8b:	ff 36                	push   (%esi)
  80bc8d:	e8 43 fe ff ff       	call   80bad5 <netconn_alloc>
  80bc92:	89 c3                	mov    %eax,%ebx
  if (newconn == NULL) {
  80bc94:	83 c4 10             	add    $0x10,%esp
  80bc97:	85 c0                	test   %eax,%eax
  80bc99:	74 72                	je     80bd0d <accept_function+0x9d>
  newconn->pcb.tcp = newpcb;
  80bc9b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bc9e:	89 43 08             	mov    %eax,0x8(%ebx)
  setup_tcp(newconn);
  80bca1:	89 d8                	mov    %ebx,%eax
  80bca3:	e8 ae f7 ff ff       	call   80b456 <setup_tcp>
  newconn->err = err;
  80bca8:	89 f8                	mov    %edi,%eax
  80bcaa:	88 43 0c             	mov    %al,0xc(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bcad:	8b 46 2c             	mov    0x2c(%esi),%eax
  80bcb0:	85 c0                	test   %eax,%eax
  80bcb2:	74 0d                	je     80bcc1 <accept_function+0x51>
  80bcb4:	83 ec 04             	sub    $0x4,%esp
  80bcb7:	6a 00                	push   $0x0
  80bcb9:	6a 00                	push   $0x0
  80bcbb:	56                   	push   %esi
  80bcbc:	ff d0                	call   *%eax
  80bcbe:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bcc1:	83 ec 08             	sub    $0x8,%esp
  80bcc4:	53                   	push   %ebx
  80bcc5:	ff 76 18             	push   0x18(%esi)
  80bcc8:	e8 fe e4 ff ff       	call   80a1cb <sys_mbox_trypost>
  80bccd:	83 c4 10             	add    $0x10,%esp
  80bcd0:	84 c0                	test   %al,%al
  80bcd2:	75 1f                	jne    80bcf3 <accept_function+0x83>
}
  80bcd4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bcd7:	5b                   	pop    %ebx
  80bcd8:	5e                   	pop    %esi
  80bcd9:	5f                   	pop    %edi
  80bcda:	5d                   	pop    %ebp
  80bcdb:	c3                   	ret    
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bcdc:	83 ec 04             	sub    $0x4,%esp
  80bcdf:	68 1c 2d 81 00       	push   $0x812d1c
  80bce4:	68 64 01 00 00       	push   $0x164
  80bce9:	68 46 2d 81 00       	push   $0x812d46
  80bcee:	e8 e3 27 00 00       	call   80e4d6 <_panic>
    newconn->pcb.tcp = NULL;
  80bcf3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    netconn_free(newconn);
  80bcfa:	83 ec 0c             	sub    $0xc,%esp
  80bcfd:	53                   	push   %ebx
  80bcfe:	e8 80 fe ff ff       	call   80bb83 <netconn_free>
    return ERR_MEM;
  80bd03:	83 c4 10             	add    $0x10,%esp
  80bd06:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bd0b:	eb c7                	jmp    80bcd4 <accept_function+0x64>
    return ERR_MEM;
  80bd0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bd12:	eb c0                	jmp    80bcd4 <accept_function+0x64>

0080bd14 <do_delconn>:
{
  80bd14:	55                   	push   %ebp
  80bd15:	89 e5                	mov    %esp,%ebp
  80bd17:	53                   	push   %ebx
  80bd18:	83 ec 04             	sub    $0x4,%esp
  80bd1b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80bd1e:	8b 13                	mov    (%ebx),%edx
  80bd20:	8b 4a 08             	mov    0x8(%edx),%ecx
  80bd23:	85 c9                	test   %ecx,%ecx
  80bd25:	74 16                	je     80bd3d <do_delconn+0x29>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bd27:	8b 02                	mov    (%edx),%eax
  80bd29:	25 f0 00 00 00       	and    $0xf0,%eax
  80bd2e:	83 f8 20             	cmp    $0x20,%eax
  80bd31:	74 53                	je     80bd86 <do_delconn+0x72>
  80bd33:	83 f8 40             	cmp    $0x40,%eax
  80bd36:	74 40                	je     80bd78 <do_delconn+0x64>
  80bd38:	83 f8 10             	cmp    $0x10,%eax
  80bd3b:	74 62                	je     80bd9f <do_delconn+0x8b>
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80bd3d:	8b 13                	mov    (%ebx),%edx
  80bd3f:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bd42:	85 c0                	test   %eax,%eax
  80bd44:	74 23                	je     80bd69 <do_delconn+0x55>
  80bd46:	83 ec 04             	sub    $0x4,%esp
  80bd49:	6a 00                	push   $0x0
  80bd4b:	6a 00                	push   $0x0
  80bd4d:	52                   	push   %edx
  80bd4e:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80bd50:	8b 13                	mov    (%ebx),%edx
  80bd52:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bd55:	83 c4 10             	add    $0x10,%esp
  80bd58:	85 c0                	test   %eax,%eax
  80bd5a:	74 0d                	je     80bd69 <do_delconn+0x55>
  80bd5c:	83 ec 04             	sub    $0x4,%esp
  80bd5f:	6a 00                	push   $0x0
  80bd61:	6a 02                	push   $0x2
  80bd63:	52                   	push   %edx
  80bd64:	ff d0                	call   *%eax
  80bd66:	83 c4 10             	add    $0x10,%esp
  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80bd69:	8b 03                	mov    (%ebx),%eax
  80bd6b:	8b 40 10             	mov    0x10(%eax),%eax
  80bd6e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bd71:	75 3c                	jne    80bdaf <do_delconn+0x9b>
}
  80bd73:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bd76:	c9                   	leave  
  80bd77:	c3                   	ret    
      raw_remove(msg->conn->pcb.raw);
  80bd78:	83 ec 0c             	sub    $0xc,%esp
  80bd7b:	51                   	push   %ecx
  80bd7c:	e8 85 21 00 00       	call   80df06 <raw_remove>
      break;
  80bd81:	83 c4 10             	add    $0x10,%esp
  80bd84:	eb b7                	jmp    80bd3d <do_delconn+0x29>
      msg->conn->pcb.udp->recv_arg = NULL;
  80bd86:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80bd8d:	83 ec 0c             	sub    $0xc,%esp
  80bd90:	8b 03                	mov    (%ebx),%eax
  80bd92:	ff 70 08             	push   0x8(%eax)
  80bd95:	e8 a7 d1 ff ff       	call   808f41 <udp_remove>
      break;
  80bd9a:	83 c4 10             	add    $0x10,%esp
  80bd9d:	eb 9e                	jmp    80bd3d <do_delconn+0x29>
      msg->conn->state = NETCONN_CLOSE;
  80bd9f:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80bda6:	8b 03                	mov    (%ebx),%eax
  80bda8:	e8 82 f9 ff ff       	call   80b72f <do_close_internal>
      return;
  80bdad:	eb c4                	jmp    80bd73 <do_delconn+0x5f>
    sys_sem_signal(msg->conn->op_completed);
  80bdaf:	83 ec 0c             	sub    $0xc,%esp
  80bdb2:	50                   	push   %eax
  80bdb3:	e8 69 e2 ff ff       	call   80a021 <sys_sem_signal>
  80bdb8:	83 c4 10             	add    $0x10,%esp
  80bdbb:	eb b6                	jmp    80bd73 <do_delconn+0x5f>

0080bdbd <do_bind>:
{
  80bdbd:	55                   	push   %ebp
  80bdbe:	89 e5                	mov    %esp,%ebp
  80bdc0:	56                   	push   %esi
  80bdc1:	53                   	push   %ebx
  80bdc2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bdc5:	8b 33                	mov    (%ebx),%esi
  80bdc7:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80bdcb:	7c 1d                	jl     80bdea <do_bind+0x2d>
    if (msg->conn->pcb.tcp != NULL) {
  80bdcd:	8b 56 08             	mov    0x8(%esi),%edx
  80bdd0:	85 d2                	test   %edx,%edx
  80bdd2:	74 73                	je     80be47 <do_bind+0x8a>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bdd4:	8b 06                	mov    (%esi),%eax
  80bdd6:	25 f0 00 00 00       	and    $0xf0,%eax
  80bddb:	83 f8 20             	cmp    $0x20,%eax
  80bdde:	74 35                	je     80be15 <do_bind+0x58>
  80bde0:	83 f8 40             	cmp    $0x40,%eax
  80bde3:	74 1c                	je     80be01 <do_bind+0x44>
  80bde5:	83 f8 10             	cmp    $0x10,%eax
  80bde8:	74 44                	je     80be2e <do_bind+0x71>
  TCPIP_APIMSG_ACK(msg);
  80bdea:	83 ec 0c             	sub    $0xc,%esp
  80bded:	8b 03                	mov    (%ebx),%eax
  80bdef:	ff 70 10             	push   0x10(%eax)
  80bdf2:	e8 2a e2 ff ff       	call   80a021 <sys_sem_signal>
}
  80bdf7:	83 c4 10             	add    $0x10,%esp
  80bdfa:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bdfd:	5b                   	pop    %ebx
  80bdfe:	5e                   	pop    %esi
  80bdff:	5d                   	pop    %ebp
  80be00:	c3                   	ret    
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80be01:	83 ec 08             	sub    $0x8,%esp
  80be04:	ff 73 04             	push   0x4(%ebx)
  80be07:	52                   	push   %edx
  80be08:	e8 86 1f 00 00       	call   80dd93 <raw_bind>
  80be0d:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80be10:	83 c4 10             	add    $0x10,%esp
  80be13:	eb d5                	jmp    80bdea <do_bind+0x2d>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80be15:	83 ec 04             	sub    $0x4,%esp
  80be18:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80be1c:	50                   	push   %eax
  80be1d:	ff 73 04             	push   0x4(%ebx)
  80be20:	52                   	push   %edx
  80be21:	e8 cb cd ff ff       	call   808bf1 <udp_bind>
  80be26:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80be29:	83 c4 10             	add    $0x10,%esp
  80be2c:	eb bc                	jmp    80bdea <do_bind+0x2d>
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80be2e:	83 ec 04             	sub    $0x4,%esp
  80be31:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80be35:	50                   	push   %eax
  80be36:	ff 73 04             	push   0x4(%ebx)
  80be39:	52                   	push   %edx
  80be3a:	e8 9c 95 ff ff       	call   8053db <tcp_bind>
  80be3f:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80be42:	83 c4 10             	add    $0x10,%esp
  80be45:	eb a3                	jmp    80bdea <do_bind+0x2d>
      msg->conn->err = ERR_VAL;
  80be47:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80be4b:	eb 9d                	jmp    80bdea <do_bind+0x2d>

0080be4d <do_connect>:
{
  80be4d:	55                   	push   %ebp
  80be4e:	89 e5                	mov    %esp,%ebp
  80be50:	56                   	push   %esi
  80be51:	53                   	push   %ebx
  80be52:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80be55:	8b 33                	mov    (%ebx),%esi
  80be57:	8b 56 08             	mov    0x8(%esi),%edx
  80be5a:	85 d2                	test   %edx,%edx
  80be5c:	74 1d                	je     80be7b <do_connect+0x2e>
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80be5e:	8b 06                	mov    (%esi),%eax
  80be60:	25 f0 00 00 00       	and    $0xf0,%eax
  80be65:	83 f8 20             	cmp    $0x20,%eax
  80be68:	74 42                	je     80beac <do_connect+0x5f>
  80be6a:	83 f8 40             	cmp    $0x40,%eax
  80be6d:	74 1c                	je     80be8b <do_connect+0x3e>
  80be6f:	83 f8 10             	cmp    $0x10,%eax
  80be72:	74 5e                	je     80bed2 <do_connect+0x85>
}
  80be74:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80be77:	5b                   	pop    %ebx
  80be78:	5e                   	pop    %esi
  80be79:	5d                   	pop    %ebp
  80be7a:	c3                   	ret    
    sys_sem_signal(msg->conn->op_completed);
  80be7b:	83 ec 0c             	sub    $0xc,%esp
  80be7e:	ff 76 10             	push   0x10(%esi)
  80be81:	e8 9b e1 ff ff       	call   80a021 <sys_sem_signal>
    return;
  80be86:	83 c4 10             	add    $0x10,%esp
  80be89:	eb e9                	jmp    80be74 <do_connect+0x27>
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80be8b:	83 ec 08             	sub    $0x8,%esp
  80be8e:	ff 73 04             	push   0x4(%ebx)
  80be91:	52                   	push   %edx
  80be92:	e8 19 1f 00 00       	call   80ddb0 <raw_connect>
  80be97:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80be9a:	83 c4 04             	add    $0x4,%esp
  80be9d:	8b 03                	mov    (%ebx),%eax
  80be9f:	ff 70 10             	push   0x10(%eax)
  80bea2:	e8 7a e1 ff ff       	call   80a021 <sys_sem_signal>
    break;
  80bea7:	83 c4 10             	add    $0x10,%esp
  80beaa:	eb c8                	jmp    80be74 <do_connect+0x27>
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80beac:	83 ec 04             	sub    $0x4,%esp
  80beaf:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80beb3:	50                   	push   %eax
  80beb4:	ff 73 04             	push   0x4(%ebx)
  80beb7:	52                   	push   %edx
  80beb8:	e8 e4 cf ff ff       	call   808ea1 <udp_connect>
  80bebd:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bec0:	83 c4 04             	add    $0x4,%esp
  80bec3:	8b 03                	mov    (%ebx),%eax
  80bec5:	ff 70 10             	push   0x10(%eax)
  80bec8:	e8 54 e1 ff ff       	call   80a021 <sys_sem_signal>
    break;
  80becd:	83 c4 10             	add    $0x10,%esp
  80bed0:	eb a2                	jmp    80be74 <do_connect+0x27>
    msg->conn->state = NETCONN_CONNECT;
  80bed2:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80bed9:	8b 03                	mov    (%ebx),%eax
  80bedb:	e8 76 f5 ff ff       	call   80b456 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80bee0:	8b 33                	mov    (%ebx),%esi
  80bee2:	68 a9 b4 80 00       	push   $0x80b4a9
  80bee7:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80beeb:	50                   	push   %eax
  80beec:	ff 73 04             	push   0x4(%ebx)
  80beef:	ff 76 08             	push   0x8(%esi)
  80bef2:	e8 d6 a3 ff ff       	call   8062cd <tcp_connect>
  80bef7:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80befa:	83 c4 10             	add    $0x10,%esp
  80befd:	e9 72 ff ff ff       	jmp    80be74 <do_connect+0x27>

0080bf02 <do_disconnect>:
{
  80bf02:	55                   	push   %ebp
  80bf03:	89 e5                	mov    %esp,%ebp
  80bf05:	53                   	push   %ebx
  80bf06:	83 ec 04             	sub    $0x4,%esp
  80bf09:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80bf0c:	8b 13                	mov    (%ebx),%edx
  80bf0e:	8b 02                	mov    (%edx),%eax
  80bf10:	25 f0 00 00 00       	and    $0xf0,%eax
  80bf15:	83 f8 20             	cmp    $0x20,%eax
  80bf18:	74 15                	je     80bf2f <do_disconnect+0x2d>
  TCPIP_APIMSG_ACK(msg);
  80bf1a:	83 ec 0c             	sub    $0xc,%esp
  80bf1d:	8b 03                	mov    (%ebx),%eax
  80bf1f:	ff 70 10             	push   0x10(%eax)
  80bf22:	e8 fa e0 ff ff       	call   80a021 <sys_sem_signal>
}
  80bf27:	83 c4 10             	add    $0x10,%esp
  80bf2a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bf2d:	c9                   	leave  
  80bf2e:	c3                   	ret    
    udp_disconnect(msg->conn->pcb.udp);
  80bf2f:	83 ec 0c             	sub    $0xc,%esp
  80bf32:	ff 72 08             	push   0x8(%edx)
  80bf35:	e8 d8 cf ff ff       	call   808f12 <udp_disconnect>
  80bf3a:	83 c4 10             	add    $0x10,%esp
  80bf3d:	eb db                	jmp    80bf1a <do_disconnect+0x18>

0080bf3f <do_listen>:
{
  80bf3f:	55                   	push   %ebp
  80bf40:	89 e5                	mov    %esp,%ebp
  80bf42:	57                   	push   %edi
  80bf43:	56                   	push   %esi
  80bf44:	53                   	push   %ebx
  80bf45:	83 ec 0c             	sub    $0xc,%esp
  80bf48:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bf4b:	8b 03                	mov    (%ebx),%eax
  80bf4d:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80bf51:	7c 0c                	jl     80bf5f <do_listen+0x20>
    if (msg->conn->pcb.tcp != NULL) {
  80bf53:	8b 50 08             	mov    0x8(%eax),%edx
  80bf56:	85 d2                	test   %edx,%edx
  80bf58:	74 05                	je     80bf5f <do_listen+0x20>
      if (msg->conn->type == NETCONN_TCP) {
  80bf5a:	83 38 10             	cmpl   $0x10,(%eax)
  80bf5d:	74 18                	je     80bf77 <do_listen+0x38>
  TCPIP_APIMSG_ACK(msg);
  80bf5f:	83 ec 0c             	sub    $0xc,%esp
  80bf62:	8b 03                	mov    (%ebx),%eax
  80bf64:	ff 70 10             	push   0x10(%eax)
  80bf67:	e8 b5 e0 ff ff       	call   80a021 <sys_sem_signal>
}
  80bf6c:	83 c4 10             	add    $0x10,%esp
  80bf6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bf72:	5b                   	pop    %ebx
  80bf73:	5e                   	pop    %esi
  80bf74:	5f                   	pop    %edi
  80bf75:	5d                   	pop    %ebp
  80bf76:	c3                   	ret    
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80bf77:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80bf7b:	74 06                	je     80bf83 <do_listen+0x44>
          msg->conn->err = ERR_CONN;
  80bf7d:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
  80bf81:	eb dc                	jmp    80bf5f <do_listen+0x20>
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80bf83:	83 ec 08             	sub    $0x8,%esp
  80bf86:	68 ff 00 00 00       	push   $0xff
  80bf8b:	52                   	push   %edx
  80bf8c:	e8 93 95 ff ff       	call   805524 <tcp_listen_with_backlog>
  80bf91:	89 c6                	mov    %eax,%esi
          if (lpcb == NULL) {
  80bf93:	83 c4 10             	add    $0x10,%esp
  80bf96:	85 c0                	test   %eax,%eax
  80bf98:	74 4e                	je     80bfe8 <do_listen+0xa9>
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80bf9a:	8b 03                	mov    (%ebx),%eax
  80bf9c:	8b 40 14             	mov    0x14(%eax),%eax
  80bf9f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bfa2:	75 4f                	jne    80bff3 <do_listen+0xb4>
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80bfa4:	8b 3b                	mov    (%ebx),%edi
  80bfa6:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80bfaa:	74 5e                	je     80c00a <do_listen+0xcb>
            if (msg->conn->err == ERR_OK) {
  80bfac:	8b 03                	mov    (%ebx),%eax
  80bfae:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80bfb2:	75 ab                	jne    80bf5f <do_listen+0x20>
              msg->conn->state = NETCONN_LISTEN;
  80bfb4:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80bfbb:	8b 03                	mov    (%ebx),%eax
  80bfbd:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80bfc0:	8b 03                	mov    (%ebx),%eax
  80bfc2:	83 ec 08             	sub    $0x8,%esp
  80bfc5:	50                   	push   %eax
  80bfc6:	ff 70 08             	push   0x8(%eax)
  80bfc9:	e8 14 98 ff ff       	call   8057e2 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80bfce:	83 c4 08             	add    $0x8,%esp
  80bfd1:	68 70 bc 80 00       	push   $0x80bc70
  80bfd6:	8b 03                	mov    (%ebx),%eax
  80bfd8:	ff 70 08             	push   0x8(%eax)
  80bfdb:	e8 43 98 ff ff       	call   805823 <tcp_accept>
  80bfe0:	83 c4 10             	add    $0x10,%esp
  80bfe3:	e9 77 ff ff ff       	jmp    80bf5f <do_listen+0x20>
            msg->conn->err = ERR_MEM;
  80bfe8:	8b 03                	mov    (%ebx),%eax
  80bfea:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bfee:	e9 6c ff ff ff       	jmp    80bf5f <do_listen+0x20>
              sys_mbox_free(msg->conn->recvmbox);
  80bff3:	83 ec 0c             	sub    $0xc,%esp
  80bff6:	50                   	push   %eax
  80bff7:	e8 72 de ff ff       	call   809e6e <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80bffc:	8b 03                	mov    (%ebx),%eax
  80bffe:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80c005:	83 c4 10             	add    $0x10,%esp
  80c008:	eb 9a                	jmp    80bfa4 <do_listen+0x65>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c00a:	83 ec 0c             	sub    $0xc,%esp
  80c00d:	6a 00                	push   $0x0
  80c00f:	e8 f9 de ff ff       	call   809f0d <sys_mbox_new>
  80c014:	89 47 18             	mov    %eax,0x18(%edi)
  80c017:	83 c4 10             	add    $0x10,%esp
  80c01a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c01d:	75 8d                	jne    80bfac <do_listen+0x6d>
                msg->conn->err = ERR_MEM;
  80c01f:	8b 03                	mov    (%ebx),%eax
  80c021:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c025:	eb 85                	jmp    80bfac <do_listen+0x6d>

0080c027 <do_send>:
{
  80c027:	55                   	push   %ebp
  80c028:	89 e5                	mov    %esp,%ebp
  80c02a:	57                   	push   %edi
  80c02b:	56                   	push   %esi
  80c02c:	53                   	push   %ebx
  80c02d:	83 ec 0c             	sub    $0xc,%esp
  80c030:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c033:	8b 33                	mov    (%ebx),%esi
  80c035:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c039:	7c 34                	jl     80c06f <do_send+0x48>
    if (msg->conn->pcb.tcp != NULL) {
  80c03b:	8b 56 08             	mov    0x8(%esi),%edx
  80c03e:	85 d2                	test   %edx,%edx
  80c040:	74 2d                	je     80c06f <do_send+0x48>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c042:	8b 06                	mov    (%esi),%eax
  80c044:	25 f0 00 00 00       	and    $0xf0,%eax
  80c049:	83 f8 20             	cmp    $0x20,%eax
  80c04c:	74 4c                	je     80c09a <do_send+0x73>
  80c04e:	83 f8 40             	cmp    $0x40,%eax
  80c051:	75 1c                	jne    80c06f <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c053:	8b 43 04             	mov    0x4(%ebx),%eax
  80c056:	8b 48 08             	mov    0x8(%eax),%ecx
  80c059:	85 c9                	test   %ecx,%ecx
  80c05b:	74 2a                	je     80c087 <do_send+0x60>
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80c05d:	83 ec 04             	sub    $0x4,%esp
  80c060:	51                   	push   %ecx
  80c061:	ff 30                	push   (%eax)
  80c063:	52                   	push   %edx
  80c064:	e8 79 1d 00 00       	call   80dde2 <raw_sendto>
  80c069:	88 46 0c             	mov    %al,0xc(%esi)
  80c06c:	83 c4 10             	add    $0x10,%esp
  TCPIP_APIMSG_ACK(msg);
  80c06f:	83 ec 0c             	sub    $0xc,%esp
  80c072:	8b 03                	mov    (%ebx),%eax
  80c074:	ff 70 10             	push   0x10(%eax)
  80c077:	e8 a5 df ff ff       	call   80a021 <sys_sem_signal>
}
  80c07c:	83 c4 10             	add    $0x10,%esp
  80c07f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c082:	5b                   	pop    %ebx
  80c083:	5e                   	pop    %esi
  80c084:	5f                   	pop    %edi
  80c085:	5d                   	pop    %ebp
  80c086:	c3                   	ret    
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80c087:	83 ec 08             	sub    $0x8,%esp
  80c08a:	ff 30                	push   (%eax)
  80c08c:	52                   	push   %edx
  80c08d:	e8 5c 1e 00 00       	call   80deee <raw_send>
  80c092:	88 46 0c             	mov    %al,0xc(%esi)
  80c095:	83 c4 10             	add    $0x10,%esp
  80c098:	eb d5                	jmp    80c06f <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c09a:	8b 43 04             	mov    0x4(%ebx),%eax
  80c09d:	8b 48 08             	mov    0x8(%eax),%ecx
  80c0a0:	85 c9                	test   %ecx,%ecx
  80c0a2:	74 16                	je     80c0ba <do_send+0x93>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c0a4:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c0a8:	57                   	push   %edi
  80c0a9:	51                   	push   %ecx
  80c0aa:	ff 30                	push   (%eax)
  80c0ac:	52                   	push   %edx
  80c0ad:	e8 92 cd ff ff       	call   808e44 <udp_sendto>
  80c0b2:	88 46 0c             	mov    %al,0xc(%esi)
  80c0b5:	83 c4 10             	add    $0x10,%esp
  80c0b8:	eb b5                	jmp    80c06f <do_send+0x48>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c0ba:	83 ec 08             	sub    $0x8,%esp
  80c0bd:	ff 30                	push   (%eax)
  80c0bf:	52                   	push   %edx
  80c0c0:	e8 bf cd ff ff       	call   808e84 <udp_send>
  80c0c5:	88 46 0c             	mov    %al,0xc(%esi)
  80c0c8:	83 c4 10             	add    $0x10,%esp
  80c0cb:	eb a2                	jmp    80c06f <do_send+0x48>

0080c0cd <do_recv>:
{
  80c0cd:	55                   	push   %ebp
  80c0ce:	89 e5                	mov    %esp,%ebp
  80c0d0:	53                   	push   %ebx
  80c0d1:	83 ec 04             	sub    $0x4,%esp
  80c0d4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c0d7:	8b 03                	mov    (%ebx),%eax
  80c0d9:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c0dd:	7c 0c                	jl     80c0eb <do_recv+0x1e>
    if (msg->conn->pcb.tcp != NULL) {
  80c0df:	8b 50 08             	mov    0x8(%eax),%edx
  80c0e2:	85 d2                	test   %edx,%edx
  80c0e4:	74 05                	je     80c0eb <do_recv+0x1e>
      if (msg->conn->type == NETCONN_TCP) {
  80c0e6:	83 38 10             	cmpl   $0x10,(%eax)
  80c0e9:	74 15                	je     80c100 <do_recv+0x33>
  TCPIP_APIMSG_ACK(msg);
  80c0eb:	83 ec 0c             	sub    $0xc,%esp
  80c0ee:	8b 03                	mov    (%ebx),%eax
  80c0f0:	ff 70 10             	push   0x10(%eax)
  80c0f3:	e8 29 df ff ff       	call   80a021 <sys_sem_signal>
}
  80c0f8:	83 c4 10             	add    $0x10,%esp
  80c0fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c0fe:	c9                   	leave  
  80c0ff:	c3                   	ret    
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c100:	83 ec 08             	sub    $0x8,%esp
  80c103:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c107:	50                   	push   %eax
  80c108:	52                   	push   %edx
  80c109:	e8 1a 95 ff ff       	call   805628 <tcp_recved>
  80c10e:	83 c4 10             	add    $0x10,%esp
  80c111:	eb d8                	jmp    80c0eb <do_recv+0x1e>

0080c113 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c113:	55                   	push   %ebp
  80c114:	89 e5                	mov    %esp,%ebp
  80c116:	83 ec 08             	sub    $0x8,%esp
  80c119:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c11c:	8b 02                	mov    (%edx),%eax
  80c11e:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c122:	7c 0f                	jl     80c133 <do_write+0x20>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c124:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c128:	74 05                	je     80c12f <do_write+0x1c>
  80c12a:	83 38 10             	cmpl   $0x10,(%eax)
  80c12d:	74 16                	je     80c145 <do_write+0x32>
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c12f:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c133:	83 ec 0c             	sub    $0xc,%esp
  80c136:	8b 02                	mov    (%edx),%eax
  80c138:	ff 70 10             	push   0x10(%eax)
  80c13b:	e8 e1 de ff ff       	call   80a021 <sys_sem_signal>
  80c140:	83 c4 10             	add    $0x10,%esp
}
  80c143:	c9                   	leave  
  80c144:	c3                   	ret    
      msg->conn->state = NETCONN_WRITE;
  80c145:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      msg->conn->write_msg = msg;
  80c14c:	8b 02                	mov    (%edx),%eax
  80c14e:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c151:	8b 02                	mov    (%edx),%eax
  80c153:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
      do_writemore(msg->conn);
  80c15a:	8b 02                	mov    (%edx),%eax
  80c15c:	e8 66 f4 ff ff       	call   80b5c7 <do_writemore>
      return;
  80c161:	eb e0                	jmp    80c143 <do_write+0x30>

0080c163 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c163:	55                   	push   %ebp
  80c164:	89 e5                	mov    %esp,%ebp
  80c166:	83 ec 08             	sub    $0x8,%esp
  80c169:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c16c:	8b 08                	mov    (%eax),%ecx
  80c16e:	8b 51 08             	mov    0x8(%ecx),%edx
  80c171:	85 d2                	test   %edx,%edx
  80c173:	0f 84 a8 00 00 00    	je     80c221 <do_getaddr+0xbe>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c179:	8b 48 04             	mov    0x4(%eax),%ecx
  80c17c:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c180:	74 2f                	je     80c1b1 <do_getaddr+0x4e>
  80c182:	8b 12                	mov    (%edx),%edx
  80c184:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c186:	8b 08                	mov    (%eax),%ecx
  80c188:	8b 11                	mov    (%ecx),%edx
  80c18a:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c190:	83 fa 20             	cmp    $0x20,%edx
  80c193:	74 3e                	je     80c1d3 <do_getaddr+0x70>
  80c195:	83 fa 40             	cmp    $0x40,%edx
  80c198:	74 1e                	je     80c1b8 <do_getaddr+0x55>
  80c19a:	83 fa 10             	cmp    $0x10,%edx
  80c19d:	74 64                	je     80c203 <do_getaddr+0xa0>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
  80c19f:	83 ec 0c             	sub    $0xc,%esp
  80c1a2:	8b 00                	mov    (%eax),%eax
  80c1a4:	ff 70 10             	push   0x10(%eax)
  80c1a7:	e8 75 de ff ff       	call   80a021 <sys_sem_signal>
}
  80c1ac:	83 c4 10             	add    $0x10,%esp
  80c1af:	c9                   	leave  
  80c1b0:	c3                   	ret    
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c1b1:	8b 52 04             	mov    0x4(%edx),%edx
  80c1b4:	89 11                	mov    %edx,(%ecx)
  80c1b6:	eb ce                	jmp    80c186 <do_getaddr+0x23>
      if (msg->msg.ad.local) {
  80c1b8:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c1bc:	74 0f                	je     80c1cd <do_getaddr+0x6a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c1be:	8b 50 08             	mov    0x8(%eax),%edx
  80c1c1:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c1c4:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c1c8:	66 89 0a             	mov    %cx,(%edx)
  80c1cb:	eb d2                	jmp    80c19f <do_getaddr+0x3c>
        msg->conn->err = ERR_CONN;
  80c1cd:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c1d1:	eb cc                	jmp    80c19f <do_getaddr+0x3c>
      if (msg->msg.ad.local) {
  80c1d3:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c1d7:	74 0f                	je     80c1e8 <do_getaddr+0x85>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c1d9:	8b 50 08             	mov    0x8(%eax),%edx
  80c1dc:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c1df:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c1e3:	66 89 0a             	mov    %cx,(%edx)
  80c1e6:	eb b7                	jmp    80c19f <do_getaddr+0x3c>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c1e8:	8b 51 08             	mov    0x8(%ecx),%edx
  80c1eb:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c1ef:	75 06                	jne    80c1f7 <do_getaddr+0x94>
          msg->conn->err = ERR_CONN;
  80c1f1:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c1f5:	eb a8                	jmp    80c19f <do_getaddr+0x3c>
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c1f7:	8b 48 08             	mov    0x8(%eax),%ecx
  80c1fa:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c1fe:	66 89 11             	mov    %dx,(%ecx)
  80c201:	eb 9c                	jmp    80c19f <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c203:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c207:	74 0f                	je     80c218 <do_getaddr+0xb5>
  80c209:	8b 51 08             	mov    0x8(%ecx),%edx
  80c20c:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80c210:	8b 50 08             	mov    0x8(%eax),%edx
  80c213:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c216:	eb 87                	jmp    80c19f <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c218:	8b 51 08             	mov    0x8(%ecx),%edx
  80c21b:	0f b7 4a 1e          	movzwl 0x1e(%edx),%ecx
  80c21f:	eb ef                	jmp    80c210 <do_getaddr+0xad>
    msg->conn->err = ERR_CONN;
  80c221:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c225:	e9 75 ff ff ff       	jmp    80c19f <do_getaddr+0x3c>

0080c22a <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c22a:	55                   	push   %ebp
  80c22b:	89 e5                	mov    %esp,%ebp
  80c22d:	83 ec 08             	sub    $0x8,%esp
  80c230:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c233:	8b 02                	mov    (%edx),%eax
  80c235:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c239:	74 05                	je     80c240 <do_close+0x16>
  80c23b:	83 38 10             	cmpl   $0x10,(%eax)
  80c23e:	74 16                	je     80c256 <do_close+0x2c>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c240:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c244:	83 ec 0c             	sub    $0xc,%esp
  80c247:	8b 02                	mov    (%edx),%eax
  80c249:	ff 70 10             	push   0x10(%eax)
  80c24c:	e8 d0 dd ff ff       	call   80a021 <sys_sem_signal>
  80c251:	83 c4 10             	add    $0x10,%esp
  }
}
  80c254:	c9                   	leave  
  80c255:	c3                   	ret    
      msg->conn->state = NETCONN_CLOSE;
  80c256:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c25d:	8b 02                	mov    (%edx),%eax
  80c25f:	e8 cb f4 ff ff       	call   80b72f <do_close_internal>
  80c264:	eb ee                	jmp    80c254 <do_close+0x2a>

0080c266 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c266:	55                   	push   %ebp
  80c267:	89 e5                	mov    %esp,%ebp
  80c269:	57                   	push   %edi
  80c26a:	56                   	push   %esi
  80c26b:	53                   	push   %ebx
  80c26c:	83 ec 18             	sub    $0x18,%esp
  80c26f:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c271:	8b 35 14 b2 b3 00    	mov    0xb3b214,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c277:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c27b:	50                   	push   %eax
  80c27c:	e8 12 b4 ff ff       	call   807693 <ntohs>
  80c281:	83 c4 10             	add    $0x10,%esp
  80c284:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c288:	0f 86 84 00 00 00    	jbe    80c312 <tcp_parseopt+0xac>
  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c28e:	83 c6 14             	add    $0x14,%esi
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c291:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c296:	eb 10                	jmp    80c2a8 <tcp_parseopt+0x42>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
  80c298:	83 c3 01             	add    $0x1,%ebx
  80c29b:	eb 0b                	jmp    80c2a8 <tcp_parseopt+0x42>
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;

        /* And we are done processing options. */
        break;
      } else {
        if (opts[c + 1] == 0) {
  80c29d:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c2a2:	84 c0                	test   %al,%al
  80c2a4:	74 6c                	je     80c312 <tcp_parseopt+0xac>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c2a6:	01 c3                	add    %eax,%ebx
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c2a8:	83 ec 0c             	sub    $0xc,%esp
  80c2ab:	a1 14 b2 b3 00       	mov    0xb3b214,%eax
  80c2b0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c2b4:	50                   	push   %eax
  80c2b5:	e8 d9 b3 ff ff       	call   807693 <ntohs>
  80c2ba:	0f b6 d3             	movzbl %bl,%edx
  80c2bd:	66 c1 e8 0c          	shr    $0xc,%ax
  80c2c1:	0f b7 c0             	movzwl %ax,%eax
  80c2c4:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c2cb:	83 c4 10             	add    $0x10,%esp
  80c2ce:	39 c2                	cmp    %eax,%edx
  80c2d0:	7d 40                	jge    80c312 <tcp_parseopt+0xac>
      opt = opts[c];
  80c2d2:	0f b6 d3             	movzbl %bl,%edx
  80c2d5:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c2d9:	84 c0                	test   %al,%al
  80c2db:	74 35                	je     80c312 <tcp_parseopt+0xac>
      } else if (opt == 0x01) {
  80c2dd:	3c 01                	cmp    $0x1,%al
  80c2df:	74 b7                	je     80c298 <tcp_parseopt+0x32>
      } else if (opt == 0x02 &&
  80c2e1:	3c 02                	cmp    $0x2,%al
  80c2e3:	75 b8                	jne    80c29d <tcp_parseopt+0x37>
  80c2e5:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c2ea:	75 b1                	jne    80c29d <tcp_parseopt+0x37>
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c2ec:	0f b6 4c 16 02       	movzbl 0x2(%esi,%edx,1),%ecx
  80c2f1:	c1 e1 08             	shl    $0x8,%ecx
  80c2f4:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c2f9:	89 d0                	mov    %edx,%eax
  80c2fb:	09 c8                	or     %ecx,%eax
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c2fd:	83 e8 01             	sub    $0x1,%eax
  80c300:	09 ca                	or     %ecx,%edx
  80c302:	66 3d b4 05          	cmp    $0x5b4,%ax
  80c306:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80c30b:	0f 42 c2             	cmovb  %edx,%eax
  80c30e:	66 89 47 34          	mov    %ax,0x34(%edi)
      }
    }
  }
}
  80c312:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c315:	5b                   	pop    %ebx
  80c316:	5e                   	pop    %esi
  80c317:	5f                   	pop    %edi
  80c318:	5d                   	pop    %ebp
  80c319:	c3                   	ret    

0080c31a <tcp_receive>:
{
  80c31a:	55                   	push   %ebp
  80c31b:	89 e5                	mov    %esp,%ebp
  80c31d:	57                   	push   %edi
  80c31e:	56                   	push   %esi
  80c31f:	53                   	push   %ebx
  80c320:	83 ec 1c             	sub    $0x1c,%esp
  80c323:	89 c7                	mov    %eax,%edi
  if (flags & TCP_ACK) {
  80c325:	f6 05 04 b2 b3 00 10 	testb  $0x10,0xb3b204
  80c32c:	0f 84 1f 04 00 00    	je     80c751 <tcp_receive+0x437>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c332:	0f b7 48 5c          	movzwl 0x5c(%eax),%ecx
  80c336:	8b 50 60             	mov    0x60(%eax),%edx
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c339:	a1 0c b2 b3 00       	mov    0xb3b20c,%eax
  80c33e:	39 c2                	cmp    %eax,%edx
  80c340:	78 53                	js     80c395 <tcp_receive+0x7b>
  80c342:	39 c2                	cmp    %eax,%edx
  80c344:	74 36                	je     80c37c <tcp_receive+0x62>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c346:	8b 35 08 b2 b3 00    	mov    0xb3b208,%esi
  80c34c:	39 77 64             	cmp    %esi,0x64(%edi)
  80c34f:	74 38                	je     80c389 <tcp_receive+0x6f>
    if (pcb->lastack == ackno) {
  80c351:	8b 5f 48             	mov    0x48(%edi),%ebx
  80c354:	a1 08 b2 b3 00       	mov    0xb3b208,%eax
  80c359:	39 c3                	cmp    %eax,%ebx
  80c35b:	74 68                	je     80c3c5 <tcp_receive+0xab>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c35d:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c360:	39 da                	cmp    %ebx,%edx
  80c362:	78 0d                	js     80c371 <tcp_receive+0x57>
  80c364:	89 c2                	mov    %eax,%edx
  80c366:	2b 57 58             	sub    0x58(%edi),%edx
  80c369:	85 d2                	test   %edx,%edx
  80c36b:	0f 8e fa 00 00 00    	jle    80c46b <tcp_receive+0x151>
      pcb->acked = 0;
  80c371:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c377:	e9 be 02 00 00       	jmp    80c63a <tcp_receive+0x320>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c37c:	8b 35 08 b2 b3 00    	mov    0xb3b208,%esi
  80c382:	39 77 64             	cmp    %esi,0x64(%edi)
  80c385:	79 bf                	jns    80c346 <tcp_receive+0x2c>
  80c387:	eb 0c                	jmp    80c395 <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c389:	8b 1d 14 b2 b3 00    	mov    0xb3b214,%ebx
  80c38f:	66 3b 4b 0e          	cmp    0xe(%ebx),%cx
  80c393:	73 bc                	jae    80c351 <tcp_receive+0x37>
      pcb->snd_wnd = tcphdr->wnd;
  80c395:	8b 1d 14 b2 b3 00    	mov    0xb3b214,%ebx
  80c39b:	0f b7 5b 0e          	movzwl 0xe(%ebx),%ebx
  80c39f:	66 89 5f 5c          	mov    %bx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c3a3:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c3a6:	a1 08 b2 b3 00       	mov    0xb3b208,%eax
  80c3ab:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c3ae:	66 85 db             	test   %bx,%bx
  80c3b1:	74 9e                	je     80c351 <tcp_receive+0x37>
  80c3b3:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c3ba:	74 95                	je     80c351 <tcp_receive+0x37>
          pcb->persist_backoff = 0;
  80c3bc:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
  80c3c3:	eb 8c                	jmp    80c351 <tcp_receive+0x37>
      pcb->acked = 0;
  80c3c5:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c3cb:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c3cf:	03 47 60             	add    0x60(%edi),%eax
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c3d2:	0f b7 c9             	movzwl %cx,%ecx
  80c3d5:	01 d1                	add    %edx,%ecx
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c3d7:	39 c8                	cmp    %ecx,%eax
  80c3d9:	0f 85 5b 02 00 00    	jne    80c63a <tcp_receive+0x320>
        ++pcb->dupacks;
  80c3df:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c3e3:	83 c0 01             	add    $0x1,%eax
  80c3e6:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c3e9:	3c 02                	cmp    $0x2,%al
  80c3eb:	0f 86 49 02 00 00    	jbe    80c63a <tcp_receive+0x320>
  80c3f1:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c3f5:	0f 84 3f 02 00 00    	je     80c63a <tcp_receive+0x320>
          if (!(pcb->flags & TF_INFR)) {
  80c3fb:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c3ff:	74 1c                	je     80c41d <tcp_receive+0x103>
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c401:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c405:	89 d0                	mov    %edx,%eax
  80c407:	66 03 47 34          	add    0x34(%edi),%ax
  80c40b:	66 39 c2             	cmp    %ax,%dx
  80c40e:	0f 83 26 02 00 00    	jae    80c63a <tcp_receive+0x320>
              pcb->cwnd += pcb->mss;
  80c414:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c418:	e9 1d 02 00 00       	jmp    80c63a <tcp_receive+0x320>
            tcp_rexmit(pcb);
  80c41d:	83 ec 0c             	sub    $0xc,%esp
  80c420:	57                   	push   %edi
  80c421:	e8 ee c1 ff ff       	call   808614 <tcp_rexmit>
            if (pcb->cwnd > pcb->snd_wnd)
  80c426:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c42a:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c42e:	83 c4 10             	add    $0x10,%esp
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c431:	89 c3                	mov    %eax,%ebx
  80c433:	66 d1 eb             	shr    %bx
  80c436:	89 d1                	mov    %edx,%ecx
  80c438:	66 d1 e9             	shr    %cx
  80c43b:	66 39 c2             	cmp    %ax,%dx
  80c43e:	0f 47 cb             	cmova  %ebx,%ecx
            if (pcb->ssthresh < 2*pcb->mss) {
  80c441:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c445:	0f b7 f1             	movzwl %cx,%esi
  80c448:	0f b7 d8             	movzwl %ax,%ebx
  80c44b:	01 db                	add    %ebx,%ebx
              pcb->ssthresh = 2*pcb->mss;
  80c44d:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c450:	39 de                	cmp    %ebx,%esi
  80c452:	0f 4d d1             	cmovge %ecx,%edx
  80c455:	66 89 57 50          	mov    %dx,0x50(%edi)
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c459:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c45c:	01 d0                	add    %edx,%eax
  80c45e:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c462:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c466:	e9 cf 01 00 00       	jmp    80c63a <tcp_receive+0x320>
      if (pcb->flags & TF_INFR) {
  80c46b:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80c46f:	f6 c2 04             	test   $0x4,%dl
  80c472:	74 0e                	je     80c482 <tcp_receive+0x168>
        pcb->flags &= ~TF_INFR;
  80c474:	83 e2 fb             	and    $0xfffffffb,%edx
  80c477:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c47a:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80c47e:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      pcb->nrtx = 0;
  80c482:	c6 47 46 00          	movb   $0x0,0x46(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c486:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c48a:	66 c1 fa 03          	sar    $0x3,%dx
  80c48e:	66 03 57 42          	add    0x42(%edi),%dx
  80c492:	66 89 57 44          	mov    %dx,0x44(%edi)
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c496:	89 c2                	mov    %eax,%edx
  80c498:	29 da                	sub    %ebx,%edx
  80c49a:	66 89 57 6c          	mov    %dx,0x6c(%edi)
      pcb->snd_buf += pcb->acked;
  80c49e:	66 01 57 6e          	add    %dx,0x6e(%edi)
      pcb->dupacks = 0;
  80c4a2:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c4a6:	89 47 48             	mov    %eax,0x48(%edi)
      if (pcb->state >= ESTABLISHED) {
  80c4a9:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c4ad:	76 1d                	jbe    80c4cc <tcp_receive+0x1b2>
        if (pcb->cwnd < pcb->ssthresh) {
  80c4af:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c4b3:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c4b7:	0f 83 da 00 00 00    	jae    80c597 <tcp_receive+0x27d>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c4bd:	89 c8                	mov    %ecx,%eax
  80c4bf:	66 03 47 34          	add    0x34(%edi),%ax
  80c4c3:	66 39 c1             	cmp    %ax,%cx
  80c4c6:	73 04                	jae    80c4cc <tcp_receive+0x1b2>
            pcb->cwnd += pcb->mss;
  80c4c8:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      while (pcb->unacked != NULL &&
  80c4cc:	8b 47 78             	mov    0x78(%edi),%eax
  80c4cf:	85 c0                	test   %eax,%eax
  80c4d1:	0f 84 19 01 00 00    	je     80c5f0 <tcp_receive+0x2d6>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c4d7:	83 ec 0c             	sub    $0xc,%esp
  80c4da:	8b 40 10             	mov    0x10(%eax),%eax
  80c4dd:	ff 70 04             	push   0x4(%eax)
  80c4e0:	e8 e3 b3 ff ff       	call   8078c8 <ntohl>
  80c4e5:	89 c3                	mov    %eax,%ebx
  80c4e7:	8b 47 78             	mov    0x78(%edi),%eax
  80c4ea:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c4ee:	8b 40 10             	mov    0x10(%eax),%eax
  80c4f1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c4f5:	89 04 24             	mov    %eax,(%esp)
  80c4f8:	e8 96 b1 ff ff       	call   807693 <ntohs>
  80c4fd:	89 c2                	mov    %eax,%edx
  80c4ff:	83 c4 10             	add    $0x10,%esp
  80c502:	b8 01 00 00 00       	mov    $0x1,%eax
  80c507:	f6 c2 01             	test   $0x1,%dl
  80c50a:	0f 84 bf 00 00 00    	je     80c5cf <tcp_receive+0x2b5>
  80c510:	2b 1d 08 b2 b3 00    	sub    0xb3b208,%ebx
  80c516:	01 c6                	add    %eax,%esi
  80c518:	01 f3                	add    %esi,%ebx
      while (pcb->unacked != NULL &&
  80c51a:	85 db                	test   %ebx,%ebx
  80c51c:	0f 8f ce 00 00 00    	jg     80c5f0 <tcp_receive+0x2d6>
        next = pcb->unacked;
  80c522:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c525:	8b 03                	mov    (%ebx),%eax
  80c527:	89 47 78             	mov    %eax,0x78(%edi)
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c52a:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c52e:	83 ec 0c             	sub    $0xc,%esp
  80c531:	ff 73 04             	push   0x4(%ebx)
  80c534:	e8 4a 87 ff ff       	call   804c83 <pbuf_clen>
  80c539:	0f b6 c0             	movzbl %al,%eax
  80c53c:	83 c4 10             	add    $0x10,%esp
  80c53f:	66 39 c6             	cmp    %ax,%si
  80c542:	72 74                	jb     80c5b8 <tcp_receive+0x29e>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c544:	83 ec 0c             	sub    $0xc,%esp
  80c547:	ff 73 04             	push   0x4(%ebx)
  80c54a:	e8 34 87 ff ff       	call   804c83 <pbuf_clen>
  80c54f:	0f b6 c0             	movzbl %al,%eax
  80c552:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c556:	89 1c 24             	mov    %ebx,(%esp)
  80c559:	e8 d1 91 ff ff       	call   80572f <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
  80c55e:	83 c4 10             	add    $0x10,%esp
  80c561:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c566:	0f 84 60 ff ff ff    	je     80c4cc <tcp_receive+0x1b2>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c56c:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c570:	0f 85 56 ff ff ff    	jne    80c4cc <tcp_receive+0x1b2>
  80c576:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c57a:	0f 85 4c ff ff ff    	jne    80c4cc <tcp_receive+0x1b2>
  80c580:	83 ec 04             	sub    $0x4,%esp
  80c583:	68 50 2e 81 00       	push   $0x812e50
  80c588:	68 5b 03 00 00       	push   $0x35b
  80c58d:	68 94 2f 81 00       	push   $0x812f94
  80c592:	e8 3f 1f 00 00       	call   80e4d6 <_panic>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c597:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c59b:	0f af c0             	imul   %eax,%eax
  80c59e:	0f b7 d9             	movzwl %cx,%ebx
  80c5a1:	99                   	cltd   
  80c5a2:	f7 fb                	idiv   %ebx
  80c5a4:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c5a6:	66 39 c1             	cmp    %ax,%cx
  80c5a9:	0f 83 1d ff ff ff    	jae    80c4cc <tcp_receive+0x1b2>
            pcb->cwnd = new_cwnd;
  80c5af:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c5b3:	e9 14 ff ff ff       	jmp    80c4cc <tcp_receive+0x1b2>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c5b8:	83 ec 04             	sub    $0x4,%esp
  80c5bb:	68 28 2e 81 00       	push   $0x812e28
  80c5c0:	68 55 03 00 00       	push   $0x355
  80c5c5:	68 94 2f 81 00       	push   $0x812f94
  80c5ca:	e8 07 1f 00 00       	call   80e4d6 <_panic>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c5cf:	83 ec 0c             	sub    $0xc,%esp
  80c5d2:	8b 47 78             	mov    0x78(%edi),%eax
  80c5d5:	8b 40 10             	mov    0x10(%eax),%eax
  80c5d8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c5dc:	50                   	push   %eax
  80c5dd:	e8 b1 b0 ff ff       	call   807693 <ntohs>
  80c5e2:	66 d1 e8             	shr    %ax
  80c5e5:	83 e0 01             	and    $0x1,%eax
  80c5e8:	83 c4 10             	add    $0x10,%esp
  80c5eb:	e9 20 ff ff ff       	jmp    80c510 <tcp_receive+0x1f6>
      if(pcb->unacked == NULL)
  80c5f0:	83 7f 78 01          	cmpl   $0x1,0x78(%edi)
  80c5f4:	66 19 c0             	sbb    %ax,%ax
  80c5f7:	66 89 47 32          	mov    %ax,0x32(%edi)
      pcb->polltmr = 0;
  80c5fb:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c5ff:	eb 39                	jmp    80c63a <tcp_receive+0x320>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c601:	83 ec 04             	sub    $0x4,%esp
  80c604:	68 28 2e 81 00       	push   $0x812e28
  80c609:	68 7f 03 00 00       	push   $0x37f
  80c60e:	68 94 2f 81 00       	push   $0x812f94
  80c613:	e8 be 1e 00 00       	call   80e4d6 <_panic>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c618:	83 ec 04             	sub    $0x4,%esp
  80c61b:	68 50 2e 81 00       	push   $0x812e50
  80c620:	68 84 03 00 00       	push   $0x384
  80c625:	68 94 2f 81 00       	push   $0x812f94
  80c62a:	e8 a7 1e 00 00       	call   80e4d6 <_panic>
      if (pcb->unsent != NULL) {
  80c62f:	8b 47 74             	mov    0x74(%edi),%eax
  80c632:	85 c0                	test   %eax,%eax
  80c634:	0f 85 cb 00 00 00    	jne    80c705 <tcp_receive+0x3eb>
    while (pcb->unsent != NULL &&
  80c63a:	8b 47 74             	mov    0x74(%edi),%eax
  80c63d:	85 c0                	test   %eax,%eax
  80c63f:	0f 84 fa 00 00 00    	je     80c73f <tcp_receive+0x425>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c645:	8b 35 08 b2 b3 00    	mov    0xb3b208,%esi
  80c64b:	83 ec 0c             	sub    $0xc,%esp
  80c64e:	8b 40 10             	mov    0x10(%eax),%eax
  80c651:	ff 70 04             	push   0x4(%eax)
  80c654:	e8 6f b2 ff ff       	call   8078c8 <ntohl>
  80c659:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c65c:	8b 47 74             	mov    0x74(%edi),%eax
  80c65f:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80c663:	8b 40 10             	mov    0x10(%eax),%eax
  80c666:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c66a:	89 04 24             	mov    %eax,(%esp)
  80c66d:	e8 21 b0 ff ff       	call   807693 <ntohs>
  80c672:	89 c2                	mov    %eax,%edx
  80c674:	83 c4 10             	add    $0x10,%esp
  80c677:	b8 01 00 00 00       	mov    $0x1,%eax
  80c67c:	f6 c2 01             	test   $0x1,%dl
  80c67f:	0f 84 99 00 00 00    	je     80c71e <tcp_receive+0x404>
  80c685:	2b 75 e4             	sub    -0x1c(%ebp),%esi
  80c688:	01 c3                	add    %eax,%ebx
    while (pcb->unsent != NULL &&
  80c68a:	39 de                	cmp    %ebx,%esi
  80c68c:	0f 88 ad 00 00 00    	js     80c73f <tcp_receive+0x425>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c692:	a1 08 b2 b3 00       	mov    0xb3b208,%eax
  80c697:	2b 47 58             	sub    0x58(%edi),%eax
  80c69a:	85 c0                	test   %eax,%eax
  80c69c:	0f 8f 9d 00 00 00    	jg     80c73f <tcp_receive+0x425>
      next = pcb->unsent;
  80c6a2:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c6a5:	8b 03                	mov    (%ebx),%eax
  80c6a7:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c6aa:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c6ae:	83 ec 0c             	sub    $0xc,%esp
  80c6b1:	ff 73 04             	push   0x4(%ebx)
  80c6b4:	e8 ca 85 ff ff       	call   804c83 <pbuf_clen>
  80c6b9:	0f b6 c0             	movzbl %al,%eax
  80c6bc:	83 c4 10             	add    $0x10,%esp
  80c6bf:	66 39 c6             	cmp    %ax,%si
  80c6c2:	0f 82 39 ff ff ff    	jb     80c601 <tcp_receive+0x2e7>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c6c8:	83 ec 0c             	sub    $0xc,%esp
  80c6cb:	ff 73 04             	push   0x4(%ebx)
  80c6ce:	e8 b0 85 ff ff       	call   804c83 <pbuf_clen>
  80c6d3:	0f b6 c0             	movzbl %al,%eax
  80c6d6:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c6da:	89 1c 24             	mov    %ebx,(%esp)
  80c6dd:	e8 4d 90 ff ff       	call   80572f <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
  80c6e2:	83 c4 10             	add    $0x10,%esp
  80c6e5:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c6ea:	0f 84 3f ff ff ff    	je     80c62f <tcp_receive+0x315>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c6f0:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c6f4:	0f 85 35 ff ff ff    	jne    80c62f <tcp_receive+0x315>
  80c6fa:	8b 47 74             	mov    0x74(%edi),%eax
  80c6fd:	85 c0                	test   %eax,%eax
  80c6ff:	0f 84 13 ff ff ff    	je     80c618 <tcp_receive+0x2fe>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c705:	83 ec 0c             	sub    $0xc,%esp
  80c708:	8b 40 10             	mov    0x10(%eax),%eax
  80c70b:	ff 70 04             	push   0x4(%eax)
  80c70e:	e8 8d af ff ff       	call   8076a0 <htonl>
  80c713:	89 47 54             	mov    %eax,0x54(%edi)
  80c716:	83 c4 10             	add    $0x10,%esp
  80c719:	e9 1c ff ff ff       	jmp    80c63a <tcp_receive+0x320>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c71e:	83 ec 0c             	sub    $0xc,%esp
  80c721:	8b 47 74             	mov    0x74(%edi),%eax
  80c724:	8b 40 10             	mov    0x10(%eax),%eax
  80c727:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c72b:	50                   	push   %eax
  80c72c:	e8 62 af ff ff       	call   807693 <ntohs>
  80c731:	66 d1 e8             	shr    %ax
  80c734:	83 e0 01             	and    $0x1,%eax
  80c737:	83 c4 10             	add    $0x10,%esp
  80c73a:	e9 46 ff ff ff       	jmp    80c685 <tcp_receive+0x36b>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c73f:	8b 47 38             	mov    0x38(%edi),%eax
  80c742:	85 c0                	test   %eax,%eax
  80c744:	74 0b                	je     80c751 <tcp_receive+0x437>
  80c746:	8b 0d 08 b2 b3 00    	mov    0xb3b208,%ecx
  80c74c:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c74f:	78 70                	js     80c7c1 <tcp_receive+0x4a7>
  if (tcplen > 0) {
  80c751:	0f b7 05 02 b2 b3 00 	movzwl 0xb3b202,%eax
  80c758:	66 85 c0             	test   %ax,%ax
  80c75b:	0f 84 5d 08 00 00    	je     80cfbe <tcp_receive+0xca4>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c761:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c764:	8b 15 0c b2 b3 00    	mov    0xb3b20c,%edx
  80c76a:	89 d9                	mov    %ebx,%ecx
  80c76c:	29 d1                	sub    %edx,%ecx
  80c76e:	89 ce                	mov    %ecx,%esi
  80c770:	83 ee 01             	sub    $0x1,%esi
  80c773:	78 16                	js     80c78b <tcp_receive+0x471>
  80c775:	be 01 00 00 00       	mov    $0x1,%esi
  80c77a:	29 d6                	sub    %edx,%esi
  80c77c:	0f b7 c0             	movzwl %ax,%eax
  80c77f:	29 c6                	sub    %eax,%esi
  80c781:	01 de                	add    %ebx,%esi
  80c783:	85 f6                	test   %esi,%esi
  80c785:	0f 8e 84 00 00 00    	jle    80c80f <tcp_receive+0x4f5>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c78b:	39 da                	cmp    %ebx,%edx
  80c78d:	0f 88 bb 01 00 00    	js     80c94e <tcp_receive+0x634>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c793:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
  80c797:	89 d0                	mov    %edx,%eax
  80c799:	29 c8                	sub    %ecx,%eax
  80c79b:	8d 40 01             	lea    0x1(%eax),%eax
  80c79e:	29 d8                	sub    %ebx,%eax
  80c7a0:	85 c0                	test   %eax,%eax
  80c7a2:	0f 8e bb 01 00 00    	jle    80c963 <tcp_receive+0x649>
      tcp_ack_now(pcb);
  80c7a8:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c7ac:	83 ec 0c             	sub    $0xc,%esp
  80c7af:	57                   	push   %edi
  80c7b0:	e8 3c b8 ff ff       	call   807ff1 <tcp_output>
  80c7b5:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80c7b8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80c7bc:	e9 30 08 00 00       	jmp    80cff1 <tcp_receive+0xcd7>
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c7c1:	8b 35 58 44 b3 00    	mov    0xb34458,%esi
      m = m - (pcb->sa >> 3);
  80c7c7:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c7cb:	89 d3                	mov    %edx,%ebx
  80c7cd:	66 c1 fb 03          	sar    $0x3,%bx
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c7d1:	89 f1                	mov    %esi,%ecx
  80c7d3:	29 c1                	sub    %eax,%ecx
      m = m - (pcb->sa >> 3);
  80c7d5:	29 d9                	sub    %ebx,%ecx
      pcb->sa += m;
  80c7d7:	01 ca                	add    %ecx,%edx
  80c7d9:	66 89 57 40          	mov    %dx,0x40(%edi)
        m = -m;
  80c7dd:	29 f0                	sub    %esi,%eax
  80c7df:	01 d8                	add    %ebx,%eax
  80c7e1:	66 85 c9             	test   %cx,%cx
  80c7e4:	0f 49 c1             	cmovns %ecx,%eax
      m = m - (pcb->sv >> 2);
  80c7e7:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80c7eb:	89 cb                	mov    %ecx,%ebx
  80c7ed:	66 c1 fb 02          	sar    $0x2,%bx
      pcb->sv += m;
  80c7f1:	29 d9                	sub    %ebx,%ecx
  80c7f3:	01 c8                	add    %ecx,%eax
  80c7f5:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c7f9:	66 c1 fa 03          	sar    $0x3,%dx
  80c7fd:	01 d0                	add    %edx,%eax
  80c7ff:	66 89 47 44          	mov    %ax,0x44(%edi)
      pcb->rttest = 0;
  80c803:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  80c80a:	e9 42 ff ff ff       	jmp    80c751 <tcp_receive+0x437>
      off = pcb->rcv_nxt - seqno;
  80c80f:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80c811:	8b 1d 1c b2 b3 00    	mov    0xb3b21c,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c817:	85 db                	test   %ebx,%ebx
  80c819:	0f 84 a2 00 00 00    	je     80c8c1 <tcp_receive+0x5a7>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c81f:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80c825:	0f 8f ad 00 00 00    	jg     80c8d8 <tcp_receive+0x5be>
      if (inseg.p->len < off) {
  80c82b:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c82f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80c832:	39 ca                	cmp    %ecx,%edx
  80c834:	0f 8d e3 00 00 00    	jge    80c91d <tcp_receive+0x603>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c83a:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80c83e:	0f b7 d6             	movzwl %si,%edx
  80c841:	39 ca                	cmp    %ecx,%edx
  80c843:	0f 8c a6 00 00 00    	jl     80c8ef <tcp_receive+0x5d5>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80c849:	29 ce                	sub    %ecx,%esi
  80c84b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
          off -= p->len;
  80c84e:	29 d0                	sub    %edx,%eax
          p->tot_len = new_tot_len;
  80c850:	66 89 73 08          	mov    %si,0x8(%ebx)
          p->len = 0;
  80c854:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80c85a:	8b 1b                	mov    (%ebx),%ebx
        while (p->len < off) {
  80c85c:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c860:	39 c2                	cmp    %eax,%edx
  80c862:	7c ea                	jl     80c84e <tcp_receive+0x534>
        if(pbuf_header(p, (s16_t)-off)) {
  80c864:	83 ec 08             	sub    $0x8,%esp
  80c867:	f7 d8                	neg    %eax
  80c869:	98                   	cwtl   
  80c86a:	50                   	push   %eax
  80c86b:	53                   	push   %ebx
  80c86c:	e8 0c 7f ff ff       	call   80477d <pbuf_header>
  80c871:	83 c4 10             	add    $0x10,%esp
  80c874:	84 c0                	test   %al,%al
  80c876:	0f 85 8a 00 00 00    	jne    80c906 <tcp_receive+0x5ec>
      inseg.dataptr = p->payload;
  80c87c:	8b 43 04             	mov    0x4(%ebx),%eax
  80c87f:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80c884:	8b 57 24             	mov    0x24(%edi),%edx
  80c887:	0f b7 05 24 b2 b3 00 	movzwl 0xb3b224,%eax
  80c88e:	66 03 05 0c b2 b3 00 	add    0xb3b20c,%ax
  80c895:	29 d0                	sub    %edx,%eax
  80c897:	66 a3 24 b2 b3 00    	mov    %ax,0xb3b224
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80c89d:	89 15 0c b2 b3 00    	mov    %edx,0xb3b20c
  80c8a3:	a1 28 b2 b3 00       	mov    0xb3b228,%eax
  80c8a8:	89 50 04             	mov    %edx,0x4(%eax)
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c8ab:	8b 15 0c b2 b3 00    	mov    0xb3b20c,%edx
  80c8b1:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c8b4:	39 da                	cmp    %ebx,%edx
  80c8b6:	0f 88 ec fe ff ff    	js     80c7a8 <tcp_receive+0x48e>
  80c8bc:	e9 d2 fe ff ff       	jmp    80c793 <tcp_receive+0x479>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c8c1:	83 ec 04             	sub    $0x4,%esp
  80c8c4:	68 ab 2f 81 00       	push   $0x812fab
  80c8c9:	68 e5 03 00 00       	push   $0x3e5
  80c8ce:	68 94 2f 81 00       	push   $0x812f94
  80c8d3:	e8 fe 1b 00 00       	call   80e4d6 <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c8d8:	83 ec 04             	sub    $0x4,%esp
  80c8db:	68 bb 2f 81 00       	push   $0x812fbb
  80c8e0:	68 e6 03 00 00       	push   $0x3e6
  80c8e5:	68 94 2f 81 00       	push   $0x812f94
  80c8ea:	e8 e7 1b 00 00       	call   80e4d6 <_panic>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c8ef:	83 ec 04             	sub    $0x4,%esp
  80c8f2:	68 ca 2f 81 00       	push   $0x812fca
  80c8f7:	68 e8 03 00 00       	push   $0x3e8
  80c8fc:	68 94 2f 81 00       	push   $0x812f94
  80c901:	e8 d0 1b 00 00       	call   80e4d6 <_panic>
          LWIP_ASSERT("pbuf_header failed", 0);
  80c906:	83 ec 04             	sub    $0x4,%esp
  80c909:	68 da 2f 81 00       	push   $0x812fda
  80c90e:	68 f5 03 00 00       	push   $0x3f5
  80c913:	68 94 2f 81 00       	push   $0x812f94
  80c918:	e8 b9 1b 00 00       	call   80e4d6 <_panic>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80c91d:	83 ec 08             	sub    $0x8,%esp
  80c920:	f7 d9                	neg    %ecx
  80c922:	0f bf c1             	movswl %cx,%eax
  80c925:	50                   	push   %eax
  80c926:	53                   	push   %ebx
  80c927:	e8 51 7e ff ff       	call   80477d <pbuf_header>
  80c92c:	83 c4 10             	add    $0x10,%esp
  80c92f:	84 c0                	test   %al,%al
  80c931:	0f 84 45 ff ff ff    	je     80c87c <tcp_receive+0x562>
          LWIP_ASSERT("pbuf_header failed", 0);
  80c937:	83 ec 04             	sub    $0x4,%esp
  80c93a:	68 da 2f 81 00       	push   $0x812fda
  80c93f:	68 fa 03 00 00       	push   $0x3fa
  80c944:	68 94 2f 81 00       	push   $0x812f94
  80c949:	e8 88 1b 00 00       	call   80e4d6 <_panic>
        tcp_ack_now(pcb);
  80c94e:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c952:	83 ec 0c             	sub    $0xc,%esp
  80c955:	57                   	push   %edi
  80c956:	e8 96 b6 ff ff       	call   807ff1 <tcp_output>
  80c95b:	83 c4 10             	add    $0x10,%esp
  80c95e:	e9 48 ff ff ff       	jmp    80c8ab <tcp_receive+0x591>
      if (pcb->rcv_nxt == seqno) {
  80c963:	39 da                	cmp    %ebx,%edx
  80c965:	0f 85 df 03 00 00    	jne    80cd4a <tcp_receive+0xa30>
        if (pcb->ooseq != NULL &&
  80c96b:	8b 47 7c             	mov    0x7c(%edi),%eax
  80c96e:	85 c0                	test   %eax,%eax
  80c970:	74 1b                	je     80c98d <tcp_receive+0x673>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80c972:	8b 48 10             	mov    0x10(%eax),%ecx
  80c975:	8b 59 04             	mov    0x4(%ecx),%ebx
  80c978:	0f b7 35 24 b2 b3 00 	movzwl 0xb3b224,%esi
  80c97f:	89 d9                	mov    %ebx,%ecx
  80c981:	29 f1                	sub    %esi,%ecx
  80c983:	29 d1                	sub    %edx,%ecx
        if (pcb->ooseq != NULL &&
  80c985:	85 c9                	test   %ecx,%ecx
  80c987:	0f 8e b2 00 00 00    	jle    80ca3f <tcp_receive+0x725>
        tcplen = TCP_TCPLEN(&inseg);
  80c98d:	0f b7 1d 24 b2 b3 00 	movzwl 0xb3b224,%ebx
  80c994:	83 ec 0c             	sub    $0xc,%esp
  80c997:	a1 28 b2 b3 00       	mov    0xb3b228,%eax
  80c99c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9a0:	50                   	push   %eax
  80c9a1:	e8 ed ac ff ff       	call   807693 <ntohs>
  80c9a6:	89 c2                	mov    %eax,%edx
  80c9a8:	83 c4 10             	add    $0x10,%esp
  80c9ab:	b8 01 00 00 00       	mov    $0x1,%eax
  80c9b0:	f6 c2 01             	test   $0x1,%dl
  80c9b3:	0f 84 ff 00 00 00    	je     80cab8 <tcp_receive+0x79e>
  80c9b9:	01 d8                	add    %ebx,%eax
  80c9bb:	66 a3 02 b2 b3 00    	mov    %ax,0xb3b202
        if (pcb->state != CLOSE_WAIT) {
  80c9c1:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80c9c5:	74 06                	je     80c9cd <tcp_receive+0x6b3>
          pcb->rcv_nxt += tcplen;
  80c9c7:	0f b7 d0             	movzwl %ax,%edx
  80c9ca:	01 57 24             	add    %edx,0x24(%edi)
        if (pcb->rcv_wnd < tcplen) {
  80c9cd:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
          pcb->rcv_wnd -= tcplen;
  80c9d1:	89 ca                	mov    %ecx,%edx
  80c9d3:	29 c2                	sub    %eax,%edx
  80c9d5:	66 39 c8             	cmp    %cx,%ax
  80c9d8:	b9 00 00 00 00       	mov    $0x0,%ecx
  80c9dd:	0f 47 d1             	cmova  %ecx,%edx
  80c9e0:	66 89 57 28          	mov    %dx,0x28(%edi)
        if (pcb->rcv_ann_wnd < tcplen) {
  80c9e4:	0f b7 4f 2a          	movzwl 0x2a(%edi),%ecx
          pcb->rcv_ann_wnd -= tcplen;
  80c9e8:	89 ca                	mov    %ecx,%edx
  80c9ea:	29 c2                	sub    %eax,%edx
  80c9ec:	66 39 c8             	cmp    %cx,%ax
  80c9ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80c9f4:	0f 46 c2             	cmovbe %edx,%eax
  80c9f7:	66 89 47 2a          	mov    %ax,0x2a(%edi)
        if (inseg.p->tot_len > 0) {
  80c9fb:	a1 1c b2 b3 00       	mov    0xb3b21c,%eax
  80ca00:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80ca05:	74 0f                	je     80ca16 <tcp_receive+0x6fc>
          recv_data = inseg.p;
  80ca07:	a3 fc b1 b3 00       	mov    %eax,0xb3b1fc
          inseg.p = NULL;
  80ca0c:	c7 05 1c b2 b3 00 00 	movl   $0x0,0xb3b21c
  80ca13:	00 00 00 
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80ca16:	83 ec 0c             	sub    $0xc,%esp
  80ca19:	a1 28 b2 b3 00       	mov    0xb3b228,%eax
  80ca1e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca22:	50                   	push   %eax
  80ca23:	e8 6b ac ff ff       	call   807693 <ntohs>
  80ca28:	83 c4 10             	add    $0x10,%esp
  80ca2b:	a8 01                	test   $0x1,%al
  80ca2d:	0f 84 da 01 00 00    	je     80cc0d <tcp_receive+0x8f3>
          recv_flags = TF_GOT_FIN;
  80ca33:	c6 05 00 b2 b3 00 20 	movb   $0x20,0xb3b200
  80ca3a:	e9 ce 01 00 00       	jmp    80cc0d <tcp_receive+0x8f3>
          if (pcb->ooseq->len > 0) {
  80ca3f:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80ca44:	74 23                	je     80ca69 <tcp_receive+0x74f>
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80ca46:	29 d3                	sub    %edx,%ebx
  80ca48:	66 89 1d 24 b2 b3 00 	mov    %bx,0xb3b224
            pbuf_realloc(inseg.p, inseg.len);
  80ca4f:	83 ec 08             	sub    $0x8,%esp
  80ca52:	0f b7 db             	movzwl %bx,%ebx
  80ca55:	53                   	push   %ebx
  80ca56:	ff 35 1c b2 b3 00    	push   0xb3b21c
  80ca5c:	e8 10 81 ff ff       	call   804b71 <pbuf_realloc>
  80ca61:	83 c4 10             	add    $0x10,%esp
  80ca64:	e9 24 ff ff ff       	jmp    80c98d <tcp_receive+0x673>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80ca69:	83 ec 0c             	sub    $0xc,%esp
  80ca6c:	a1 28 b2 b3 00       	mov    0xb3b228,%eax
  80ca71:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca75:	50                   	push   %eax
  80ca76:	e8 18 ac ff ff       	call   807693 <ntohs>
  80ca7b:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80ca7d:	8b 47 7c             	mov    0x7c(%edi),%eax
  80ca80:	8b 40 10             	mov    0x10(%eax),%eax
  80ca83:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca87:	89 04 24             	mov    %eax,(%esp)
  80ca8a:	e8 04 ac ff ff       	call   807693 <ntohs>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80ca8f:	31 c3                	xor    %eax,%ebx
  80ca91:	83 c4 10             	add    $0x10,%esp
  80ca94:	f6 c3 03             	test   $0x3,%bl
  80ca97:	0f 85 f0 fe ff ff    	jne    80c98d <tcp_receive+0x673>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80ca9d:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80caa0:	8b 10                	mov    (%eax),%edx
  80caa2:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80caa5:	83 ec 08             	sub    $0x8,%esp
  80caa8:	50                   	push   %eax
  80caa9:	6a 04                	push   $0x4
  80caab:	e8 4b 7a ff ff       	call   8044fb <memp_free>
  80cab0:	83 c4 10             	add    $0x10,%esp
  80cab3:	e9 d5 fe ff ff       	jmp    80c98d <tcp_receive+0x673>
        tcplen = TCP_TCPLEN(&inseg);
  80cab8:	83 ec 0c             	sub    $0xc,%esp
  80cabb:	a1 28 b2 b3 00       	mov    0xb3b228,%eax
  80cac0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cac4:	50                   	push   %eax
  80cac5:	e8 c9 ab ff ff       	call   807693 <ntohs>
  80caca:	66 d1 e8             	shr    %ax
  80cacd:	83 e0 01             	and    $0x1,%eax
  80cad0:	83 c4 10             	add    $0x10,%esp
  80cad3:	e9 e1 fe ff ff       	jmp    80c9b9 <tcp_receive+0x69f>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cad8:	83 ec 0c             	sub    $0xc,%esp
  80cadb:	8b 43 10             	mov    0x10(%ebx),%eax
  80cade:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cae2:	50                   	push   %eax
  80cae3:	e8 ab ab ff ff       	call   807693 <ntohs>
  80cae8:	66 d1 e8             	shr    %ax
  80caeb:	83 e0 01             	and    $0x1,%eax
  80caee:	83 c4 10             	add    $0x10,%esp
  80caf1:	e9 5a 01 00 00       	jmp    80cc50 <tcp_receive+0x936>
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80caf6:	83 ec 0c             	sub    $0xc,%esp
  80caf9:	8b 43 10             	mov    0x10(%ebx),%eax
  80cafc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb00:	50                   	push   %eax
  80cb01:	e8 8d ab ff ff       	call   807693 <ntohs>
  80cb06:	66 d1 e8             	shr    %ax
  80cb09:	83 e0 01             	and    $0x1,%eax
  80cb0c:	83 c4 10             	add    $0x10,%esp
  80cb0f:	e9 6f 01 00 00       	jmp    80cc83 <tcp_receive+0x969>
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80cb14:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cb18:	83 ec 0c             	sub    $0xc,%esp
  80cb1b:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb1e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb22:	50                   	push   %eax
  80cb23:	e8 6b ab ff ff       	call   807693 <ntohs>
  80cb28:	89 c2                	mov    %eax,%edx
  80cb2a:	83 c4 10             	add    $0x10,%esp
  80cb2d:	b8 01 00 00 00       	mov    $0x1,%eax
  80cb32:	f6 c2 01             	test   $0x1,%dl
  80cb35:	74 0d                	je     80cb44 <tcp_receive+0x82a>
  80cb37:	01 f0                	add    %esi,%eax
  80cb39:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80cb3d:	29 c2                	sub    %eax,%edx
  80cb3f:	e9 4f 01 00 00       	jmp    80cc93 <tcp_receive+0x979>
  80cb44:	83 ec 0c             	sub    $0xc,%esp
  80cb47:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb4a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb4e:	50                   	push   %eax
  80cb4f:	e8 3f ab ff ff       	call   807693 <ntohs>
  80cb54:	66 d1 e8             	shr    %ax
  80cb57:	83 e0 01             	and    $0x1,%eax
  80cb5a:	83 c4 10             	add    $0x10,%esp
  80cb5d:	eb d8                	jmp    80cb37 <tcp_receive+0x81d>
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cb5f:	83 ec 0c             	sub    $0xc,%esp
  80cb62:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb65:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb69:	50                   	push   %eax
  80cb6a:	e8 24 ab ff ff       	call   807693 <ntohs>
  80cb6f:	66 d1 e8             	shr    %ax
  80cb72:	83 e0 01             	and    $0x1,%eax
  80cb75:	83 c4 10             	add    $0x10,%esp
  80cb78:	e9 48 01 00 00       	jmp    80ccc5 <tcp_receive+0x9ab>
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80cb7d:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cb81:	83 ec 0c             	sub    $0xc,%esp
  80cb84:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb87:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb8b:	50                   	push   %eax
  80cb8c:	e8 02 ab ff ff       	call   807693 <ntohs>
  80cb91:	89 c2                	mov    %eax,%edx
  80cb93:	83 c4 10             	add    $0x10,%esp
  80cb96:	b8 01 00 00 00       	mov    $0x1,%eax
  80cb9b:	f6 c2 01             	test   $0x1,%dl
  80cb9e:	74 0d                	je     80cbad <tcp_receive+0x893>
  80cba0:	01 f0                	add    %esi,%eax
  80cba2:	0f b7 57 2a          	movzwl 0x2a(%edi),%edx
  80cba6:	29 c2                	sub    %eax,%edx
  80cba8:	e9 28 01 00 00       	jmp    80ccd5 <tcp_receive+0x9bb>
  80cbad:	83 ec 0c             	sub    $0xc,%esp
  80cbb0:	8b 43 10             	mov    0x10(%ebx),%eax
  80cbb3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbb7:	50                   	push   %eax
  80cbb8:	e8 d6 aa ff ff       	call   807693 <ntohs>
  80cbbd:	66 d1 e8             	shr    %ax
  80cbc0:	83 e0 01             	and    $0x1,%eax
  80cbc3:	83 c4 10             	add    $0x10,%esp
  80cbc6:	eb d8                	jmp    80cba0 <tcp_receive+0x886>
              recv_data = cseg->p;
  80cbc8:	a3 fc b1 b3 00       	mov    %eax,0xb3b1fc
            cseg->p = NULL;
  80cbcd:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80cbd4:	83 ec 0c             	sub    $0xc,%esp
  80cbd7:	8b 43 10             	mov    0x10(%ebx),%eax
  80cbda:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbde:	50                   	push   %eax
  80cbdf:	e8 af aa ff ff       	call   807693 <ntohs>
  80cbe4:	83 c4 10             	add    $0x10,%esp
  80cbe7:	a8 01                	test   $0x1,%al
  80cbe9:	74 11                	je     80cbfc <tcp_receive+0x8e2>
            recv_flags = TF_GOT_FIN;
  80cbeb:	c6 05 00 b2 b3 00 20 	movb   $0x20,0xb3b200
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80cbf2:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80cbf6:	0f 84 0b 01 00 00    	je     80cd07 <tcp_receive+0x9ed>
          pcb->ooseq = cseg->next;
  80cbfc:	8b 03                	mov    (%ebx),%eax
  80cbfe:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80cc01:	83 ec 0c             	sub    $0xc,%esp
  80cc04:	53                   	push   %ebx
  80cc05:	e8 25 8b ff ff       	call   80572f <tcp_seg_free>
  80cc0a:	83 c4 10             	add    $0x10,%esp
        while (pcb->ooseq != NULL &&
  80cc0d:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cc10:	85 db                	test   %ebx,%ebx
  80cc12:	0f 84 fb 00 00 00    	je     80cd13 <tcp_receive+0x9f9>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80cc18:	8b 53 10             	mov    0x10(%ebx),%edx
  80cc1b:	8b 42 04             	mov    0x4(%edx),%eax
        while (pcb->ooseq != NULL &&
  80cc1e:	3b 47 24             	cmp    0x24(%edi),%eax
  80cc21:	0f 85 ec 00 00 00    	jne    80cd13 <tcp_receive+0x9f9>
          seqno = pcb->ooseq->tcphdr->seqno;
  80cc27:	a3 0c b2 b3 00       	mov    %eax,0xb3b20c
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cc2c:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cc30:	83 ec 0c             	sub    $0xc,%esp
  80cc33:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80cc37:	50                   	push   %eax
  80cc38:	e8 56 aa ff ff       	call   807693 <ntohs>
  80cc3d:	89 c2                	mov    %eax,%edx
  80cc3f:	83 c4 10             	add    $0x10,%esp
  80cc42:	b8 01 00 00 00       	mov    $0x1,%eax
  80cc47:	f6 c2 01             	test   $0x1,%dl
  80cc4a:	0f 84 88 fe ff ff    	je     80cad8 <tcp_receive+0x7be>
  80cc50:	01 f0                	add    %esi,%eax
  80cc52:	01 47 24             	add    %eax,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cc55:	0f b7 77 28          	movzwl 0x28(%edi),%esi
  80cc59:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80cc5d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cc60:	83 ec 0c             	sub    $0xc,%esp
  80cc63:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc66:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc6a:	50                   	push   %eax
  80cc6b:	e8 23 aa ff ff       	call   807693 <ntohs>
  80cc70:	89 c2                	mov    %eax,%edx
  80cc72:	83 c4 10             	add    $0x10,%esp
  80cc75:	b8 01 00 00 00       	mov    $0x1,%eax
  80cc7a:	f6 c2 01             	test   $0x1,%dl
  80cc7d:	0f 84 73 fe ff ff    	je     80caf6 <tcp_receive+0x7dc>
  80cc83:	03 45 e4             	add    -0x1c(%ebp),%eax
  80cc86:	ba 00 00 00 00       	mov    $0x0,%edx
  80cc8b:	39 c6                	cmp    %eax,%esi
  80cc8d:	0f 8d 81 fe ff ff    	jge    80cb14 <tcp_receive+0x7fa>
            pcb->rcv_wnd = 0;
  80cc93:	66 89 57 28          	mov    %dx,0x28(%edi)
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cc97:	0f b7 77 2a          	movzwl 0x2a(%edi),%esi
  80cc9b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80cc9f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cca2:	83 ec 0c             	sub    $0xc,%esp
  80cca5:	8b 43 10             	mov    0x10(%ebx),%eax
  80cca8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ccac:	50                   	push   %eax
  80ccad:	e8 e1 a9 ff ff       	call   807693 <ntohs>
  80ccb2:	89 c2                	mov    %eax,%edx
  80ccb4:	83 c4 10             	add    $0x10,%esp
  80ccb7:	b8 01 00 00 00       	mov    $0x1,%eax
  80ccbc:	f6 c2 01             	test   $0x1,%dl
  80ccbf:	0f 84 9a fe ff ff    	je     80cb5f <tcp_receive+0x845>
  80ccc5:	03 45 e4             	add    -0x1c(%ebp),%eax
  80ccc8:	ba 00 00 00 00       	mov    $0x0,%edx
  80cccd:	39 c6                	cmp    %eax,%esi
  80cccf:	0f 8d a8 fe ff ff    	jge    80cb7d <tcp_receive+0x863>
            pcb->rcv_ann_wnd = 0;
  80ccd5:	66 89 57 2a          	mov    %dx,0x2a(%edi)
          if (cseg->p->tot_len > 0) {
  80ccd9:	8b 43 04             	mov    0x4(%ebx),%eax
  80ccdc:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cce1:	0f 84 ed fe ff ff    	je     80cbd4 <tcp_receive+0x8ba>
            if (recv_data) {
  80cce7:	8b 15 fc b1 b3 00    	mov    0xb3b1fc,%edx
  80cced:	85 d2                	test   %edx,%edx
  80ccef:	0f 84 d3 fe ff ff    	je     80cbc8 <tcp_receive+0x8ae>
              pbuf_cat(recv_data, cseg->p);
  80ccf5:	83 ec 08             	sub    $0x8,%esp
  80ccf8:	50                   	push   %eax
  80ccf9:	52                   	push   %edx
  80ccfa:	e8 af 7f ff ff       	call   804cae <pbuf_cat>
  80ccff:	83 c4 10             	add    $0x10,%esp
  80cd02:	e9 c6 fe ff ff       	jmp    80cbcd <tcp_receive+0x8b3>
              pcb->state = CLOSE_WAIT;
  80cd07:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
  80cd0e:	e9 e9 fe ff ff       	jmp    80cbfc <tcp_receive+0x8e2>
        tcp_ack(pcb);
  80cd13:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80cd17:	89 c1                	mov    %eax,%ecx
  80cd19:	83 e1 01             	and    $0x1,%ecx
  80cd1c:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  80cd1f:	75 0f                	jne    80cd30 <tcp_receive+0xa16>
  80cd21:	83 c8 01             	or     $0x1,%eax
  80cd24:	88 47 20             	mov    %al,0x20(%edi)
        accepted_inseq = 1; 
  80cd27:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  80cd2b:	e9 c1 02 00 00       	jmp    80cff1 <tcp_receive+0xcd7>
        tcp_ack(pcb);
  80cd30:	83 e0 fe             	and    $0xfffffffe,%eax
  80cd33:	83 c8 02             	or     $0x2,%eax
  80cd36:	88 47 20             	mov    %al,0x20(%edi)
  80cd39:	83 ec 0c             	sub    $0xc,%esp
  80cd3c:	57                   	push   %edi
  80cd3d:	e8 af b2 ff ff       	call   807ff1 <tcp_output>
  80cd42:	83 c4 10             	add    $0x10,%esp
  80cd45:	e9 a7 02 00 00       	jmp    80cff1 <tcp_receive+0xcd7>
        tcp_ack_now(pcb);
  80cd4a:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cd4e:	83 ec 0c             	sub    $0xc,%esp
  80cd51:	57                   	push   %edi
  80cd52:	e8 9a b2 ff ff       	call   807ff1 <tcp_output>
        if (pcb->ooseq == NULL) {
  80cd57:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cd5a:	83 c4 10             	add    $0x10,%esp
  80cd5d:	85 db                	test   %ebx,%ebx
  80cd5f:	74 1e                	je     80cd7f <tcp_receive+0xa65>
            if (seqno == next->tcphdr->seqno) {
  80cd61:	8b 0d 0c b2 b3 00    	mov    0xb3b20c,%ecx
  80cd67:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80cd6a:	8d 51 01             	lea    0x1(%ecx),%edx
  80cd6d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
          prev = NULL;
  80cd70:	be 00 00 00 00       	mov    $0x0,%esi
  80cd75:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80cd78:	89 c7                	mov    %eax,%edi
  80cd7a:	e9 d7 00 00 00       	jmp    80ce56 <tcp_receive+0xb3c>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80cd7f:	83 ec 0c             	sub    $0xc,%esp
  80cd82:	68 18 b2 b3 00       	push   $0xb3b218
  80cd87:	e8 1c 8a ff ff       	call   8057a8 <tcp_seg_copy>
  80cd8c:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cd8f:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cd92:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cd96:	e9 56 02 00 00       	jmp    80cff1 <tcp_receive+0xcd7>
  80cd9b:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80cd9e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (inseg.len > next->len) {
  80cda2:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80cda6:	66 39 05 24 b2 b3 00 	cmp    %ax,0xb3b224
  80cdad:	0f 86 3e 02 00 00    	jbe    80cff1 <tcp_receive+0xcd7>
                cseg = tcp_seg_copy(&inseg);
  80cdb3:	83 ec 0c             	sub    $0xc,%esp
  80cdb6:	68 18 b2 b3 00       	push   $0xb3b218
  80cdbb:	e8 e8 89 ff ff       	call   8057a8 <tcp_seg_copy>
  80cdc0:	89 c1                	mov    %eax,%ecx
  80cdc2:	89 45 e0             	mov    %eax,-0x20(%ebp)
                if (cseg != NULL) {
  80cdc5:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cdc8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80cdcc:	85 c0                	test   %eax,%eax
  80cdce:	0f 84 1d 02 00 00    	je     80cff1 <tcp_receive+0xcd7>
                  cseg->next = next->next;
  80cdd4:	8b 03                	mov    (%ebx),%eax
  80cdd6:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80cdd8:	85 f6                	test   %esi,%esi
  80cdda:	74 5c                	je     80ce38 <tcp_receive+0xb1e>
                    prev->next = cseg;
  80cddc:	89 0e                	mov    %ecx,(%esi)
                  tcp_seg_free(next);
  80cdde:	83 ec 0c             	sub    $0xc,%esp
  80cde1:	53                   	push   %ebx
  80cde2:	e8 48 89 ff ff       	call   80572f <tcp_seg_free>
                  if (cseg->next != NULL) {
  80cde7:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80cdea:	8b 06                	mov    (%esi),%eax
  80cdec:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cdef:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg->next != NULL) {
  80cdf3:	85 c0                	test   %eax,%eax
  80cdf5:	0f 84 f6 01 00 00    	je     80cff1 <tcp_receive+0xcd7>
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80cdfb:	8b 0d 0c b2 b3 00    	mov    0xb3b20c,%ecx
  80ce01:	8b 40 10             	mov    0x10(%eax),%eax
  80ce04:	8b 40 04             	mov    0x4(%eax),%eax
  80ce07:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80ce0b:	01 ca                	add    %ecx,%edx
  80ce0d:	29 c2                	sub    %eax,%edx
  80ce0f:	85 d2                	test   %edx,%edx
  80ce11:	0f 8e da 01 00 00    	jle    80cff1 <tcp_receive+0xcd7>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80ce17:	29 c8                	sub    %ecx,%eax
  80ce19:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80ce1d:	83 ec 08             	sub    $0x8,%esp
  80ce20:	0f b7 c0             	movzwl %ax,%eax
  80ce23:	50                   	push   %eax
  80ce24:	ff 76 04             	push   0x4(%esi)
  80ce27:	e8 45 7d ff ff       	call   804b71 <pbuf_realloc>
  80ce2c:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ce2f:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80ce33:	e9 b9 01 00 00       	jmp    80cff1 <tcp_receive+0xcd7>
                    pcb->ooseq = cseg;
  80ce38:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ce3b:	89 47 7c             	mov    %eax,0x7c(%edi)
  80ce3e:	eb 9e                	jmp    80cdde <tcp_receive+0xac4>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80ce40:	39 c1                	cmp    %eax,%ecx
  80ce42:	0f 88 a0 00 00 00    	js     80cee8 <tcp_receive+0xbce>
              if (next->next == NULL &&
  80ce48:	8b 13                	mov    (%ebx),%edx
  80ce4a:	89 de                	mov    %ebx,%esi
  80ce4c:	85 d2                	test   %edx,%edx
  80ce4e:	0f 84 0d 01 00 00    	je     80cf61 <tcp_receive+0xc47>
  80ce54:	89 d3                	mov    %edx,%ebx
            if (seqno == next->tcphdr->seqno) {
  80ce56:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce59:	8b 40 04             	mov    0x4(%eax),%eax
  80ce5c:	39 c8                	cmp    %ecx,%eax
  80ce5e:	0f 84 37 ff ff ff    	je     80cd9b <tcp_receive+0xa81>
              if (prev == NULL) {
  80ce64:	85 f6                	test   %esi,%esi
  80ce66:	74 d8                	je     80ce40 <tcp_receive+0xb26>
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80ce68:	8b 56 10             	mov    0x10(%esi),%edx
  80ce6b:	3b 7a 04             	cmp    0x4(%edx),%edi
  80ce6e:	78 d8                	js     80ce48 <tcp_receive+0xb2e>
  80ce70:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80ce73:	29 c2                	sub    %eax,%edx
  80ce75:	85 d2                	test   %edx,%edx
  80ce77:	7f cf                	jg     80ce48 <tcp_receive+0xb2e>
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80ce79:	0f b7 15 24 b2 b3 00 	movzwl 0xb3b224,%edx
  80ce80:	01 ca                	add    %ecx,%edx
  80ce82:	29 c2                	sub    %eax,%edx
  80ce84:	85 d2                	test   %edx,%edx
  80ce86:	0f 8f b3 00 00 00    	jg     80cf3f <tcp_receive+0xc25>
                cseg = tcp_seg_copy(&inseg);
  80ce8c:	83 ec 0c             	sub    $0xc,%esp
  80ce8f:	68 18 b2 b3 00       	push   $0xb3b218
  80ce94:	e8 0f 89 ff ff       	call   8057a8 <tcp_seg_copy>
                if (cseg != NULL) {
  80ce99:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ce9c:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80cea0:	85 c0                	test   %eax,%eax
  80cea2:	0f 84 49 01 00 00    	je     80cff1 <tcp_receive+0xcd7>
                  cseg->next = next;
  80cea8:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80ceaa:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80ceac:	8b 46 10             	mov    0x10(%esi),%eax
  80ceaf:	8b 48 04             	mov    0x4(%eax),%ecx
  80ceb2:	a1 0c b2 b3 00       	mov    0xb3b20c,%eax
  80ceb7:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80cebb:	01 ca                	add    %ecx,%edx
  80cebd:	29 c2                	sub    %eax,%edx
  80cebf:	85 d2                	test   %edx,%edx
  80cec1:	0f 8e 2a 01 00 00    	jle    80cff1 <tcp_receive+0xcd7>
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80cec7:	29 c8                	sub    %ecx,%eax
  80cec9:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80cecd:	83 ec 08             	sub    $0x8,%esp
  80ced0:	0f b7 c0             	movzwl %ax,%eax
  80ced3:	50                   	push   %eax
  80ced4:	ff 76 04             	push   0x4(%esi)
  80ced7:	e8 95 7c ff ff       	call   804b71 <pbuf_realloc>
  80cedc:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cedf:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cee3:	e9 09 01 00 00       	jmp    80cff1 <tcp_receive+0xcd7>
                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cee8:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80ceeb:	0f b7 15 24 b2 b3 00 	movzwl 0xb3b224,%edx
  80cef2:	01 ca                	add    %ecx,%edx
  80cef4:	29 c2                	sub    %eax,%edx
  80cef6:	85 d2                	test   %edx,%edx
  80cef8:	7f 26                	jg     80cf20 <tcp_receive+0xc06>
                  cseg = tcp_seg_copy(&inseg);
  80cefa:	83 ec 0c             	sub    $0xc,%esp
  80cefd:	68 18 b2 b3 00       	push   $0xb3b218
  80cf02:	e8 a1 88 ff ff       	call   8057a8 <tcp_seg_copy>
                  if (cseg != NULL) {
  80cf07:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf0a:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg != NULL) {
  80cf0e:	85 c0                	test   %eax,%eax
  80cf10:	0f 84 db 00 00 00    	je     80cff1 <tcp_receive+0xcd7>
                    cseg->next = next;
  80cf16:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80cf18:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cf1b:	e9 d1 00 00 00       	jmp    80cff1 <tcp_receive+0xcd7>
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cf20:	29 c8                	sub    %ecx,%eax
  80cf22:	66 a3 24 b2 b3 00    	mov    %ax,0xb3b224
                    pbuf_realloc(inseg.p, inseg.len);
  80cf28:	83 ec 08             	sub    $0x8,%esp
  80cf2b:	0f b7 c0             	movzwl %ax,%eax
  80cf2e:	50                   	push   %eax
  80cf2f:	ff 35 1c b2 b3 00    	push   0xb3b21c
  80cf35:	e8 37 7c ff ff       	call   804b71 <pbuf_realloc>
  80cf3a:	83 c4 10             	add    $0x10,%esp
  80cf3d:	eb bb                	jmp    80cefa <tcp_receive+0xbe0>
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cf3f:	29 c8                	sub    %ecx,%eax
  80cf41:	66 a3 24 b2 b3 00    	mov    %ax,0xb3b224
                  pbuf_realloc(inseg.p, inseg.len);
  80cf47:	83 ec 08             	sub    $0x8,%esp
  80cf4a:	0f b7 c0             	movzwl %ax,%eax
  80cf4d:	50                   	push   %eax
  80cf4e:	ff 35 1c b2 b3 00    	push   0xb3b21c
  80cf54:	e8 18 7c ff ff       	call   804b71 <pbuf_realloc>
  80cf59:	83 c4 10             	add    $0x10,%esp
  80cf5c:	e9 2b ff ff ff       	jmp    80ce8c <tcp_receive+0xb72>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80cf61:	29 c1                	sub    %eax,%ecx
  u8_t accepted_inseq = 0;
  80cf63:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (next->next == NULL &&
  80cf67:	85 c9                	test   %ecx,%ecx
  80cf69:	0f 8e 82 00 00 00    	jle    80cff1 <tcp_receive+0xcd7>
                next->next = tcp_seg_copy(&inseg);
  80cf6f:	83 ec 0c             	sub    $0xc,%esp
  80cf72:	68 18 b2 b3 00       	push   $0xb3b218
  80cf77:	e8 2c 88 ff ff       	call   8057a8 <tcp_seg_copy>
  80cf7c:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80cf7e:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf81:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (next->next != NULL) {
  80cf85:	85 c0                	test   %eax,%eax
  80cf87:	74 68                	je     80cff1 <tcp_receive+0xcd7>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80cf89:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf8c:	8b 48 04             	mov    0x4(%eax),%ecx
  80cf8f:	a1 0c b2 b3 00       	mov    0xb3b20c,%eax
  80cf94:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80cf98:	01 ca                	add    %ecx,%edx
  80cf9a:	29 c2                	sub    %eax,%edx
  80cf9c:	85 d2                	test   %edx,%edx
  80cf9e:	7e 51                	jle    80cff1 <tcp_receive+0xcd7>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80cfa0:	29 c8                	sub    %ecx,%eax
  80cfa2:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80cfa6:	83 ec 08             	sub    $0x8,%esp
  80cfa9:	0f b7 c0             	movzwl %ax,%eax
  80cfac:	50                   	push   %eax
  80cfad:	ff 73 04             	push   0x4(%ebx)
  80cfb0:	e8 bc 7b ff ff       	call   804b71 <pbuf_realloc>
  80cfb5:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cfb8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cfbc:	eb 33                	jmp    80cff1 <tcp_receive+0xcd7>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80cfbe:	a1 0c b2 b3 00       	mov    0xb3b20c,%eax
  80cfc3:	8b 57 24             	mov    0x24(%edi),%edx
  80cfc6:	39 d0                	cmp    %edx,%eax
  80cfc8:	78 13                	js     80cfdd <tcp_receive+0xcc3>
  80cfca:	83 c0 01             	add    $0x1,%eax
  80cfcd:	29 d0                	sub    %edx,%eax
  80cfcf:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80cfd3:	29 d0                	sub    %edx,%eax
  u8_t accepted_inseq = 0;
  80cfd5:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80cfd9:	85 c0                	test   %eax,%eax
  80cfdb:	7e 14                	jle    80cff1 <tcp_receive+0xcd7>
      tcp_ack_now(pcb);
  80cfdd:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cfe1:	83 ec 0c             	sub    $0xc,%esp
  80cfe4:	57                   	push   %edi
  80cfe5:	e8 07 b0 ff ff       	call   807ff1 <tcp_output>
  80cfea:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cfed:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
}
  80cff1:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80cff5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80cff8:	5b                   	pop    %ebx
  80cff9:	5e                   	pop    %esi
  80cffa:	5f                   	pop    %edi
  80cffb:	5d                   	pop    %ebp
  80cffc:	c3                   	ret    

0080cffd <tcp_input>:
{
  80cffd:	55                   	push   %ebp
  80cffe:	89 e5                	mov    %esp,%ebp
  80d000:	57                   	push   %edi
  80d001:	56                   	push   %esi
  80d002:	53                   	push   %ebx
  80d003:	83 ec 38             	sub    $0x38,%esp
  80d006:	8b 75 08             	mov    0x8(%ebp),%esi
  iphdr = p->payload;
  80d009:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d00c:	89 1d 10 b2 b3 00    	mov    %ebx,0xb3b210
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d012:	0f b7 03             	movzwl (%ebx),%eax
  80d015:	50                   	push   %eax
  80d016:	e8 78 a6 ff ff       	call   807693 <ntohs>
  80d01b:	66 c1 e8 08          	shr    $0x8,%ax
  80d01f:	83 e0 0f             	and    $0xf,%eax
  80d022:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80d025:	a3 14 b2 b3 00       	mov    %eax,0xb3b214
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d02a:	a1 10 b2 b3 00       	mov    0xb3b210,%eax
  80d02f:	0f b7 00             	movzwl (%eax),%eax
  80d032:	89 04 24             	mov    %eax,(%esp)
  80d035:	e8 59 a6 ff ff       	call   807693 <ntohs>
  80d03a:	83 c4 08             	add    $0x8,%esp
  80d03d:	66 c1 e8 06          	shr    $0x6,%ax
  80d041:	83 e0 3c             	and    $0x3c,%eax
  80d044:	f7 d8                	neg    %eax
  80d046:	98                   	cwtl   
  80d047:	50                   	push   %eax
  80d048:	56                   	push   %esi
  80d049:	e8 2f 77 ff ff       	call   80477d <pbuf_header>
  80d04e:	83 c4 10             	add    $0x10,%esp
  80d051:	84 c0                	test   %al,%al
  80d053:	75 07                	jne    80d05c <tcp_input+0x5f>
  80d055:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80d05a:	77 14                	ja     80d070 <tcp_input+0x73>
    pbuf_free(p);
  80d05c:	83 ec 0c             	sub    $0xc,%esp
  80d05f:	56                   	push   %esi
  80d060:	e8 e7 77 ff ff       	call   80484c <pbuf_free>
    return;
  80d065:	83 c4 10             	add    $0x10,%esp
}
  80d068:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d06b:	5b                   	pop    %ebx
  80d06c:	5e                   	pop    %esi
  80d06d:	5f                   	pop    %edi
  80d06e:	5d                   	pop    %ebp
  80d06f:	c3                   	ret    
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d070:	83 ec 08             	sub    $0x8,%esp
  80d073:	ff 75 0c             	push   0xc(%ebp)
  80d076:	a1 10 b2 b3 00       	mov    0xb3b210,%eax
  80d07b:	83 c0 10             	add    $0x10,%eax
  80d07e:	50                   	push   %eax
  80d07f:	e8 c6 93 ff ff       	call   80644a <ip_addr_isbroadcast>
  80d084:	83 c4 10             	add    $0x10,%esp
  80d087:	84 c0                	test   %al,%al
  80d089:	0f 85 54 01 00 00    	jne    80d1e3 <tcp_input+0x1e6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d08f:	a1 10 b2 b3 00       	mov    0xb3b210,%eax
  80d094:	8b 58 10             	mov    0x10(%eax),%ebx
  80d097:	83 ec 0c             	sub    $0xc,%esp
  80d09a:	68 00 00 00 f0       	push   $0xf0000000
  80d09f:	e8 24 a8 ff ff       	call   8078c8 <ntohl>
  80d0a4:	21 c3                	and    %eax,%ebx
  80d0a6:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d0ad:	e8 16 a8 ff ff       	call   8078c8 <ntohl>
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d0b2:	83 c4 10             	add    $0x10,%esp
  80d0b5:	39 c3                	cmp    %eax,%ebx
  80d0b7:	0f 84 26 01 00 00    	je     80d1e3 <tcp_input+0x1e6>
      (struct ip_addr *)&(iphdr->dest),
  80d0bd:	a1 10 b2 b3 00       	mov    0xb3b210,%eax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d0c2:	83 ec 0c             	sub    $0xc,%esp
  80d0c5:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80d0c9:	52                   	push   %edx
  80d0ca:	6a 06                	push   $0x6
  80d0cc:	8d 50 10             	lea    0x10(%eax),%edx
  80d0cf:	52                   	push   %edx
  80d0d0:	83 c0 0c             	add    $0xc,%eax
  80d0d3:	50                   	push   %eax
  80d0d4:	56                   	push   %esi
  80d0d5:	e8 90 a2 ff ff       	call   80736a <inet_chksum_pseudo>
  80d0da:	83 c4 20             	add    $0x20,%esp
  80d0dd:	66 85 c0             	test   %ax,%ax
  80d0e0:	0f 85 0e 01 00 00    	jne    80d1f4 <tcp_input+0x1f7>
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d0e6:	83 ec 0c             	sub    $0xc,%esp
  80d0e9:	a1 14 b2 b3 00       	mov    0xb3b214,%eax
  80d0ee:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d0f2:	50                   	push   %eax
  80d0f3:	e8 9b a5 ff ff       	call   807693 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d0f8:	83 c4 08             	add    $0x8,%esp
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d0fb:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80d0ff:	f7 d8                	neg    %eax
  80d101:	c1 e0 02             	shl    $0x2,%eax
  80d104:	98                   	cwtl   
  80d105:	50                   	push   %eax
  80d106:	56                   	push   %esi
  80d107:	e8 71 76 ff ff       	call   80477d <pbuf_header>
  80d10c:	83 c4 10             	add    $0x10,%esp
  80d10f:	84 c0                	test   %al,%al
  80d111:	0f 85 ee 00 00 00    	jne    80d205 <tcp_input+0x208>
  tcphdr->src = ntohs(tcphdr->src);
  80d117:	8b 1d 14 b2 b3 00    	mov    0xb3b214,%ebx
  80d11d:	83 ec 0c             	sub    $0xc,%esp
  80d120:	0f b7 03             	movzwl (%ebx),%eax
  80d123:	50                   	push   %eax
  80d124:	e8 6a a5 ff ff       	call   807693 <ntohs>
  80d129:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d12c:	8b 1d 14 b2 b3 00    	mov    0xb3b214,%ebx
  80d132:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d136:	89 04 24             	mov    %eax,(%esp)
  80d139:	e8 55 a5 ff ff       	call   807693 <ntohs>
  80d13e:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d142:	8b 1d 14 b2 b3 00    	mov    0xb3b214,%ebx
  80d148:	83 c4 04             	add    $0x4,%esp
  80d14b:	ff 73 04             	push   0x4(%ebx)
  80d14e:	e8 75 a7 ff ff       	call   8078c8 <ntohl>
  80d153:	89 43 04             	mov    %eax,0x4(%ebx)
  80d156:	a3 0c b2 b3 00       	mov    %eax,0xb3b20c
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d15b:	8b 1d 14 b2 b3 00    	mov    0xb3b214,%ebx
  80d161:	83 c4 04             	add    $0x4,%esp
  80d164:	ff 73 08             	push   0x8(%ebx)
  80d167:	e8 5c a7 ff ff       	call   8078c8 <ntohl>
  80d16c:	89 43 08             	mov    %eax,0x8(%ebx)
  80d16f:	a3 08 b2 b3 00       	mov    %eax,0xb3b208
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d174:	8b 1d 14 b2 b3 00    	mov    0xb3b214,%ebx
  80d17a:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d17e:	89 04 24             	mov    %eax,(%esp)
  80d181:	e8 0d a5 ff ff       	call   807693 <ntohs>
  80d186:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d18a:	a1 14 b2 b3 00       	mov    0xb3b214,%eax
  80d18f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d193:	89 04 24             	mov    %eax,(%esp)
  80d196:	e8 f8 a4 ff ff       	call   807693 <ntohs>
  80d19b:	89 c1                	mov    %eax,%ecx
  80d19d:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d1a1:	83 e0 3f             	and    $0x3f,%eax
  80d1a4:	a2 04 b2 b3 00       	mov    %al,0xb3b204
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d1a9:	83 c4 10             	add    $0x10,%esp
  80d1ac:	f6 c1 03             	test   $0x3,%cl
  80d1af:	0f 95 c0             	setne  %al
  80d1b2:	0f b6 c0             	movzbl %al,%eax
  80d1b5:	66 03 46 08          	add    0x8(%esi),%ax
  80d1b9:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d1bd:	66 a3 02 b2 b3 00    	mov    %ax,0xb3b202
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d1c3:	a1 4c 44 b3 00       	mov    0xb3444c,%eax
  80d1c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if (pcb->remote_port == tcphdr->src &&
  80d1cb:	8b 15 14 b2 b3 00    	mov    0xb3b214,%edx
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d1d1:	8b 0d 10 b2 b3 00    	mov    0xb3b210,%ecx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d1d7:	89 c3                	mov    %eax,%ebx
  prev = NULL;
  80d1d9:	bf 00 00 00 00       	mov    $0x0,%edi
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d1de:	e9 ab 00 00 00       	jmp    80d28e <tcp_input+0x291>
    pbuf_free(p);
  80d1e3:	83 ec 0c             	sub    $0xc,%esp
  80d1e6:	56                   	push   %esi
  80d1e7:	e8 60 76 ff ff       	call   80484c <pbuf_free>
    return;
  80d1ec:	83 c4 10             	add    $0x10,%esp
  80d1ef:	e9 74 fe ff ff       	jmp    80d068 <tcp_input+0x6b>
    pbuf_free(p);
  80d1f4:	83 ec 0c             	sub    $0xc,%esp
  80d1f7:	56                   	push   %esi
  80d1f8:	e8 4f 76 ff ff       	call   80484c <pbuf_free>
    return;
  80d1fd:	83 c4 10             	add    $0x10,%esp
  80d200:	e9 63 fe ff ff       	jmp    80d068 <tcp_input+0x6b>
    pbuf_free(p);
  80d205:	83 ec 0c             	sub    $0xc,%esp
  80d208:	56                   	push   %esi
  80d209:	e8 3e 76 ff ff       	call   80484c <pbuf_free>
    return;
  80d20e:	83 c4 10             	add    $0x10,%esp
  80d211:	e9 52 fe ff ff       	jmp    80d068 <tcp_input+0x6b>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d216:	83 ec 04             	sub    $0x4,%esp
  80d219:	68 70 2e 81 00       	push   $0x812e70
  80d21e:	68 b5 00 00 00       	push   $0xb5
  80d223:	68 94 2f 81 00       	push   $0x812f94
  80d228:	e8 a9 12 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d22d:	83 ec 04             	sub    $0x4,%esp
  80d230:	68 98 2e 81 00       	push   $0x812e98
  80d235:	68 b6 00 00 00       	push   $0xb6
  80d23a:	68 94 2f 81 00       	push   $0x812f94
  80d23f:	e8 92 12 00 00       	call   80e4d6 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d244:	83 ec 04             	sub    $0x4,%esp
  80d247:	68 c4 2e 81 00       	push   $0x812ec4
  80d24c:	68 b7 00 00 00       	push   $0xb7
  80d251:	68 94 2f 81 00       	push   $0x812f94
  80d256:	e8 7b 12 00 00       	call   80e4d6 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d25b:	83 ec 04             	sub    $0x4,%esp
  80d25e:	68 ec 2e 81 00       	push   $0x812eec
  80d263:	68 c0 00 00 00       	push   $0xc0
  80d268:	68 94 2f 81 00       	push   $0x812f94
  80d26d:	e8 64 12 00 00       	call   80e4d6 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d272:	83 ec 04             	sub    $0x4,%esp
  80d275:	68 18 2f 81 00       	push   $0x812f18
  80d27a:	68 c6 00 00 00       	push   $0xc6
  80d27f:	68 94 2f 81 00       	push   $0x812f94
  80d284:	e8 4d 12 00 00       	call   80e4d6 <_panic>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d289:	89 df                	mov    %ebx,%edi
  80d28b:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d28e:	85 db                	test   %ebx,%ebx
  80d290:	0f 84 4b 0a 00 00    	je     80dce1 <tcp_input+0xce4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d296:	8b 43 10             	mov    0x10(%ebx),%eax
  80d299:	85 c0                	test   %eax,%eax
  80d29b:	0f 84 75 ff ff ff    	je     80d216 <tcp_input+0x219>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d2a1:	83 f8 0a             	cmp    $0xa,%eax
  80d2a4:	74 87                	je     80d22d <tcp_input+0x230>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d2a6:	83 f8 01             	cmp    $0x1,%eax
  80d2a9:	74 99                	je     80d244 <tcp_input+0x247>
    if (pcb->remote_port == tcphdr->src &&
  80d2ab:	0f b7 02             	movzwl (%edx),%eax
  80d2ae:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d2b2:	75 d5                	jne    80d289 <tcp_input+0x28c>
  80d2b4:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d2b8:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d2bc:	75 cb                	jne    80d289 <tcp_input+0x28c>
       pcb->local_port == tcphdr->dest &&
  80d2be:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d2c1:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d2c4:	75 c3                	jne    80d289 <tcp_input+0x28c>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d2c6:	8b 41 10             	mov    0x10(%ecx),%eax
  80d2c9:	39 03                	cmp    %eax,(%ebx)
  80d2cb:	75 bc                	jne    80d289 <tcp_input+0x28c>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d2cd:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d2d0:	39 c3                	cmp    %eax,%ebx
  80d2d2:	74 87                	je     80d25b <tcp_input+0x25e>
      if (prev != NULL) {
  80d2d4:	85 ff                	test   %edi,%edi
  80d2d6:	74 13                	je     80d2eb <tcp_input+0x2ee>
        prev->next = pcb->next;
  80d2d8:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d2db:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d2de:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d2e1:	89 1d 4c 44 b3 00    	mov    %ebx,0xb3444c
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d2e7:	39 c3                	cmp    %eax,%ebx
  80d2e9:	74 87                	je     80d272 <tcp_input+0x275>
    inseg.next = NULL;
  80d2eb:	c7 05 18 b2 b3 00 00 	movl   $0x0,0xb3b218
  80d2f2:	00 00 00 
    inseg.len = p->tot_len;
  80d2f5:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d2f9:	66 a3 24 b2 b3 00    	mov    %ax,0xb3b224
    inseg.dataptr = p->payload;
  80d2ff:	8b 46 04             	mov    0x4(%esi),%eax
  80d302:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
    inseg.p = p;
  80d307:	89 35 1c b2 b3 00    	mov    %esi,0xb3b21c
    inseg.tcphdr = tcphdr;
  80d30d:	89 15 28 b2 b3 00    	mov    %edx,0xb3b228
    recv_data = NULL;
  80d313:	c7 05 fc b1 b3 00 00 	movl   $0x0,0xb3b1fc
  80d31a:	00 00 00 
    recv_flags = 0;
  80d31d:	c6 05 00 b2 b3 00 00 	movb   $0x0,0xb3b200
    if (pcb->refused_data != NULL) {
  80d324:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d32a:	85 c0                	test   %eax,%eax
  80d32c:	74 2c                	je     80d35a <tcp_input+0x35d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d32e:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d334:	85 d2                	test   %edx,%edx
  80d336:	0f 84 dd 02 00 00    	je     80d619 <tcp_input+0x61c>
  80d33c:	6a 00                	push   $0x0
  80d33e:	50                   	push   %eax
  80d33f:	53                   	push   %ebx
  80d340:	ff 73 18             	push   0x18(%ebx)
  80d343:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d345:	83 c4 10             	add    $0x10,%esp
  80d348:	84 c0                	test   %al,%al
  80d34a:	0f 85 da 02 00 00    	jne    80d62a <tcp_input+0x62d>
        pcb->refused_data = NULL;
  80d350:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d357:	00 00 00 
    tcp_input_pcb = pcb;
  80d35a:	89 1d f8 b1 b3 00    	mov    %ebx,0xb3b1f8
  if (flags & TCP_RST) {
  80d360:	0f b6 05 04 b2 b3 00 	movzbl 0xb3b204,%eax
  80d367:	a8 04                	test   $0x4,%al
  80d369:	0f 84 f6 02 00 00    	je     80d665 <tcp_input+0x668>
    if (pcb->state == SYN_SENT) {
  80d36f:	8b 53 10             	mov    0x10(%ebx),%edx
  80d372:	83 fa 02             	cmp    $0x2,%edx
  80d375:	0f 84 c0 02 00 00    	je     80d63b <tcp_input+0x63e>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d37b:	a1 0c b2 b3 00       	mov    0xb3b20c,%eax
  80d380:	2b 43 24             	sub    0x24(%ebx),%eax
  80d383:	78 1d                	js     80d3a2 <tcp_input+0x3a5>
  80d385:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d389:	29 c8                	sub    %ecx,%eax
  80d38b:	85 c0                	test   %eax,%eax
  80d38d:	7f 13                	jg     80d3a2 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d38f:	85 d2                	test   %edx,%edx
  80d391:	0f 84 b7 02 00 00    	je     80d64e <tcp_input+0x651>
      recv_flags = TF_RESET;
  80d397:	c6 05 00 b2 b3 00 08 	movb   $0x8,0xb3b200
      pcb->flags &= ~TF_ACK_DELAY;
  80d39e:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
    tcp_input_pcb = NULL;
  80d3a2:	c7 05 f8 b1 b3 00 00 	movl   $0x0,0xb3b1f8
  80d3a9:	00 00 00 
      if (recv_flags & TF_RESET) {
  80d3ac:	0f b6 05 00 b2 b3 00 	movzbl 0xb3b200,%eax
  80d3b3:	a8 08                	test   $0x8,%al
  80d3b5:	0f 84 cf 07 00 00    	je     80db8a <tcp_input+0xb8d>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d3bb:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d3c1:	85 c0                	test   %eax,%eax
  80d3c3:	74 0d                	je     80d3d2 <tcp_input+0x3d5>
  80d3c5:	83 ec 08             	sub    $0x8,%esp
  80d3c8:	6a fa                	push   $0xfffffffa
  80d3ca:	ff 73 18             	push   0x18(%ebx)
  80d3cd:	ff d0                	call   *%eax
  80d3cf:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d3d2:	83 ec 08             	sub    $0x8,%esp
  80d3d5:	53                   	push   %ebx
  80d3d6:	68 4c 44 b3 00       	push   $0xb3444c
  80d3db:	e8 e5 84 ff ff       	call   8058c5 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d3e0:	83 c4 08             	add    $0x8,%esp
  80d3e3:	53                   	push   %ebx
  80d3e4:	6a 02                	push   $0x2
  80d3e6:	e8 10 71 ff ff       	call   8044fb <memp_free>
  80d3eb:	83 c4 10             	add    $0x10,%esp
    if (inseg.p != NULL)
  80d3ee:	a1 1c b2 b3 00       	mov    0xb3b21c,%eax
  80d3f3:	85 c0                	test   %eax,%eax
  80d3f5:	0f 84 6d fc ff ff    	je     80d068 <tcp_input+0x6b>
      pbuf_free(inseg.p);
  80d3fb:	83 ec 0c             	sub    $0xc,%esp
  80d3fe:	50                   	push   %eax
  80d3ff:	e8 48 74 ff ff       	call   80484c <pbuf_free>
      inseg.p = NULL;
  80d404:	c7 05 1c b2 b3 00 00 	movl   $0x0,0xb3b21c
  80d40b:	00 00 00 
  80d40e:	83 c4 10             	add    $0x10,%esp
  80d411:	e9 52 fc ff ff       	jmp    80d068 <tcp_input+0x6b>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d416:	83 ec 04             	sub    $0x4,%esp
  80d419:	68 44 2f 81 00       	push   $0x812f44
  80d41e:	68 d0 00 00 00       	push   $0xd0
  80d423:	68 94 2f 81 00       	push   $0x812f94
  80d428:	e8 a9 10 00 00       	call   80e4d6 <_panic>
    tcp_ack_now(pcb);
  80d42d:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d431:	83 ec 0c             	sub    $0xc,%esp
  80d434:	53                   	push   %ebx
  80d435:	e8 b7 ab ff ff       	call   807ff1 <tcp_output>
  80d43a:	83 c4 10             	add    $0x10,%esp
  80d43d:	eb 4c                	jmp    80d48b <tcp_input+0x48e>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d43f:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d442:	85 db                	test   %ebx,%ebx
  80d444:	74 5e                	je     80d4a4 <tcp_input+0x4a7>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d446:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d44a:	75 ca                	jne    80d416 <tcp_input+0x419>
      if (pcb->remote_port == tcphdr->src &&
  80d44c:	0f b7 02             	movzwl (%edx),%eax
  80d44f:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d453:	75 ea                	jne    80d43f <tcp_input+0x442>
  80d455:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d459:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d45d:	75 e0                	jne    80d43f <tcp_input+0x442>
         pcb->local_port == tcphdr->dest &&
  80d45f:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d462:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d465:	75 d8                	jne    80d43f <tcp_input+0x442>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d467:	8b 41 10             	mov    0x10(%ecx),%eax
  80d46a:	39 03                	cmp    %eax,(%ebx)
  80d46c:	75 d1                	jne    80d43f <tcp_input+0x442>
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d46e:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d472:	03 05 0c b2 b3 00    	add    0xb3b20c,%eax
  80d478:	89 c2                	mov    %eax,%edx
  80d47a:	2b 53 24             	sub    0x24(%ebx),%edx
  80d47d:	85 d2                	test   %edx,%edx
  80d47f:	7e 03                	jle    80d484 <tcp_input+0x487>
    pcb->rcv_nxt = seqno + tcplen;
  80d481:	89 43 24             	mov    %eax,0x24(%ebx)
  if (tcplen > 0) {
  80d484:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80d489:	75 a2                	jne    80d42d <tcp_input+0x430>
  return tcp_output(pcb);
  80d48b:	83 ec 0c             	sub    $0xc,%esp
  80d48e:	53                   	push   %ebx
  80d48f:	e8 5d ab ff ff       	call   807ff1 <tcp_output>
        pbuf_free(p);
  80d494:	89 34 24             	mov    %esi,(%esp)
  80d497:	e8 b0 73 ff ff       	call   80484c <pbuf_free>
        return;
  80d49c:	83 c4 10             	add    $0x10,%esp
  80d49f:	e9 c4 fb ff ff       	jmp    80d068 <tcp_input+0x6b>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d4a4:	a1 50 44 b3 00       	mov    0xb34450,%eax
  80d4a9:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d4ac:	89 c7                	mov    %eax,%edi
  80d4ae:	eb 0f                	jmp    80d4bf <tcp_input+0x4c2>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d4b0:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d4b4:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
  80d4b8:	74 1a                	je     80d4d4 <tcp_input+0x4d7>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d4ba:	89 fb                	mov    %edi,%ebx
  80d4bc:	8b 7f 0c             	mov    0xc(%edi),%edi
  80d4bf:	85 ff                	test   %edi,%edi
  80d4c1:	0f 84 f5 07 00 00    	je     80dcbc <tcp_input+0xcbf>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d4c7:	8b 07                	mov    (%edi),%eax
  80d4c9:	85 c0                	test   %eax,%eax
  80d4cb:	74 e3                	je     80d4b0 <tcp_input+0x4b3>
  80d4cd:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d4d0:	75 e8                	jne    80d4ba <tcp_input+0x4bd>
  80d4d2:	eb dc                	jmp    80d4b0 <tcp_input+0x4b3>
        if (prev != NULL) {
  80d4d4:	85 db                	test   %ebx,%ebx
  80d4d6:	74 12                	je     80d4ea <tcp_input+0x4ed>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d4d8:	8b 47 0c             	mov    0xc(%edi),%eax
  80d4db:	89 43 0c             	mov    %eax,0xc(%ebx)
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d4de:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d4e1:	89 47 0c             	mov    %eax,0xc(%edi)
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d4e4:	89 3d 50 44 b3 00    	mov    %edi,0xb34450
  if (flags & TCP_ACK) {
  80d4ea:	f6 45 d6 10          	testb  $0x10,-0x2a(%ebp)
  80d4ee:	75 17                	jne    80d507 <tcp_input+0x50a>
  } else if (flags & TCP_SYN) {
  80d4f0:	f6 45 d6 02          	testb  $0x2,-0x2a(%ebp)
  80d4f4:	75 43                	jne    80d539 <tcp_input+0x53c>
        pbuf_free(p);
  80d4f6:	83 ec 0c             	sub    $0xc,%esp
  80d4f9:	56                   	push   %esi
  80d4fa:	e8 4d 73 ff ff       	call   80484c <pbuf_free>
        return;
  80d4ff:	83 c4 10             	add    $0x10,%esp
  80d502:	e9 61 fb ff ff       	jmp    80d068 <tcp_input+0x6b>
    tcp_rst(ackno + 1, seqno + tcplen,
  80d507:	83 ec 08             	sub    $0x8,%esp
  80d50a:	0f b7 02             	movzwl (%edx),%eax
  80d50d:	50                   	push   %eax
  80d50e:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d512:	50                   	push   %eax
  80d513:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d516:	50                   	push   %eax
  80d517:	83 c1 10             	add    $0x10,%ecx
  80d51a:	51                   	push   %ecx
  80d51b:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d51f:	03 05 0c b2 b3 00    	add    0xb3b20c,%eax
  80d525:	50                   	push   %eax
  80d526:	a1 08 b2 b3 00       	mov    0xb3b208,%eax
  80d52b:	83 c0 01             	add    $0x1,%eax
  80d52e:	50                   	push   %eax
  80d52f:	e8 60 af ff ff       	call   808494 <tcp_rst>
  80d534:	83 c4 20             	add    $0x20,%esp
  80d537:	eb bd                	jmp    80d4f6 <tcp_input+0x4f9>
    npcb = tcp_alloc(pcb->prio);
  80d539:	83 ec 0c             	sub    $0xc,%esp
  80d53c:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  80d540:	50                   	push   %eax
  80d541:	e8 b1 8b ff ff       	call   8060f7 <tcp_alloc>
  80d546:	89 c3                	mov    %eax,%ebx
    if (npcb == NULL) {
  80d548:	83 c4 10             	add    $0x10,%esp
  80d54b:	85 c0                	test   %eax,%eax
  80d54d:	74 a7                	je     80d4f6 <tcp_input+0x4f9>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d54f:	a1 10 b2 b3 00       	mov    0xb3b210,%eax
  80d554:	8b 50 10             	mov    0x10(%eax),%edx
  80d557:	89 13                	mov    %edx,(%ebx)
    npcb->local_port = pcb->local_port;
  80d559:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d55d:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d561:	8b 40 0c             	mov    0xc(%eax),%eax
  80d564:	89 43 04             	mov    %eax,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  80d567:	8b 15 14 b2 b3 00    	mov    0xb3b214,%edx
  80d56d:	0f b7 02             	movzwl (%edx),%eax
  80d570:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  80d574:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  80d57b:	a1 0c b2 b3 00       	mov    0xb3b20c,%eax
  80d580:	8d 48 01             	lea    0x1(%eax),%ecx
  80d583:	89 4b 24             	mov    %ecx,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  80d586:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d58a:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  80d58e:	66 89 53 50          	mov    %dx,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d592:	83 e8 01             	sub    $0x1,%eax
  80d595:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  80d598:	8b 47 18             	mov    0x18(%edi),%eax
  80d59b:	89 43 18             	mov    %eax,0x18(%ebx)
    npcb->accept = pcb->accept;
  80d59e:	8b 47 20             	mov    0x20(%edi),%eax
  80d5a1:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d5a7:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d5ab:	66 25 99 01          	and    $0x199,%ax
  80d5af:	66 89 43 08          	mov    %ax,0x8(%ebx)
    TCP_REG(&tcp_active_pcbs, npcb);
  80d5b3:	a1 4c 44 b3 00       	mov    0xb3444c,%eax
  80d5b8:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d5bb:	89 1d 4c 44 b3 00    	mov    %ebx,0xb3444c
  80d5c1:	e8 6d 4c ff ff       	call   802233 <tcp_timer_needed>
    tcp_parseopt(npcb);
  80d5c6:	89 d8                	mov    %ebx,%eax
  80d5c8:	e8 99 ec ff ff       	call   80c266 <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d5cd:	83 ec 08             	sub    $0x8,%esp
  80d5d0:	8d 43 04             	lea    0x4(%ebx),%eax
  80d5d3:	50                   	push   %eax
  80d5d4:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d5d8:	50                   	push   %eax
  80d5d9:	e8 b7 8c ff ff       	call   806295 <tcp_eff_send_mss>
  80d5de:	66 89 43 34          	mov    %ax,0x34(%ebx)
    optdata = TCP_BUILD_MSS_OPTION();
  80d5e2:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d5e9:	e8 b2 a0 ff ff       	call   8076a0 <htonl>
  80d5ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d5f1:	83 c4 0c             	add    $0xc,%esp
  80d5f4:	6a 04                	push   $0x4
  80d5f6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d5f9:	50                   	push   %eax
  80d5fa:	6a 00                	push   $0x0
  80d5fc:	6a 12                	push   $0x12
  80d5fe:	6a 00                	push   $0x0
  80d600:	6a 00                	push   $0x0
  80d602:	53                   	push   %ebx
  80d603:	e8 d3 a2 ff ff       	call   8078db <tcp_enqueue>
    return tcp_output(npcb);
  80d608:	83 c4 14             	add    $0x14,%esp
  80d60b:	53                   	push   %ebx
  80d60c:	e8 e0 a9 ff ff       	call   807ff1 <tcp_output>
  80d611:	83 c4 10             	add    $0x10,%esp
  80d614:	e9 dd fe ff ff       	jmp    80d4f6 <tcp_input+0x4f9>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d619:	83 ec 0c             	sub    $0xc,%esp
  80d61c:	50                   	push   %eax
  80d61d:	e8 2a 72 ff ff       	call   80484c <pbuf_free>
  80d622:	83 c4 10             	add    $0x10,%esp
  80d625:	e9 26 fd ff ff       	jmp    80d350 <tcp_input+0x353>
        pbuf_free(p);
  80d62a:	83 ec 0c             	sub    $0xc,%esp
  80d62d:	56                   	push   %esi
  80d62e:	e8 19 72 ff ff       	call   80484c <pbuf_free>
        return;
  80d633:	83 c4 10             	add    $0x10,%esp
  80d636:	e9 2d fa ff ff       	jmp    80d068 <tcp_input+0x6b>
      if (ackno == pcb->snd_nxt) {
  80d63b:	a1 08 b2 b3 00       	mov    0xb3b208,%eax
  80d640:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d643:	0f 84 4e fd ff ff    	je     80d397 <tcp_input+0x39a>
  80d649:	e9 54 fd ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d64e:	83 ec 04             	sub    $0x4,%esp
  80d651:	68 74 2f 81 00       	push   $0x812f74
  80d656:	68 09 02 00 00       	push   $0x209
  80d65b:	68 94 2f 81 00       	push   $0x812f94
  80d660:	e8 71 0e 00 00       	call   80e4d6 <_panic>
  pcb->tmr = tcp_ticks;
  80d665:	8b 15 58 44 b3 00    	mov    0xb34458,%edx
  80d66b:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d66e:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  switch (pcb->state) {
  80d675:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d679:	0f 87 23 fd ff ff    	ja     80d3a2 <tcp_input+0x3a5>
  80d67f:	8b 53 10             	mov    0x10(%ebx),%edx
  80d682:	ff 24 95 18 30 81 00 	jmp    *0x813018(,%edx,4)
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d689:	83 e0 12             	and    $0x12,%eax
  80d68c:	3c 12                	cmp    $0x12,%al
  80d68e:	74 4d                	je     80d6dd <tcp_input+0x6e0>
    else if (flags & TCP_ACK) {
  80d690:	f6 05 04 b2 b3 00 10 	testb  $0x10,0xb3b204
  80d697:	0f 84 05 fd ff ff    	je     80d3a2 <tcp_input+0x3a5>
        tcphdr->dest, tcphdr->src);
  80d69d:	8b 15 14 b2 b3 00    	mov    0xb3b214,%edx
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d6a3:	a1 10 b2 b3 00       	mov    0xb3b210,%eax
  80d6a8:	83 ec 08             	sub    $0x8,%esp
  80d6ab:	0f b7 0a             	movzwl (%edx),%ecx
  80d6ae:	51                   	push   %ecx
  80d6af:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d6b3:	52                   	push   %edx
  80d6b4:	8d 50 0c             	lea    0xc(%eax),%edx
  80d6b7:	52                   	push   %edx
  80d6b8:	83 c0 10             	add    $0x10,%eax
  80d6bb:	50                   	push   %eax
  80d6bc:	0f b7 05 02 b2 b3 00 	movzwl 0xb3b202,%eax
  80d6c3:	03 05 0c b2 b3 00    	add    0xb3b20c,%eax
  80d6c9:	50                   	push   %eax
  80d6ca:	ff 35 08 b2 b3 00    	push   0xb3b208
  80d6d0:	e8 bf ad ff ff       	call   808494 <tcp_rst>
  80d6d5:	83 c4 20             	add    $0x20,%esp
  80d6d8:	e9 c5 fc ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d6dd:	83 ec 0c             	sub    $0xc,%esp
  80d6e0:	8b 43 78             	mov    0x78(%ebx),%eax
  80d6e3:	8b 40 10             	mov    0x10(%eax),%eax
  80d6e6:	ff 70 04             	push   0x4(%eax)
  80d6e9:	e8 da a1 ff ff       	call   8078c8 <ntohl>
  80d6ee:	8b 15 08 b2 b3 00    	mov    0xb3b208,%edx
  80d6f4:	83 c0 01             	add    $0x1,%eax
  80d6f7:	83 c4 10             	add    $0x10,%esp
  80d6fa:	39 d0                	cmp    %edx,%eax
  80d6fc:	75 92                	jne    80d690 <tcp_input+0x693>
      pcb->snd_buf++;
  80d6fe:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80d703:	a1 0c b2 b3 00       	mov    0xb3b20c,%eax
  80d708:	8d 48 01             	lea    0x1(%eax),%ecx
  80d70b:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80d70e:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80d711:	8b 15 14 b2 b3 00    	mov    0xb3b214,%edx
  80d717:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d71b:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d71f:	83 e8 01             	sub    $0x1,%eax
  80d722:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80d725:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
      tcp_parseopt(pcb);
  80d72c:	89 d8                	mov    %ebx,%eax
  80d72e:	e8 33 eb ff ff       	call   80c266 <tcp_parseopt>
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d733:	83 ec 08             	sub    $0x8,%esp
  80d736:	8d 43 04             	lea    0x4(%ebx),%eax
  80d739:	50                   	push   %eax
  80d73a:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d73e:	50                   	push   %eax
  80d73f:	e8 51 8b ff ff       	call   806295 <tcp_eff_send_mss>
  80d744:	66 89 43 34          	mov    %ax,0x34(%ebx)
      pcb->ssthresh = pcb->mss * 10;
  80d748:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d74b:	66 89 53 50          	mov    %dx,0x50(%ebx)
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d74f:	83 c4 10             	add    $0x10,%esp
  80d752:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80d757:	74 63                	je     80d7bc <tcp_input+0x7bf>
  80d759:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d75d:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80d761:	66 85 c0             	test   %ax,%ax
  80d764:	74 5a                	je     80d7c0 <tcp_input+0x7c3>
      --pcb->snd_queuelen;
  80d766:	83 e8 01             	sub    $0x1,%eax
  80d769:	66 89 43 70          	mov    %ax,0x70(%ebx)
      rseg = pcb->unacked;
  80d76d:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80d770:	8b 10                	mov    (%eax),%edx
  80d772:	89 53 78             	mov    %edx,0x78(%ebx)
      if(pcb->unacked == NULL)
  80d775:	85 d2                	test   %edx,%edx
  80d777:	74 5e                	je     80d7d7 <tcp_input+0x7da>
        pcb->rtime = 0;
  80d779:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80d77f:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      tcp_seg_free(rseg);
  80d783:	83 ec 0c             	sub    $0xc,%esp
  80d786:	50                   	push   %eax
  80d787:	e8 a3 7f ff ff       	call   80572f <tcp_seg_free>
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d78c:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80d792:	83 c4 10             	add    $0x10,%esp
  80d795:	85 c0                	test   %eax,%eax
  80d797:	74 0e                	je     80d7a7 <tcp_input+0x7aa>
  80d799:	83 ec 04             	sub    $0x4,%esp
  80d79c:	6a 00                	push   $0x0
  80d79e:	53                   	push   %ebx
  80d79f:	ff 73 18             	push   0x18(%ebx)
  80d7a2:	ff d0                	call   *%eax
  80d7a4:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d7a7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d7ab:	83 ec 0c             	sub    $0xc,%esp
  80d7ae:	53                   	push   %ebx
  80d7af:	e8 3d a8 ff ff       	call   807ff1 <tcp_output>
  80d7b4:	83 c4 10             	add    $0x10,%esp
  80d7b7:	e9 e6 fb ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d7bc:	01 c0                	add    %eax,%eax
  80d7be:	eb 99                	jmp    80d759 <tcp_input+0x75c>
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d7c0:	83 ec 04             	sub    $0x4,%esp
  80d7c3:	68 ed 2f 81 00       	push   $0x812fed
  80d7c8:	68 35 02 00 00       	push   $0x235
  80d7cd:	68 94 2f 81 00       	push   $0x812f94
  80d7d2:	e8 ff 0c 00 00       	call   80e4d6 <_panic>
        pcb->rtime = -1;
  80d7d7:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80d7dd:	eb a4                	jmp    80d783 <tcp_input+0x786>
    if (flags & TCP_ACK &&
  80d7df:	83 e0 14             	and    $0x14,%eax
  80d7e2:	3c 10                	cmp    $0x10,%al
  80d7e4:	0f 85 b8 fb ff ff    	jne    80d3a2 <tcp_input+0x3a5>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80d7ea:	8b 15 08 b2 b3 00    	mov    0xb3b208,%edx
  80d7f0:	8d 42 ff             	lea    -0x1(%edx),%eax
  80d7f3:	3b 43 48             	cmp    0x48(%ebx),%eax
  80d7f6:	78 09                	js     80d801 <tcp_input+0x804>
  80d7f8:	89 d0                	mov    %edx,%eax
  80d7fa:	2b 43 54             	sub    0x54(%ebx),%eax
  80d7fd:	85 c0                	test   %eax,%eax
  80d7ff:	7e 3b                	jle    80d83c <tcp_input+0x83f>
                tcphdr->dest, tcphdr->src);
  80d801:	8b 0d 14 b2 b3 00    	mov    0xb3b214,%ecx
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d807:	a1 10 b2 b3 00       	mov    0xb3b210,%eax
  80d80c:	83 ec 08             	sub    $0x8,%esp
  80d80f:	0f b7 31             	movzwl (%ecx),%esi
  80d812:	56                   	push   %esi
  80d813:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80d817:	51                   	push   %ecx
  80d818:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d81b:	51                   	push   %ecx
  80d81c:	83 c0 10             	add    $0x10,%eax
  80d81f:	50                   	push   %eax
  80d820:	0f b7 05 02 b2 b3 00 	movzwl 0xb3b202,%eax
  80d827:	03 05 0c b2 b3 00    	add    0xb3b20c,%eax
  80d82d:	50                   	push   %eax
  80d82e:	52                   	push   %edx
  80d82f:	e8 60 ac ff ff       	call   808494 <tcp_rst>
  80d834:	83 c4 20             	add    $0x20,%esp
  80d837:	e9 66 fb ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
        pcb->state = ESTABLISHED;
  80d83c:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d843:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80d849:	85 c0                	test   %eax,%eax
  80d84b:	74 5e                	je     80d8ab <tcp_input+0x8ae>
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80d84d:	83 ec 04             	sub    $0x4,%esp
  80d850:	6a 00                	push   $0x0
  80d852:	53                   	push   %ebx
  80d853:	ff 73 18             	push   0x18(%ebx)
  80d856:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80d858:	83 c4 10             	add    $0x10,%esp
  80d85b:	84 c0                	test   %al,%al
  80d85d:	75 63                	jne    80d8c2 <tcp_input+0x8c5>
        old_cwnd = pcb->cwnd;
  80d85f:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        accepted_inseq = tcp_receive(pcb);
  80d863:	89 d8                	mov    %ebx,%eax
  80d865:	e8 b0 ea ff ff       	call   80c31a <tcp_receive>
  80d86a:	89 c2                	mov    %eax,%edx
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d86c:	66 83 fe 01          	cmp    $0x1,%si
  80d870:	74 6b                	je     80d8dd <tcp_input+0x8e0>
  80d872:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d876:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
        if ((flags & TCP_FIN) && accepted_inseq) {
  80d87a:	f6 05 04 b2 b3 00 01 	testb  $0x1,0xb3b204
  80d881:	0f 84 1b fb ff ff    	je     80d3a2 <tcp_input+0x3a5>
  80d887:	84 d2                	test   %dl,%dl
  80d889:	0f 84 13 fb ff ff    	je     80d3a2 <tcp_input+0x3a5>
          tcp_ack_now(pcb);
  80d88f:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d893:	83 ec 0c             	sub    $0xc,%esp
  80d896:	53                   	push   %ebx
  80d897:	e8 55 a7 ff ff       	call   807ff1 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80d89c:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d8a3:	83 c4 10             	add    $0x10,%esp
  80d8a6:	e9 f7 fa ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d8ab:	83 ec 04             	sub    $0x4,%esp
  80d8ae:	68 03 30 81 00       	push   $0x813003
  80d8b3:	68 5b 02 00 00       	push   $0x25b
  80d8b8:	68 94 2f 81 00       	push   $0x812f94
  80d8bd:	e8 14 0c 00 00       	call   80e4d6 <_panic>
          tcp_abort(pcb);
  80d8c2:	83 ec 0c             	sub    $0xc,%esp
  80d8c5:	53                   	push   %ebx
  80d8c6:	e8 8a 82 ff ff       	call   805b55 <tcp_abort>
    tcp_input_pcb = NULL;
  80d8cb:	c7 05 f8 b1 b3 00 00 	movl   $0x0,0xb3b1f8
  80d8d2:	00 00 00 
  80d8d5:	83 c4 10             	add    $0x10,%esp
  80d8d8:	e9 11 fb ff ff       	jmp    80d3ee <tcp_input+0x3f1>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d8dd:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d8e1:	01 c0                	add    %eax,%eax
  80d8e3:	eb 91                	jmp    80d876 <tcp_input+0x879>
    accepted_inseq = tcp_receive(pcb);
  80d8e5:	89 d8                	mov    %ebx,%eax
  80d8e7:	e8 2e ea ff ff       	call   80c31a <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80d8ec:	f6 05 04 b2 b3 00 01 	testb  $0x1,0xb3b204
  80d8f3:	0f 84 a9 fa ff ff    	je     80d3a2 <tcp_input+0x3a5>
  80d8f9:	84 c0                	test   %al,%al
  80d8fb:	0f 84 a1 fa ff ff    	je     80d3a2 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80d901:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d905:	83 ec 0c             	sub    $0xc,%esp
  80d908:	53                   	push   %ebx
  80d909:	e8 e3 a6 ff ff       	call   807ff1 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80d90e:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d915:	83 c4 10             	add    $0x10,%esp
  80d918:	e9 85 fa ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80d91d:	89 d8                	mov    %ebx,%eax
  80d91f:	e8 f6 e9 ff ff       	call   80c31a <tcp_receive>
    if (flags & TCP_FIN) {
  80d924:	0f b6 05 04 b2 b3 00 	movzbl 0xb3b204,%eax
  80d92b:	a8 01                	test   $0x1,%al
  80d92d:	0f 84 b7 00 00 00    	je     80d9ea <tcp_input+0x9ed>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d933:	a8 10                	test   $0x10,%al
  80d935:	74 0a                	je     80d941 <tcp_input+0x944>
  80d937:	a1 08 b2 b3 00       	mov    0xb3b208,%eax
  80d93c:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d93f:	74 1c                	je     80d95d <tcp_input+0x960>
        tcp_ack_now(pcb);
  80d941:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d945:	83 ec 0c             	sub    $0xc,%esp
  80d948:	53                   	push   %ebx
  80d949:	e8 a3 a6 ff ff       	call   807ff1 <tcp_output>
        pcb->state = CLOSING;
  80d94e:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80d955:	83 c4 10             	add    $0x10,%esp
  80d958:	e9 45 fa ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
        tcp_ack_now(pcb);
  80d95d:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d961:	83 ec 0c             	sub    $0xc,%esp
  80d964:	53                   	push   %ebx
  80d965:	e8 87 a6 ff ff       	call   807ff1 <tcp_output>
        tcp_pcb_purge(pcb);
  80d96a:	89 1c 24             	mov    %ebx,(%esp)
  80d96d:	e8 d6 7e ff ff       	call   805848 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80d972:	a1 4c 44 b3 00       	mov    0xb3444c,%eax
  80d977:	83 c4 10             	add    $0x10,%esp
  80d97a:	39 c3                	cmp    %eax,%ebx
  80d97c:	74 11                	je     80d98f <tcp_input+0x992>
  80d97e:	a3 44 44 b3 00       	mov    %eax,0xb34444
  80d983:	ba 00 00 00 00       	mov    $0x0,%edx
  80d988:	be 01 00 00 00       	mov    $0x1,%esi
  80d98d:	eb 2b                	jmp    80d9ba <tcp_input+0x9bd>
  80d98f:	8b 40 0c             	mov    0xc(%eax),%eax
  80d992:	a3 4c 44 b3 00       	mov    %eax,0xb3444c
        pcb->state = TIME_WAIT;
  80d997:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80d99e:	a1 48 44 b3 00       	mov    0xb34448,%eax
  80d9a3:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d9a6:	89 1d 48 44 b3 00    	mov    %ebx,0xb34448
  80d9ac:	e8 82 48 ff ff       	call   802233 <tcp_timer_needed>
  80d9b1:	e9 ec f9 ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
  80d9b6:	89 f2                	mov    %esi,%edx
        TCP_RMV(&tcp_active_pcbs, pcb);
  80d9b8:	89 c8                	mov    %ecx,%eax
  80d9ba:	85 c0                	test   %eax,%eax
  80d9bc:	74 1c                	je     80d9da <tcp_input+0x9dd>
  80d9be:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d9c1:	39 cb                	cmp    %ecx,%ebx
  80d9c3:	75 f1                	jne    80d9b6 <tcp_input+0x9b9>
  80d9c5:	85 c9                	test   %ecx,%ecx
  80d9c7:	74 ed                	je     80d9b6 <tcp_input+0x9b9>
  80d9c9:	84 d2                	test   %dl,%dl
  80d9cb:	74 05                	je     80d9d2 <tcp_input+0x9d5>
  80d9cd:	a3 44 44 b3 00       	mov    %eax,0xb34444
  80d9d2:	8b 53 0c             	mov    0xc(%ebx),%edx
  80d9d5:	89 50 0c             	mov    %edx,0xc(%eax)
  80d9d8:	eb bd                	jmp    80d997 <tcp_input+0x99a>
  80d9da:	84 d2                	test   %dl,%dl
  80d9dc:	74 b9                	je     80d997 <tcp_input+0x99a>
  80d9de:	c7 05 44 44 b3 00 00 	movl   $0x0,0xb34444
  80d9e5:	00 00 00 
  80d9e8:	eb ad                	jmp    80d997 <tcp_input+0x99a>
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d9ea:	a8 10                	test   $0x10,%al
  80d9ec:	0f 84 b0 f9 ff ff    	je     80d3a2 <tcp_input+0x3a5>
  80d9f2:	a1 08 b2 b3 00       	mov    0xb3b208,%eax
  80d9f7:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d9fa:	0f 85 a2 f9 ff ff    	jne    80d3a2 <tcp_input+0x3a5>
      pcb->state = FIN_WAIT_2;
  80da00:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80da07:	e9 96 f9 ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80da0c:	89 d8                	mov    %ebx,%eax
  80da0e:	e8 07 e9 ff ff       	call   80c31a <tcp_receive>
    if (flags & TCP_FIN) {
  80da13:	f6 05 04 b2 b3 00 01 	testb  $0x1,0xb3b204
  80da1a:	0f 84 82 f9 ff ff    	je     80d3a2 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80da20:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80da24:	83 ec 0c             	sub    $0xc,%esp
  80da27:	53                   	push   %ebx
  80da28:	e8 c4 a5 ff ff       	call   807ff1 <tcp_output>
      tcp_pcb_purge(pcb);
  80da2d:	89 1c 24             	mov    %ebx,(%esp)
  80da30:	e8 13 7e ff ff       	call   805848 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80da35:	a1 4c 44 b3 00       	mov    0xb3444c,%eax
  80da3a:	83 c4 10             	add    $0x10,%esp
  80da3d:	39 c3                	cmp    %eax,%ebx
  80da3f:	74 11                	je     80da52 <tcp_input+0xa55>
  80da41:	a3 44 44 b3 00       	mov    %eax,0xb34444
  80da46:	b9 00 00 00 00       	mov    $0x0,%ecx
  80da4b:	be 01 00 00 00       	mov    $0x1,%esi
  80da50:	eb 2b                	jmp    80da7d <tcp_input+0xa80>
  80da52:	8b 40 0c             	mov    0xc(%eax),%eax
  80da55:	a3 4c 44 b3 00       	mov    %eax,0xb3444c
      pcb->state = TIME_WAIT;
  80da5a:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80da61:	a1 48 44 b3 00       	mov    0xb34448,%eax
  80da66:	89 43 0c             	mov    %eax,0xc(%ebx)
  80da69:	89 1d 48 44 b3 00    	mov    %ebx,0xb34448
  80da6f:	e8 bf 47 ff ff       	call   802233 <tcp_timer_needed>
  80da74:	e9 29 f9 ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
  80da79:	89 f1                	mov    %esi,%ecx
      TCP_RMV(&tcp_active_pcbs, pcb);
  80da7b:	89 d0                	mov    %edx,%eax
  80da7d:	85 c0                	test   %eax,%eax
  80da7f:	74 1c                	je     80da9d <tcp_input+0xaa0>
  80da81:	8b 50 0c             	mov    0xc(%eax),%edx
  80da84:	85 d2                	test   %edx,%edx
  80da86:	74 f1                	je     80da79 <tcp_input+0xa7c>
  80da88:	39 d3                	cmp    %edx,%ebx
  80da8a:	75 ed                	jne    80da79 <tcp_input+0xa7c>
  80da8c:	84 c9                	test   %cl,%cl
  80da8e:	74 05                	je     80da95 <tcp_input+0xa98>
  80da90:	a3 44 44 b3 00       	mov    %eax,0xb34444
  80da95:	8b 53 0c             	mov    0xc(%ebx),%edx
  80da98:	89 50 0c             	mov    %edx,0xc(%eax)
  80da9b:	eb bd                	jmp    80da5a <tcp_input+0xa5d>
  80da9d:	84 c9                	test   %cl,%cl
  80da9f:	74 b9                	je     80da5a <tcp_input+0xa5d>
  80daa1:	c7 05 44 44 b3 00 00 	movl   $0x0,0xb34444
  80daa8:	00 00 00 
  80daab:	eb ad                	jmp    80da5a <tcp_input+0xa5d>
    tcp_receive(pcb);
  80daad:	89 d8                	mov    %ebx,%eax
  80daaf:	e8 66 e8 ff ff       	call   80c31a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dab4:	f6 05 04 b2 b3 00 10 	testb  $0x10,0xb3b204
  80dabb:	0f 84 e1 f8 ff ff    	je     80d3a2 <tcp_input+0x3a5>
  80dac1:	a1 08 b2 b3 00       	mov    0xb3b208,%eax
  80dac6:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dac9:	0f 85 d3 f8 ff ff    	jne    80d3a2 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80dacf:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dad3:	83 ec 0c             	sub    $0xc,%esp
  80dad6:	53                   	push   %ebx
  80dad7:	e8 15 a5 ff ff       	call   807ff1 <tcp_output>
      tcp_pcb_purge(pcb);
  80dadc:	89 1c 24             	mov    %ebx,(%esp)
  80dadf:	e8 64 7d ff ff       	call   805848 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dae4:	a1 4c 44 b3 00       	mov    0xb3444c,%eax
  80dae9:	83 c4 10             	add    $0x10,%esp
  80daec:	39 c3                	cmp    %eax,%ebx
  80daee:	74 11                	je     80db01 <tcp_input+0xb04>
  80daf0:	a3 44 44 b3 00       	mov    %eax,0xb34444
  80daf5:	ba 00 00 00 00       	mov    $0x0,%edx
  80dafa:	be 01 00 00 00       	mov    $0x1,%esi
  80daff:	eb 2b                	jmp    80db2c <tcp_input+0xb2f>
  80db01:	8b 40 0c             	mov    0xc(%eax),%eax
  80db04:	a3 4c 44 b3 00       	mov    %eax,0xb3444c
      pcb->state = TIME_WAIT;
  80db09:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80db10:	a1 48 44 b3 00       	mov    0xb34448,%eax
  80db15:	89 43 0c             	mov    %eax,0xc(%ebx)
  80db18:	89 1d 48 44 b3 00    	mov    %ebx,0xb34448
  80db1e:	e8 10 47 ff ff       	call   802233 <tcp_timer_needed>
  80db23:	e9 7a f8 ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
  80db28:	89 f2                	mov    %esi,%edx
      TCP_RMV(&tcp_active_pcbs, pcb);
  80db2a:	89 c8                	mov    %ecx,%eax
  80db2c:	85 c0                	test   %eax,%eax
  80db2e:	74 1c                	je     80db4c <tcp_input+0xb4f>
  80db30:	8b 48 0c             	mov    0xc(%eax),%ecx
  80db33:	39 cb                	cmp    %ecx,%ebx
  80db35:	75 f1                	jne    80db28 <tcp_input+0xb2b>
  80db37:	85 c9                	test   %ecx,%ecx
  80db39:	74 ed                	je     80db28 <tcp_input+0xb2b>
  80db3b:	84 d2                	test   %dl,%dl
  80db3d:	74 05                	je     80db44 <tcp_input+0xb47>
  80db3f:	a3 44 44 b3 00       	mov    %eax,0xb34444
  80db44:	8b 53 0c             	mov    0xc(%ebx),%edx
  80db47:	89 50 0c             	mov    %edx,0xc(%eax)
  80db4a:	eb bd                	jmp    80db09 <tcp_input+0xb0c>
  80db4c:	84 d2                	test   %dl,%dl
  80db4e:	74 b9                	je     80db09 <tcp_input+0xb0c>
  80db50:	c7 05 44 44 b3 00 00 	movl   $0x0,0xb34444
  80db57:	00 00 00 
  80db5a:	eb ad                	jmp    80db09 <tcp_input+0xb0c>
    tcp_receive(pcb);
  80db5c:	89 d8                	mov    %ebx,%eax
  80db5e:	e8 b7 e7 ff ff       	call   80c31a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80db63:	f6 05 04 b2 b3 00 10 	testb  $0x10,0xb3b204
  80db6a:	0f 84 32 f8 ff ff    	je     80d3a2 <tcp_input+0x3a5>
  80db70:	a1 08 b2 b3 00       	mov    0xb3b208,%eax
  80db75:	39 43 54             	cmp    %eax,0x54(%ebx)
  80db78:	0f 85 24 f8 ff ff    	jne    80d3a2 <tcp_input+0x3a5>
      recv_flags = TF_CLOSED;
  80db7e:	c6 05 00 b2 b3 00 10 	movb   $0x10,0xb3b200
  80db85:	e9 18 f8 ff ff       	jmp    80d3a2 <tcp_input+0x3a5>
      } else if (recv_flags & TF_CLOSED) {
  80db8a:	a8 10                	test   $0x10,%al
  80db8c:	0f 85 96 00 00 00    	jne    80dc28 <tcp_input+0xc2b>
        if (pcb->acked > 0) {
  80db92:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        err = ERR_OK;
  80db96:	b8 00 00 00 00       	mov    $0x0,%eax
        if (pcb->acked > 0) {
  80db9b:	66 85 d2             	test   %dx,%dx
  80db9e:	74 1a                	je     80dbba <tcp_input+0xbbd>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80dba0:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80dba6:	85 c9                	test   %ecx,%ecx
  80dba8:	74 10                	je     80dbba <tcp_input+0xbbd>
  80dbaa:	83 ec 04             	sub    $0x4,%esp
  80dbad:	0f b7 d2             	movzwl %dx,%edx
  80dbb0:	52                   	push   %edx
  80dbb1:	53                   	push   %ebx
  80dbb2:	ff 73 18             	push   0x18(%ebx)
  80dbb5:	ff d1                	call   *%ecx
  80dbb7:	83 c4 10             	add    $0x10,%esp
        if (recv_data != NULL) {
  80dbba:	8b 15 fc b1 b3 00    	mov    0xb3b1fc,%edx
  80dbc0:	85 d2                	test   %edx,%edx
  80dbc2:	0f 84 a9 00 00 00    	je     80dc71 <tcp_input+0xc74>
          if(flags & TCP_PSH) {
  80dbc8:	f6 05 04 b2 b3 00 08 	testb  $0x8,0xb3b204
  80dbcf:	74 04                	je     80dbd5 <tcp_input+0xbd8>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80dbd1:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dbd5:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dbdb:	85 c0                	test   %eax,%eax
  80dbdd:	74 6a                	je     80dc49 <tcp_input+0xc4c>
  80dbdf:	6a 00                	push   $0x0
  80dbe1:	52                   	push   %edx
  80dbe2:	53                   	push   %ebx
  80dbe3:	ff 73 18             	push   0x18(%ebx)
  80dbe6:	ff d0                	call   *%eax
          if (err != ERR_OK) {
  80dbe8:	83 c4 10             	add    $0x10,%esp
  80dbeb:	84 c0                	test   %al,%al
  80dbed:	75 68                	jne    80dc57 <tcp_input+0xc5a>
        if (recv_flags & TF_GOT_FIN) {
  80dbef:	f6 05 00 b2 b3 00 20 	testb  $0x20,0xb3b200
  80dbf6:	74 1f                	je     80dc17 <tcp_input+0xc1a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80dbf8:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dbfe:	85 c0                	test   %eax,%eax
  80dc00:	74 15                	je     80dc17 <tcp_input+0xc1a>
  80dc02:	6a 00                	push   $0x0
  80dc04:	6a 00                	push   $0x0
  80dc06:	53                   	push   %ebx
  80dc07:	ff 73 18             	push   0x18(%ebx)
  80dc0a:	ff d0                	call   *%eax
  80dc0c:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  80dc0f:	84 c0                	test   %al,%al
  80dc11:	0f 85 d7 f7 ff ff    	jne    80d3ee <tcp_input+0x3f1>
          tcp_output(pcb);
  80dc17:	83 ec 0c             	sub    $0xc,%esp
  80dc1a:	53                   	push   %ebx
  80dc1b:	e8 d1 a3 ff ff       	call   807ff1 <tcp_output>
  80dc20:	83 c4 10             	add    $0x10,%esp
  80dc23:	e9 c6 f7 ff ff       	jmp    80d3ee <tcp_input+0x3f1>
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80dc28:	83 ec 08             	sub    $0x8,%esp
  80dc2b:	53                   	push   %ebx
  80dc2c:	68 4c 44 b3 00       	push   $0xb3444c
  80dc31:	e8 8f 7c ff ff       	call   8058c5 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80dc36:	83 c4 08             	add    $0x8,%esp
  80dc39:	53                   	push   %ebx
  80dc3a:	6a 02                	push   $0x2
  80dc3c:	e8 ba 68 ff ff       	call   8044fb <memp_free>
  80dc41:	83 c4 10             	add    $0x10,%esp
  80dc44:	e9 a5 f7 ff ff       	jmp    80d3ee <tcp_input+0x3f1>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dc49:	83 ec 0c             	sub    $0xc,%esp
  80dc4c:	52                   	push   %edx
  80dc4d:	e8 fa 6b ff ff       	call   80484c <pbuf_free>
  80dc52:	83 c4 10             	add    $0x10,%esp
  80dc55:	eb 98                	jmp    80dbef <tcp_input+0xbf2>
            pcb->refused_data = recv_data;
  80dc57:	a1 fc b1 b3 00       	mov    0xb3b1fc,%eax
  80dc5c:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
        if (recv_flags & TF_GOT_FIN) {
  80dc62:	f6 05 00 b2 b3 00 20 	testb  $0x20,0xb3b200
  80dc69:	0f 84 7f f7 ff ff    	je     80d3ee <tcp_input+0x3f1>
  80dc6f:	eb 87                	jmp    80dbf8 <tcp_input+0xbfb>
  80dc71:	f6 05 00 b2 b3 00 20 	testb  $0x20,0xb3b200
  80dc78:	74 95                	je     80dc0f <tcp_input+0xc12>
  80dc7a:	e9 79 ff ff ff       	jmp    80dbf8 <tcp_input+0xbfb>
        tcphdr->dest, tcphdr->src);
  80dc7f:	8b 15 14 b2 b3 00    	mov    0xb3b214,%edx
        &(iphdr->dest), &(iphdr->src),
  80dc85:	a1 10 b2 b3 00       	mov    0xb3b210,%eax
      tcp_rst(ackno, seqno + tcplen,
  80dc8a:	83 ec 08             	sub    $0x8,%esp
  80dc8d:	0f b7 0a             	movzwl (%edx),%ecx
  80dc90:	51                   	push   %ecx
  80dc91:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80dc95:	52                   	push   %edx
  80dc96:	8d 50 0c             	lea    0xc(%eax),%edx
  80dc99:	52                   	push   %edx
  80dc9a:	83 c0 10             	add    $0x10,%eax
  80dc9d:	50                   	push   %eax
  80dc9e:	0f b7 05 02 b2 b3 00 	movzwl 0xb3b202,%eax
  80dca5:	03 05 0c b2 b3 00    	add    0xb3b20c,%eax
  80dcab:	50                   	push   %eax
  80dcac:	ff 35 08 b2 b3 00    	push   0xb3b208
  80dcb2:	e8 dd a7 ff ff       	call   808494 <tcp_rst>
  80dcb7:	83 c4 20             	add    $0x20,%esp
  80dcba:	eb 14                	jmp    80dcd0 <tcp_input+0xcd3>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80dcbc:	83 ec 0c             	sub    $0xc,%esp
  80dcbf:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80dcc3:	50                   	push   %eax
  80dcc4:	e8 ca 99 ff ff       	call   807693 <ntohs>
  80dcc9:	83 c4 10             	add    $0x10,%esp
  80dccc:	a8 04                	test   $0x4,%al
  80dcce:	74 af                	je     80dc7f <tcp_input+0xc82>
    pbuf_free(p);
  80dcd0:	83 ec 0c             	sub    $0xc,%esp
  80dcd3:	56                   	push   %esi
  80dcd4:	e8 73 6b ff ff       	call   80484c <pbuf_free>
  80dcd9:	83 c4 10             	add    $0x10,%esp
  80dcdc:	e9 87 f3 ff ff       	jmp    80d068 <tcp_input+0x6b>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80dce1:	8b 1d 48 44 b3 00    	mov    0xb34448,%ebx
  80dce7:	e9 56 f7 ff ff       	jmp    80d442 <tcp_input+0x445>

0080dcec <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80dcec:	55                   	push   %ebp
  80dced:	89 e5                	mov    %esp,%ebp
  80dcef:	57                   	push   %edi
  80dcf0:	56                   	push   %esi
  80dcf1:	53                   	push   %ebx
  80dcf2:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80dcf5:	8b 45 08             	mov    0x8(%ebp),%eax
  80dcf8:	8b 78 04             	mov    0x4(%eax),%edi
  proto = IPH_PROTO(iphdr);
  80dcfb:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80dcff:	50                   	push   %eax
  80dd00:	e8 8e 99 ff ff       	call   807693 <ntohs>
  80dd05:	89 c2                	mov    %eax,%edx

  prev = NULL;
  pcb = raw_pcbs;
  80dd07:	8b 1d 2c b2 b3 00    	mov    0xb3b22c,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dd0d:	83 c4 10             	add    $0x10,%esp
  u8_t eaten = 0;
  80dd10:	b8 00 00 00 00       	mov    $0x0,%eax
  prev = NULL;
  80dd15:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    if (pcb->protocol == proto) {
  80dd1c:	0f b6 f2             	movzbl %dl,%esi
  while ((eaten == 0) && (pcb != NULL)) {
  80dd1f:	eb 11                	jmp    80dd32 <raw_input+0x46>
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dd21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80dd24:	89 45 08             	mov    %eax,0x8(%ebp)
          eaten = 1;
  80dd27:	b8 01 00 00 00       	mov    $0x1,%eax
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80dd2c:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80dd2f:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while ((eaten == 0) && (pcb != NULL)) {
  80dd32:	84 c0                	test   %al,%al
  80dd34:	75 55                	jne    80dd8b <raw_input+0x9f>
  80dd36:	85 db                	test   %ebx,%ebx
  80dd38:	74 51                	je     80dd8b <raw_input+0x9f>
    if (pcb->protocol == proto) {
  80dd3a:	0f b6 53 10          	movzbl 0x10(%ebx),%edx
  80dd3e:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd43:	39 f2                	cmp    %esi,%edx
  80dd45:	75 e5                	jne    80dd2c <raw_input+0x40>
      if (pcb->recv != NULL) {
  80dd47:	8b 53 14             	mov    0x14(%ebx),%edx
  80dd4a:	85 d2                	test   %edx,%edx
  80dd4c:	74 de                	je     80dd2c <raw_input+0x40>
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dd4e:	8d 47 0c             	lea    0xc(%edi),%eax
  80dd51:	50                   	push   %eax
  80dd52:	ff 75 08             	push   0x8(%ebp)
  80dd55:	53                   	push   %ebx
  80dd56:	ff 73 18             	push   0x18(%ebx)
  80dd59:	ff d2                	call   *%edx
  80dd5b:	83 c4 10             	add    $0x10,%esp
  80dd5e:	84 c0                	test   %al,%al
  80dd60:	74 ca                	je     80dd2c <raw_input+0x40>
          if (prev != NULL) {
  80dd62:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80dd65:	85 c9                	test   %ecx,%ecx
  80dd67:	74 b8                	je     80dd21 <raw_input+0x35>
            prev->next = pcb->next;
  80dd69:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dd6c:	89 41 0c             	mov    %eax,0xc(%ecx)
            pcb->next = raw_pcbs;
  80dd6f:	a1 2c b2 b3 00       	mov    0xb3b22c,%eax
  80dd74:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80dd77:	89 1d 2c b2 b3 00    	mov    %ebx,0xb3b22c
          eaten = 1;
  80dd7d:	b8 01 00 00 00       	mov    $0x1,%eax
          p = NULL;
  80dd82:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80dd89:	eb a1                	jmp    80dd2c <raw_input+0x40>
  }
  return eaten;
}
  80dd8b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dd8e:	5b                   	pop    %ebx
  80dd8f:	5e                   	pop    %esi
  80dd90:	5f                   	pop    %edi
  80dd91:	5d                   	pop    %ebp
  80dd92:	c3                   	ret    

0080dd93 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dd93:	55                   	push   %ebp
  80dd94:	89 e5                	mov    %esp,%ebp
  80dd96:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  80dd99:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd9e:	85 d2                	test   %edx,%edx
  80dda0:	74 02                	je     80dda4 <raw_bind+0x11>
  80dda2:	8b 02                	mov    (%edx),%eax
  80dda4:	8b 55 08             	mov    0x8(%ebp),%edx
  80dda7:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  80dda9:	b8 00 00 00 00       	mov    $0x0,%eax
  80ddae:	5d                   	pop    %ebp
  80ddaf:	c3                   	ret    

0080ddb0 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80ddb0:	55                   	push   %ebp
  80ddb1:	89 e5                	mov    %esp,%ebp
  80ddb3:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80ddb6:	b8 00 00 00 00       	mov    $0x0,%eax
  80ddbb:	85 d2                	test   %edx,%edx
  80ddbd:	74 02                	je     80ddc1 <raw_connect+0x11>
  80ddbf:	8b 02                	mov    (%edx),%eax
  80ddc1:	8b 55 08             	mov    0x8(%ebp),%edx
  80ddc4:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  80ddc7:	b8 00 00 00 00       	mov    $0x0,%eax
  80ddcc:	5d                   	pop    %ebp
  80ddcd:	c3                   	ret    

0080ddce <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80ddce:	55                   	push   %ebp
  80ddcf:	89 e5                	mov    %esp,%ebp
  80ddd1:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80ddd4:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ddd7:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80ddda:	8b 55 10             	mov    0x10(%ebp),%edx
  80dddd:	89 50 18             	mov    %edx,0x18(%eax)
}
  80dde0:	5d                   	pop    %ebp
  80dde1:	c3                   	ret    

0080dde2 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80dde2:	55                   	push   %ebp
  80dde3:	89 e5                	mov    %esp,%ebp
  80dde5:	57                   	push   %edi
  80dde6:	56                   	push   %esi
  80dde7:	53                   	push   %ebx
  80dde8:	83 ec 14             	sub    $0x14,%esp
  80ddeb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ddee:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80ddf1:	6a 14                	push   $0x14
  80ddf3:	57                   	push   %edi
  80ddf4:	e8 84 69 ff ff       	call   80477d <pbuf_header>
  80ddf9:	83 c4 10             	add    $0x10,%esp
  80ddfc:	84 c0                	test   %al,%al
  80ddfe:	74 52                	je     80de52 <raw_sendto+0x70>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80de00:	83 ec 04             	sub    $0x4,%esp
  80de03:	6a 00                	push   $0x0
  80de05:	6a 00                	push   $0x0
  80de07:	6a 01                	push   $0x1
  80de09:	e8 04 6b ff ff       	call   804912 <pbuf_alloc>
  80de0e:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80de10:	83 c4 10             	add    $0x10,%esp
  80de13:	85 c0                	test   %eax,%eax
  80de15:	0f 84 be 00 00 00    	je     80ded9 <raw_sendto+0xf7>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80de1b:	83 ec 08             	sub    $0x8,%esp
  80de1e:	57                   	push   %edi
  80de1f:	50                   	push   %eax
  80de20:	e8 f5 6e ff ff       	call   804d1a <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80de25:	83 c4 04             	add    $0x4,%esp
  80de28:	ff 75 10             	push   0x10(%ebp)
  80de2b:	e8 5f 86 ff ff       	call   80648f <ip_route>
  80de30:	83 c4 10             	add    $0x10,%esp
  80de33:	85 c0                	test   %eax,%eax
  80de35:	75 41                	jne    80de78 <raw_sendto+0x96>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80de37:	39 f7                	cmp    %esi,%edi
  80de39:	0f 84 a1 00 00 00    	je     80dee0 <raw_sendto+0xfe>
      pbuf_free(q);
  80de3f:	83 ec 0c             	sub    $0xc,%esp
  80de42:	56                   	push   %esi
  80de43:	e8 04 6a ff ff       	call   80484c <pbuf_free>
  80de48:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80de4b:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80de50:	eb 66                	jmp    80deb8 <raw_sendto+0xd6>
    if(pbuf_header(q, -IP_HLEN)) {
  80de52:	83 ec 08             	sub    $0x8,%esp
  80de55:	6a ec                	push   $0xffffffec
  80de57:	57                   	push   %edi
  80de58:	e8 20 69 ff ff       	call   80477d <pbuf_header>
  80de5d:	83 c4 10             	add    $0x10,%esp
  80de60:	84 c0                	test   %al,%al
  80de62:	75 5e                	jne    80dec2 <raw_sendto+0xe0>
  if ((netif = ip_route(ipaddr)) == NULL) {
  80de64:	83 ec 0c             	sub    $0xc,%esp
  80de67:	ff 75 10             	push   0x10(%ebp)
  80de6a:	e8 20 86 ff ff       	call   80648f <ip_route>
  80de6f:	83 c4 10             	add    $0x10,%esp
  80de72:	85 c0                	test   %eax,%eax
  80de74:	74 71                	je     80dee7 <raw_sendto+0x105>
    q = p;
  80de76:	89 fe                	mov    %edi,%esi
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80de78:	89 da                	mov    %ebx,%edx
  80de7a:	85 db                	test   %ebx,%ebx
  80de7c:	74 05                	je     80de83 <raw_sendto+0xa1>
  80de7e:	83 3b 00             	cmpl   $0x0,(%ebx)
  80de81:	75 03                	jne    80de86 <raw_sendto+0xa4>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80de83:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80de86:	83 ec 04             	sub    $0x4,%esp
  80de89:	50                   	push   %eax
  80de8a:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80de8e:	50                   	push   %eax
  80de8f:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80de93:	50                   	push   %eax
  80de94:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80de98:	50                   	push   %eax
  80de99:	ff 75 10             	push   0x10(%ebp)
  80de9c:	52                   	push   %edx
  80de9d:	56                   	push   %esi
  80de9e:	e8 6b 89 ff ff       	call   80680e <ip_output_if>
  80dea3:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80dea5:	83 c4 20             	add    $0x20,%esp
  80dea8:	39 f7                	cmp    %esi,%edi
  80deaa:	74 0c                	je     80deb8 <raw_sendto+0xd6>
    /* free the header */
    pbuf_free(q);
  80deac:	83 ec 0c             	sub    $0xc,%esp
  80deaf:	56                   	push   %esi
  80deb0:	e8 97 69 ff ff       	call   80484c <pbuf_free>
  80deb5:	83 c4 10             	add    $0x10,%esp
  }
  return err;
}
  80deb8:	89 d8                	mov    %ebx,%eax
  80deba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80debd:	5b                   	pop    %ebx
  80debe:	5e                   	pop    %esi
  80debf:	5f                   	pop    %edi
  80dec0:	5d                   	pop    %ebp
  80dec1:	c3                   	ret    
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80dec2:	83 ec 04             	sub    $0x4,%esp
  80dec5:	68 40 30 81 00       	push   $0x813040
  80deca:	68 e3 00 00 00       	push   $0xe3
  80decf:	68 66 30 81 00       	push   $0x813066
  80ded4:	e8 fd 05 00 00       	call   80e4d6 <_panic>
      return ERR_MEM;
  80ded9:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80dede:	eb d8                	jmp    80deb8 <raw_sendto+0xd6>
    return ERR_RTE;
  80dee0:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80dee5:	eb d1                	jmp    80deb8 <raw_sendto+0xd6>
  80dee7:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80deec:	eb ca                	jmp    80deb8 <raw_sendto+0xd6>

0080deee <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80deee:	55                   	push   %ebp
  80deef:	89 e5                	mov    %esp,%ebp
  80def1:	83 ec 0c             	sub    $0xc,%esp
  80def4:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80def7:	8d 50 04             	lea    0x4(%eax),%edx
  80defa:	52                   	push   %edx
  80defb:	ff 75 0c             	push   0xc(%ebp)
  80defe:	50                   	push   %eax
  80deff:	e8 de fe ff ff       	call   80dde2 <raw_sendto>
}
  80df04:	c9                   	leave  
  80df05:	c3                   	ret    

0080df06 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80df06:	55                   	push   %ebp
  80df07:	89 e5                	mov    %esp,%ebp
  80df09:	83 ec 08             	sub    $0x8,%esp
  80df0c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80df0f:	a1 2c b2 b3 00       	mov    0xb3b22c,%eax
  80df14:	39 c8                	cmp    %ecx,%eax
  80df16:	75 1b                	jne    80df33 <raw_remove+0x2d>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80df18:	8b 41 0c             	mov    0xc(%ecx),%eax
  80df1b:	a3 2c b2 b3 00       	mov    %eax,0xb3b22c
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80df20:	83 ec 08             	sub    $0x8,%esp
  80df23:	51                   	push   %ecx
  80df24:	6a 00                	push   $0x0
  80df26:	e8 d0 65 ff ff       	call   8044fb <memp_free>
}
  80df2b:	83 c4 10             	add    $0x10,%esp
  80df2e:	c9                   	leave  
  80df2f:	c3                   	ret    
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80df30:	8b 40 0c             	mov    0xc(%eax),%eax
  80df33:	85 c0                	test   %eax,%eax
  80df35:	74 e9                	je     80df20 <raw_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80df37:	8b 50 0c             	mov    0xc(%eax),%edx
  80df3a:	39 ca                	cmp    %ecx,%edx
  80df3c:	75 f2                	jne    80df30 <raw_remove+0x2a>
  80df3e:	85 d2                	test   %edx,%edx
  80df40:	74 ee                	je     80df30 <raw_remove+0x2a>
        pcb2->next = pcb->next;
  80df42:	8b 51 0c             	mov    0xc(%ecx),%edx
  80df45:	89 50 0c             	mov    %edx,0xc(%eax)
  80df48:	eb e6                	jmp    80df30 <raw_remove+0x2a>

0080df4a <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80df4a:	55                   	push   %ebp
  80df4b:	89 e5                	mov    %esp,%ebp
  80df4d:	56                   	push   %esi
  80df4e:	53                   	push   %ebx
  80df4f:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80df52:	83 ec 0c             	sub    $0xc,%esp
  80df55:	6a 00                	push   $0x0
  80df57:	e8 49 65 ff ff       	call   8044a5 <memp_malloc>
  80df5c:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80df5e:	83 c4 10             	add    $0x10,%esp
  80df61:	85 c0                	test   %eax,%eax
  80df63:	74 27                	je     80df8c <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80df65:	83 ec 04             	sub    $0x4,%esp
  80df68:	6a 1c                	push   $0x1c
  80df6a:	6a 00                	push   $0x0
  80df6c:	50                   	push   %eax
  80df6d:	e8 69 0d 00 00       	call   80ecdb <memset>
    pcb->protocol = proto;
  80df72:	89 f0                	mov    %esi,%eax
  80df74:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80df77:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80df7b:	a1 2c b2 b3 00       	mov    0xb3b22c,%eax
  80df80:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80df83:	89 1d 2c b2 b3 00    	mov    %ebx,0xb3b22c
  80df89:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80df8c:	89 d8                	mov    %ebx,%eax
  80df8e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80df91:	5b                   	pop    %ebx
  80df92:	5e                   	pop    %esi
  80df93:	5d                   	pop    %ebp
  80df94:	c3                   	ret    

0080df95 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80df95:	55                   	push   %ebp
  80df96:	89 e5                	mov    %esp,%ebp
  80df98:	57                   	push   %edi
  80df99:	56                   	push   %esi
  80df9a:	53                   	push   %ebx
  80df9b:	83 ec 28             	sub    $0x28,%esp
  80df9e:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80dfa1:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80dfa4:	0f b7 07             	movzwl (%edi),%eax
  80dfa7:	50                   	push   %eax
  80dfa8:	e8 e6 96 ff ff       	call   807693 <ntohs>
  80dfad:	66 c1 e8 06          	shr    $0x6,%ax
  80dfb1:	83 e0 3c             	and    $0x3c,%eax
  80dfb4:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80dfb8:	89 c6                	mov    %eax,%esi
  80dfba:	f7 de                	neg    %esi
  80dfbc:	0f bf f6             	movswl %si,%esi
  80dfbf:	83 c4 08             	add    $0x8,%esp
  80dfc2:	56                   	push   %esi
  80dfc3:	53                   	push   %ebx
  80dfc4:	e8 b4 67 ff ff       	call   80477d <pbuf_header>
  80dfc9:	83 c4 10             	add    $0x10,%esp
  80dfcc:	84 c0                	test   %al,%al
  80dfce:	75 67                	jne    80e037 <icmp_input+0xa2>
  80dfd0:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80dfd5:	76 60                	jbe    80e037 <icmp_input+0xa2>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80dfd7:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80dfda:	80 38 08             	cmpb   $0x8,(%eax)
  80dfdd:	74 0e                	je     80dfed <icmp_input+0x58>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80dfdf:	83 ec 0c             	sub    $0xc,%esp
  80dfe2:	53                   	push   %ebx
  80dfe3:	e8 64 68 ff ff       	call   80484c <pbuf_free>
  return;
  80dfe8:	83 c4 10             	add    $0x10,%esp
  80dfeb:	eb 56                	jmp    80e043 <icmp_input+0xae>
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80dfed:	83 ec 08             	sub    $0x8,%esp
  80dff0:	ff 75 0c             	push   0xc(%ebp)
  80dff3:	8d 47 10             	lea    0x10(%edi),%eax
  80dff6:	50                   	push   %eax
  80dff7:	e8 4e 84 ff ff       	call   80644a <ip_addr_isbroadcast>
  80dffc:	83 c4 10             	add    $0x10,%esp
  80dfff:	84 c0                	test   %al,%al
  80e001:	75 48                	jne    80e04b <icmp_input+0xb6>
  80e003:	8b 47 10             	mov    0x10(%edi),%eax
  80e006:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e009:	83 ec 0c             	sub    $0xc,%esp
  80e00c:	68 00 00 00 f0       	push   $0xf0000000
  80e011:	e8 b2 98 ff ff       	call   8078c8 <ntohl>
  80e016:	23 45 e0             	and    -0x20(%ebp),%eax
  80e019:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e01c:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e023:	e8 a0 98 ff ff       	call   8078c8 <ntohl>
  80e028:	83 c4 10             	add    $0x10,%esp
  80e02b:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e02e:	74 1b                	je     80e04b <icmp_input+0xb6>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e030:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80e035:	77 22                	ja     80e059 <icmp_input+0xc4>
lenerr:
  pbuf_free(p);
  80e037:	83 ec 0c             	sub    $0xc,%esp
  80e03a:	53                   	push   %ebx
  80e03b:	e8 0c 68 ff ff       	call   80484c <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e040:	83 c4 10             	add    $0x10,%esp
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80e043:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e046:	5b                   	pop    %ebx
  80e047:	5e                   	pop    %esi
  80e048:	5f                   	pop    %edi
  80e049:	5d                   	pop    %ebp
  80e04a:	c3                   	ret    
      pbuf_free(p);
  80e04b:	83 ec 0c             	sub    $0xc,%esp
  80e04e:	53                   	push   %ebx
  80e04f:	e8 f8 67 ff ff       	call   80484c <pbuf_free>
      return;
  80e054:	83 c4 10             	add    $0x10,%esp
  80e057:	eb ea                	jmp    80e043 <icmp_input+0xae>
    if (inet_chksum_pbuf(p) != 0) {
  80e059:	83 ec 0c             	sub    $0xc,%esp
  80e05c:	53                   	push   %ebx
  80e05d:	e8 09 95 ff ff       	call   80756b <inet_chksum_pbuf>
  80e062:	83 c4 10             	add    $0x10,%esp
  80e065:	66 85 c0             	test   %ax,%ax
  80e068:	0f 85 97 00 00 00    	jne    80e105 <icmp_input+0x170>
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e06e:	83 ec 08             	sub    $0x8,%esp
  80e071:	6a 22                	push   $0x22
  80e073:	53                   	push   %ebx
  80e074:	e8 04 67 ff ff       	call   80477d <pbuf_header>
  80e079:	83 c4 10             	add    $0x10,%esp
  80e07c:	84 c0                	test   %al,%al
  80e07e:	0f 84 fc 00 00 00    	je     80e180 <icmp_input+0x1eb>
      if (pbuf_header(p, hlen)) {
  80e084:	83 ec 08             	sub    $0x8,%esp
  80e087:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e08b:	50                   	push   %eax
  80e08c:	53                   	push   %ebx
  80e08d:	e8 eb 66 ff ff       	call   80477d <pbuf_header>
  80e092:	83 c4 10             	add    $0x10,%esp
  80e095:	84 c0                	test   %al,%al
  80e097:	75 7d                	jne    80e116 <icmp_input+0x181>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e099:	83 ec 04             	sub    $0x4,%esp
  80e09c:	6a 00                	push   $0x0
  80e09e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e0a2:	50                   	push   %eax
  80e0a3:	6a 02                	push   $0x2
  80e0a5:	e8 68 68 ff ff       	call   804912 <pbuf_alloc>
  80e0aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e0ad:	83 c4 10             	add    $0x10,%esp
  80e0b0:	85 c0                	test   %eax,%eax
  80e0b2:	74 76                	je     80e12a <icmp_input+0x195>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e0b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e0b7:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e0bb:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80e0bf:	83 c0 08             	add    $0x8,%eax
  80e0c2:	98                   	cwtl   
  80e0c3:	39 c2                	cmp    %eax,%edx
  80e0c5:	72 74                	jb     80e13b <icmp_input+0x1a6>
      if (pbuf_copy(r, p) != ERR_OK) {
  80e0c7:	83 ec 08             	sub    $0x8,%esp
  80e0ca:	53                   	push   %ebx
  80e0cb:	ff 75 e0             	push   -0x20(%ebp)
  80e0ce:	e8 0e 6d ff ff       	call   804de1 <pbuf_copy>
  80e0d3:	83 c4 10             	add    $0x10,%esp
  80e0d6:	84 c0                	test   %al,%al
  80e0d8:	75 78                	jne    80e152 <icmp_input+0x1bd>
      iphdr = r->payload;
  80e0da:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e0dd:	8b 78 04             	mov    0x4(%eax),%edi
      if (pbuf_header(r, -hlen)) {
  80e0e0:	83 ec 08             	sub    $0x8,%esp
  80e0e3:	56                   	push   %esi
  80e0e4:	50                   	push   %eax
  80e0e5:	e8 93 66 ff ff       	call   80477d <pbuf_header>
  80e0ea:	83 c4 10             	add    $0x10,%esp
  80e0ed:	84 c0                	test   %al,%al
  80e0ef:	75 78                	jne    80e169 <icmp_input+0x1d4>
      pbuf_free(p);
  80e0f1:	83 ec 0c             	sub    $0xc,%esp
  80e0f4:	53                   	push   %ebx
  80e0f5:	e8 52 67 ff ff       	call   80484c <pbuf_free>
  80e0fa:	83 c4 10             	add    $0x10,%esp
      p = r;
  80e0fd:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e100:	e9 91 00 00 00       	jmp    80e196 <icmp_input+0x201>
      pbuf_free(p);
  80e105:	83 ec 0c             	sub    $0xc,%esp
  80e108:	53                   	push   %ebx
  80e109:	e8 3e 67 ff ff       	call   80484c <pbuf_free>
      return;
  80e10e:	83 c4 10             	add    $0x10,%esp
  80e111:	e9 2d ff ff ff       	jmp    80e043 <icmp_input+0xae>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e116:	83 ec 04             	sub    $0x4,%esp
  80e119:	68 7c 30 81 00       	push   $0x81307c
  80e11e:	6a 7b                	push   $0x7b
  80e120:	68 70 31 81 00       	push   $0x813170
  80e125:	e8 ac 03 00 00       	call   80e4d6 <_panic>
  pbuf_free(p);
  80e12a:	83 ec 0c             	sub    $0xc,%esp
  80e12d:	53                   	push   %ebx
  80e12e:	e8 19 67 ff ff       	call   80484c <pbuf_free>
  return;
  80e133:	83 c4 10             	add    $0x10,%esp
  80e136:	e9 08 ff ff ff       	jmp    80e043 <icmp_input+0xae>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e13b:	83 ec 04             	sub    $0x4,%esp
  80e13e:	68 b0 30 81 00       	push   $0x8130b0
  80e143:	68 84 00 00 00       	push   $0x84
  80e148:	68 70 31 81 00       	push   $0x813170
  80e14d:	e8 84 03 00 00       	call   80e4d6 <_panic>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e152:	83 ec 04             	sub    $0x4,%esp
  80e155:	68 e8 30 81 00       	push   $0x8130e8
  80e15a:	68 88 00 00 00       	push   $0x88
  80e15f:	68 70 31 81 00       	push   $0x813170
  80e164:	e8 6d 03 00 00       	call   80e4d6 <_panic>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e169:	83 ec 04             	sub    $0x4,%esp
  80e16c:	68 10 31 81 00       	push   $0x813110
  80e171:	68 8e 00 00 00       	push   $0x8e
  80e176:	68 70 31 81 00       	push   $0x813170
  80e17b:	e8 56 03 00 00       	call   80e4d6 <_panic>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e180:	83 ec 08             	sub    $0x8,%esp
  80e183:	6a de                	push   $0xffffffde
  80e185:	53                   	push   %ebx
  80e186:	e8 f2 65 ff ff       	call   80477d <pbuf_header>
  80e18b:	83 c4 10             	add    $0x10,%esp
  80e18e:	84 c0                	test   %al,%al
  80e190:	0f 85 d3 00 00 00    	jne    80e269 <icmp_input+0x2d4>
    iecho = p->payload;
  80e196:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e199:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e19c:	8b 57 10             	mov    0x10(%edi),%edx
  80e19f:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e1a2:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e1a5:	83 ec 0c             	sub    $0xc,%esp
  80e1a8:	0f b7 06             	movzwl (%esi),%eax
  80e1ab:	50                   	push   %eax
  80e1ac:	e8 e2 94 ff ff       	call   807693 <ntohs>
  80e1b1:	0f b6 c0             	movzbl %al,%eax
  80e1b4:	89 04 24             	mov    %eax,(%esp)
  80e1b7:	e8 ca 94 ff ff       	call   807686 <htons>
  80e1bc:	66 89 06             	mov    %ax,(%esi)
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e1bf:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e1c3:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e1c7:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e1ce:	e8 b3 94 ff ff       	call   807686 <htons>
  80e1d3:	83 c4 10             	add    $0x10,%esp
  80e1d6:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e1da:	0f 82 a0 00 00 00    	jb     80e280 <icmp_input+0x2eb>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e1e0:	83 ec 0c             	sub    $0xc,%esp
  80e1e3:	68 00 08 00 00       	push   $0x800
  80e1e8:	e8 99 94 ff ff       	call   807686 <htons>
  80e1ed:	0f b7 56 02          	movzwl 0x2(%esi),%edx
  80e1f1:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  80e1f5:	83 c4 10             	add    $0x10,%esp
  80e1f8:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e1fc:	83 ec 0c             	sub    $0xc,%esp
  80e1ff:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e203:	50                   	push   %eax
  80e204:	e8 8a 94 ff ff       	call   807693 <ntohs>
  80e209:	66 0d 00 ff          	or     $0xff00,%ax
  80e20d:	0f b7 c0             	movzwl %ax,%eax
  80e210:	89 04 24             	mov    %eax,(%esp)
  80e213:	e8 6e 94 ff ff       	call   807686 <htons>
  80e218:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e21c:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e222:	83 c4 08             	add    $0x8,%esp
  80e225:	6a 14                	push   $0x14
  80e227:	57                   	push   %edi
  80e228:	e8 28 93 ff ff       	call   807555 <inet_chksum>
  80e22d:	66 89 47 0a          	mov    %ax,0xa(%edi)
    if(pbuf_header(p, hlen)) {
  80e231:	83 c4 08             	add    $0x8,%esp
  80e234:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e238:	50                   	push   %eax
  80e239:	53                   	push   %ebx
  80e23a:	e8 3e 65 ff ff       	call   80477d <pbuf_header>
  80e23f:	83 c4 10             	add    $0x10,%esp
  80e242:	84 c0                	test   %al,%al
  80e244:	75 53                	jne    80e299 <icmp_input+0x304>
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e246:	83 ec 04             	sub    $0x4,%esp
  80e249:	ff 75 0c             	push   0xc(%ebp)
  80e24c:	6a 01                	push   $0x1
  80e24e:	6a 00                	push   $0x0
  80e250:	68 ff 00 00 00       	push   $0xff
  80e255:	6a 00                	push   $0x0
  80e257:	83 c7 0c             	add    $0xc,%edi
  80e25a:	57                   	push   %edi
  80e25b:	53                   	push   %ebx
  80e25c:	e8 ad 85 ff ff       	call   80680e <ip_output_if>
  80e261:	83 c4 20             	add    $0x20,%esp
  80e264:	e9 76 fd ff ff       	jmp    80dfdf <icmp_input+0x4a>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e269:	83 ec 04             	sub    $0x4,%esp
  80e26c:	68 10 31 81 00       	push   $0x813110
  80e271:	68 98 00 00 00       	push   $0x98
  80e276:	68 70 31 81 00       	push   $0x813170
  80e27b:	e8 56 02 00 00       	call   80e4d6 <_panic>
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e280:	83 ec 0c             	sub    $0xc,%esp
  80e283:	68 00 08 00 00       	push   $0x800
  80e288:	e8 f9 93 ff ff       	call   807686 <htons>
  80e28d:	66 03 46 02          	add    0x2(%esi),%ax
  80e291:	83 c4 10             	add    $0x10,%esp
  80e294:	e9 5f ff ff ff       	jmp    80e1f8 <icmp_input+0x263>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e299:	83 ec 04             	sub    $0x4,%esp
  80e29c:	68 d8 21 81 00       	push   $0x8121d8
  80e2a1:	68 b9 00 00 00       	push   $0xb9
  80e2a6:	68 70 31 81 00       	push   $0x813170
  80e2ab:	e8 26 02 00 00       	call   80e4d6 <_panic>

0080e2b0 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e2b0:	55                   	push   %ebp
  80e2b1:	89 e5                	mov    %esp,%ebp
  80e2b3:	57                   	push   %edi
  80e2b4:	56                   	push   %esi
  80e2b5:	53                   	push   %ebx
  80e2b6:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e2b9:	6a 00                	push   $0x0
  80e2bb:	6a 24                	push   $0x24
  80e2bd:	6a 01                	push   $0x1
  80e2bf:	e8 4e 66 ff ff       	call   804912 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e2c4:	83 c4 10             	add    $0x10,%esp
  80e2c7:	85 c0                	test   %eax,%eax
  80e2c9:	0f 84 a5 00 00 00    	je     80e374 <icmp_dest_unreach+0xc4>
  80e2cf:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e2d1:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e2d6:	0f 86 a0 00 00 00    	jbe    80e37c <icmp_dest_unreach+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e2dc:	8b 45 08             	mov    0x8(%ebp),%eax
  80e2df:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e2e2:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e2e5:	83 ec 0c             	sub    $0xc,%esp
  80e2e8:	0f b7 06             	movzwl (%esi),%eax
  80e2eb:	50                   	push   %eax
  80e2ec:	e8 a2 93 ff ff       	call   807693 <ntohs>
  80e2f1:	0f b6 c0             	movzbl %al,%eax
  80e2f4:	80 cc 03             	or     $0x3,%ah
  80e2f7:	89 04 24             	mov    %eax,(%esp)
  80e2fa:	e8 87 93 ff ff       	call   807686 <htons>
  80e2ff:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e302:	0f b7 c0             	movzwl %ax,%eax
  80e305:	89 04 24             	mov    %eax,(%esp)
  80e308:	e8 86 93 ff ff       	call   807693 <ntohs>
  80e30d:	b0 00                	mov    $0x0,%al
  80e30f:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e313:	0f b7 c0             	movzwl %ax,%eax
  80e316:	89 04 24             	mov    %eax,(%esp)
  80e319:	e8 68 93 ff ff       	call   807686 <htons>
  80e31e:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e321:	83 c4 0c             	add    $0xc,%esp
  80e324:	6a 1c                	push   $0x1c
  80e326:	8b 45 08             	mov    0x8(%ebp),%eax
  80e329:	ff 70 04             	push   0x4(%eax)
  80e32c:	8b 43 04             	mov    0x4(%ebx),%eax
  80e32f:	83 c0 08             	add    $0x8,%eax
  80e332:	50                   	push   %eax
  80e333:	e8 4b 0a 00 00       	call   80ed83 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e338:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e33e:	83 c4 08             	add    $0x8,%esp
  80e341:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e345:	50                   	push   %eax
  80e346:	56                   	push   %esi
  80e347:	e8 09 92 ff ff       	call   807555 <inet_chksum>
  80e34c:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e350:	83 c4 08             	add    $0x8,%esp
  80e353:	6a 01                	push   $0x1
  80e355:	6a 00                	push   $0x0
  80e357:	68 ff 00 00 00       	push   $0xff
  80e35c:	83 c7 0c             	add    $0xc,%edi
  80e35f:	57                   	push   %edi
  80e360:	6a 00                	push   $0x0
  80e362:	53                   	push   %ebx
  80e363:	e8 1d 86 ff ff       	call   806985 <ip_output>
  pbuf_free(q);
  80e368:	83 c4 14             	add    $0x14,%esp
  80e36b:	53                   	push   %ebx
  80e36c:	e8 db 64 ff ff       	call   80484c <pbuf_free>
  80e371:	83 c4 10             	add    $0x10,%esp
}
  80e374:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e377:	5b                   	pop    %ebx
  80e378:	5e                   	pop    %esi
  80e379:	5f                   	pop    %edi
  80e37a:	5d                   	pop    %ebp
  80e37b:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e37c:	83 ec 04             	sub    $0x4,%esp
  80e37f:	68 44 31 81 00       	push   $0x813144
  80e384:	68 ee 00 00 00       	push   $0xee
  80e389:	68 70 31 81 00       	push   $0x813170
  80e38e:	e8 43 01 00 00       	call   80e4d6 <_panic>

0080e393 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e393:	55                   	push   %ebp
  80e394:	89 e5                	mov    %esp,%ebp
  80e396:	57                   	push   %edi
  80e397:	56                   	push   %esi
  80e398:	53                   	push   %ebx
  80e399:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e39c:	6a 00                	push   $0x0
  80e39e:	6a 24                	push   $0x24
  80e3a0:	6a 01                	push   $0x1
  80e3a2:	e8 6b 65 ff ff       	call   804912 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e3a7:	83 c4 10             	add    $0x10,%esp
  80e3aa:	85 c0                	test   %eax,%eax
  80e3ac:	0f 84 a5 00 00 00    	je     80e457 <icmp_time_exceeded+0xc4>
  80e3b2:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e3b4:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e3b9:	0f 86 a0 00 00 00    	jbe    80e45f <icmp_time_exceeded+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e3bf:	8b 45 08             	mov    0x8(%ebp),%eax
  80e3c2:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e3c5:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e3c8:	83 ec 0c             	sub    $0xc,%esp
  80e3cb:	0f b7 06             	movzwl (%esi),%eax
  80e3ce:	50                   	push   %eax
  80e3cf:	e8 bf 92 ff ff       	call   807693 <ntohs>
  80e3d4:	0f b6 c0             	movzbl %al,%eax
  80e3d7:	80 cc 0b             	or     $0xb,%ah
  80e3da:	89 04 24             	mov    %eax,(%esp)
  80e3dd:	e8 a4 92 ff ff       	call   807686 <htons>
  80e3e2:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e3e5:	0f b7 c0             	movzwl %ax,%eax
  80e3e8:	89 04 24             	mov    %eax,(%esp)
  80e3eb:	e8 a3 92 ff ff       	call   807693 <ntohs>
  80e3f0:	b0 00                	mov    $0x0,%al
  80e3f2:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e3f6:	0f b7 c0             	movzwl %ax,%eax
  80e3f9:	89 04 24             	mov    %eax,(%esp)
  80e3fc:	e8 85 92 ff ff       	call   807686 <htons>
  80e401:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e404:	83 c4 0c             	add    $0xc,%esp
  80e407:	6a 1c                	push   $0x1c
  80e409:	8b 45 08             	mov    0x8(%ebp),%eax
  80e40c:	ff 70 04             	push   0x4(%eax)
  80e40f:	8b 43 04             	mov    0x4(%ebx),%eax
  80e412:	83 c0 08             	add    $0x8,%eax
  80e415:	50                   	push   %eax
  80e416:	e8 68 09 00 00       	call   80ed83 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e41b:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e421:	83 c4 08             	add    $0x8,%esp
  80e424:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e428:	50                   	push   %eax
  80e429:	56                   	push   %esi
  80e42a:	e8 26 91 ff ff       	call   807555 <inet_chksum>
  80e42f:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e433:	83 c4 08             	add    $0x8,%esp
  80e436:	6a 01                	push   $0x1
  80e438:	6a 00                	push   $0x0
  80e43a:	68 ff 00 00 00       	push   $0xff
  80e43f:	83 c7 0c             	add    $0xc,%edi
  80e442:	57                   	push   %edi
  80e443:	6a 00                	push   $0x0
  80e445:	53                   	push   %ebx
  80e446:	e8 3a 85 ff ff       	call   806985 <ip_output>
  pbuf_free(q);
  80e44b:	83 c4 14             	add    $0x14,%esp
  80e44e:	53                   	push   %ebx
  80e44f:	e8 f8 63 ff ff       	call   80484c <pbuf_free>
  80e454:	83 c4 10             	add    $0x10,%esp
}
  80e457:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e45a:	5b                   	pop    %ebx
  80e45b:	5e                   	pop    %esi
  80e45c:	5f                   	pop    %edi
  80e45d:	5d                   	pop    %ebp
  80e45e:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e45f:	83 ec 04             	sub    $0x4,%esp
  80e462:	68 44 31 81 00       	push   $0x813144
  80e467:	68 1d 01 00 00       	push   $0x11d
  80e46c:	68 70 31 81 00       	push   $0x813170
  80e471:	e8 60 00 00 00       	call   80e4d6 <_panic>

0080e476 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80e476:	55                   	push   %ebp
  80e477:	89 e5                	mov    %esp,%ebp
  80e479:	56                   	push   %esi
  80e47a:	53                   	push   %ebx
  80e47b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e47e:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	//定义在kern/syscall.c中的sys_getenvid()可以获得curenv->env_id。
	//而之前我们知道env_id 0~9位 是在envs数组中的索引。(在inc/env.h中，并且有专门的宏 ENVX(envid) 供调用)
	thisenv = &envs[ENVX(sys_getenvid())];
  80e481:	e8 c3 0a 00 00       	call   80ef49 <sys_getenvid>
  80e486:	25 ff 03 00 00       	and    $0x3ff,%eax
  80e48b:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80e48e:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80e493:	a3 30 b2 b3 00       	mov    %eax,0xb3b230

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e498:	85 db                	test   %ebx,%ebx
  80e49a:	7e 07                	jle    80e4a3 <libmain+0x2d>
		binaryname = argv[0];
  80e49c:	8b 06                	mov    (%esi),%eax
  80e49e:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80e4a3:	83 ec 08             	sub    $0x8,%esp
  80e4a6:	56                   	push   %esi
  80e4a7:	53                   	push   %ebx
  80e4a8:	e8 c8 20 ff ff       	call   800575 <umain>

	// exit gracefully
	exit();
  80e4ad:	e8 0a 00 00 00       	call   80e4bc <exit>
}
  80e4b2:	83 c4 10             	add    $0x10,%esp
  80e4b5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e4b8:	5b                   	pop    %ebx
  80e4b9:	5e                   	pop    %esi
  80e4ba:	5d                   	pop    %ebp
  80e4bb:	c3                   	ret    

0080e4bc <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e4bc:	55                   	push   %ebp
  80e4bd:	89 e5                	mov    %esp,%ebp
  80e4bf:	83 ec 08             	sub    $0x8,%esp
	close_all();
  80e4c2:	e8 55 12 00 00       	call   80f71c <close_all>
	sys_env_destroy(0);
  80e4c7:	83 ec 0c             	sub    $0xc,%esp
  80e4ca:	6a 00                	push   $0x0
  80e4cc:	e8 37 0a 00 00       	call   80ef08 <sys_env_destroy>
}
  80e4d1:	83 c4 10             	add    $0x10,%esp
  80e4d4:	c9                   	leave  
  80e4d5:	c3                   	ret    

0080e4d6 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e4d6:	55                   	push   %ebp
  80e4d7:	89 e5                	mov    %esp,%ebp
  80e4d9:	56                   	push   %esi
  80e4da:	53                   	push   %ebx
	va_list ap;

	va_start(ap, fmt);
  80e4db:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e4de:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e4e4:	e8 60 0a 00 00       	call   80ef49 <sys_getenvid>
  80e4e9:	83 ec 0c             	sub    $0xc,%esp
  80e4ec:	ff 75 0c             	push   0xc(%ebp)
  80e4ef:	ff 75 08             	push   0x8(%ebp)
  80e4f2:	56                   	push   %esi
  80e4f3:	50                   	push   %eax
  80e4f4:	68 94 31 81 00       	push   $0x813194
  80e4f9:	e8 b3 00 00 00       	call   80e5b1 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e4fe:	83 c4 18             	add    $0x18,%esp
  80e501:	53                   	push   %ebx
  80e502:	ff 75 10             	push   0x10(%ebp)
  80e505:	e8 56 00 00 00       	call   80e560 <vcprintf>
	cprintf("\n");
  80e50a:	c7 04 24 88 0d 81 00 	movl   $0x810d88,(%esp)
  80e511:	e8 9b 00 00 00       	call   80e5b1 <cprintf>
  80e516:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e519:	cc                   	int3   
  80e51a:	eb fd                	jmp    80e519 <_panic+0x43>

0080e51c <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e51c:	55                   	push   %ebp
  80e51d:	89 e5                	mov    %esp,%ebp
  80e51f:	53                   	push   %ebx
  80e520:	83 ec 04             	sub    $0x4,%esp
  80e523:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e526:	8b 13                	mov    (%ebx),%edx
  80e528:	8d 42 01             	lea    0x1(%edx),%eax
  80e52b:	89 03                	mov    %eax,(%ebx)
  80e52d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e530:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e534:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e539:	74 09                	je     80e544 <putch+0x28>
		sys_cputs(b->buf, b->idx);
		b->idx = 0;
	}
	b->cnt++;
  80e53b:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e53f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e542:	c9                   	leave  
  80e543:	c3                   	ret    
		sys_cputs(b->buf, b->idx);
  80e544:	83 ec 08             	sub    $0x8,%esp
  80e547:	68 ff 00 00 00       	push   $0xff
  80e54c:	8d 43 08             	lea    0x8(%ebx),%eax
  80e54f:	50                   	push   %eax
  80e550:	e8 76 09 00 00       	call   80eecb <sys_cputs>
		b->idx = 0;
  80e555:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e55b:	83 c4 10             	add    $0x10,%esp
  80e55e:	eb db                	jmp    80e53b <putch+0x1f>

0080e560 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e560:	55                   	push   %ebp
  80e561:	89 e5                	mov    %esp,%ebp
  80e563:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e569:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e570:	00 00 00 
	b.cnt = 0;
  80e573:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e57a:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e57d:	ff 75 0c             	push   0xc(%ebp)
  80e580:	ff 75 08             	push   0x8(%ebp)
  80e583:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e589:	50                   	push   %eax
  80e58a:	68 1c e5 80 00       	push   $0x80e51c
  80e58f:	e8 14 01 00 00       	call   80e6a8 <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e594:	83 c4 08             	add    $0x8,%esp
  80e597:	ff b5 f0 fe ff ff    	push   -0x110(%ebp)
  80e59d:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e5a3:	50                   	push   %eax
  80e5a4:	e8 22 09 00 00       	call   80eecb <sys_cputs>

	return b.cnt;
}
  80e5a9:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e5af:	c9                   	leave  
  80e5b0:	c3                   	ret    

0080e5b1 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e5b1:	55                   	push   %ebp
  80e5b2:	89 e5                	mov    %esp,%ebp
  80e5b4:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e5b7:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e5ba:	50                   	push   %eax
  80e5bb:	ff 75 08             	push   0x8(%ebp)
  80e5be:	e8 9d ff ff ff       	call   80e560 <vcprintf>
	va_end(ap);

	return cnt;
}
  80e5c3:	c9                   	leave  
  80e5c4:	c3                   	ret    

0080e5c5 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e5c5:	55                   	push   %ebp
  80e5c6:	89 e5                	mov    %esp,%ebp
  80e5c8:	57                   	push   %edi
  80e5c9:	56                   	push   %esi
  80e5ca:	53                   	push   %ebx
  80e5cb:	83 ec 1c             	sub    $0x1c,%esp
  80e5ce:	89 c7                	mov    %eax,%edi
  80e5d0:	89 d6                	mov    %edx,%esi
  80e5d2:	8b 45 08             	mov    0x8(%ebp),%eax
  80e5d5:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e5d8:	89 d1                	mov    %edx,%ecx
  80e5da:	89 c2                	mov    %eax,%edx
  80e5dc:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e5df:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80e5e2:	8b 45 10             	mov    0x10(%ebp),%eax
  80e5e5:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80e5e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e5eb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80e5f2:	39 c2                	cmp    %eax,%edx
  80e5f4:	1b 4d e4             	sbb    -0x1c(%ebp),%ecx
  80e5f7:	72 3e                	jb     80e637 <printnum+0x72>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80e5f9:	83 ec 0c             	sub    $0xc,%esp
  80e5fc:	ff 75 18             	push   0x18(%ebp)
  80e5ff:	83 eb 01             	sub    $0x1,%ebx
  80e602:	53                   	push   %ebx
  80e603:	50                   	push   %eax
  80e604:	83 ec 08             	sub    $0x8,%esp
  80e607:	ff 75 e4             	push   -0x1c(%ebp)
  80e60a:	ff 75 e0             	push   -0x20(%ebp)
  80e60d:	ff 75 dc             	push   -0x24(%ebp)
  80e610:	ff 75 d8             	push   -0x28(%ebp)
  80e613:	e8 a8 23 00 00       	call   8109c0 <__udivdi3>
  80e618:	83 c4 18             	add    $0x18,%esp
  80e61b:	52                   	push   %edx
  80e61c:	50                   	push   %eax
  80e61d:	89 f2                	mov    %esi,%edx
  80e61f:	89 f8                	mov    %edi,%eax
  80e621:	e8 9f ff ff ff       	call   80e5c5 <printnum>
  80e626:	83 c4 20             	add    $0x20,%esp
  80e629:	eb 13                	jmp    80e63e <printnum+0x79>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80e62b:	83 ec 08             	sub    $0x8,%esp
  80e62e:	56                   	push   %esi
  80e62f:	ff 75 18             	push   0x18(%ebp)
  80e632:	ff d7                	call   *%edi
  80e634:	83 c4 10             	add    $0x10,%esp
		while (--width > 0)
  80e637:	83 eb 01             	sub    $0x1,%ebx
  80e63a:	85 db                	test   %ebx,%ebx
  80e63c:	7f ed                	jg     80e62b <printnum+0x66>
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80e63e:	83 ec 08             	sub    $0x8,%esp
  80e641:	56                   	push   %esi
  80e642:	83 ec 04             	sub    $0x4,%esp
  80e645:	ff 75 e4             	push   -0x1c(%ebp)
  80e648:	ff 75 e0             	push   -0x20(%ebp)
  80e64b:	ff 75 dc             	push   -0x24(%ebp)
  80e64e:	ff 75 d8             	push   -0x28(%ebp)
  80e651:	e8 8a 24 00 00       	call   810ae0 <__umoddi3>
  80e656:	83 c4 14             	add    $0x14,%esp
  80e659:	0f be 80 b7 31 81 00 	movsbl 0x8131b7(%eax),%eax
  80e660:	50                   	push   %eax
  80e661:	ff d7                	call   *%edi
}
  80e663:	83 c4 10             	add    $0x10,%esp
  80e666:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e669:	5b                   	pop    %ebx
  80e66a:	5e                   	pop    %esi
  80e66b:	5f                   	pop    %edi
  80e66c:	5d                   	pop    %ebp
  80e66d:	c3                   	ret    

0080e66e <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e66e:	55                   	push   %ebp
  80e66f:	89 e5                	mov    %esp,%ebp
  80e671:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e674:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e678:	8b 10                	mov    (%eax),%edx
  80e67a:	3b 50 04             	cmp    0x4(%eax),%edx
  80e67d:	73 0a                	jae    80e689 <sprintputch+0x1b>
		*b->buf++ = ch;
  80e67f:	8d 4a 01             	lea    0x1(%edx),%ecx
  80e682:	89 08                	mov    %ecx,(%eax)
  80e684:	8b 45 08             	mov    0x8(%ebp),%eax
  80e687:	88 02                	mov    %al,(%edx)
}
  80e689:	5d                   	pop    %ebp
  80e68a:	c3                   	ret    

0080e68b <printfmt>:
{
  80e68b:	55                   	push   %ebp
  80e68c:	89 e5                	mov    %esp,%ebp
  80e68e:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
  80e691:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80e694:	50                   	push   %eax
  80e695:	ff 75 10             	push   0x10(%ebp)
  80e698:	ff 75 0c             	push   0xc(%ebp)
  80e69b:	ff 75 08             	push   0x8(%ebp)
  80e69e:	e8 05 00 00 00       	call   80e6a8 <vprintfmt>
}
  80e6a3:	83 c4 10             	add    $0x10,%esp
  80e6a6:	c9                   	leave  
  80e6a7:	c3                   	ret    

0080e6a8 <vprintfmt>:
{
  80e6a8:	55                   	push   %ebp
  80e6a9:	89 e5                	mov    %esp,%ebp
  80e6ab:	57                   	push   %edi
  80e6ac:	56                   	push   %esi
  80e6ad:	53                   	push   %ebx
  80e6ae:	83 ec 3c             	sub    $0x3c,%esp
  80e6b1:	8b 75 08             	mov    0x8(%ebp),%esi
  80e6b4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e6b7:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e6ba:	eb 0a                	jmp    80e6c6 <vprintfmt+0x1e>
			putch(ch, putdat);
  80e6bc:	83 ec 08             	sub    $0x8,%esp
  80e6bf:	53                   	push   %ebx
  80e6c0:	50                   	push   %eax
  80e6c1:	ff d6                	call   *%esi
  80e6c3:	83 c4 10             	add    $0x10,%esp
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80e6c6:	83 c7 01             	add    $0x1,%edi
  80e6c9:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e6cd:	83 f8 25             	cmp    $0x25,%eax
  80e6d0:	74 0c                	je     80e6de <vprintfmt+0x36>
			if (ch == '\0')
  80e6d2:	85 c0                	test   %eax,%eax
  80e6d4:	75 e6                	jne    80e6bc <vprintfmt+0x14>
}
  80e6d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e6d9:	5b                   	pop    %ebx
  80e6da:	5e                   	pop    %esi
  80e6db:	5f                   	pop    %edi
  80e6dc:	5d                   	pop    %ebp
  80e6dd:	c3                   	ret    
		padc = ' ';
  80e6de:	c6 45 d3 20          	movb   $0x20,-0x2d(%ebp)
		altflag = 0;
  80e6e2:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		precision = -1;
  80e6e9:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
		width = -1;
  80e6f0:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
  80e6f7:	b9 00 00 00 00       	mov    $0x0,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80e6fc:	8d 47 01             	lea    0x1(%edi),%eax
  80e6ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e702:	0f b6 17             	movzbl (%edi),%edx
  80e705:	8d 42 dd             	lea    -0x23(%edx),%eax
  80e708:	3c 55                	cmp    $0x55,%al
  80e70a:	0f 87 bb 03 00 00    	ja     80eacb <vprintfmt+0x423>
  80e710:	0f b6 c0             	movzbl %al,%eax
  80e713:	ff 24 85 00 33 81 00 	jmp    *0x813300(,%eax,4)
  80e71a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
  80e71d:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%ebp)
  80e721:	eb d9                	jmp    80e6fc <vprintfmt+0x54>
		switch (ch = *(unsigned char *) fmt++) {
  80e723:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e726:	c6 45 d3 30          	movb   $0x30,-0x2d(%ebp)
  80e72a:	eb d0                	jmp    80e6fc <vprintfmt+0x54>
  80e72c:	0f b6 d2             	movzbl %dl,%edx
  80e72f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			for (precision = 0; ; ++fmt) {
  80e732:	b8 00 00 00 00       	mov    $0x0,%eax
  80e737:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
				precision = precision * 10 + ch - '0';
  80e73a:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80e73d:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
				ch = *fmt;
  80e741:	0f be 17             	movsbl (%edi),%edx
				if (ch < '0' || ch > '9')
  80e744:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80e747:	83 f9 09             	cmp    $0x9,%ecx
  80e74a:	77 55                	ja     80e7a1 <vprintfmt+0xf9>
			for (precision = 0; ; ++fmt) {
  80e74c:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
  80e74f:	eb e9                	jmp    80e73a <vprintfmt+0x92>
			precision = va_arg(ap, int);
  80e751:	8b 45 14             	mov    0x14(%ebp),%eax
  80e754:	8b 00                	mov    (%eax),%eax
  80e756:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e759:	8b 45 14             	mov    0x14(%ebp),%eax
  80e75c:	8d 40 04             	lea    0x4(%eax),%eax
  80e75f:	89 45 14             	mov    %eax,0x14(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e762:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
  80e765:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e769:	79 91                	jns    80e6fc <vprintfmt+0x54>
				width = precision, precision = -1;
  80e76b:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e76e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e771:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
  80e778:	eb 82                	jmp    80e6fc <vprintfmt+0x54>
  80e77a:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e77d:	85 d2                	test   %edx,%edx
  80e77f:	b8 00 00 00 00       	mov    $0x0,%eax
  80e784:	0f 49 c2             	cmovns %edx,%eax
  80e787:	89 45 e0             	mov    %eax,-0x20(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e78a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80e78d:	e9 6a ff ff ff       	jmp    80e6fc <vprintfmt+0x54>
		switch (ch = *(unsigned char *) fmt++) {
  80e792:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			altflag = 1;
  80e795:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
			goto reswitch;
  80e79c:	e9 5b ff ff ff       	jmp    80e6fc <vprintfmt+0x54>
  80e7a1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e7a4:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e7a7:	eb bc                	jmp    80e765 <vprintfmt+0xbd>
			lflag++;
  80e7a9:	83 c1 01             	add    $0x1,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80e7ac:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80e7af:	e9 48 ff ff ff       	jmp    80e6fc <vprintfmt+0x54>
			putch(va_arg(ap, int), putdat);
  80e7b4:	8b 45 14             	mov    0x14(%ebp),%eax
  80e7b7:	8d 78 04             	lea    0x4(%eax),%edi
  80e7ba:	83 ec 08             	sub    $0x8,%esp
  80e7bd:	53                   	push   %ebx
  80e7be:	ff 30                	push   (%eax)
  80e7c0:	ff d6                	call   *%esi
			break;
  80e7c2:	83 c4 10             	add    $0x10,%esp
			putch(va_arg(ap, int), putdat);
  80e7c5:	89 7d 14             	mov    %edi,0x14(%ebp)
			break;
  80e7c8:	e9 9d 02 00 00       	jmp    80ea6a <vprintfmt+0x3c2>
			err = va_arg(ap, int);
  80e7cd:	8b 45 14             	mov    0x14(%ebp),%eax
  80e7d0:	8d 78 04             	lea    0x4(%eax),%edi
  80e7d3:	8b 10                	mov    (%eax),%edx
  80e7d5:	89 d0                	mov    %edx,%eax
  80e7d7:	f7 d8                	neg    %eax
  80e7d9:	0f 48 c2             	cmovs  %edx,%eax
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80e7dc:	83 f8 0f             	cmp    $0xf,%eax
  80e7df:	7f 23                	jg     80e804 <vprintfmt+0x15c>
  80e7e1:	8b 14 85 60 34 81 00 	mov    0x813460(,%eax,4),%edx
  80e7e8:	85 d2                	test   %edx,%edx
  80e7ea:	74 18                	je     80e804 <vprintfmt+0x15c>
				printfmt(putch, putdat, "%s", p);
  80e7ec:	52                   	push   %edx
  80e7ed:	68 9d 23 81 00       	push   $0x81239d
  80e7f2:	53                   	push   %ebx
  80e7f3:	56                   	push   %esi
  80e7f4:	e8 92 fe ff ff       	call   80e68b <printfmt>
  80e7f9:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80e7fc:	89 7d 14             	mov    %edi,0x14(%ebp)
  80e7ff:	e9 66 02 00 00       	jmp    80ea6a <vprintfmt+0x3c2>
				printfmt(putch, putdat, "error %d", err);
  80e804:	50                   	push   %eax
  80e805:	68 cf 31 81 00       	push   $0x8131cf
  80e80a:	53                   	push   %ebx
  80e80b:	56                   	push   %esi
  80e80c:	e8 7a fe ff ff       	call   80e68b <printfmt>
  80e811:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80e814:	89 7d 14             	mov    %edi,0x14(%ebp)
				printfmt(putch, putdat, "error %d", err);
  80e817:	e9 4e 02 00 00       	jmp    80ea6a <vprintfmt+0x3c2>
			if ((p = va_arg(ap, char *)) == NULL)
  80e81c:	8b 45 14             	mov    0x14(%ebp),%eax
  80e81f:	83 c0 04             	add    $0x4,%eax
  80e822:	89 45 c8             	mov    %eax,-0x38(%ebp)
  80e825:	8b 45 14             	mov    0x14(%ebp),%eax
  80e828:	8b 10                	mov    (%eax),%edx
				p = "(null)";
  80e82a:	85 d2                	test   %edx,%edx
  80e82c:	b8 c8 31 81 00       	mov    $0x8131c8,%eax
  80e831:	0f 45 c2             	cmovne %edx,%eax
  80e834:	89 45 cc             	mov    %eax,-0x34(%ebp)
			if (width > 0 && padc != '-')
  80e837:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e83b:	7e 06                	jle    80e843 <vprintfmt+0x19b>
  80e83d:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%ebp)
  80e841:	75 0d                	jne    80e850 <vprintfmt+0x1a8>
				for (width -= strnlen(p, precision); width > 0; width--)
  80e843:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80e846:	89 c7                	mov    %eax,%edi
  80e848:	03 45 e0             	add    -0x20(%ebp),%eax
  80e84b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e84e:	eb 55                	jmp    80e8a5 <vprintfmt+0x1fd>
  80e850:	83 ec 08             	sub    $0x8,%esp
  80e853:	ff 75 d8             	push   -0x28(%ebp)
  80e856:	ff 75 cc             	push   -0x34(%ebp)
  80e859:	e8 0a 03 00 00       	call   80eb68 <strnlen>
  80e85e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e861:	29 c1                	sub    %eax,%ecx
  80e863:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  80e866:	83 c4 10             	add    $0x10,%esp
  80e869:	89 cf                	mov    %ecx,%edi
					putch(padc, putdat);
  80e86b:	0f be 45 d3          	movsbl -0x2d(%ebp),%eax
  80e86f:	89 45 e0             	mov    %eax,-0x20(%ebp)
				for (width -= strnlen(p, precision); width > 0; width--)
  80e872:	eb 0f                	jmp    80e883 <vprintfmt+0x1db>
					putch(padc, putdat);
  80e874:	83 ec 08             	sub    $0x8,%esp
  80e877:	53                   	push   %ebx
  80e878:	ff 75 e0             	push   -0x20(%ebp)
  80e87b:	ff d6                	call   *%esi
				for (width -= strnlen(p, precision); width > 0; width--)
  80e87d:	83 ef 01             	sub    $0x1,%edi
  80e880:	83 c4 10             	add    $0x10,%esp
  80e883:	85 ff                	test   %edi,%edi
  80e885:	7f ed                	jg     80e874 <vprintfmt+0x1cc>
  80e887:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  80e88a:	85 d2                	test   %edx,%edx
  80e88c:	b8 00 00 00 00       	mov    $0x0,%eax
  80e891:	0f 49 c2             	cmovns %edx,%eax
  80e894:	29 c2                	sub    %eax,%edx
  80e896:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80e899:	eb a8                	jmp    80e843 <vprintfmt+0x19b>
					putch(ch, putdat);
  80e89b:	83 ec 08             	sub    $0x8,%esp
  80e89e:	53                   	push   %ebx
  80e89f:	52                   	push   %edx
  80e8a0:	ff d6                	call   *%esi
  80e8a2:	83 c4 10             	add    $0x10,%esp
  80e8a5:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e8a8:	29 f9                	sub    %edi,%ecx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80e8aa:	83 c7 01             	add    $0x1,%edi
  80e8ad:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e8b1:	0f be d0             	movsbl %al,%edx
  80e8b4:	85 d2                	test   %edx,%edx
  80e8b6:	74 4b                	je     80e903 <vprintfmt+0x25b>
  80e8b8:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80e8bc:	78 06                	js     80e8c4 <vprintfmt+0x21c>
  80e8be:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  80e8c2:	78 1e                	js     80e8e2 <vprintfmt+0x23a>
				if (altflag && (ch < ' ' || ch > '~'))
  80e8c4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80e8c8:	74 d1                	je     80e89b <vprintfmt+0x1f3>
  80e8ca:	0f be c0             	movsbl %al,%eax
  80e8cd:	83 e8 20             	sub    $0x20,%eax
  80e8d0:	83 f8 5e             	cmp    $0x5e,%eax
  80e8d3:	76 c6                	jbe    80e89b <vprintfmt+0x1f3>
					putch('?', putdat);
  80e8d5:	83 ec 08             	sub    $0x8,%esp
  80e8d8:	53                   	push   %ebx
  80e8d9:	6a 3f                	push   $0x3f
  80e8db:	ff d6                	call   *%esi
  80e8dd:	83 c4 10             	add    $0x10,%esp
  80e8e0:	eb c3                	jmp    80e8a5 <vprintfmt+0x1fd>
  80e8e2:	89 cf                	mov    %ecx,%edi
  80e8e4:	eb 0e                	jmp    80e8f4 <vprintfmt+0x24c>
				putch(' ', putdat);
  80e8e6:	83 ec 08             	sub    $0x8,%esp
  80e8e9:	53                   	push   %ebx
  80e8ea:	6a 20                	push   $0x20
  80e8ec:	ff d6                	call   *%esi
			for (; width > 0; width--)
  80e8ee:	83 ef 01             	sub    $0x1,%edi
  80e8f1:	83 c4 10             	add    $0x10,%esp
  80e8f4:	85 ff                	test   %edi,%edi
  80e8f6:	7f ee                	jg     80e8e6 <vprintfmt+0x23e>
			if ((p = va_arg(ap, char *)) == NULL)
  80e8f8:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80e8fb:	89 45 14             	mov    %eax,0x14(%ebp)
  80e8fe:	e9 67 01 00 00       	jmp    80ea6a <vprintfmt+0x3c2>
  80e903:	89 cf                	mov    %ecx,%edi
  80e905:	eb ed                	jmp    80e8f4 <vprintfmt+0x24c>
	if (lflag >= 2)
  80e907:	83 f9 01             	cmp    $0x1,%ecx
  80e90a:	7f 1b                	jg     80e927 <vprintfmt+0x27f>
	else if (lflag)
  80e90c:	85 c9                	test   %ecx,%ecx
  80e90e:	74 63                	je     80e973 <vprintfmt+0x2cb>
		return va_arg(*ap, long);
  80e910:	8b 45 14             	mov    0x14(%ebp),%eax
  80e913:	8b 00                	mov    (%eax),%eax
  80e915:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e918:	99                   	cltd   
  80e919:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80e91c:	8b 45 14             	mov    0x14(%ebp),%eax
  80e91f:	8d 40 04             	lea    0x4(%eax),%eax
  80e922:	89 45 14             	mov    %eax,0x14(%ebp)
  80e925:	eb 17                	jmp    80e93e <vprintfmt+0x296>
		return va_arg(*ap, long long);
  80e927:	8b 45 14             	mov    0x14(%ebp),%eax
  80e92a:	8b 50 04             	mov    0x4(%eax),%edx
  80e92d:	8b 00                	mov    (%eax),%eax
  80e92f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e932:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80e935:	8b 45 14             	mov    0x14(%ebp),%eax
  80e938:	8d 40 08             	lea    0x8(%eax),%eax
  80e93b:	89 45 14             	mov    %eax,0x14(%ebp)
			if ((long long) num < 0) {
  80e93e:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80e941:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			base = 10;
  80e944:	bf 0a 00 00 00       	mov    $0xa,%edi
			if ((long long) num < 0) {
  80e949:	85 c9                	test   %ecx,%ecx
  80e94b:	0f 89 ff 00 00 00    	jns    80ea50 <vprintfmt+0x3a8>
				putch('-', putdat);
  80e951:	83 ec 08             	sub    $0x8,%esp
  80e954:	53                   	push   %ebx
  80e955:	6a 2d                	push   $0x2d
  80e957:	ff d6                	call   *%esi
				num = -(long long) num;
  80e959:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80e95c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80e95f:	f7 da                	neg    %edx
  80e961:	83 d1 00             	adc    $0x0,%ecx
  80e964:	f7 d9                	neg    %ecx
  80e966:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80e969:	bf 0a 00 00 00       	mov    $0xa,%edi
  80e96e:	e9 dd 00 00 00       	jmp    80ea50 <vprintfmt+0x3a8>
		return va_arg(*ap, int);
  80e973:	8b 45 14             	mov    0x14(%ebp),%eax
  80e976:	8b 00                	mov    (%eax),%eax
  80e978:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e97b:	99                   	cltd   
  80e97c:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80e97f:	8b 45 14             	mov    0x14(%ebp),%eax
  80e982:	8d 40 04             	lea    0x4(%eax),%eax
  80e985:	89 45 14             	mov    %eax,0x14(%ebp)
  80e988:	eb b4                	jmp    80e93e <vprintfmt+0x296>
	if (lflag >= 2)
  80e98a:	83 f9 01             	cmp    $0x1,%ecx
  80e98d:	7f 1e                	jg     80e9ad <vprintfmt+0x305>
	else if (lflag)
  80e98f:	85 c9                	test   %ecx,%ecx
  80e991:	74 32                	je     80e9c5 <vprintfmt+0x31d>
		return va_arg(*ap, unsigned long);
  80e993:	8b 45 14             	mov    0x14(%ebp),%eax
  80e996:	8b 10                	mov    (%eax),%edx
  80e998:	b9 00 00 00 00       	mov    $0x0,%ecx
  80e99d:	8d 40 04             	lea    0x4(%eax),%eax
  80e9a0:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80e9a3:	bf 0a 00 00 00       	mov    $0xa,%edi
		return va_arg(*ap, unsigned long);
  80e9a8:	e9 a3 00 00 00       	jmp    80ea50 <vprintfmt+0x3a8>
		return va_arg(*ap, unsigned long long);
  80e9ad:	8b 45 14             	mov    0x14(%ebp),%eax
  80e9b0:	8b 10                	mov    (%eax),%edx
  80e9b2:	8b 48 04             	mov    0x4(%eax),%ecx
  80e9b5:	8d 40 08             	lea    0x8(%eax),%eax
  80e9b8:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80e9bb:	bf 0a 00 00 00       	mov    $0xa,%edi
		return va_arg(*ap, unsigned long long);
  80e9c0:	e9 8b 00 00 00       	jmp    80ea50 <vprintfmt+0x3a8>
		return va_arg(*ap, unsigned int);
  80e9c5:	8b 45 14             	mov    0x14(%ebp),%eax
  80e9c8:	8b 10                	mov    (%eax),%edx
  80e9ca:	b9 00 00 00 00       	mov    $0x0,%ecx
  80e9cf:	8d 40 04             	lea    0x4(%eax),%eax
  80e9d2:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80e9d5:	bf 0a 00 00 00       	mov    $0xa,%edi
		return va_arg(*ap, unsigned int);
  80e9da:	eb 74                	jmp    80ea50 <vprintfmt+0x3a8>
	if (lflag >= 2)
  80e9dc:	83 f9 01             	cmp    $0x1,%ecx
  80e9df:	7f 1b                	jg     80e9fc <vprintfmt+0x354>
	else if (lflag)
  80e9e1:	85 c9                	test   %ecx,%ecx
  80e9e3:	74 2c                	je     80ea11 <vprintfmt+0x369>
		return va_arg(*ap, unsigned long);
  80e9e5:	8b 45 14             	mov    0x14(%ebp),%eax
  80e9e8:	8b 10                	mov    (%eax),%edx
  80e9ea:	b9 00 00 00 00       	mov    $0x0,%ecx
  80e9ef:	8d 40 04             	lea    0x4(%eax),%eax
  80e9f2:	89 45 14             	mov    %eax,0x14(%ebp)
			base=8;
  80e9f5:	bf 08 00 00 00       	mov    $0x8,%edi
		return va_arg(*ap, unsigned long);
  80e9fa:	eb 54                	jmp    80ea50 <vprintfmt+0x3a8>
		return va_arg(*ap, unsigned long long);
  80e9fc:	8b 45 14             	mov    0x14(%ebp),%eax
  80e9ff:	8b 10                	mov    (%eax),%edx
  80ea01:	8b 48 04             	mov    0x4(%eax),%ecx
  80ea04:	8d 40 08             	lea    0x8(%eax),%eax
  80ea07:	89 45 14             	mov    %eax,0x14(%ebp)
			base=8;
  80ea0a:	bf 08 00 00 00       	mov    $0x8,%edi
		return va_arg(*ap, unsigned long long);
  80ea0f:	eb 3f                	jmp    80ea50 <vprintfmt+0x3a8>
		return va_arg(*ap, unsigned int);
  80ea11:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea14:	8b 10                	mov    (%eax),%edx
  80ea16:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ea1b:	8d 40 04             	lea    0x4(%eax),%eax
  80ea1e:	89 45 14             	mov    %eax,0x14(%ebp)
			base=8;
  80ea21:	bf 08 00 00 00       	mov    $0x8,%edi
		return va_arg(*ap, unsigned int);
  80ea26:	eb 28                	jmp    80ea50 <vprintfmt+0x3a8>
			putch('0', putdat);
  80ea28:	83 ec 08             	sub    $0x8,%esp
  80ea2b:	53                   	push   %ebx
  80ea2c:	6a 30                	push   $0x30
  80ea2e:	ff d6                	call   *%esi
			putch('x', putdat);
  80ea30:	83 c4 08             	add    $0x8,%esp
  80ea33:	53                   	push   %ebx
  80ea34:	6a 78                	push   $0x78
  80ea36:	ff d6                	call   *%esi
			num = (unsigned long long)
  80ea38:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea3b:	8b 10                	mov    (%eax),%edx
  80ea3d:	b9 00 00 00 00       	mov    $0x0,%ecx
			goto number;
  80ea42:	83 c4 10             	add    $0x10,%esp
				(uintptr_t) va_arg(ap, void *);
  80ea45:	8d 40 04             	lea    0x4(%eax),%eax
  80ea48:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ea4b:	bf 10 00 00 00       	mov    $0x10,%edi
			printnum(putch, putdat, num, base, width, padc);
  80ea50:	83 ec 0c             	sub    $0xc,%esp
  80ea53:	0f be 45 d3          	movsbl -0x2d(%ebp),%eax
  80ea57:	50                   	push   %eax
  80ea58:	ff 75 e0             	push   -0x20(%ebp)
  80ea5b:	57                   	push   %edi
  80ea5c:	51                   	push   %ecx
  80ea5d:	52                   	push   %edx
  80ea5e:	89 da                	mov    %ebx,%edx
  80ea60:	89 f0                	mov    %esi,%eax
  80ea62:	e8 5e fb ff ff       	call   80e5c5 <printnum>
			break;
  80ea67:	83 c4 20             	add    $0x20,%esp
			err = va_arg(ap, int);
  80ea6a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80ea6d:	e9 54 fc ff ff       	jmp    80e6c6 <vprintfmt+0x1e>
	if (lflag >= 2)
  80ea72:	83 f9 01             	cmp    $0x1,%ecx
  80ea75:	7f 1b                	jg     80ea92 <vprintfmt+0x3ea>
	else if (lflag)
  80ea77:	85 c9                	test   %ecx,%ecx
  80ea79:	74 2c                	je     80eaa7 <vprintfmt+0x3ff>
		return va_arg(*ap, unsigned long);
  80ea7b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea7e:	8b 10                	mov    (%eax),%edx
  80ea80:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ea85:	8d 40 04             	lea    0x4(%eax),%eax
  80ea88:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ea8b:	bf 10 00 00 00       	mov    $0x10,%edi
		return va_arg(*ap, unsigned long);
  80ea90:	eb be                	jmp    80ea50 <vprintfmt+0x3a8>
		return va_arg(*ap, unsigned long long);
  80ea92:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea95:	8b 10                	mov    (%eax),%edx
  80ea97:	8b 48 04             	mov    0x4(%eax),%ecx
  80ea9a:	8d 40 08             	lea    0x8(%eax),%eax
  80ea9d:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eaa0:	bf 10 00 00 00       	mov    $0x10,%edi
		return va_arg(*ap, unsigned long long);
  80eaa5:	eb a9                	jmp    80ea50 <vprintfmt+0x3a8>
		return va_arg(*ap, unsigned int);
  80eaa7:	8b 45 14             	mov    0x14(%ebp),%eax
  80eaaa:	8b 10                	mov    (%eax),%edx
  80eaac:	b9 00 00 00 00       	mov    $0x0,%ecx
  80eab1:	8d 40 04             	lea    0x4(%eax),%eax
  80eab4:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eab7:	bf 10 00 00 00       	mov    $0x10,%edi
		return va_arg(*ap, unsigned int);
  80eabc:	eb 92                	jmp    80ea50 <vprintfmt+0x3a8>
			putch(ch, putdat);
  80eabe:	83 ec 08             	sub    $0x8,%esp
  80eac1:	53                   	push   %ebx
  80eac2:	6a 25                	push   $0x25
  80eac4:	ff d6                	call   *%esi
			break;
  80eac6:	83 c4 10             	add    $0x10,%esp
  80eac9:	eb 9f                	jmp    80ea6a <vprintfmt+0x3c2>
			putch('%', putdat);
  80eacb:	83 ec 08             	sub    $0x8,%esp
  80eace:	53                   	push   %ebx
  80eacf:	6a 25                	push   $0x25
  80ead1:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80ead3:	83 c4 10             	add    $0x10,%esp
  80ead6:	89 f8                	mov    %edi,%eax
  80ead8:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  80eadc:	74 05                	je     80eae3 <vprintfmt+0x43b>
  80eade:	83 e8 01             	sub    $0x1,%eax
  80eae1:	eb f5                	jmp    80ead8 <vprintfmt+0x430>
  80eae3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80eae6:	eb 82                	jmp    80ea6a <vprintfmt+0x3c2>

0080eae8 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80eae8:	55                   	push   %ebp
  80eae9:	89 e5                	mov    %esp,%ebp
  80eaeb:	83 ec 18             	sub    $0x18,%esp
  80eaee:	8b 45 08             	mov    0x8(%ebp),%eax
  80eaf1:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80eaf4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80eaf7:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80eafb:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80eafe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80eb05:	85 c0                	test   %eax,%eax
  80eb07:	74 26                	je     80eb2f <vsnprintf+0x47>
  80eb09:	85 d2                	test   %edx,%edx
  80eb0b:	7e 22                	jle    80eb2f <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80eb0d:	ff 75 14             	push   0x14(%ebp)
  80eb10:	ff 75 10             	push   0x10(%ebp)
  80eb13:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80eb16:	50                   	push   %eax
  80eb17:	68 6e e6 80 00       	push   $0x80e66e
  80eb1c:	e8 87 fb ff ff       	call   80e6a8 <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80eb21:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80eb24:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80eb27:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80eb2a:	83 c4 10             	add    $0x10,%esp
}
  80eb2d:	c9                   	leave  
  80eb2e:	c3                   	ret    
		return -E_INVAL;
  80eb2f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80eb34:	eb f7                	jmp    80eb2d <vsnprintf+0x45>

0080eb36 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80eb36:	55                   	push   %ebp
  80eb37:	89 e5                	mov    %esp,%ebp
  80eb39:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80eb3c:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80eb3f:	50                   	push   %eax
  80eb40:	ff 75 10             	push   0x10(%ebp)
  80eb43:	ff 75 0c             	push   0xc(%ebp)
  80eb46:	ff 75 08             	push   0x8(%ebp)
  80eb49:	e8 9a ff ff ff       	call   80eae8 <vsnprintf>
	va_end(ap);

	return rc;
}
  80eb4e:	c9                   	leave  
  80eb4f:	c3                   	ret    

0080eb50 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80eb50:	55                   	push   %ebp
  80eb51:	89 e5                	mov    %esp,%ebp
  80eb53:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80eb56:	b8 00 00 00 00       	mov    $0x0,%eax
  80eb5b:	eb 03                	jmp    80eb60 <strlen+0x10>
		n++;
  80eb5d:	83 c0 01             	add    $0x1,%eax
	for (n = 0; *s != '\0'; s++)
  80eb60:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80eb64:	75 f7                	jne    80eb5d <strlen+0xd>
	return n;
}
  80eb66:	5d                   	pop    %ebp
  80eb67:	c3                   	ret    

0080eb68 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80eb68:	55                   	push   %ebp
  80eb69:	89 e5                	mov    %esp,%ebp
  80eb6b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80eb6e:	8b 55 0c             	mov    0xc(%ebp),%edx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80eb71:	b8 00 00 00 00       	mov    $0x0,%eax
  80eb76:	eb 03                	jmp    80eb7b <strnlen+0x13>
		n++;
  80eb78:	83 c0 01             	add    $0x1,%eax
	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80eb7b:	39 d0                	cmp    %edx,%eax
  80eb7d:	74 08                	je     80eb87 <strnlen+0x1f>
  80eb7f:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  80eb83:	75 f3                	jne    80eb78 <strnlen+0x10>
  80eb85:	89 c2                	mov    %eax,%edx
	return n;
}
  80eb87:	89 d0                	mov    %edx,%eax
  80eb89:	5d                   	pop    %ebp
  80eb8a:	c3                   	ret    

0080eb8b <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80eb8b:	55                   	push   %ebp
  80eb8c:	89 e5                	mov    %esp,%ebp
  80eb8e:	53                   	push   %ebx
  80eb8f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80eb92:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80eb95:	b8 00 00 00 00       	mov    $0x0,%eax
  80eb9a:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
  80eb9e:	88 14 01             	mov    %dl,(%ecx,%eax,1)
  80eba1:	83 c0 01             	add    $0x1,%eax
  80eba4:	84 d2                	test   %dl,%dl
  80eba6:	75 f2                	jne    80eb9a <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  80eba8:	89 c8                	mov    %ecx,%eax
  80ebaa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ebad:	c9                   	leave  
  80ebae:	c3                   	ret    

0080ebaf <strcat>:

char *
strcat(char *dst, const char *src)
{
  80ebaf:	55                   	push   %ebp
  80ebb0:	89 e5                	mov    %esp,%ebp
  80ebb2:	53                   	push   %ebx
  80ebb3:	83 ec 10             	sub    $0x10,%esp
  80ebb6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80ebb9:	53                   	push   %ebx
  80ebba:	e8 91 ff ff ff       	call   80eb50 <strlen>
  80ebbf:	83 c4 08             	add    $0x8,%esp
	strcpy(dst + len, src);
  80ebc2:	ff 75 0c             	push   0xc(%ebp)
  80ebc5:	01 d8                	add    %ebx,%eax
  80ebc7:	50                   	push   %eax
  80ebc8:	e8 be ff ff ff       	call   80eb8b <strcpy>
	return dst;
}
  80ebcd:	89 d8                	mov    %ebx,%eax
  80ebcf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ebd2:	c9                   	leave  
  80ebd3:	c3                   	ret    

0080ebd4 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80ebd4:	55                   	push   %ebp
  80ebd5:	89 e5                	mov    %esp,%ebp
  80ebd7:	56                   	push   %esi
  80ebd8:	53                   	push   %ebx
  80ebd9:	8b 75 08             	mov    0x8(%ebp),%esi
  80ebdc:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ebdf:	89 f3                	mov    %esi,%ebx
  80ebe1:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80ebe4:	89 f0                	mov    %esi,%eax
  80ebe6:	eb 0f                	jmp    80ebf7 <strncpy+0x23>
		*dst++ = *src;
  80ebe8:	83 c0 01             	add    $0x1,%eax
  80ebeb:	0f b6 0a             	movzbl (%edx),%ecx
  80ebee:	88 48 ff             	mov    %cl,-0x1(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80ebf1:	80 f9 01             	cmp    $0x1,%cl
  80ebf4:	83 da ff             	sbb    $0xffffffff,%edx
	for (i = 0; i < size; i++) {
  80ebf7:	39 d8                	cmp    %ebx,%eax
  80ebf9:	75 ed                	jne    80ebe8 <strncpy+0x14>
	}
	return ret;
}
  80ebfb:	89 f0                	mov    %esi,%eax
  80ebfd:	5b                   	pop    %ebx
  80ebfe:	5e                   	pop    %esi
  80ebff:	5d                   	pop    %ebp
  80ec00:	c3                   	ret    

0080ec01 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80ec01:	55                   	push   %ebp
  80ec02:	89 e5                	mov    %esp,%ebp
  80ec04:	56                   	push   %esi
  80ec05:	53                   	push   %ebx
  80ec06:	8b 75 08             	mov    0x8(%ebp),%esi
  80ec09:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ec0c:	8b 55 10             	mov    0x10(%ebp),%edx
  80ec0f:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80ec11:	85 d2                	test   %edx,%edx
  80ec13:	74 21                	je     80ec36 <strlcpy+0x35>
  80ec15:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80ec19:	89 f2                	mov    %esi,%edx
  80ec1b:	eb 09                	jmp    80ec26 <strlcpy+0x25>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80ec1d:	83 c1 01             	add    $0x1,%ecx
  80ec20:	83 c2 01             	add    $0x1,%edx
  80ec23:	88 5a ff             	mov    %bl,-0x1(%edx)
		while (--size > 0 && *src != '\0')
  80ec26:	39 c2                	cmp    %eax,%edx
  80ec28:	74 09                	je     80ec33 <strlcpy+0x32>
  80ec2a:	0f b6 19             	movzbl (%ecx),%ebx
  80ec2d:	84 db                	test   %bl,%bl
  80ec2f:	75 ec                	jne    80ec1d <strlcpy+0x1c>
  80ec31:	89 d0                	mov    %edx,%eax
		*dst = '\0';
  80ec33:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80ec36:	29 f0                	sub    %esi,%eax
}
  80ec38:	5b                   	pop    %ebx
  80ec39:	5e                   	pop    %esi
  80ec3a:	5d                   	pop    %ebp
  80ec3b:	c3                   	ret    

0080ec3c <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80ec3c:	55                   	push   %ebp
  80ec3d:	89 e5                	mov    %esp,%ebp
  80ec3f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ec42:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80ec45:	eb 06                	jmp    80ec4d <strcmp+0x11>
		p++, q++;
  80ec47:	83 c1 01             	add    $0x1,%ecx
  80ec4a:	83 c2 01             	add    $0x1,%edx
	while (*p && *p == *q)
  80ec4d:	0f b6 01             	movzbl (%ecx),%eax
  80ec50:	84 c0                	test   %al,%al
  80ec52:	74 04                	je     80ec58 <strcmp+0x1c>
  80ec54:	3a 02                	cmp    (%edx),%al
  80ec56:	74 ef                	je     80ec47 <strcmp+0xb>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80ec58:	0f b6 c0             	movzbl %al,%eax
  80ec5b:	0f b6 12             	movzbl (%edx),%edx
  80ec5e:	29 d0                	sub    %edx,%eax
}
  80ec60:	5d                   	pop    %ebp
  80ec61:	c3                   	ret    

0080ec62 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80ec62:	55                   	push   %ebp
  80ec63:	89 e5                	mov    %esp,%ebp
  80ec65:	53                   	push   %ebx
  80ec66:	8b 45 08             	mov    0x8(%ebp),%eax
  80ec69:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ec6c:	89 c3                	mov    %eax,%ebx
  80ec6e:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80ec71:	eb 06                	jmp    80ec79 <strncmp+0x17>
		n--, p++, q++;
  80ec73:	83 c0 01             	add    $0x1,%eax
  80ec76:	83 c2 01             	add    $0x1,%edx
	while (n > 0 && *p && *p == *q)
  80ec79:	39 d8                	cmp    %ebx,%eax
  80ec7b:	74 18                	je     80ec95 <strncmp+0x33>
  80ec7d:	0f b6 08             	movzbl (%eax),%ecx
  80ec80:	84 c9                	test   %cl,%cl
  80ec82:	74 04                	je     80ec88 <strncmp+0x26>
  80ec84:	3a 0a                	cmp    (%edx),%cl
  80ec86:	74 eb                	je     80ec73 <strncmp+0x11>
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80ec88:	0f b6 00             	movzbl (%eax),%eax
  80ec8b:	0f b6 12             	movzbl (%edx),%edx
  80ec8e:	29 d0                	sub    %edx,%eax
}
  80ec90:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ec93:	c9                   	leave  
  80ec94:	c3                   	ret    
		return 0;
  80ec95:	b8 00 00 00 00       	mov    $0x0,%eax
  80ec9a:	eb f4                	jmp    80ec90 <strncmp+0x2e>

0080ec9c <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80ec9c:	55                   	push   %ebp
  80ec9d:	89 e5                	mov    %esp,%ebp
  80ec9f:	8b 45 08             	mov    0x8(%ebp),%eax
  80eca2:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80eca6:	eb 03                	jmp    80ecab <strchr+0xf>
  80eca8:	83 c0 01             	add    $0x1,%eax
  80ecab:	0f b6 10             	movzbl (%eax),%edx
  80ecae:	84 d2                	test   %dl,%dl
  80ecb0:	74 06                	je     80ecb8 <strchr+0x1c>
		if (*s == c)
  80ecb2:	38 ca                	cmp    %cl,%dl
  80ecb4:	75 f2                	jne    80eca8 <strchr+0xc>
  80ecb6:	eb 05                	jmp    80ecbd <strchr+0x21>
			return (char *) s;
	return 0;
  80ecb8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ecbd:	5d                   	pop    %ebp
  80ecbe:	c3                   	ret    

0080ecbf <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80ecbf:	55                   	push   %ebp
  80ecc0:	89 e5                	mov    %esp,%ebp
  80ecc2:	8b 45 08             	mov    0x8(%ebp),%eax
  80ecc5:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80ecc9:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80eccc:	38 ca                	cmp    %cl,%dl
  80ecce:	74 09                	je     80ecd9 <strfind+0x1a>
  80ecd0:	84 d2                	test   %dl,%dl
  80ecd2:	74 05                	je     80ecd9 <strfind+0x1a>
	for (; *s; s++)
  80ecd4:	83 c0 01             	add    $0x1,%eax
  80ecd7:	eb f0                	jmp    80ecc9 <strfind+0xa>
			break;
	return (char *) s;
}
  80ecd9:	5d                   	pop    %ebp
  80ecda:	c3                   	ret    

0080ecdb <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80ecdb:	55                   	push   %ebp
  80ecdc:	89 e5                	mov    %esp,%ebp
  80ecde:	57                   	push   %edi
  80ecdf:	56                   	push   %esi
  80ece0:	53                   	push   %ebx
  80ece1:	8b 7d 08             	mov    0x8(%ebp),%edi
  80ece4:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80ece7:	85 c9                	test   %ecx,%ecx
  80ece9:	74 2f                	je     80ed1a <memset+0x3f>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80eceb:	89 f8                	mov    %edi,%eax
  80eced:	09 c8                	or     %ecx,%eax
  80ecef:	a8 03                	test   $0x3,%al
  80ecf1:	75 21                	jne    80ed14 <memset+0x39>
		c &= 0xFF;
  80ecf3:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80ecf7:	89 d0                	mov    %edx,%eax
  80ecf9:	c1 e0 08             	shl    $0x8,%eax
  80ecfc:	89 d3                	mov    %edx,%ebx
  80ecfe:	c1 e3 18             	shl    $0x18,%ebx
  80ed01:	89 d6                	mov    %edx,%esi
  80ed03:	c1 e6 10             	shl    $0x10,%esi
  80ed06:	09 f3                	or     %esi,%ebx
  80ed08:	09 da                	or     %ebx,%edx
  80ed0a:	09 d0                	or     %edx,%eax
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80ed0c:	c1 e9 02             	shr    $0x2,%ecx
		asm volatile("cld; rep stosl\n"
  80ed0f:	fc                   	cld    
  80ed10:	f3 ab                	rep stos %eax,%es:(%edi)
  80ed12:	eb 06                	jmp    80ed1a <memset+0x3f>
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80ed14:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ed17:	fc                   	cld    
  80ed18:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80ed1a:	89 f8                	mov    %edi,%eax
  80ed1c:	5b                   	pop    %ebx
  80ed1d:	5e                   	pop    %esi
  80ed1e:	5f                   	pop    %edi
  80ed1f:	5d                   	pop    %ebp
  80ed20:	c3                   	ret    

0080ed21 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80ed21:	55                   	push   %ebp
  80ed22:	89 e5                	mov    %esp,%ebp
  80ed24:	57                   	push   %edi
  80ed25:	56                   	push   %esi
  80ed26:	8b 45 08             	mov    0x8(%ebp),%eax
  80ed29:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ed2c:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80ed2f:	39 c6                	cmp    %eax,%esi
  80ed31:	73 32                	jae    80ed65 <memmove+0x44>
  80ed33:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80ed36:	39 c2                	cmp    %eax,%edx
  80ed38:	76 2b                	jbe    80ed65 <memmove+0x44>
		s += n;
		d += n;
  80ed3a:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80ed3d:	89 d6                	mov    %edx,%esi
  80ed3f:	09 fe                	or     %edi,%esi
  80ed41:	09 ce                	or     %ecx,%esi
  80ed43:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80ed49:	75 0e                	jne    80ed59 <memmove+0x38>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80ed4b:	83 ef 04             	sub    $0x4,%edi
  80ed4e:	8d 72 fc             	lea    -0x4(%edx),%esi
  80ed51:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("std; rep movsl\n"
  80ed54:	fd                   	std    
  80ed55:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ed57:	eb 09                	jmp    80ed62 <memmove+0x41>
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80ed59:	83 ef 01             	sub    $0x1,%edi
  80ed5c:	8d 72 ff             	lea    -0x1(%edx),%esi
			asm volatile("std; rep movsb\n"
  80ed5f:	fd                   	std    
  80ed60:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80ed62:	fc                   	cld    
  80ed63:	eb 1a                	jmp    80ed7f <memmove+0x5e>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80ed65:	89 f2                	mov    %esi,%edx
  80ed67:	09 c2                	or     %eax,%edx
  80ed69:	09 ca                	or     %ecx,%edx
  80ed6b:	f6 c2 03             	test   $0x3,%dl
  80ed6e:	75 0a                	jne    80ed7a <memmove+0x59>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80ed70:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("cld; rep movsl\n"
  80ed73:	89 c7                	mov    %eax,%edi
  80ed75:	fc                   	cld    
  80ed76:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ed78:	eb 05                	jmp    80ed7f <memmove+0x5e>
		else
			asm volatile("cld; rep movsb\n"
  80ed7a:	89 c7                	mov    %eax,%edi
  80ed7c:	fc                   	cld    
  80ed7d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80ed7f:	5e                   	pop    %esi
  80ed80:	5f                   	pop    %edi
  80ed81:	5d                   	pop    %ebp
  80ed82:	c3                   	ret    

0080ed83 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80ed83:	55                   	push   %ebp
  80ed84:	89 e5                	mov    %esp,%ebp
  80ed86:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80ed89:	ff 75 10             	push   0x10(%ebp)
  80ed8c:	ff 75 0c             	push   0xc(%ebp)
  80ed8f:	ff 75 08             	push   0x8(%ebp)
  80ed92:	e8 8a ff ff ff       	call   80ed21 <memmove>
}
  80ed97:	c9                   	leave  
  80ed98:	c3                   	ret    

0080ed99 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80ed99:	55                   	push   %ebp
  80ed9a:	89 e5                	mov    %esp,%ebp
  80ed9c:	56                   	push   %esi
  80ed9d:	53                   	push   %ebx
  80ed9e:	8b 45 08             	mov    0x8(%ebp),%eax
  80eda1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80eda4:	89 c6                	mov    %eax,%esi
  80eda6:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80eda9:	eb 06                	jmp    80edb1 <memcmp+0x18>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
  80edab:	83 c0 01             	add    $0x1,%eax
  80edae:	83 c2 01             	add    $0x1,%edx
	while (n-- > 0) {
  80edb1:	39 f0                	cmp    %esi,%eax
  80edb3:	74 14                	je     80edc9 <memcmp+0x30>
		if (*s1 != *s2)
  80edb5:	0f b6 08             	movzbl (%eax),%ecx
  80edb8:	0f b6 1a             	movzbl (%edx),%ebx
  80edbb:	38 d9                	cmp    %bl,%cl
  80edbd:	74 ec                	je     80edab <memcmp+0x12>
			return (int) *s1 - (int) *s2;
  80edbf:	0f b6 c1             	movzbl %cl,%eax
  80edc2:	0f b6 db             	movzbl %bl,%ebx
  80edc5:	29 d8                	sub    %ebx,%eax
  80edc7:	eb 05                	jmp    80edce <memcmp+0x35>
	}

	return 0;
  80edc9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80edce:	5b                   	pop    %ebx
  80edcf:	5e                   	pop    %esi
  80edd0:	5d                   	pop    %ebp
  80edd1:	c3                   	ret    

0080edd2 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80edd2:	55                   	push   %ebp
  80edd3:	89 e5                	mov    %esp,%ebp
  80edd5:	8b 45 08             	mov    0x8(%ebp),%eax
  80edd8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80eddb:	89 c2                	mov    %eax,%edx
  80eddd:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80ede0:	eb 03                	jmp    80ede5 <memfind+0x13>
  80ede2:	83 c0 01             	add    $0x1,%eax
  80ede5:	39 d0                	cmp    %edx,%eax
  80ede7:	73 04                	jae    80eded <memfind+0x1b>
		if (*(const unsigned char *) s == (unsigned char) c)
  80ede9:	38 08                	cmp    %cl,(%eax)
  80edeb:	75 f5                	jne    80ede2 <memfind+0x10>
			break;
	return (void *) s;
}
  80eded:	5d                   	pop    %ebp
  80edee:	c3                   	ret    

0080edef <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80edef:	55                   	push   %ebp
  80edf0:	89 e5                	mov    %esp,%ebp
  80edf2:	57                   	push   %edi
  80edf3:	56                   	push   %esi
  80edf4:	53                   	push   %ebx
  80edf5:	8b 55 08             	mov    0x8(%ebp),%edx
  80edf8:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80edfb:	eb 03                	jmp    80ee00 <strtol+0x11>
		s++;
  80edfd:	83 c2 01             	add    $0x1,%edx
	while (*s == ' ' || *s == '\t')
  80ee00:	0f b6 02             	movzbl (%edx),%eax
  80ee03:	3c 20                	cmp    $0x20,%al
  80ee05:	74 f6                	je     80edfd <strtol+0xe>
  80ee07:	3c 09                	cmp    $0x9,%al
  80ee09:	74 f2                	je     80edfd <strtol+0xe>

	// plus/minus sign
	if (*s == '+')
  80ee0b:	3c 2b                	cmp    $0x2b,%al
  80ee0d:	74 2a                	je     80ee39 <strtol+0x4a>
	int neg = 0;
  80ee0f:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
  80ee14:	3c 2d                	cmp    $0x2d,%al
  80ee16:	74 2b                	je     80ee43 <strtol+0x54>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80ee18:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80ee1e:	75 0f                	jne    80ee2f <strtol+0x40>
  80ee20:	80 3a 30             	cmpb   $0x30,(%edx)
  80ee23:	74 28                	je     80ee4d <strtol+0x5e>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80ee25:	85 db                	test   %ebx,%ebx
  80ee27:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ee2c:	0f 44 d8             	cmove  %eax,%ebx
  80ee2f:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee34:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80ee37:	eb 46                	jmp    80ee7f <strtol+0x90>
		s++;
  80ee39:	83 c2 01             	add    $0x1,%edx
	int neg = 0;
  80ee3c:	bf 00 00 00 00       	mov    $0x0,%edi
  80ee41:	eb d5                	jmp    80ee18 <strtol+0x29>
		s++, neg = 1;
  80ee43:	83 c2 01             	add    $0x1,%edx
  80ee46:	bf 01 00 00 00       	mov    $0x1,%edi
  80ee4b:	eb cb                	jmp    80ee18 <strtol+0x29>
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80ee4d:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80ee51:	74 0e                	je     80ee61 <strtol+0x72>
	else if (base == 0 && s[0] == '0')
  80ee53:	85 db                	test   %ebx,%ebx
  80ee55:	75 d8                	jne    80ee2f <strtol+0x40>
		s++, base = 8;
  80ee57:	83 c2 01             	add    $0x1,%edx
  80ee5a:	bb 08 00 00 00       	mov    $0x8,%ebx
  80ee5f:	eb ce                	jmp    80ee2f <strtol+0x40>
		s += 2, base = 16;
  80ee61:	83 c2 02             	add    $0x2,%edx
  80ee64:	bb 10 00 00 00       	mov    $0x10,%ebx
  80ee69:	eb c4                	jmp    80ee2f <strtol+0x40>
	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
  80ee6b:	0f be c0             	movsbl %al,%eax
  80ee6e:	83 e8 30             	sub    $0x30,%eax
			dig = *s - 'a' + 10;
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80ee71:	3b 45 10             	cmp    0x10(%ebp),%eax
  80ee74:	7d 3a                	jge    80eeb0 <strtol+0xc1>
			break;
		s++, val = (val * base) + dig;
  80ee76:	83 c2 01             	add    $0x1,%edx
  80ee79:	0f af 4d 10          	imul   0x10(%ebp),%ecx
  80ee7d:	01 c1                	add    %eax,%ecx
		if (*s >= '0' && *s <= '9')
  80ee7f:	0f b6 02             	movzbl (%edx),%eax
  80ee82:	8d 70 d0             	lea    -0x30(%eax),%esi
  80ee85:	89 f3                	mov    %esi,%ebx
  80ee87:	80 fb 09             	cmp    $0x9,%bl
  80ee8a:	76 df                	jbe    80ee6b <strtol+0x7c>
		else if (*s >= 'a' && *s <= 'z')
  80ee8c:	8d 70 9f             	lea    -0x61(%eax),%esi
  80ee8f:	89 f3                	mov    %esi,%ebx
  80ee91:	80 fb 19             	cmp    $0x19,%bl
  80ee94:	77 08                	ja     80ee9e <strtol+0xaf>
			dig = *s - 'a' + 10;
  80ee96:	0f be c0             	movsbl %al,%eax
  80ee99:	83 e8 57             	sub    $0x57,%eax
  80ee9c:	eb d3                	jmp    80ee71 <strtol+0x82>
		else if (*s >= 'A' && *s <= 'Z')
  80ee9e:	8d 70 bf             	lea    -0x41(%eax),%esi
  80eea1:	89 f3                	mov    %esi,%ebx
  80eea3:	80 fb 19             	cmp    $0x19,%bl
  80eea6:	77 08                	ja     80eeb0 <strtol+0xc1>
			dig = *s - 'A' + 10;
  80eea8:	0f be c0             	movsbl %al,%eax
  80eeab:	83 e8 37             	sub    $0x37,%eax
  80eeae:	eb c1                	jmp    80ee71 <strtol+0x82>
		// we don't properly detect overflow!
	}

	if (endptr)
  80eeb0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80eeb4:	74 05                	je     80eebb <strtol+0xcc>
		*endptr = (char *) s;
  80eeb6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80eeb9:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
  80eebb:	89 c8                	mov    %ecx,%eax
  80eebd:	f7 d8                	neg    %eax
  80eebf:	85 ff                	test   %edi,%edi
  80eec1:	0f 45 c8             	cmovne %eax,%ecx
}
  80eec4:	89 c8                	mov    %ecx,%eax
  80eec6:	5b                   	pop    %ebx
  80eec7:	5e                   	pop    %esi
  80eec8:	5f                   	pop    %edi
  80eec9:	5d                   	pop    %ebp
  80eeca:	c3                   	ret    

0080eecb <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80eecb:	55                   	push   %ebp
  80eecc:	89 e5                	mov    %esp,%ebp
  80eece:	57                   	push   %edi
  80eecf:	56                   	push   %esi
  80eed0:	53                   	push   %ebx
	asm volatile("int %1\n"
  80eed1:	b8 00 00 00 00       	mov    $0x0,%eax
  80eed6:	8b 55 08             	mov    0x8(%ebp),%edx
  80eed9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eedc:	89 c3                	mov    %eax,%ebx
  80eede:	89 c7                	mov    %eax,%edi
  80eee0:	89 c6                	mov    %eax,%esi
  80eee2:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80eee4:	5b                   	pop    %ebx
  80eee5:	5e                   	pop    %esi
  80eee6:	5f                   	pop    %edi
  80eee7:	5d                   	pop    %ebp
  80eee8:	c3                   	ret    

0080eee9 <sys_cgetc>:

int
sys_cgetc(void)
{
  80eee9:	55                   	push   %ebp
  80eeea:	89 e5                	mov    %esp,%ebp
  80eeec:	57                   	push   %edi
  80eeed:	56                   	push   %esi
  80eeee:	53                   	push   %ebx
	asm volatile("int %1\n"
  80eeef:	ba 00 00 00 00       	mov    $0x0,%edx
  80eef4:	b8 01 00 00 00       	mov    $0x1,%eax
  80eef9:	89 d1                	mov    %edx,%ecx
  80eefb:	89 d3                	mov    %edx,%ebx
  80eefd:	89 d7                	mov    %edx,%edi
  80eeff:	89 d6                	mov    %edx,%esi
  80ef01:	cd 30                	int    $0x30
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80ef03:	5b                   	pop    %ebx
  80ef04:	5e                   	pop    %esi
  80ef05:	5f                   	pop    %edi
  80ef06:	5d                   	pop    %ebp
  80ef07:	c3                   	ret    

0080ef08 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80ef08:	55                   	push   %ebp
  80ef09:	89 e5                	mov    %esp,%ebp
  80ef0b:	57                   	push   %edi
  80ef0c:	56                   	push   %esi
  80ef0d:	53                   	push   %ebx
  80ef0e:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80ef11:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ef16:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef19:	b8 03 00 00 00       	mov    $0x3,%eax
  80ef1e:	89 cb                	mov    %ecx,%ebx
  80ef20:	89 cf                	mov    %ecx,%edi
  80ef22:	89 ce                	mov    %ecx,%esi
  80ef24:	cd 30                	int    $0x30
	if(check && ret > 0)
  80ef26:	85 c0                	test   %eax,%eax
  80ef28:	7f 08                	jg     80ef32 <sys_env_destroy+0x2a>
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80ef2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef2d:	5b                   	pop    %ebx
  80ef2e:	5e                   	pop    %esi
  80ef2f:	5f                   	pop    %edi
  80ef30:	5d                   	pop    %ebp
  80ef31:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef32:	83 ec 0c             	sub    $0xc,%esp
  80ef35:	50                   	push   %eax
  80ef36:	6a 03                	push   $0x3
  80ef38:	68 bf 34 81 00       	push   $0x8134bf
  80ef3d:	6a 2a                	push   $0x2a
  80ef3f:	68 dc 34 81 00       	push   $0x8134dc
  80ef44:	e8 8d f5 ff ff       	call   80e4d6 <_panic>

0080ef49 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80ef49:	55                   	push   %ebp
  80ef4a:	89 e5                	mov    %esp,%ebp
  80ef4c:	57                   	push   %edi
  80ef4d:	56                   	push   %esi
  80ef4e:	53                   	push   %ebx
	asm volatile("int %1\n"
  80ef4f:	ba 00 00 00 00       	mov    $0x0,%edx
  80ef54:	b8 02 00 00 00       	mov    $0x2,%eax
  80ef59:	89 d1                	mov    %edx,%ecx
  80ef5b:	89 d3                	mov    %edx,%ebx
  80ef5d:	89 d7                	mov    %edx,%edi
  80ef5f:	89 d6                	mov    %edx,%esi
  80ef61:	cd 30                	int    $0x30
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80ef63:	5b                   	pop    %ebx
  80ef64:	5e                   	pop    %esi
  80ef65:	5f                   	pop    %edi
  80ef66:	5d                   	pop    %ebp
  80ef67:	c3                   	ret    

0080ef68 <sys_yield>:

void
sys_yield(void)
{
  80ef68:	55                   	push   %ebp
  80ef69:	89 e5                	mov    %esp,%ebp
  80ef6b:	57                   	push   %edi
  80ef6c:	56                   	push   %esi
  80ef6d:	53                   	push   %ebx
	asm volatile("int %1\n"
  80ef6e:	ba 00 00 00 00       	mov    $0x0,%edx
  80ef73:	b8 0b 00 00 00       	mov    $0xb,%eax
  80ef78:	89 d1                	mov    %edx,%ecx
  80ef7a:	89 d3                	mov    %edx,%ebx
  80ef7c:	89 d7                	mov    %edx,%edi
  80ef7e:	89 d6                	mov    %edx,%esi
  80ef80:	cd 30                	int    $0x30
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80ef82:	5b                   	pop    %ebx
  80ef83:	5e                   	pop    %esi
  80ef84:	5f                   	pop    %edi
  80ef85:	5d                   	pop    %ebp
  80ef86:	c3                   	ret    

0080ef87 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80ef87:	55                   	push   %ebp
  80ef88:	89 e5                	mov    %esp,%ebp
  80ef8a:	57                   	push   %edi
  80ef8b:	56                   	push   %esi
  80ef8c:	53                   	push   %ebx
  80ef8d:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80ef90:	be 00 00 00 00       	mov    $0x0,%esi
  80ef95:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef98:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef9b:	b8 04 00 00 00       	mov    $0x4,%eax
  80efa0:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80efa3:	89 f7                	mov    %esi,%edi
  80efa5:	cd 30                	int    $0x30
	if(check && ret > 0)
  80efa7:	85 c0                	test   %eax,%eax
  80efa9:	7f 08                	jg     80efb3 <sys_page_alloc+0x2c>
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80efab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80efae:	5b                   	pop    %ebx
  80efaf:	5e                   	pop    %esi
  80efb0:	5f                   	pop    %edi
  80efb1:	5d                   	pop    %ebp
  80efb2:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80efb3:	83 ec 0c             	sub    $0xc,%esp
  80efb6:	50                   	push   %eax
  80efb7:	6a 04                	push   $0x4
  80efb9:	68 bf 34 81 00       	push   $0x8134bf
  80efbe:	6a 2a                	push   $0x2a
  80efc0:	68 dc 34 81 00       	push   $0x8134dc
  80efc5:	e8 0c f5 ff ff       	call   80e4d6 <_panic>

0080efca <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80efca:	55                   	push   %ebp
  80efcb:	89 e5                	mov    %esp,%ebp
  80efcd:	57                   	push   %edi
  80efce:	56                   	push   %esi
  80efcf:	53                   	push   %ebx
  80efd0:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80efd3:	8b 55 08             	mov    0x8(%ebp),%edx
  80efd6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80efd9:	b8 05 00 00 00       	mov    $0x5,%eax
  80efde:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80efe1:	8b 7d 14             	mov    0x14(%ebp),%edi
  80efe4:	8b 75 18             	mov    0x18(%ebp),%esi
  80efe7:	cd 30                	int    $0x30
	if(check && ret > 0)
  80efe9:	85 c0                	test   %eax,%eax
  80efeb:	7f 08                	jg     80eff5 <sys_page_map+0x2b>
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80efed:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eff0:	5b                   	pop    %ebx
  80eff1:	5e                   	pop    %esi
  80eff2:	5f                   	pop    %edi
  80eff3:	5d                   	pop    %ebp
  80eff4:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80eff5:	83 ec 0c             	sub    $0xc,%esp
  80eff8:	50                   	push   %eax
  80eff9:	6a 05                	push   $0x5
  80effb:	68 bf 34 81 00       	push   $0x8134bf
  80f000:	6a 2a                	push   $0x2a
  80f002:	68 dc 34 81 00       	push   $0x8134dc
  80f007:	e8 ca f4 ff ff       	call   80e4d6 <_panic>

0080f00c <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f00c:	55                   	push   %ebp
  80f00d:	89 e5                	mov    %esp,%ebp
  80f00f:	57                   	push   %edi
  80f010:	56                   	push   %esi
  80f011:	53                   	push   %ebx
  80f012:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f015:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f01a:	8b 55 08             	mov    0x8(%ebp),%edx
  80f01d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f020:	b8 06 00 00 00       	mov    $0x6,%eax
  80f025:	89 df                	mov    %ebx,%edi
  80f027:	89 de                	mov    %ebx,%esi
  80f029:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f02b:	85 c0                	test   %eax,%eax
  80f02d:	7f 08                	jg     80f037 <sys_page_unmap+0x2b>
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f02f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f032:	5b                   	pop    %ebx
  80f033:	5e                   	pop    %esi
  80f034:	5f                   	pop    %edi
  80f035:	5d                   	pop    %ebp
  80f036:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f037:	83 ec 0c             	sub    $0xc,%esp
  80f03a:	50                   	push   %eax
  80f03b:	6a 06                	push   $0x6
  80f03d:	68 bf 34 81 00       	push   $0x8134bf
  80f042:	6a 2a                	push   $0x2a
  80f044:	68 dc 34 81 00       	push   $0x8134dc
  80f049:	e8 88 f4 ff ff       	call   80e4d6 <_panic>

0080f04e <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80f04e:	55                   	push   %ebp
  80f04f:	89 e5                	mov    %esp,%ebp
  80f051:	57                   	push   %edi
  80f052:	56                   	push   %esi
  80f053:	53                   	push   %ebx
  80f054:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f057:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f05c:	8b 55 08             	mov    0x8(%ebp),%edx
  80f05f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f062:	b8 08 00 00 00       	mov    $0x8,%eax
  80f067:	89 df                	mov    %ebx,%edi
  80f069:	89 de                	mov    %ebx,%esi
  80f06b:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f06d:	85 c0                	test   %eax,%eax
  80f06f:	7f 08                	jg     80f079 <sys_env_set_status+0x2b>
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80f071:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f074:	5b                   	pop    %ebx
  80f075:	5e                   	pop    %esi
  80f076:	5f                   	pop    %edi
  80f077:	5d                   	pop    %ebp
  80f078:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f079:	83 ec 0c             	sub    $0xc,%esp
  80f07c:	50                   	push   %eax
  80f07d:	6a 08                	push   $0x8
  80f07f:	68 bf 34 81 00       	push   $0x8134bf
  80f084:	6a 2a                	push   $0x2a
  80f086:	68 dc 34 81 00       	push   $0x8134dc
  80f08b:	e8 46 f4 ff ff       	call   80e4d6 <_panic>

0080f090 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80f090:	55                   	push   %ebp
  80f091:	89 e5                	mov    %esp,%ebp
  80f093:	57                   	push   %edi
  80f094:	56                   	push   %esi
  80f095:	53                   	push   %ebx
  80f096:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f099:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f09e:	8b 55 08             	mov    0x8(%ebp),%edx
  80f0a1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f0a4:	b8 09 00 00 00       	mov    $0x9,%eax
  80f0a9:	89 df                	mov    %ebx,%edi
  80f0ab:	89 de                	mov    %ebx,%esi
  80f0ad:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f0af:	85 c0                	test   %eax,%eax
  80f0b1:	7f 08                	jg     80f0bb <sys_env_set_trapframe+0x2b>
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80f0b3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f0b6:	5b                   	pop    %ebx
  80f0b7:	5e                   	pop    %esi
  80f0b8:	5f                   	pop    %edi
  80f0b9:	5d                   	pop    %ebp
  80f0ba:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f0bb:	83 ec 0c             	sub    $0xc,%esp
  80f0be:	50                   	push   %eax
  80f0bf:	6a 09                	push   $0x9
  80f0c1:	68 bf 34 81 00       	push   $0x8134bf
  80f0c6:	6a 2a                	push   $0x2a
  80f0c8:	68 dc 34 81 00       	push   $0x8134dc
  80f0cd:	e8 04 f4 ff ff       	call   80e4d6 <_panic>

0080f0d2 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80f0d2:	55                   	push   %ebp
  80f0d3:	89 e5                	mov    %esp,%ebp
  80f0d5:	57                   	push   %edi
  80f0d6:	56                   	push   %esi
  80f0d7:	53                   	push   %ebx
  80f0d8:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f0db:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f0e0:	8b 55 08             	mov    0x8(%ebp),%edx
  80f0e3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f0e6:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f0eb:	89 df                	mov    %ebx,%edi
  80f0ed:	89 de                	mov    %ebx,%esi
  80f0ef:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f0f1:	85 c0                	test   %eax,%eax
  80f0f3:	7f 08                	jg     80f0fd <sys_env_set_pgfault_upcall+0x2b>
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f0f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f0f8:	5b                   	pop    %ebx
  80f0f9:	5e                   	pop    %esi
  80f0fa:	5f                   	pop    %edi
  80f0fb:	5d                   	pop    %ebp
  80f0fc:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f0fd:	83 ec 0c             	sub    $0xc,%esp
  80f100:	50                   	push   %eax
  80f101:	6a 0a                	push   $0xa
  80f103:	68 bf 34 81 00       	push   $0x8134bf
  80f108:	6a 2a                	push   $0x2a
  80f10a:	68 dc 34 81 00       	push   $0x8134dc
  80f10f:	e8 c2 f3 ff ff       	call   80e4d6 <_panic>

0080f114 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f114:	55                   	push   %ebp
  80f115:	89 e5                	mov    %esp,%ebp
  80f117:	57                   	push   %edi
  80f118:	56                   	push   %esi
  80f119:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f11a:	8b 55 08             	mov    0x8(%ebp),%edx
  80f11d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f120:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f125:	be 00 00 00 00       	mov    $0x0,%esi
  80f12a:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f12d:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f130:	cd 30                	int    $0x30
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f132:	5b                   	pop    %ebx
  80f133:	5e                   	pop    %esi
  80f134:	5f                   	pop    %edi
  80f135:	5d                   	pop    %ebp
  80f136:	c3                   	ret    

0080f137 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f137:	55                   	push   %ebp
  80f138:	89 e5                	mov    %esp,%ebp
  80f13a:	57                   	push   %edi
  80f13b:	56                   	push   %esi
  80f13c:	53                   	push   %ebx
  80f13d:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f140:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f145:	8b 55 08             	mov    0x8(%ebp),%edx
  80f148:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f14d:	89 cb                	mov    %ecx,%ebx
  80f14f:	89 cf                	mov    %ecx,%edi
  80f151:	89 ce                	mov    %ecx,%esi
  80f153:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f155:	85 c0                	test   %eax,%eax
  80f157:	7f 08                	jg     80f161 <sys_ipc_recv+0x2a>
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f159:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f15c:	5b                   	pop    %ebx
  80f15d:	5e                   	pop    %esi
  80f15e:	5f                   	pop    %edi
  80f15f:	5d                   	pop    %ebp
  80f160:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f161:	83 ec 0c             	sub    $0xc,%esp
  80f164:	50                   	push   %eax
  80f165:	6a 0d                	push   $0xd
  80f167:	68 bf 34 81 00       	push   $0x8134bf
  80f16c:	6a 2a                	push   $0x2a
  80f16e:	68 dc 34 81 00       	push   $0x8134dc
  80f173:	e8 5e f3 ff ff       	call   80e4d6 <_panic>

0080f178 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f178:	55                   	push   %ebp
  80f179:	89 e5                	mov    %esp,%ebp
  80f17b:	57                   	push   %edi
  80f17c:	56                   	push   %esi
  80f17d:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f17e:	ba 00 00 00 00       	mov    $0x0,%edx
  80f183:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f188:	89 d1                	mov    %edx,%ecx
  80f18a:	89 d3                	mov    %edx,%ebx
  80f18c:	89 d7                	mov    %edx,%edi
  80f18e:	89 d6                	mov    %edx,%esi
  80f190:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f192:	5b                   	pop    %ebx
  80f193:	5e                   	pop    %esi
  80f194:	5f                   	pop    %edi
  80f195:	5d                   	pop    %ebp
  80f196:	c3                   	ret    

0080f197 <sys_e1000_try_send>:

int
sys_e1000_try_send(void *buf, size_t len)
{
  80f197:	55                   	push   %ebp
  80f198:	89 e5                	mov    %esp,%ebp
  80f19a:	57                   	push   %edi
  80f19b:	56                   	push   %esi
  80f19c:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f19d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f1a2:	8b 55 08             	mov    0x8(%ebp),%edx
  80f1a5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f1a8:	b8 0f 00 00 00       	mov    $0xf,%eax
  80f1ad:	89 df                	mov    %ebx,%edi
  80f1af:	89 de                	mov    %ebx,%esi
  80f1b1:	cd 30                	int    $0x30
    return syscall(SYS_e1000_try_send, 0, (uint32_t)buf, len, 0, 0, 0);
}
  80f1b3:	5b                   	pop    %ebx
  80f1b4:	5e                   	pop    %esi
  80f1b5:	5f                   	pop    %edi
  80f1b6:	5d                   	pop    %ebp
  80f1b7:	c3                   	ret    

0080f1b8 <sys_e1000_recv>:

int
sys_e1000_recv(void *dstva, size_t *len)
{
  80f1b8:	55                   	push   %ebp
  80f1b9:	89 e5                	mov    %esp,%ebp
  80f1bb:	57                   	push   %edi
  80f1bc:	56                   	push   %esi
  80f1bd:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f1be:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f1c3:	8b 55 08             	mov    0x8(%ebp),%edx
  80f1c6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f1c9:	b8 10 00 00 00       	mov    $0x10,%eax
  80f1ce:	89 df                	mov    %ebx,%edi
  80f1d0:	89 de                	mov    %ebx,%esi
  80f1d2:	cd 30                	int    $0x30
    return syscall(SYS_e1000_recv, 0, (uint32_t) dstva, (uint32_t) len, 0, 0, 0);
}
  80f1d4:	5b                   	pop    %ebx
  80f1d5:	5e                   	pop    %esi
  80f1d6:	5f                   	pop    %edi
  80f1d7:	5d                   	pop    %ebp
  80f1d8:	c3                   	ret    

0080f1d9 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80f1d9:	55                   	push   %ebp
  80f1da:	89 e5                	mov    %esp,%ebp
  80f1dc:	56                   	push   %esi
  80f1dd:	53                   	push   %ebx
  80f1de:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  80f1e1:	8b 30                	mov    (%eax),%esi
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	//2.
	if( (err & FEC_WR)==0 || (uvpt[PGNUM(addr)] & PTE_COW)==0 ) panic("pgfault: invalid user trap frame(not a write or to COW)");
  80f1e3:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  80f1e7:	0f 84 8e 00 00 00    	je     80f27b <pgfault+0xa2>
  80f1ed:	89 f0                	mov    %esi,%eax
  80f1ef:	c1 e8 0c             	shr    $0xc,%eax
  80f1f2:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f1f9:	f6 c4 08             	test   $0x8,%ah
  80f1fc:	74 7d                	je     80f27b <pgfault+0xa2>
	//   You should make three system calls.

	// LAB 4: Your code here.
	//panic("pgfault not implemented");
	//3.
	envid_t envid = sys_getenvid();
  80f1fe:	e8 46 fd ff ff       	call   80ef49 <sys_getenvid>
  80f203:	89 c3                	mov    %eax,%ebx
	r = sys_page_alloc(envid, (void *)PFTEMP, PTE_P | PTE_W | PTE_U);
  80f205:	83 ec 04             	sub    $0x4,%esp
  80f208:	6a 07                	push   $0x7
  80f20a:	68 00 f0 7f 00       	push   $0x7ff000
  80f20f:	50                   	push   %eax
  80f210:	e8 72 fd ff ff       	call   80ef87 <sys_page_alloc>
        if(r<0) panic("pgfault: page allocation failed %e", r);
  80f215:	83 c4 10             	add    $0x10,%esp
  80f218:	85 c0                	test   %eax,%eax
  80f21a:	78 73                	js     80f28f <pgfault+0xb6>
        
        addr = ROUNDDOWN(addr, PGSIZE);
  80f21c:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
        memmove(PFTEMP, addr, PGSIZE);
  80f222:	83 ec 04             	sub    $0x4,%esp
  80f225:	68 00 10 00 00       	push   $0x1000
  80f22a:	56                   	push   %esi
  80f22b:	68 00 f0 7f 00       	push   $0x7ff000
  80f230:	e8 ec fa ff ff       	call   80ed21 <memmove>
	if ((r = sys_page_unmap(envid, addr)) < 0)
  80f235:	83 c4 08             	add    $0x8,%esp
  80f238:	56                   	push   %esi
  80f239:	53                   	push   %ebx
  80f23a:	e8 cd fd ff ff       	call   80f00c <sys_page_unmap>
  80f23f:	83 c4 10             	add    $0x10,%esp
  80f242:	85 c0                	test   %eax,%eax
  80f244:	78 5b                	js     80f2a1 <pgfault+0xc8>
		panic("pgfault: page unmap failed (%e)", r);
	if ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) < 0)
  80f246:	83 ec 0c             	sub    $0xc,%esp
  80f249:	6a 07                	push   $0x7
  80f24b:	56                   	push   %esi
  80f24c:	53                   	push   %ebx
  80f24d:	68 00 f0 7f 00       	push   $0x7ff000
  80f252:	53                   	push   %ebx
  80f253:	e8 72 fd ff ff       	call   80efca <sys_page_map>
  80f258:	83 c4 20             	add    $0x20,%esp
  80f25b:	85 c0                	test   %eax,%eax
  80f25d:	78 54                	js     80f2b3 <pgfault+0xda>
		panic("pgfault: page map failed (%e)", r);
	if ((r = sys_page_unmap(envid, PFTEMP)) < 0)
  80f25f:	83 ec 08             	sub    $0x8,%esp
  80f262:	68 00 f0 7f 00       	push   $0x7ff000
  80f267:	53                   	push   %ebx
  80f268:	e8 9f fd ff ff       	call   80f00c <sys_page_unmap>
  80f26d:	83 c4 10             	add    $0x10,%esp
  80f270:	85 c0                	test   %eax,%eax
  80f272:	78 51                	js     80f2c5 <pgfault+0xec>
		panic("pgfault: page unmap failed (%e)", r);
}	
  80f274:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f277:	5b                   	pop    %ebx
  80f278:	5e                   	pop    %esi
  80f279:	5d                   	pop    %ebp
  80f27a:	c3                   	ret    
	if( (err & FEC_WR)==0 || (uvpt[PGNUM(addr)] & PTE_COW)==0 ) panic("pgfault: invalid user trap frame(not a write or to COW)");
  80f27b:	83 ec 04             	sub    $0x4,%esp
  80f27e:	68 ec 34 81 00       	push   $0x8134ec
  80f283:	6a 1d                	push   $0x1d
  80f285:	68 68 35 81 00       	push   $0x813568
  80f28a:	e8 47 f2 ff ff       	call   80e4d6 <_panic>
        if(r<0) panic("pgfault: page allocation failed %e", r);
  80f28f:	50                   	push   %eax
  80f290:	68 24 35 81 00       	push   $0x813524
  80f295:	6a 29                	push   $0x29
  80f297:	68 68 35 81 00       	push   $0x813568
  80f29c:	e8 35 f2 ff ff       	call   80e4d6 <_panic>
		panic("pgfault: page unmap failed (%e)", r);
  80f2a1:	50                   	push   %eax
  80f2a2:	68 48 35 81 00       	push   $0x813548
  80f2a7:	6a 2e                	push   $0x2e
  80f2a9:	68 68 35 81 00       	push   $0x813568
  80f2ae:	e8 23 f2 ff ff       	call   80e4d6 <_panic>
		panic("pgfault: page map failed (%e)", r);
  80f2b3:	50                   	push   %eax
  80f2b4:	68 73 35 81 00       	push   $0x813573
  80f2b9:	6a 30                	push   $0x30
  80f2bb:	68 68 35 81 00       	push   $0x813568
  80f2c0:	e8 11 f2 ff ff       	call   80e4d6 <_panic>
		panic("pgfault: page unmap failed (%e)", r);
  80f2c5:	50                   	push   %eax
  80f2c6:	68 48 35 81 00       	push   $0x813548
  80f2cb:	6a 32                	push   $0x32
  80f2cd:	68 68 35 81 00       	push   $0x813568
  80f2d2:	e8 ff f1 ff ff       	call   80e4d6 <_panic>

0080f2d7 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f2d7:	55                   	push   %ebp
  80f2d8:	89 e5                	mov    %esp,%ebp
  80f2da:	57                   	push   %edi
  80f2db:	56                   	push   %esi
  80f2dc:	53                   	push   %ebx
  80f2dd:	83 ec 28             	sub    $0x28,%esp
	// LAB 4: Your code here.
	//panic("fork not implemented");
	//仿照dumbfork.c中的dumbfork()写
	//1.
	set_pgfault_handler(pgfault);
  80f2e0:	68 d9 f1 80 00       	push   $0x80f1d9
  80f2e5:	e8 fb 15 00 00       	call   8108e5 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f2ea:	b8 07 00 00 00       	mov    $0x7,%eax
  80f2ef:	cd 30                	int    $0x30
  80f2f1:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//2.
	envid_t envid=sys_exofork();
	if (envid < 0)
  80f2f4:	83 c4 10             	add    $0x10,%esp
  80f2f7:	85 c0                	test   %eax,%eax
  80f2f9:	78 2d                	js     80f328 <fork+0x51>
	
	//3.
	// We're the parent.
	// 此处与dumbfork()不同, uvpt,uvpd用法见于 memlayout.h 与lib/entry.S
	int r;
	for (uintptr_t addr = UTEXT; addr < USTACKTOP; addr += PGSIZE) {/*UTEXT: Where user programs generally begin*/
  80f2fb:	bb 00 00 80 00       	mov    $0x800000,%ebx
	if (envid == 0) {
  80f300:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80f304:	75 73                	jne    80f379 <fork+0xa2>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f306:	e8 3e fc ff ff       	call   80ef49 <sys_getenvid>
  80f30b:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f310:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f313:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f318:	a3 30 b2 b3 00       	mov    %eax,0xb3b230
		return 0;
  80f31d:	8b 45 dc             	mov    -0x24(%ebp),%eax
	//5.
	r = sys_env_set_status(envid, ENV_RUNNABLE);
	if(r<0) return r;
	
	return envid;
}
  80f320:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f323:	5b                   	pop    %ebx
  80f324:	5e                   	pop    %esi
  80f325:	5f                   	pop    %edi
  80f326:	5d                   	pop    %ebp
  80f327:	c3                   	ret    
		panic("sys_exofork: %e", envid);
  80f328:	50                   	push   %eax
  80f329:	68 91 35 81 00       	push   $0x813591
  80f32e:	6a 78                	push   $0x78
  80f330:	68 68 35 81 00       	push   $0x813568
  80f335:	e8 9c f1 ff ff       	call   80e4d6 <_panic>
	r=sys_page_map(this_envid, va, envid, va, perm);//一定要用系统调用， 因为权限！！
  80f33a:	83 ec 0c             	sub    $0xc,%esp
  80f33d:	ff 75 e4             	push   -0x1c(%ebp)
  80f340:	57                   	push   %edi
  80f341:	ff 75 dc             	push   -0x24(%ebp)
  80f344:	57                   	push   %edi
  80f345:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f348:	56                   	push   %esi
  80f349:	e8 7c fc ff ff       	call   80efca <sys_page_map>
	if(r<0) return r;
  80f34e:	83 c4 20             	add    $0x20,%esp
  80f351:	85 c0                	test   %eax,%eax
  80f353:	78 cb                	js     80f320 <fork+0x49>
	r=sys_page_map(this_envid, va, this_envid, va, perm);
  80f355:	83 ec 0c             	sub    $0xc,%esp
  80f358:	ff 75 e4             	push   -0x1c(%ebp)
  80f35b:	57                   	push   %edi
  80f35c:	56                   	push   %esi
  80f35d:	57                   	push   %edi
  80f35e:	56                   	push   %esi
  80f35f:	e8 66 fc ff ff       	call   80efca <sys_page_map>
		    if( ( r=duppage( envid, PGNUM(addr) ) )< 0 ) return r;
  80f364:	83 c4 20             	add    $0x20,%esp
  80f367:	85 c0                	test   %eax,%eax
  80f369:	78 76                	js     80f3e1 <fork+0x10a>
	for (uintptr_t addr = UTEXT; addr < USTACKTOP; addr += PGSIZE) {/*UTEXT: Where user programs generally begin*/
  80f36b:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f371:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  80f377:	74 75                	je     80f3ee <fork+0x117>
		if ( (uvpd[PDX(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_P) ) {
  80f379:	89 d8                	mov    %ebx,%eax
  80f37b:	c1 e8 16             	shr    $0x16,%eax
  80f37e:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f385:	a8 01                	test   $0x1,%al
  80f387:	74 e2                	je     80f36b <fork+0x94>
  80f389:	89 de                	mov    %ebx,%esi
  80f38b:	c1 ee 0c             	shr    $0xc,%esi
  80f38e:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f395:	a8 01                	test   $0x1,%al
  80f397:	74 d2                	je     80f36b <fork+0x94>
	envid_t this_envid = sys_getenvid();//父进程号
  80f399:	e8 ab fb ff ff       	call   80ef49 <sys_getenvid>
  80f39e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	void * va = (void *)(pn * PGSIZE);
  80f3a1:	89 f7                	mov    %esi,%edi
  80f3a3:	c1 e7 0c             	shl    $0xc,%edi
	int perm = uvpt[pn] & PTE_SYSCALL;
  80f3a6:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f3ad:	89 c1                	mov    %eax,%ecx
  80f3af:	81 e1 07 0e 00 00    	and    $0xe07,%ecx
  80f3b5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	if ( uvpt[pn] & PTE_SHARE ){/* lab5 exercise8 */
  80f3b8:	8b 14 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%edx
  80f3bf:	f6 c6 04             	test   $0x4,%dh
  80f3c2:	0f 85 72 ff ff ff    	jne    80f33a <fork+0x63>
		perm &= ~PTE_W;
  80f3c8:	25 05 0e 00 00       	and    $0xe05,%eax
  80f3cd:	80 cc 08             	or     $0x8,%ah
  80f3d0:	f7 c1 02 08 00 00    	test   $0x802,%ecx
  80f3d6:	0f 44 c1             	cmove  %ecx,%eax
  80f3d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f3dc:	e9 59 ff ff ff       	jmp    80f33a <fork+0x63>
  80f3e1:	ba 00 00 00 00       	mov    $0x0,%edx
  80f3e6:	0f 4f c2             	cmovg  %edx,%eax
  80f3e9:	e9 32 ff ff ff       	jmp    80f320 <fork+0x49>
	r=sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);
  80f3ee:	83 ec 04             	sub    $0x4,%esp
  80f3f1:	6a 07                	push   $0x7
  80f3f3:	68 00 f0 bf ee       	push   $0xeebff000
  80f3f8:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80f3fb:	57                   	push   %edi
  80f3fc:	e8 86 fb ff ff       	call   80ef87 <sys_page_alloc>
	if(r<0) return r;
  80f401:	83 c4 10             	add    $0x10,%esp
  80f404:	85 c0                	test   %eax,%eax
  80f406:	0f 88 14 ff ff ff    	js     80f320 <fork+0x49>
	r=sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
  80f40c:	83 ec 08             	sub    $0x8,%esp
  80f40f:	68 5b 09 81 00       	push   $0x81095b
  80f414:	57                   	push   %edi
  80f415:	e8 b8 fc ff ff       	call   80f0d2 <sys_env_set_pgfault_upcall>
	if(r<0) return r;
  80f41a:	83 c4 10             	add    $0x10,%esp
  80f41d:	85 c0                	test   %eax,%eax
  80f41f:	0f 88 fb fe ff ff    	js     80f320 <fork+0x49>
	r = sys_env_set_status(envid, ENV_RUNNABLE);
  80f425:	83 ec 08             	sub    $0x8,%esp
  80f428:	6a 02                	push   $0x2
  80f42a:	57                   	push   %edi
  80f42b:	e8 1e fc ff ff       	call   80f04e <sys_env_set_status>
	if(r<0) return r;
  80f430:	83 c4 10             	add    $0x10,%esp
	return envid;
  80f433:	85 c0                	test   %eax,%eax
  80f435:	0f 49 c7             	cmovns %edi,%eax
  80f438:	e9 e3 fe ff ff       	jmp    80f320 <fork+0x49>

0080f43d <sfork>:

// Challenge!
int
sfork(void)
{
  80f43d:	55                   	push   %ebp
  80f43e:	89 e5                	mov    %esp,%ebp
  80f440:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  80f443:	68 a1 35 81 00       	push   $0x8135a1
  80f448:	68 a1 00 00 00       	push   $0xa1
  80f44d:	68 68 35 81 00       	push   $0x813568
  80f452:	e8 7f f0 ff ff       	call   80e4d6 <_panic>

0080f457 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page. 也就是UTOP)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80f457:	55                   	push   %ebp
  80f458:	89 e5                	mov    %esp,%ebp
  80f45a:	56                   	push   %esi
  80f45b:	53                   	push   %ebx
  80f45c:	8b 75 08             	mov    0x8(%ebp),%esi
  80f45f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f462:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	//panic("ipc_recv not implemented");
	if(!pg) pg=(void *) UTOP;
  80f465:	85 c0                	test   %eax,%eax
  80f467:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  80f46c:	0f 44 c2             	cmove  %edx,%eax
	int r=sys_ipc_recv(pg);
  80f46f:	83 ec 0c             	sub    $0xc,%esp
  80f472:	50                   	push   %eax
  80f473:	e8 bf fc ff ff       	call   80f137 <sys_ipc_recv>
	
	//thisenv在lib/libmain.c中定义。 currenv在kern/env.h中定义。
	//这里注释要求用thisenv。
	//应该是因为用户环境下没有权限访问currenv，只能利用libmain()函数中定义的thisenv。
	if(from_env_store) *from_env_store = (r < 0? 0 : thisenv->env_ipc_from);
  80f478:	83 c4 10             	add    $0x10,%esp
  80f47b:	85 f6                	test   %esi,%esi
  80f47d:	74 14                	je     80f493 <ipc_recv+0x3c>
  80f47f:	ba 00 00 00 00       	mov    $0x0,%edx
  80f484:	85 c0                	test   %eax,%eax
  80f486:	78 09                	js     80f491 <ipc_recv+0x3a>
  80f488:	8b 15 30 b2 b3 00    	mov    0xb3b230,%edx
  80f48e:	8b 52 74             	mov    0x74(%edx),%edx
  80f491:	89 16                	mov    %edx,(%esi)
	if(perm_store) *perm_store= (r<0? 0:thisenv->env_ipc_perm);
  80f493:	85 db                	test   %ebx,%ebx
  80f495:	74 14                	je     80f4ab <ipc_recv+0x54>
  80f497:	ba 00 00 00 00       	mov    $0x0,%edx
  80f49c:	85 c0                	test   %eax,%eax
  80f49e:	78 09                	js     80f4a9 <ipc_recv+0x52>
  80f4a0:	8b 15 30 b2 b3 00    	mov    0xb3b230,%edx
  80f4a6:	8b 52 78             	mov    0x78(%edx),%edx
  80f4a9:	89 13                	mov    %edx,(%ebx)
	
	if(r<0) return r;
  80f4ab:	85 c0                	test   %eax,%eax
  80f4ad:	78 08                	js     80f4b7 <ipc_recv+0x60>
	
	return thisenv->env_ipc_value;
  80f4af:	a1 30 b2 b3 00       	mov    0xb3b230,%eax
  80f4b4:	8b 40 70             	mov    0x70(%eax),%eax
}
  80f4b7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f4ba:	5b                   	pop    %ebx
  80f4bb:	5e                   	pop    %esi
  80f4bc:	5d                   	pop    %ebp
  80f4bd:	c3                   	ret    

0080f4be <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80f4be:	55                   	push   %ebp
  80f4bf:	89 e5                	mov    %esp,%ebp
  80f4c1:	57                   	push   %edi
  80f4c2:	56                   	push   %esi
  80f4c3:	53                   	push   %ebx
  80f4c4:	83 ec 0c             	sub    $0xc,%esp
  80f4c7:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f4ca:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f4cd:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	//panic("ipc_send not implemented");
	int r;
	if (!pg)  pg = (void *) UTOP;
  80f4d0:	85 db                	test   %ebx,%ebx
  80f4d2:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80f4d7:	0f 44 d8             	cmove  %eax,%ebx
  80f4da:	eb 05                	jmp    80f4e1 <ipc_send+0x23>
	
	do{
		r=sys_ipc_try_send(to_env, val, pg, perm);
		//用户级程序不能直接调用 sched_yeild();
		if( r==-E_IPC_NOT_RECV ) sys_yield();
  80f4dc:	e8 87 fa ff ff       	call   80ef68 <sys_yield>
		r=sys_ipc_try_send(to_env, val, pg, perm);
  80f4e1:	ff 75 14             	push   0x14(%ebp)
  80f4e4:	53                   	push   %ebx
  80f4e5:	56                   	push   %esi
  80f4e6:	57                   	push   %edi
  80f4e7:	e8 28 fc ff ff       	call   80f114 <sys_ipc_try_send>
		if( r==-E_IPC_NOT_RECV ) sys_yield();
  80f4ec:	83 c4 10             	add    $0x10,%esp
  80f4ef:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80f4f2:	74 e8                	je     80f4dc <ipc_send+0x1e>
		else if( r<0 && (r!=-E_IPC_NOT_RECV) ) panic("ipc_send failed: %e", r);
  80f4f4:	85 c0                	test   %eax,%eax
  80f4f6:	78 08                	js     80f500 <ipc_send+0x42>
	}while (r<0);

}
  80f4f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f4fb:	5b                   	pop    %ebx
  80f4fc:	5e                   	pop    %esi
  80f4fd:	5f                   	pop    %edi
  80f4fe:	5d                   	pop    %ebp
  80f4ff:	c3                   	ret    
		else if( r<0 && (r!=-E_IPC_NOT_RECV) ) panic("ipc_send failed: %e", r);
  80f500:	50                   	push   %eax
  80f501:	68 b7 35 81 00       	push   $0x8135b7
  80f506:	6a 3d                	push   $0x3d
  80f508:	68 cb 35 81 00       	push   $0x8135cb
  80f50d:	e8 c4 ef ff ff       	call   80e4d6 <_panic>

0080f512 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80f512:	55                   	push   %ebp
  80f513:	89 e5                	mov    %esp,%ebp
  80f515:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80f518:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80f51d:	6b d0 7c             	imul   $0x7c,%eax,%edx
  80f520:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80f526:	8b 52 50             	mov    0x50(%edx),%edx
  80f529:	39 ca                	cmp    %ecx,%edx
  80f52b:	74 11                	je     80f53e <ipc_find_env+0x2c>
	for (i = 0; i < NENV; i++)
  80f52d:	83 c0 01             	add    $0x1,%eax
  80f530:	3d 00 04 00 00       	cmp    $0x400,%eax
  80f535:	75 e6                	jne    80f51d <ipc_find_env+0xb>
			return envs[i].env_id;
	return 0;
  80f537:	b8 00 00 00 00       	mov    $0x0,%eax
  80f53c:	eb 0b                	jmp    80f549 <ipc_find_env+0x37>
			return envs[i].env_id;
  80f53e:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f541:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f546:	8b 40 48             	mov    0x48(%eax),%eax
}
  80f549:	5d                   	pop    %ebp
  80f54a:	c3                   	ret    

0080f54b <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80f54b:	55                   	push   %ebp
  80f54c:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f54e:	8b 45 08             	mov    0x8(%ebp),%eax
  80f551:	05 00 00 00 30       	add    $0x30000000,%eax
  80f556:	c1 e8 0c             	shr    $0xc,%eax
}
  80f559:	5d                   	pop    %ebp
  80f55a:	c3                   	ret    

0080f55b <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80f55b:	55                   	push   %ebp
  80f55c:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f55e:	8b 45 08             	mov    0x8(%ebp),%eax
  80f561:	05 00 00 00 30       	add    $0x30000000,%eax
	return INDEX2DATA(fd2num(fd));
  80f566:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f56b:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80f570:	5d                   	pop    %ebp
  80f571:	c3                   	ret    

0080f572 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80f572:	55                   	push   %ebp
  80f573:	89 e5                	mov    %esp,%ebp
  80f575:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80f57a:	89 c2                	mov    %eax,%edx
  80f57c:	c1 ea 16             	shr    $0x16,%edx
  80f57f:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f586:	f6 c2 01             	test   $0x1,%dl
  80f589:	74 29                	je     80f5b4 <fd_alloc+0x42>
  80f58b:	89 c2                	mov    %eax,%edx
  80f58d:	c1 ea 0c             	shr    $0xc,%edx
  80f590:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f597:	f6 c2 01             	test   $0x1,%dl
  80f59a:	74 18                	je     80f5b4 <fd_alloc+0x42>
	for (i = 0; i < MAXFD; i++) {
  80f59c:	05 00 10 00 00       	add    $0x1000,%eax
  80f5a1:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80f5a6:	75 d2                	jne    80f57a <fd_alloc+0x8>
  80f5a8:	b8 00 00 00 00       	mov    $0x0,%eax
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
	return -E_MAX_OPEN;
  80f5ad:	b9 f6 ff ff ff       	mov    $0xfffffff6,%ecx
  80f5b2:	eb 05                	jmp    80f5b9 <fd_alloc+0x47>
			return 0;
  80f5b4:	b9 00 00 00 00       	mov    $0x0,%ecx
			*fd_store = fd;
  80f5b9:	8b 55 08             	mov    0x8(%ebp),%edx
  80f5bc:	89 02                	mov    %eax,(%edx)
}
  80f5be:	89 c8                	mov    %ecx,%eax
  80f5c0:	5d                   	pop    %ebp
  80f5c1:	c3                   	ret    

0080f5c2 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80f5c2:	55                   	push   %ebp
  80f5c3:	89 e5                	mov    %esp,%ebp
  80f5c5:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80f5c8:	83 f8 1f             	cmp    $0x1f,%eax
  80f5cb:	77 30                	ja     80f5fd <fd_lookup+0x3b>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80f5cd:	c1 e0 0c             	shl    $0xc,%eax
  80f5d0:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80f5d5:	8b 15 00 dd 7b ef    	mov    0xef7bdd00,%edx
  80f5db:	f6 c2 01             	test   $0x1,%dl
  80f5de:	74 24                	je     80f604 <fd_lookup+0x42>
  80f5e0:	89 c2                	mov    %eax,%edx
  80f5e2:	c1 ea 0c             	shr    $0xc,%edx
  80f5e5:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f5ec:	f6 c2 01             	test   $0x1,%dl
  80f5ef:	74 1a                	je     80f60b <fd_lookup+0x49>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80f5f1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f5f4:	89 02                	mov    %eax,(%edx)
	return 0;
  80f5f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f5fb:	5d                   	pop    %ebp
  80f5fc:	c3                   	ret    
		return -E_INVAL;
  80f5fd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f602:	eb f7                	jmp    80f5fb <fd_lookup+0x39>
		return -E_INVAL;
  80f604:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f609:	eb f0                	jmp    80f5fb <fd_lookup+0x39>
  80f60b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f610:	eb e9                	jmp    80f5fb <fd_lookup+0x39>

0080f612 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80f612:	55                   	push   %ebp
  80f613:	89 e5                	mov    %esp,%ebp
  80f615:	53                   	push   %ebx
  80f616:	83 ec 04             	sub    $0x4,%esp
  80f619:	8b 55 08             	mov    0x8(%ebp),%edx
	int i;
	for (i = 0; devtab[i]; i++)
  80f61c:	b8 00 00 00 00       	mov    $0x0,%eax
  80f621:	bb ec 42 81 00       	mov    $0x8142ec,%ebx
		if (devtab[i]->dev_id == dev_id) {
  80f626:	39 13                	cmp    %edx,(%ebx)
  80f628:	74 37                	je     80f661 <dev_lookup+0x4f>
	for (i = 0; devtab[i]; i++)
  80f62a:	83 c0 01             	add    $0x1,%eax
  80f62d:	8b 1c 85 54 36 81 00 	mov    0x813654(,%eax,4),%ebx
  80f634:	85 db                	test   %ebx,%ebx
  80f636:	75 ee                	jne    80f626 <dev_lookup+0x14>
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80f638:	a1 30 b2 b3 00       	mov    0xb3b230,%eax
  80f63d:	8b 40 48             	mov    0x48(%eax),%eax
  80f640:	83 ec 04             	sub    $0x4,%esp
  80f643:	52                   	push   %edx
  80f644:	50                   	push   %eax
  80f645:	68 d8 35 81 00       	push   $0x8135d8
  80f64a:	e8 62 ef ff ff       	call   80e5b1 <cprintf>
	*dev = 0;
	return -E_INVAL;
  80f64f:	83 c4 10             	add    $0x10,%esp
  80f652:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
			*dev = devtab[i];
  80f657:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f65a:	89 1a                	mov    %ebx,(%edx)
}
  80f65c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f65f:	c9                   	leave  
  80f660:	c3                   	ret    
			return 0;
  80f661:	b8 00 00 00 00       	mov    $0x0,%eax
  80f666:	eb ef                	jmp    80f657 <dev_lookup+0x45>

0080f668 <fd_close>:
{
  80f668:	55                   	push   %ebp
  80f669:	89 e5                	mov    %esp,%ebp
  80f66b:	57                   	push   %edi
  80f66c:	56                   	push   %esi
  80f66d:	53                   	push   %ebx
  80f66e:	83 ec 24             	sub    $0x24,%esp
  80f671:	8b 75 08             	mov    0x8(%ebp),%esi
  80f674:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f677:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80f67a:	50                   	push   %eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f67b:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80f681:	c1 e8 0c             	shr    $0xc,%eax
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f684:	50                   	push   %eax
  80f685:	e8 38 ff ff ff       	call   80f5c2 <fd_lookup>
  80f68a:	89 c3                	mov    %eax,%ebx
  80f68c:	83 c4 10             	add    $0x10,%esp
  80f68f:	85 c0                	test   %eax,%eax
  80f691:	78 05                	js     80f698 <fd_close+0x30>
	    || fd != fd2)
  80f693:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80f696:	74 16                	je     80f6ae <fd_close+0x46>
		return (must_exist ? r : 0);
  80f698:	89 f8                	mov    %edi,%eax
  80f69a:	84 c0                	test   %al,%al
  80f69c:	b8 00 00 00 00       	mov    $0x0,%eax
  80f6a1:	0f 44 d8             	cmove  %eax,%ebx
}
  80f6a4:	89 d8                	mov    %ebx,%eax
  80f6a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f6a9:	5b                   	pop    %ebx
  80f6aa:	5e                   	pop    %esi
  80f6ab:	5f                   	pop    %edi
  80f6ac:	5d                   	pop    %ebp
  80f6ad:	c3                   	ret    
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80f6ae:	83 ec 08             	sub    $0x8,%esp
  80f6b1:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80f6b4:	50                   	push   %eax
  80f6b5:	ff 36                	push   (%esi)
  80f6b7:	e8 56 ff ff ff       	call   80f612 <dev_lookup>
  80f6bc:	89 c3                	mov    %eax,%ebx
  80f6be:	83 c4 10             	add    $0x10,%esp
  80f6c1:	85 c0                	test   %eax,%eax
  80f6c3:	78 1a                	js     80f6df <fd_close+0x77>
		if (dev->dev_close)
  80f6c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f6c8:	8b 40 10             	mov    0x10(%eax),%eax
			r = 0;
  80f6cb:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (dev->dev_close)
  80f6d0:	85 c0                	test   %eax,%eax
  80f6d2:	74 0b                	je     80f6df <fd_close+0x77>
			r = (*dev->dev_close)(fd);
  80f6d4:	83 ec 0c             	sub    $0xc,%esp
  80f6d7:	56                   	push   %esi
  80f6d8:	ff d0                	call   *%eax
  80f6da:	89 c3                	mov    %eax,%ebx
  80f6dc:	83 c4 10             	add    $0x10,%esp
	(void) sys_page_unmap(0, fd);
  80f6df:	83 ec 08             	sub    $0x8,%esp
  80f6e2:	56                   	push   %esi
  80f6e3:	6a 00                	push   $0x0
  80f6e5:	e8 22 f9 ff ff       	call   80f00c <sys_page_unmap>
	return r;
  80f6ea:	83 c4 10             	add    $0x10,%esp
  80f6ed:	eb b5                	jmp    80f6a4 <fd_close+0x3c>

0080f6ef <close>:

int
close(int fdnum)
{
  80f6ef:	55                   	push   %ebp
  80f6f0:	89 e5                	mov    %esp,%ebp
  80f6f2:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f6f5:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f6f8:	50                   	push   %eax
  80f6f9:	ff 75 08             	push   0x8(%ebp)
  80f6fc:	e8 c1 fe ff ff       	call   80f5c2 <fd_lookup>
  80f701:	83 c4 10             	add    $0x10,%esp
  80f704:	85 c0                	test   %eax,%eax
  80f706:	79 02                	jns    80f70a <close+0x1b>
		return r;
	else
		return fd_close(fd, 1);
}
  80f708:	c9                   	leave  
  80f709:	c3                   	ret    
		return fd_close(fd, 1);
  80f70a:	83 ec 08             	sub    $0x8,%esp
  80f70d:	6a 01                	push   $0x1
  80f70f:	ff 75 f4             	push   -0xc(%ebp)
  80f712:	e8 51 ff ff ff       	call   80f668 <fd_close>
  80f717:	83 c4 10             	add    $0x10,%esp
  80f71a:	eb ec                	jmp    80f708 <close+0x19>

0080f71c <close_all>:

void
close_all(void)
{
  80f71c:	55                   	push   %ebp
  80f71d:	89 e5                	mov    %esp,%ebp
  80f71f:	53                   	push   %ebx
  80f720:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80f723:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80f728:	83 ec 0c             	sub    $0xc,%esp
  80f72b:	53                   	push   %ebx
  80f72c:	e8 be ff ff ff       	call   80f6ef <close>
	for (i = 0; i < MAXFD; i++)
  80f731:	83 c3 01             	add    $0x1,%ebx
  80f734:	83 c4 10             	add    $0x10,%esp
  80f737:	83 fb 20             	cmp    $0x20,%ebx
  80f73a:	75 ec                	jne    80f728 <close_all+0xc>
}
  80f73c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f73f:	c9                   	leave  
  80f740:	c3                   	ret    

0080f741 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80f741:	55                   	push   %ebp
  80f742:	89 e5                	mov    %esp,%ebp
  80f744:	57                   	push   %edi
  80f745:	56                   	push   %esi
  80f746:	53                   	push   %ebx
  80f747:	83 ec 34             	sub    $0x34,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80f74a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80f74d:	50                   	push   %eax
  80f74e:	ff 75 08             	push   0x8(%ebp)
  80f751:	e8 6c fe ff ff       	call   80f5c2 <fd_lookup>
  80f756:	89 c3                	mov    %eax,%ebx
  80f758:	83 c4 10             	add    $0x10,%esp
  80f75b:	85 c0                	test   %eax,%eax
  80f75d:	78 7f                	js     80f7de <dup+0x9d>
		return r;
	close(newfdnum);
  80f75f:	83 ec 0c             	sub    $0xc,%esp
  80f762:	ff 75 0c             	push   0xc(%ebp)
  80f765:	e8 85 ff ff ff       	call   80f6ef <close>

	newfd = INDEX2FD(newfdnum);
  80f76a:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f76d:	c1 e6 0c             	shl    $0xc,%esi
  80f770:	81 ee 00 00 00 30    	sub    $0x30000000,%esi
	ova = fd2data(oldfd);
  80f776:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80f779:	89 3c 24             	mov    %edi,(%esp)
  80f77c:	e8 da fd ff ff       	call   80f55b <fd2data>
  80f781:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  80f783:	89 34 24             	mov    %esi,(%esp)
  80f786:	e8 d0 fd ff ff       	call   80f55b <fd2data>
  80f78b:	83 c4 10             	add    $0x10,%esp
  80f78e:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80f791:	89 d8                	mov    %ebx,%eax
  80f793:	c1 e8 16             	shr    $0x16,%eax
  80f796:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f79d:	a8 01                	test   $0x1,%al
  80f79f:	74 11                	je     80f7b2 <dup+0x71>
  80f7a1:	89 d8                	mov    %ebx,%eax
  80f7a3:	c1 e8 0c             	shr    $0xc,%eax
  80f7a6:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f7ad:	f6 c2 01             	test   $0x1,%dl
  80f7b0:	75 36                	jne    80f7e8 <dup+0xa7>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f7b2:	89 f8                	mov    %edi,%eax
  80f7b4:	c1 e8 0c             	shr    $0xc,%eax
  80f7b7:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f7be:	83 ec 0c             	sub    $0xc,%esp
  80f7c1:	25 07 0e 00 00       	and    $0xe07,%eax
  80f7c6:	50                   	push   %eax
  80f7c7:	56                   	push   %esi
  80f7c8:	6a 00                	push   $0x0
  80f7ca:	57                   	push   %edi
  80f7cb:	6a 00                	push   $0x0
  80f7cd:	e8 f8 f7 ff ff       	call   80efca <sys_page_map>
  80f7d2:	89 c3                	mov    %eax,%ebx
  80f7d4:	83 c4 20             	add    $0x20,%esp
  80f7d7:	85 c0                	test   %eax,%eax
  80f7d9:	78 33                	js     80f80e <dup+0xcd>
		goto err;

	return newfdnum;
  80f7db:	8b 5d 0c             	mov    0xc(%ebp),%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  80f7de:	89 d8                	mov    %ebx,%eax
  80f7e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f7e3:	5b                   	pop    %ebx
  80f7e4:	5e                   	pop    %esi
  80f7e5:	5f                   	pop    %edi
  80f7e6:	5d                   	pop    %ebp
  80f7e7:	c3                   	ret    
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80f7e8:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f7ef:	83 ec 0c             	sub    $0xc,%esp
  80f7f2:	25 07 0e 00 00       	and    $0xe07,%eax
  80f7f7:	50                   	push   %eax
  80f7f8:	ff 75 d4             	push   -0x2c(%ebp)
  80f7fb:	6a 00                	push   $0x0
  80f7fd:	53                   	push   %ebx
  80f7fe:	6a 00                	push   $0x0
  80f800:	e8 c5 f7 ff ff       	call   80efca <sys_page_map>
  80f805:	89 c3                	mov    %eax,%ebx
  80f807:	83 c4 20             	add    $0x20,%esp
  80f80a:	85 c0                	test   %eax,%eax
  80f80c:	79 a4                	jns    80f7b2 <dup+0x71>
	sys_page_unmap(0, newfd);
  80f80e:	83 ec 08             	sub    $0x8,%esp
  80f811:	56                   	push   %esi
  80f812:	6a 00                	push   $0x0
  80f814:	e8 f3 f7 ff ff       	call   80f00c <sys_page_unmap>
	sys_page_unmap(0, nva);
  80f819:	83 c4 08             	add    $0x8,%esp
  80f81c:	ff 75 d4             	push   -0x2c(%ebp)
  80f81f:	6a 00                	push   $0x0
  80f821:	e8 e6 f7 ff ff       	call   80f00c <sys_page_unmap>
	return r;
  80f826:	83 c4 10             	add    $0x10,%esp
  80f829:	eb b3                	jmp    80f7de <dup+0x9d>

0080f82b <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80f82b:	55                   	push   %ebp
  80f82c:	89 e5                	mov    %esp,%ebp
  80f82e:	56                   	push   %esi
  80f82f:	53                   	push   %ebx
  80f830:	83 ec 18             	sub    $0x18,%esp
  80f833:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f836:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f839:	50                   	push   %eax
  80f83a:	56                   	push   %esi
  80f83b:	e8 82 fd ff ff       	call   80f5c2 <fd_lookup>
  80f840:	83 c4 10             	add    $0x10,%esp
  80f843:	85 c0                	test   %eax,%eax
  80f845:	78 3c                	js     80f883 <read+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f847:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  80f84a:	83 ec 08             	sub    $0x8,%esp
  80f84d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f850:	50                   	push   %eax
  80f851:	ff 33                	push   (%ebx)
  80f853:	e8 ba fd ff ff       	call   80f612 <dev_lookup>
  80f858:	83 c4 10             	add    $0x10,%esp
  80f85b:	85 c0                	test   %eax,%eax
  80f85d:	78 24                	js     80f883 <read+0x58>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80f85f:	8b 43 08             	mov    0x8(%ebx),%eax
  80f862:	83 e0 03             	and    $0x3,%eax
  80f865:	83 f8 01             	cmp    $0x1,%eax
  80f868:	74 20                	je     80f88a <read+0x5f>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
  80f86a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f86d:	8b 40 08             	mov    0x8(%eax),%eax
  80f870:	85 c0                	test   %eax,%eax
  80f872:	74 37                	je     80f8ab <read+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80f874:	83 ec 04             	sub    $0x4,%esp
  80f877:	ff 75 10             	push   0x10(%ebp)
  80f87a:	ff 75 0c             	push   0xc(%ebp)
  80f87d:	53                   	push   %ebx
  80f87e:	ff d0                	call   *%eax
  80f880:	83 c4 10             	add    $0x10,%esp
}
  80f883:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f886:	5b                   	pop    %ebx
  80f887:	5e                   	pop    %esi
  80f888:	5d                   	pop    %ebp
  80f889:	c3                   	ret    
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80f88a:	a1 30 b2 b3 00       	mov    0xb3b230,%eax
  80f88f:	8b 40 48             	mov    0x48(%eax),%eax
  80f892:	83 ec 04             	sub    $0x4,%esp
  80f895:	56                   	push   %esi
  80f896:	50                   	push   %eax
  80f897:	68 19 36 81 00       	push   $0x813619
  80f89c:	e8 10 ed ff ff       	call   80e5b1 <cprintf>
		return -E_INVAL;
  80f8a1:	83 c4 10             	add    $0x10,%esp
  80f8a4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f8a9:	eb d8                	jmp    80f883 <read+0x58>
		return -E_NOT_SUPP;
  80f8ab:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80f8b0:	eb d1                	jmp    80f883 <read+0x58>

0080f8b2 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80f8b2:	55                   	push   %ebp
  80f8b3:	89 e5                	mov    %esp,%ebp
  80f8b5:	57                   	push   %edi
  80f8b6:	56                   	push   %esi
  80f8b7:	53                   	push   %ebx
  80f8b8:	83 ec 0c             	sub    $0xc,%esp
  80f8bb:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f8be:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80f8c1:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f8c6:	eb 02                	jmp    80f8ca <readn+0x18>
  80f8c8:	01 c3                	add    %eax,%ebx
  80f8ca:	39 f3                	cmp    %esi,%ebx
  80f8cc:	73 21                	jae    80f8ef <readn+0x3d>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80f8ce:	83 ec 04             	sub    $0x4,%esp
  80f8d1:	89 f0                	mov    %esi,%eax
  80f8d3:	29 d8                	sub    %ebx,%eax
  80f8d5:	50                   	push   %eax
  80f8d6:	89 d8                	mov    %ebx,%eax
  80f8d8:	03 45 0c             	add    0xc(%ebp),%eax
  80f8db:	50                   	push   %eax
  80f8dc:	57                   	push   %edi
  80f8dd:	e8 49 ff ff ff       	call   80f82b <read>
		if (m < 0)
  80f8e2:	83 c4 10             	add    $0x10,%esp
  80f8e5:	85 c0                	test   %eax,%eax
  80f8e7:	78 04                	js     80f8ed <readn+0x3b>
			return m;
		if (m == 0)
  80f8e9:	75 dd                	jne    80f8c8 <readn+0x16>
  80f8eb:	eb 02                	jmp    80f8ef <readn+0x3d>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80f8ed:	89 c3                	mov    %eax,%ebx
			break;
	}
	return tot;
}
  80f8ef:	89 d8                	mov    %ebx,%eax
  80f8f1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f8f4:	5b                   	pop    %ebx
  80f8f5:	5e                   	pop    %esi
  80f8f6:	5f                   	pop    %edi
  80f8f7:	5d                   	pop    %ebp
  80f8f8:	c3                   	ret    

0080f8f9 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80f8f9:	55                   	push   %ebp
  80f8fa:	89 e5                	mov    %esp,%ebp
  80f8fc:	56                   	push   %esi
  80f8fd:	53                   	push   %ebx
  80f8fe:	83 ec 18             	sub    $0x18,%esp
  80f901:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f904:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f907:	50                   	push   %eax
  80f908:	53                   	push   %ebx
  80f909:	e8 b4 fc ff ff       	call   80f5c2 <fd_lookup>
  80f90e:	83 c4 10             	add    $0x10,%esp
  80f911:	85 c0                	test   %eax,%eax
  80f913:	78 37                	js     80f94c <write+0x53>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f915:	8b 75 f0             	mov    -0x10(%ebp),%esi
  80f918:	83 ec 08             	sub    $0x8,%esp
  80f91b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f91e:	50                   	push   %eax
  80f91f:	ff 36                	push   (%esi)
  80f921:	e8 ec fc ff ff       	call   80f612 <dev_lookup>
  80f926:	83 c4 10             	add    $0x10,%esp
  80f929:	85 c0                	test   %eax,%eax
  80f92b:	78 1f                	js     80f94c <write+0x53>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f92d:	f6 46 08 03          	testb  $0x3,0x8(%esi)
  80f931:	74 20                	je     80f953 <write+0x5a>
		return -E_INVAL;
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80f933:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f936:	8b 40 0c             	mov    0xc(%eax),%eax
  80f939:	85 c0                	test   %eax,%eax
  80f93b:	74 37                	je     80f974 <write+0x7b>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80f93d:	83 ec 04             	sub    $0x4,%esp
  80f940:	ff 75 10             	push   0x10(%ebp)
  80f943:	ff 75 0c             	push   0xc(%ebp)
  80f946:	56                   	push   %esi
  80f947:	ff d0                	call   *%eax
  80f949:	83 c4 10             	add    $0x10,%esp
}
  80f94c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f94f:	5b                   	pop    %ebx
  80f950:	5e                   	pop    %esi
  80f951:	5d                   	pop    %ebp
  80f952:	c3                   	ret    
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80f953:	a1 30 b2 b3 00       	mov    0xb3b230,%eax
  80f958:	8b 40 48             	mov    0x48(%eax),%eax
  80f95b:	83 ec 04             	sub    $0x4,%esp
  80f95e:	53                   	push   %ebx
  80f95f:	50                   	push   %eax
  80f960:	68 35 36 81 00       	push   $0x813635
  80f965:	e8 47 ec ff ff       	call   80e5b1 <cprintf>
		return -E_INVAL;
  80f96a:	83 c4 10             	add    $0x10,%esp
  80f96d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f972:	eb d8                	jmp    80f94c <write+0x53>
		return -E_NOT_SUPP;
  80f974:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80f979:	eb d1                	jmp    80f94c <write+0x53>

0080f97b <seek>:

int
seek(int fdnum, off_t offset)
{
  80f97b:	55                   	push   %ebp
  80f97c:	89 e5                	mov    %esp,%ebp
  80f97e:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f981:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f984:	50                   	push   %eax
  80f985:	ff 75 08             	push   0x8(%ebp)
  80f988:	e8 35 fc ff ff       	call   80f5c2 <fd_lookup>
  80f98d:	83 c4 10             	add    $0x10,%esp
  80f990:	85 c0                	test   %eax,%eax
  80f992:	78 0e                	js     80f9a2 <seek+0x27>
		return r;
	fd->fd_offset = offset;
  80f994:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f997:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f99a:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80f99d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f9a2:	c9                   	leave  
  80f9a3:	c3                   	ret    

0080f9a4 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80f9a4:	55                   	push   %ebp
  80f9a5:	89 e5                	mov    %esp,%ebp
  80f9a7:	56                   	push   %esi
  80f9a8:	53                   	push   %ebx
  80f9a9:	83 ec 18             	sub    $0x18,%esp
  80f9ac:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f9af:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f9b2:	50                   	push   %eax
  80f9b3:	53                   	push   %ebx
  80f9b4:	e8 09 fc ff ff       	call   80f5c2 <fd_lookup>
  80f9b9:	83 c4 10             	add    $0x10,%esp
  80f9bc:	85 c0                	test   %eax,%eax
  80f9be:	78 34                	js     80f9f4 <ftruncate+0x50>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f9c0:	8b 75 f0             	mov    -0x10(%ebp),%esi
  80f9c3:	83 ec 08             	sub    $0x8,%esp
  80f9c6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f9c9:	50                   	push   %eax
  80f9ca:	ff 36                	push   (%esi)
  80f9cc:	e8 41 fc ff ff       	call   80f612 <dev_lookup>
  80f9d1:	83 c4 10             	add    $0x10,%esp
  80f9d4:	85 c0                	test   %eax,%eax
  80f9d6:	78 1c                	js     80f9f4 <ftruncate+0x50>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f9d8:	f6 46 08 03          	testb  $0x3,0x8(%esi)
  80f9dc:	74 1d                	je     80f9fb <ftruncate+0x57>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  80f9de:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f9e1:	8b 40 18             	mov    0x18(%eax),%eax
  80f9e4:	85 c0                	test   %eax,%eax
  80f9e6:	74 34                	je     80fa1c <ftruncate+0x78>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  80f9e8:	83 ec 08             	sub    $0x8,%esp
  80f9eb:	ff 75 0c             	push   0xc(%ebp)
  80f9ee:	56                   	push   %esi
  80f9ef:	ff d0                	call   *%eax
  80f9f1:	83 c4 10             	add    $0x10,%esp
}
  80f9f4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f9f7:	5b                   	pop    %ebx
  80f9f8:	5e                   	pop    %esi
  80f9f9:	5d                   	pop    %ebp
  80f9fa:	c3                   	ret    
			thisenv->env_id, fdnum);
  80f9fb:	a1 30 b2 b3 00       	mov    0xb3b230,%eax
  80fa00:	8b 40 48             	mov    0x48(%eax),%eax
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  80fa03:	83 ec 04             	sub    $0x4,%esp
  80fa06:	53                   	push   %ebx
  80fa07:	50                   	push   %eax
  80fa08:	68 f8 35 81 00       	push   $0x8135f8
  80fa0d:	e8 9f eb ff ff       	call   80e5b1 <cprintf>
		return -E_INVAL;
  80fa12:	83 c4 10             	add    $0x10,%esp
  80fa15:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fa1a:	eb d8                	jmp    80f9f4 <ftruncate+0x50>
		return -E_NOT_SUPP;
  80fa1c:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fa21:	eb d1                	jmp    80f9f4 <ftruncate+0x50>

0080fa23 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80fa23:	55                   	push   %ebp
  80fa24:	89 e5                	mov    %esp,%ebp
  80fa26:	56                   	push   %esi
  80fa27:	53                   	push   %ebx
  80fa28:	83 ec 18             	sub    $0x18,%esp
  80fa2b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fa2e:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fa31:	50                   	push   %eax
  80fa32:	ff 75 08             	push   0x8(%ebp)
  80fa35:	e8 88 fb ff ff       	call   80f5c2 <fd_lookup>
  80fa3a:	83 c4 10             	add    $0x10,%esp
  80fa3d:	85 c0                	test   %eax,%eax
  80fa3f:	78 49                	js     80fa8a <fstat+0x67>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fa41:	8b 75 f0             	mov    -0x10(%ebp),%esi
  80fa44:	83 ec 08             	sub    $0x8,%esp
  80fa47:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fa4a:	50                   	push   %eax
  80fa4b:	ff 36                	push   (%esi)
  80fa4d:	e8 c0 fb ff ff       	call   80f612 <dev_lookup>
  80fa52:	83 c4 10             	add    $0x10,%esp
  80fa55:	85 c0                	test   %eax,%eax
  80fa57:	78 31                	js     80fa8a <fstat+0x67>
		return r;
	if (!dev->dev_stat)
  80fa59:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fa5c:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  80fa60:	74 2f                	je     80fa91 <fstat+0x6e>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80fa62:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  80fa65:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80fa6c:	00 00 00 
	stat->st_isdir = 0;
  80fa6f:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80fa76:	00 00 00 
	stat->st_dev = dev;
  80fa79:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  80fa7f:	83 ec 08             	sub    $0x8,%esp
  80fa82:	53                   	push   %ebx
  80fa83:	56                   	push   %esi
  80fa84:	ff 50 14             	call   *0x14(%eax)
  80fa87:	83 c4 10             	add    $0x10,%esp
}
  80fa8a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fa8d:	5b                   	pop    %ebx
  80fa8e:	5e                   	pop    %esi
  80fa8f:	5d                   	pop    %ebp
  80fa90:	c3                   	ret    
		return -E_NOT_SUPP;
  80fa91:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fa96:	eb f2                	jmp    80fa8a <fstat+0x67>

0080fa98 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  80fa98:	55                   	push   %ebp
  80fa99:	89 e5                	mov    %esp,%ebp
  80fa9b:	56                   	push   %esi
  80fa9c:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80fa9d:	83 ec 08             	sub    $0x8,%esp
  80faa0:	6a 00                	push   $0x0
  80faa2:	ff 75 08             	push   0x8(%ebp)
  80faa5:	e8 e4 01 00 00       	call   80fc8e <open>
  80faaa:	89 c3                	mov    %eax,%ebx
  80faac:	83 c4 10             	add    $0x10,%esp
  80faaf:	85 c0                	test   %eax,%eax
  80fab1:	78 1b                	js     80face <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  80fab3:	83 ec 08             	sub    $0x8,%esp
  80fab6:	ff 75 0c             	push   0xc(%ebp)
  80fab9:	50                   	push   %eax
  80faba:	e8 64 ff ff ff       	call   80fa23 <fstat>
  80fabf:	89 c6                	mov    %eax,%esi
	close(fd);
  80fac1:	89 1c 24             	mov    %ebx,(%esp)
  80fac4:	e8 26 fc ff ff       	call   80f6ef <close>
	return r;
  80fac9:	83 c4 10             	add    $0x10,%esp
  80facc:	89 f3                	mov    %esi,%ebx
}
  80face:	89 d8                	mov    %ebx,%eax
  80fad0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fad3:	5b                   	pop    %ebx
  80fad4:	5e                   	pop    %esi
  80fad5:	5d                   	pop    %ebp
  80fad6:	c3                   	ret    

0080fad7 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80fad7:	55                   	push   %ebp
  80fad8:	89 e5                	mov    %esp,%ebp
  80fada:	56                   	push   %esi
  80fadb:	53                   	push   %ebx
  80fadc:	89 c6                	mov    %eax,%esi
  80fade:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  80fae0:	83 3d 00 d0 b3 00 00 	cmpl   $0x0,0xb3d000
  80fae7:	74 27                	je     80fb10 <fsipc+0x39>
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80fae9:	6a 07                	push   $0x7
  80faeb:	68 00 c0 b3 00       	push   $0xb3c000
  80faf0:	56                   	push   %esi
  80faf1:	ff 35 00 d0 b3 00    	push   0xb3d000
  80faf7:	e8 c2 f9 ff ff       	call   80f4be <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  80fafc:	83 c4 0c             	add    $0xc,%esp
  80faff:	6a 00                	push   $0x0
  80fb01:	53                   	push   %ebx
  80fb02:	6a 00                	push   $0x0
  80fb04:	e8 4e f9 ff ff       	call   80f457 <ipc_recv>
}
  80fb09:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fb0c:	5b                   	pop    %ebx
  80fb0d:	5e                   	pop    %esi
  80fb0e:	5d                   	pop    %ebp
  80fb0f:	c3                   	ret    
		fsenv = ipc_find_env(ENV_TYPE_FS);
  80fb10:	83 ec 0c             	sub    $0xc,%esp
  80fb13:	6a 01                	push   $0x1
  80fb15:	e8 f8 f9 ff ff       	call   80f512 <ipc_find_env>
  80fb1a:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
  80fb1f:	83 c4 10             	add    $0x10,%esp
  80fb22:	eb c5                	jmp    80fae9 <fsipc+0x12>

0080fb24 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  80fb24:	55                   	push   %ebp
  80fb25:	89 e5                	mov    %esp,%ebp
  80fb27:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80fb2a:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb2d:	8b 40 0c             	mov    0xc(%eax),%eax
  80fb30:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  80fb35:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fb38:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80fb3d:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb42:	b8 02 00 00 00       	mov    $0x2,%eax
  80fb47:	e8 8b ff ff ff       	call   80fad7 <fsipc>
}
  80fb4c:	c9                   	leave  
  80fb4d:	c3                   	ret    

0080fb4e <devfile_flush>:
{
  80fb4e:	55                   	push   %ebp
  80fb4f:	89 e5                	mov    %esp,%ebp
  80fb51:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  80fb54:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb57:	8b 40 0c             	mov    0xc(%eax),%eax
  80fb5a:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  80fb5f:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb64:	b8 06 00 00 00       	mov    $0x6,%eax
  80fb69:	e8 69 ff ff ff       	call   80fad7 <fsipc>
}
  80fb6e:	c9                   	leave  
  80fb6f:	c3                   	ret    

0080fb70 <devfile_stat>:
{
  80fb70:	55                   	push   %ebp
  80fb71:	89 e5                	mov    %esp,%ebp
  80fb73:	53                   	push   %ebx
  80fb74:	83 ec 04             	sub    $0x4,%esp
  80fb77:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  80fb7a:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb7d:	8b 40 0c             	mov    0xc(%eax),%eax
  80fb80:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  80fb85:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb8a:	b8 05 00 00 00       	mov    $0x5,%eax
  80fb8f:	e8 43 ff ff ff       	call   80fad7 <fsipc>
  80fb94:	85 c0                	test   %eax,%eax
  80fb96:	78 2c                	js     80fbc4 <devfile_stat+0x54>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  80fb98:	83 ec 08             	sub    $0x8,%esp
  80fb9b:	68 00 c0 b3 00       	push   $0xb3c000
  80fba0:	53                   	push   %ebx
  80fba1:	e8 e5 ef ff ff       	call   80eb8b <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  80fba6:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  80fbab:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  80fbb1:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  80fbb6:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  80fbbc:	83 c4 10             	add    $0x10,%esp
  80fbbf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fbc4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fbc7:	c9                   	leave  
  80fbc8:	c3                   	ret    

0080fbc9 <devfile_write>:
{
  80fbc9:	55                   	push   %ebp
  80fbca:	89 e5                	mov    %esp,%ebp
  80fbcc:	83 ec 0c             	sub    $0xc,%esp
  80fbcf:	8b 45 10             	mov    0x10(%ebp),%eax
  80fbd2:	ba f8 0f 00 00       	mov    $0xff8,%edx
  80fbd7:	39 d0                	cmp    %edx,%eax
  80fbd9:	0f 47 c2             	cmova  %edx,%eax
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  80fbdc:	8b 55 08             	mov    0x8(%ebp),%edx
  80fbdf:	8b 52 0c             	mov    0xc(%edx),%edx
  80fbe2:	89 15 00 c0 b3 00    	mov    %edx,0xb3c000
	fsipcbuf.write.req_n = n;
  80fbe8:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	memmove(fsipcbuf.write.req_buf, buf, n);
  80fbed:	50                   	push   %eax
  80fbee:	ff 75 0c             	push   0xc(%ebp)
  80fbf1:	68 08 c0 b3 00       	push   $0xb3c008
  80fbf6:	e8 26 f1 ff ff       	call   80ed21 <memmove>
	return  fsipc(FSREQ_WRITE, NULL);
  80fbfb:	ba 00 00 00 00       	mov    $0x0,%edx
  80fc00:	b8 04 00 00 00       	mov    $0x4,%eax
  80fc05:	e8 cd fe ff ff       	call   80fad7 <fsipc>
}
  80fc0a:	c9                   	leave  
  80fc0b:	c3                   	ret    

0080fc0c <devfile_read>:
{
  80fc0c:	55                   	push   %ebp
  80fc0d:	89 e5                	mov    %esp,%ebp
  80fc0f:	56                   	push   %esi
  80fc10:	53                   	push   %ebx
  80fc11:	8b 75 10             	mov    0x10(%ebp),%esi
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  80fc14:	8b 45 08             	mov    0x8(%ebp),%eax
  80fc17:	8b 40 0c             	mov    0xc(%eax),%eax
  80fc1a:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  80fc1f:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  80fc25:	ba 00 00 00 00       	mov    $0x0,%edx
  80fc2a:	b8 03 00 00 00       	mov    $0x3,%eax
  80fc2f:	e8 a3 fe ff ff       	call   80fad7 <fsipc>
  80fc34:	89 c3                	mov    %eax,%ebx
  80fc36:	85 c0                	test   %eax,%eax
  80fc38:	78 1f                	js     80fc59 <devfile_read+0x4d>
	assert(r <= n);
  80fc3a:	39 f0                	cmp    %esi,%eax
  80fc3c:	77 24                	ja     80fc62 <devfile_read+0x56>
	assert(r <= PGSIZE);
  80fc3e:	3d 00 10 00 00       	cmp    $0x1000,%eax
  80fc43:	7f 33                	jg     80fc78 <devfile_read+0x6c>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  80fc45:	83 ec 04             	sub    $0x4,%esp
  80fc48:	50                   	push   %eax
  80fc49:	68 00 c0 b3 00       	push   $0xb3c000
  80fc4e:	ff 75 0c             	push   0xc(%ebp)
  80fc51:	e8 cb f0 ff ff       	call   80ed21 <memmove>
	return r;
  80fc56:	83 c4 10             	add    $0x10,%esp
}
  80fc59:	89 d8                	mov    %ebx,%eax
  80fc5b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fc5e:	5b                   	pop    %ebx
  80fc5f:	5e                   	pop    %esi
  80fc60:	5d                   	pop    %ebp
  80fc61:	c3                   	ret    
	assert(r <= n);
  80fc62:	68 68 36 81 00       	push   $0x813668
  80fc67:	68 8b 23 81 00       	push   $0x81238b
  80fc6c:	6a 7c                	push   $0x7c
  80fc6e:	68 6f 36 81 00       	push   $0x81366f
  80fc73:	e8 5e e8 ff ff       	call   80e4d6 <_panic>
	assert(r <= PGSIZE);
  80fc78:	68 7a 36 81 00       	push   $0x81367a
  80fc7d:	68 8b 23 81 00       	push   $0x81238b
  80fc82:	6a 7d                	push   $0x7d
  80fc84:	68 6f 36 81 00       	push   $0x81366f
  80fc89:	e8 48 e8 ff ff       	call   80e4d6 <_panic>

0080fc8e <open>:
{
  80fc8e:	55                   	push   %ebp
  80fc8f:	89 e5                	mov    %esp,%ebp
  80fc91:	56                   	push   %esi
  80fc92:	53                   	push   %ebx
  80fc93:	83 ec 1c             	sub    $0x1c,%esp
  80fc96:	8b 75 08             	mov    0x8(%ebp),%esi
	if (strlen(path) >= MAXPATHLEN)
  80fc99:	56                   	push   %esi
  80fc9a:	e8 b1 ee ff ff       	call   80eb50 <strlen>
  80fc9f:	83 c4 10             	add    $0x10,%esp
  80fca2:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  80fca7:	7f 6c                	jg     80fd15 <open+0x87>
	if ((r = fd_alloc(&fd)) < 0)
  80fca9:	83 ec 0c             	sub    $0xc,%esp
  80fcac:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fcaf:	50                   	push   %eax
  80fcb0:	e8 bd f8 ff ff       	call   80f572 <fd_alloc>
  80fcb5:	89 c3                	mov    %eax,%ebx
  80fcb7:	83 c4 10             	add    $0x10,%esp
  80fcba:	85 c0                	test   %eax,%eax
  80fcbc:	78 3c                	js     80fcfa <open+0x6c>
	strcpy(fsipcbuf.open.req_path, path);
  80fcbe:	83 ec 08             	sub    $0x8,%esp
  80fcc1:	56                   	push   %esi
  80fcc2:	68 00 c0 b3 00       	push   $0xb3c000
  80fcc7:	e8 bf ee ff ff       	call   80eb8b <strcpy>
	fsipcbuf.open.req_omode = mode;
  80fccc:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fccf:	a3 00 c4 b3 00       	mov    %eax,0xb3c400
	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  80fcd4:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fcd7:	b8 01 00 00 00       	mov    $0x1,%eax
  80fcdc:	e8 f6 fd ff ff       	call   80fad7 <fsipc>
  80fce1:	89 c3                	mov    %eax,%ebx
  80fce3:	83 c4 10             	add    $0x10,%esp
  80fce6:	85 c0                	test   %eax,%eax
  80fce8:	78 19                	js     80fd03 <open+0x75>
	return fd2num(fd);
  80fcea:	83 ec 0c             	sub    $0xc,%esp
  80fced:	ff 75 f4             	push   -0xc(%ebp)
  80fcf0:	e8 56 f8 ff ff       	call   80f54b <fd2num>
  80fcf5:	89 c3                	mov    %eax,%ebx
  80fcf7:	83 c4 10             	add    $0x10,%esp
}
  80fcfa:	89 d8                	mov    %ebx,%eax
  80fcfc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fcff:	5b                   	pop    %ebx
  80fd00:	5e                   	pop    %esi
  80fd01:	5d                   	pop    %ebp
  80fd02:	c3                   	ret    
		fd_close(fd, 0);
  80fd03:	83 ec 08             	sub    $0x8,%esp
  80fd06:	6a 00                	push   $0x0
  80fd08:	ff 75 f4             	push   -0xc(%ebp)
  80fd0b:	e8 58 f9 ff ff       	call   80f668 <fd_close>
		return r;
  80fd10:	83 c4 10             	add    $0x10,%esp
  80fd13:	eb e5                	jmp    80fcfa <open+0x6c>
		return -E_BAD_PATH;
  80fd15:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  80fd1a:	eb de                	jmp    80fcfa <open+0x6c>

0080fd1c <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  80fd1c:	55                   	push   %ebp
  80fd1d:	89 e5                	mov    %esp,%ebp
  80fd1f:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  80fd22:	ba 00 00 00 00       	mov    $0x0,%edx
  80fd27:	b8 08 00 00 00       	mov    $0x8,%eax
  80fd2c:	e8 a6 fd ff ff       	call   80fad7 <fsipc>
}
  80fd31:	c9                   	leave  
  80fd32:	c3                   	ret    

0080fd33 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  80fd33:	55                   	push   %ebp
  80fd34:	89 e5                	mov    %esp,%ebp
  80fd36:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  80fd39:	68 86 36 81 00       	push   $0x813686
  80fd3e:	ff 75 0c             	push   0xc(%ebp)
  80fd41:	e8 45 ee ff ff       	call   80eb8b <strcpy>
	return 0;
}
  80fd46:	b8 00 00 00 00       	mov    $0x0,%eax
  80fd4b:	c9                   	leave  
  80fd4c:	c3                   	ret    

0080fd4d <devsock_close>:
{
  80fd4d:	55                   	push   %ebp
  80fd4e:	89 e5                	mov    %esp,%ebp
  80fd50:	53                   	push   %ebx
  80fd51:	83 ec 10             	sub    $0x10,%esp
  80fd54:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  80fd57:	53                   	push   %ebx
  80fd58:	e8 24 0c 00 00       	call   810981 <pageref>
  80fd5d:	89 c2                	mov    %eax,%edx
  80fd5f:	83 c4 10             	add    $0x10,%esp
		return 0;
  80fd62:	b8 00 00 00 00       	mov    $0x0,%eax
	if (pageref(fd) == 1)
  80fd67:	83 fa 01             	cmp    $0x1,%edx
  80fd6a:	74 05                	je     80fd71 <devsock_close+0x24>
}
  80fd6c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fd6f:	c9                   	leave  
  80fd70:	c3                   	ret    
		return nsipc_close(fd->fd_sock.sockid);
  80fd71:	83 ec 0c             	sub    $0xc,%esp
  80fd74:	ff 73 0c             	push   0xc(%ebx)
  80fd77:	e8 b7 02 00 00       	call   810033 <nsipc_close>
  80fd7c:	83 c4 10             	add    $0x10,%esp
  80fd7f:	eb eb                	jmp    80fd6c <devsock_close+0x1f>

0080fd81 <devsock_write>:
{
  80fd81:	55                   	push   %ebp
  80fd82:	89 e5                	mov    %esp,%ebp
  80fd84:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  80fd87:	6a 00                	push   $0x0
  80fd89:	ff 75 10             	push   0x10(%ebp)
  80fd8c:	ff 75 0c             	push   0xc(%ebp)
  80fd8f:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd92:	ff 70 0c             	push   0xc(%eax)
  80fd95:	e8 79 03 00 00       	call   810113 <nsipc_send>
}
  80fd9a:	c9                   	leave  
  80fd9b:	c3                   	ret    

0080fd9c <devsock_read>:
{
  80fd9c:	55                   	push   %ebp
  80fd9d:	89 e5                	mov    %esp,%ebp
  80fd9f:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  80fda2:	6a 00                	push   $0x0
  80fda4:	ff 75 10             	push   0x10(%ebp)
  80fda7:	ff 75 0c             	push   0xc(%ebp)
  80fdaa:	8b 45 08             	mov    0x8(%ebp),%eax
  80fdad:	ff 70 0c             	push   0xc(%eax)
  80fdb0:	e8 ef 02 00 00       	call   8100a4 <nsipc_recv>
}
  80fdb5:	c9                   	leave  
  80fdb6:	c3                   	ret    

0080fdb7 <fd2sockid>:
{
  80fdb7:	55                   	push   %ebp
  80fdb8:	89 e5                	mov    %esp,%ebp
  80fdba:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fd, &sfd)) < 0)
  80fdbd:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80fdc0:	52                   	push   %edx
  80fdc1:	50                   	push   %eax
  80fdc2:	e8 fb f7 ff ff       	call   80f5c2 <fd_lookup>
  80fdc7:	83 c4 10             	add    $0x10,%esp
  80fdca:	85 c0                	test   %eax,%eax
  80fdcc:	78 10                	js     80fdde <fd2sockid+0x27>
	if (sfd->fd_dev_id != devsock.dev_id)
  80fdce:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fdd1:	8b 0d 08 43 81 00    	mov    0x814308,%ecx
  80fdd7:	39 08                	cmp    %ecx,(%eax)
  80fdd9:	75 05                	jne    80fde0 <fd2sockid+0x29>
	return sfd->fd_sock.sockid;
  80fddb:	8b 40 0c             	mov    0xc(%eax),%eax
}
  80fdde:	c9                   	leave  
  80fddf:	c3                   	ret    
		return -E_NOT_SUPP;
  80fde0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fde5:	eb f7                	jmp    80fdde <fd2sockid+0x27>

0080fde7 <alloc_sockfd>:
{
  80fde7:	55                   	push   %ebp
  80fde8:	89 e5                	mov    %esp,%ebp
  80fdea:	56                   	push   %esi
  80fdeb:	53                   	push   %ebx
  80fdec:	83 ec 1c             	sub    $0x1c,%esp
  80fdef:	89 c6                	mov    %eax,%esi
	if ((r = fd_alloc(&sfd)) < 0
  80fdf1:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fdf4:	50                   	push   %eax
  80fdf5:	e8 78 f7 ff ff       	call   80f572 <fd_alloc>
  80fdfa:	89 c3                	mov    %eax,%ebx
  80fdfc:	83 c4 10             	add    $0x10,%esp
  80fdff:	85 c0                	test   %eax,%eax
  80fe01:	78 43                	js     80fe46 <alloc_sockfd+0x5f>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  80fe03:	83 ec 04             	sub    $0x4,%esp
  80fe06:	68 07 04 00 00       	push   $0x407
  80fe0b:	ff 75 f4             	push   -0xc(%ebp)
  80fe0e:	6a 00                	push   $0x0
  80fe10:	e8 72 f1 ff ff       	call   80ef87 <sys_page_alloc>
  80fe15:	89 c3                	mov    %eax,%ebx
  80fe17:	83 c4 10             	add    $0x10,%esp
  80fe1a:	85 c0                	test   %eax,%eax
  80fe1c:	78 28                	js     80fe46 <alloc_sockfd+0x5f>
	sfd->fd_dev_id = devsock.dev_id;
  80fe1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fe21:	8b 15 08 43 81 00    	mov    0x814308,%edx
  80fe27:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  80fe29:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fe2c:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  80fe33:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  80fe36:	83 ec 0c             	sub    $0xc,%esp
  80fe39:	50                   	push   %eax
  80fe3a:	e8 0c f7 ff ff       	call   80f54b <fd2num>
  80fe3f:	89 c3                	mov    %eax,%ebx
  80fe41:	83 c4 10             	add    $0x10,%esp
  80fe44:	eb 0c                	jmp    80fe52 <alloc_sockfd+0x6b>
		nsipc_close(sockid);
  80fe46:	83 ec 0c             	sub    $0xc,%esp
  80fe49:	56                   	push   %esi
  80fe4a:	e8 e4 01 00 00       	call   810033 <nsipc_close>
		return r;
  80fe4f:	83 c4 10             	add    $0x10,%esp
}
  80fe52:	89 d8                	mov    %ebx,%eax
  80fe54:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fe57:	5b                   	pop    %ebx
  80fe58:	5e                   	pop    %esi
  80fe59:	5d                   	pop    %ebp
  80fe5a:	c3                   	ret    

0080fe5b <accept>:
{
  80fe5b:	55                   	push   %ebp
  80fe5c:	89 e5                	mov    %esp,%ebp
  80fe5e:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  80fe61:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe64:	e8 4e ff ff ff       	call   80fdb7 <fd2sockid>
  80fe69:	85 c0                	test   %eax,%eax
  80fe6b:	78 1b                	js     80fe88 <accept+0x2d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80fe6d:	83 ec 04             	sub    $0x4,%esp
  80fe70:	ff 75 10             	push   0x10(%ebp)
  80fe73:	ff 75 0c             	push   0xc(%ebp)
  80fe76:	50                   	push   %eax
  80fe77:	e8 0e 01 00 00       	call   80ff8a <nsipc_accept>
  80fe7c:	83 c4 10             	add    $0x10,%esp
  80fe7f:	85 c0                	test   %eax,%eax
  80fe81:	78 05                	js     80fe88 <accept+0x2d>
	return alloc_sockfd(r);
  80fe83:	e8 5f ff ff ff       	call   80fde7 <alloc_sockfd>
}
  80fe88:	c9                   	leave  
  80fe89:	c3                   	ret    

0080fe8a <bind>:
{
  80fe8a:	55                   	push   %ebp
  80fe8b:	89 e5                	mov    %esp,%ebp
  80fe8d:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  80fe90:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe93:	e8 1f ff ff ff       	call   80fdb7 <fd2sockid>
  80fe98:	85 c0                	test   %eax,%eax
  80fe9a:	78 12                	js     80feae <bind+0x24>
	return nsipc_bind(r, name, namelen);
  80fe9c:	83 ec 04             	sub    $0x4,%esp
  80fe9f:	ff 75 10             	push   0x10(%ebp)
  80fea2:	ff 75 0c             	push   0xc(%ebp)
  80fea5:	50                   	push   %eax
  80fea6:	e8 31 01 00 00       	call   80ffdc <nsipc_bind>
  80feab:	83 c4 10             	add    $0x10,%esp
}
  80feae:	c9                   	leave  
  80feaf:	c3                   	ret    

0080feb0 <shutdown>:
{
  80feb0:	55                   	push   %ebp
  80feb1:	89 e5                	mov    %esp,%ebp
  80feb3:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  80feb6:	8b 45 08             	mov    0x8(%ebp),%eax
  80feb9:	e8 f9 fe ff ff       	call   80fdb7 <fd2sockid>
  80febe:	85 c0                	test   %eax,%eax
  80fec0:	78 0f                	js     80fed1 <shutdown+0x21>
	return nsipc_shutdown(r, how);
  80fec2:	83 ec 08             	sub    $0x8,%esp
  80fec5:	ff 75 0c             	push   0xc(%ebp)
  80fec8:	50                   	push   %eax
  80fec9:	e8 43 01 00 00       	call   810011 <nsipc_shutdown>
  80fece:	83 c4 10             	add    $0x10,%esp
}
  80fed1:	c9                   	leave  
  80fed2:	c3                   	ret    

0080fed3 <connect>:
{
  80fed3:	55                   	push   %ebp
  80fed4:	89 e5                	mov    %esp,%ebp
  80fed6:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  80fed9:	8b 45 08             	mov    0x8(%ebp),%eax
  80fedc:	e8 d6 fe ff ff       	call   80fdb7 <fd2sockid>
  80fee1:	85 c0                	test   %eax,%eax
  80fee3:	78 12                	js     80fef7 <connect+0x24>
	return nsipc_connect(r, name, namelen);
  80fee5:	83 ec 04             	sub    $0x4,%esp
  80fee8:	ff 75 10             	push   0x10(%ebp)
  80feeb:	ff 75 0c             	push   0xc(%ebp)
  80feee:	50                   	push   %eax
  80feef:	e8 59 01 00 00       	call   81004d <nsipc_connect>
  80fef4:	83 c4 10             	add    $0x10,%esp
}
  80fef7:	c9                   	leave  
  80fef8:	c3                   	ret    

0080fef9 <listen>:
{
  80fef9:	55                   	push   %ebp
  80fefa:	89 e5                	mov    %esp,%ebp
  80fefc:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  80feff:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff02:	e8 b0 fe ff ff       	call   80fdb7 <fd2sockid>
  80ff07:	85 c0                	test   %eax,%eax
  80ff09:	78 0f                	js     80ff1a <listen+0x21>
	return nsipc_listen(r, backlog);
  80ff0b:	83 ec 08             	sub    $0x8,%esp
  80ff0e:	ff 75 0c             	push   0xc(%ebp)
  80ff11:	50                   	push   %eax
  80ff12:	e8 6b 01 00 00       	call   810082 <nsipc_listen>
  80ff17:	83 c4 10             	add    $0x10,%esp
}
  80ff1a:	c9                   	leave  
  80ff1b:	c3                   	ret    

0080ff1c <socket>:

int
socket(int domain, int type, int protocol)
{
  80ff1c:	55                   	push   %ebp
  80ff1d:	89 e5                	mov    %esp,%ebp
  80ff1f:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  80ff22:	ff 75 10             	push   0x10(%ebp)
  80ff25:	ff 75 0c             	push   0xc(%ebp)
  80ff28:	ff 75 08             	push   0x8(%ebp)
  80ff2b:	e8 41 02 00 00       	call   810171 <nsipc_socket>
  80ff30:	83 c4 10             	add    $0x10,%esp
  80ff33:	85 c0                	test   %eax,%eax
  80ff35:	78 05                	js     80ff3c <socket+0x20>
		return r;
	return alloc_sockfd(r);
  80ff37:	e8 ab fe ff ff       	call   80fde7 <alloc_sockfd>
}
  80ff3c:	c9                   	leave  
  80ff3d:	c3                   	ret    

0080ff3e <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  80ff3e:	55                   	push   %ebp
  80ff3f:	89 e5                	mov    %esp,%ebp
  80ff41:	53                   	push   %ebx
  80ff42:	83 ec 04             	sub    $0x4,%esp
  80ff45:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  80ff47:	83 3d 00 f0 b3 00 00 	cmpl   $0x0,0xb3f000
  80ff4e:	74 26                	je     80ff76 <nsipc+0x38>
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  80ff50:	6a 07                	push   $0x7
  80ff52:	68 00 e0 b3 00       	push   $0xb3e000
  80ff57:	53                   	push   %ebx
  80ff58:	ff 35 00 f0 b3 00    	push   0xb3f000
  80ff5e:	e8 5b f5 ff ff       	call   80f4be <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  80ff63:	83 c4 0c             	add    $0xc,%esp
  80ff66:	6a 00                	push   $0x0
  80ff68:	6a 00                	push   $0x0
  80ff6a:	6a 00                	push   $0x0
  80ff6c:	e8 e6 f4 ff ff       	call   80f457 <ipc_recv>
}
  80ff71:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ff74:	c9                   	leave  
  80ff75:	c3                   	ret    
		nsenv = ipc_find_env(ENV_TYPE_NS);
  80ff76:	83 ec 0c             	sub    $0xc,%esp
  80ff79:	6a 02                	push   $0x2
  80ff7b:	e8 92 f5 ff ff       	call   80f512 <ipc_find_env>
  80ff80:	a3 00 f0 b3 00       	mov    %eax,0xb3f000
  80ff85:	83 c4 10             	add    $0x10,%esp
  80ff88:	eb c6                	jmp    80ff50 <nsipc+0x12>

0080ff8a <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80ff8a:	55                   	push   %ebp
  80ff8b:	89 e5                	mov    %esp,%ebp
  80ff8d:	56                   	push   %esi
  80ff8e:	53                   	push   %ebx
  80ff8f:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  80ff92:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff95:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.accept.req_addrlen = *addrlen;
  80ff9a:	8b 06                	mov    (%esi),%eax
  80ff9c:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  80ffa1:	b8 01 00 00 00       	mov    $0x1,%eax
  80ffa6:	e8 93 ff ff ff       	call   80ff3e <nsipc>
  80ffab:	89 c3                	mov    %eax,%ebx
  80ffad:	85 c0                	test   %eax,%eax
  80ffaf:	79 09                	jns    80ffba <nsipc_accept+0x30>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
		*addrlen = ret->ret_addrlen;
	}
	return r;
}
  80ffb1:	89 d8                	mov    %ebx,%eax
  80ffb3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ffb6:	5b                   	pop    %ebx
  80ffb7:	5e                   	pop    %esi
  80ffb8:	5d                   	pop    %ebp
  80ffb9:	c3                   	ret    
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  80ffba:	83 ec 04             	sub    $0x4,%esp
  80ffbd:	ff 35 10 e0 b3 00    	push   0xb3e010
  80ffc3:	68 00 e0 b3 00       	push   $0xb3e000
  80ffc8:	ff 75 0c             	push   0xc(%ebp)
  80ffcb:	e8 51 ed ff ff       	call   80ed21 <memmove>
		*addrlen = ret->ret_addrlen;
  80ffd0:	a1 10 e0 b3 00       	mov    0xb3e010,%eax
  80ffd5:	89 06                	mov    %eax,(%esi)
  80ffd7:	83 c4 10             	add    $0x10,%esp
	return r;
  80ffda:	eb d5                	jmp    80ffb1 <nsipc_accept+0x27>

0080ffdc <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80ffdc:	55                   	push   %ebp
  80ffdd:	89 e5                	mov    %esp,%ebp
  80ffdf:	53                   	push   %ebx
  80ffe0:	83 ec 08             	sub    $0x8,%esp
  80ffe3:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  80ffe6:	8b 45 08             	mov    0x8(%ebp),%eax
  80ffe9:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  80ffee:	53                   	push   %ebx
  80ffef:	ff 75 0c             	push   0xc(%ebp)
  80fff2:	68 04 e0 b3 00       	push   $0xb3e004
  80fff7:	e8 25 ed ff ff       	call   80ed21 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  80fffc:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_BIND);
  810002:	b8 02 00 00 00       	mov    $0x2,%eax
  810007:	e8 32 ff ff ff       	call   80ff3e <nsipc>
}
  81000c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81000f:	c9                   	leave  
  810010:	c3                   	ret    

00810011 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  810011:	55                   	push   %ebp
  810012:	89 e5                	mov    %esp,%ebp
  810014:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  810017:	8b 45 08             	mov    0x8(%ebp),%eax
  81001a:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.shutdown.req_how = how;
  81001f:	8b 45 0c             	mov    0xc(%ebp),%eax
  810022:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_SHUTDOWN);
  810027:	b8 03 00 00 00       	mov    $0x3,%eax
  81002c:	e8 0d ff ff ff       	call   80ff3e <nsipc>
}
  810031:	c9                   	leave  
  810032:	c3                   	ret    

00810033 <nsipc_close>:

int
nsipc_close(int s)
{
  810033:	55                   	push   %ebp
  810034:	89 e5                	mov    %esp,%ebp
  810036:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  810039:	8b 45 08             	mov    0x8(%ebp),%eax
  81003c:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	return nsipc(NSREQ_CLOSE);
  810041:	b8 04 00 00 00       	mov    $0x4,%eax
  810046:	e8 f3 fe ff ff       	call   80ff3e <nsipc>
}
  81004b:	c9                   	leave  
  81004c:	c3                   	ret    

0081004d <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  81004d:	55                   	push   %ebp
  81004e:	89 e5                	mov    %esp,%ebp
  810050:	53                   	push   %ebx
  810051:	83 ec 08             	sub    $0x8,%esp
  810054:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  810057:	8b 45 08             	mov    0x8(%ebp),%eax
  81005a:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  81005f:	53                   	push   %ebx
  810060:	ff 75 0c             	push   0xc(%ebp)
  810063:	68 04 e0 b3 00       	push   $0xb3e004
  810068:	e8 b4 ec ff ff       	call   80ed21 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  81006d:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_CONNECT);
  810073:	b8 05 00 00 00       	mov    $0x5,%eax
  810078:	e8 c1 fe ff ff       	call   80ff3e <nsipc>
}
  81007d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810080:	c9                   	leave  
  810081:	c3                   	ret    

00810082 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  810082:	55                   	push   %ebp
  810083:	89 e5                	mov    %esp,%ebp
  810085:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  810088:	8b 45 08             	mov    0x8(%ebp),%eax
  81008b:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.listen.req_backlog = backlog;
  810090:	8b 45 0c             	mov    0xc(%ebp),%eax
  810093:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_LISTEN);
  810098:	b8 06 00 00 00       	mov    $0x6,%eax
  81009d:	e8 9c fe ff ff       	call   80ff3e <nsipc>
}
  8100a2:	c9                   	leave  
  8100a3:	c3                   	ret    

008100a4 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  8100a4:	55                   	push   %ebp
  8100a5:	89 e5                	mov    %esp,%ebp
  8100a7:	56                   	push   %esi
  8100a8:	53                   	push   %ebx
  8100a9:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  8100ac:	8b 45 08             	mov    0x8(%ebp),%eax
  8100af:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.recv.req_len = len;
  8100b4:	89 35 04 e0 b3 00    	mov    %esi,0xb3e004
	nsipcbuf.recv.req_flags = flags;
  8100ba:	8b 45 14             	mov    0x14(%ebp),%eax
  8100bd:	a3 08 e0 b3 00       	mov    %eax,0xb3e008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  8100c2:	b8 07 00 00 00       	mov    $0x7,%eax
  8100c7:	e8 72 fe ff ff       	call   80ff3e <nsipc>
  8100cc:	89 c3                	mov    %eax,%ebx
  8100ce:	85 c0                	test   %eax,%eax
  8100d0:	78 22                	js     8100f4 <nsipc_recv+0x50>
		assert(r < 1600 && r <= len);
  8100d2:	b8 3f 06 00 00       	mov    $0x63f,%eax
  8100d7:	39 c6                	cmp    %eax,%esi
  8100d9:	0f 4e c6             	cmovle %esi,%eax
  8100dc:	39 c3                	cmp    %eax,%ebx
  8100de:	7f 1d                	jg     8100fd <nsipc_recv+0x59>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  8100e0:	83 ec 04             	sub    $0x4,%esp
  8100e3:	53                   	push   %ebx
  8100e4:	68 00 e0 b3 00       	push   $0xb3e000
  8100e9:	ff 75 0c             	push   0xc(%ebp)
  8100ec:	e8 30 ec ff ff       	call   80ed21 <memmove>
  8100f1:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  8100f4:	89 d8                	mov    %ebx,%eax
  8100f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8100f9:	5b                   	pop    %ebx
  8100fa:	5e                   	pop    %esi
  8100fb:	5d                   	pop    %ebp
  8100fc:	c3                   	ret    
		assert(r < 1600 && r <= len);
  8100fd:	68 92 36 81 00       	push   $0x813692
  810102:	68 8b 23 81 00       	push   $0x81238b
  810107:	6a 62                	push   $0x62
  810109:	68 a7 36 81 00       	push   $0x8136a7
  81010e:	e8 c3 e3 ff ff       	call   80e4d6 <_panic>

00810113 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  810113:	55                   	push   %ebp
  810114:	89 e5                	mov    %esp,%ebp
  810116:	53                   	push   %ebx
  810117:	83 ec 04             	sub    $0x4,%esp
  81011a:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  81011d:	8b 45 08             	mov    0x8(%ebp),%eax
  810120:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	assert(size < 1600);
  810125:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  81012b:	7f 2e                	jg     81015b <nsipc_send+0x48>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  81012d:	83 ec 04             	sub    $0x4,%esp
  810130:	53                   	push   %ebx
  810131:	ff 75 0c             	push   0xc(%ebp)
  810134:	68 0c e0 b3 00       	push   $0xb3e00c
  810139:	e8 e3 eb ff ff       	call   80ed21 <memmove>
	nsipcbuf.send.req_size = size;
  81013e:	89 1d 04 e0 b3 00    	mov    %ebx,0xb3e004
	nsipcbuf.send.req_flags = flags;
  810144:	8b 45 14             	mov    0x14(%ebp),%eax
  810147:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SEND);
  81014c:	b8 08 00 00 00       	mov    $0x8,%eax
  810151:	e8 e8 fd ff ff       	call   80ff3e <nsipc>
}
  810156:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810159:	c9                   	leave  
  81015a:	c3                   	ret    
	assert(size < 1600);
  81015b:	68 b3 36 81 00       	push   $0x8136b3
  810160:	68 8b 23 81 00       	push   $0x81238b
  810165:	6a 6d                	push   $0x6d
  810167:	68 a7 36 81 00       	push   $0x8136a7
  81016c:	e8 65 e3 ff ff       	call   80e4d6 <_panic>

00810171 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  810171:	55                   	push   %ebp
  810172:	89 e5                	mov    %esp,%ebp
  810174:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  810177:	8b 45 08             	mov    0x8(%ebp),%eax
  81017a:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.socket.req_type = type;
  81017f:	8b 45 0c             	mov    0xc(%ebp),%eax
  810182:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	nsipcbuf.socket.req_protocol = protocol;
  810187:	8b 45 10             	mov    0x10(%ebp),%eax
  81018a:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SOCKET);
  81018f:	b8 09 00 00 00       	mov    $0x9,%eax
  810194:	e8 a5 fd ff ff       	call   80ff3e <nsipc>
}
  810199:	c9                   	leave  
  81019a:	c3                   	ret    

0081019b <free>:
	return v;
}

void
free(void *v)
{
  81019b:	55                   	push   %ebp
  81019c:	89 e5                	mov    %esp,%ebp
  81019e:	53                   	push   %ebx
  81019f:	83 ec 04             	sub    $0x4,%esp
  8101a2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  8101a5:	85 db                	test   %ebx,%ebx
  8101a7:	0f 84 85 00 00 00    	je     810232 <free+0x97>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8101ad:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  8101b3:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8101b8:	77 51                	ja     81020b <free+0x70>

	c = ROUNDDOWN(v, PGSIZE);
  8101ba:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8101c0:	89 d8                	mov    %ebx,%eax
  8101c2:	c1 e8 0c             	shr    $0xc,%eax
  8101c5:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  8101cc:	f6 c4 02             	test   $0x2,%ah
  8101cf:	74 50                	je     810221 <free+0x86>
		sys_page_unmap(0, c);
  8101d1:	83 ec 08             	sub    $0x8,%esp
  8101d4:	53                   	push   %ebx
  8101d5:	6a 00                	push   $0x0
  8101d7:	e8 30 ee ff ff       	call   80f00c <sys_page_unmap>
		c += PGSIZE;
  8101dc:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  8101e2:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  8101e8:	83 c4 10             	add    $0x10,%esp
  8101eb:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8101f0:	76 ce                	jbe    8101c0 <free+0x25>
  8101f2:	68 fb 36 81 00       	push   $0x8136fb
  8101f7:	68 8b 23 81 00       	push   $0x81238b
  8101fc:	68 81 00 00 00       	push   $0x81
  810201:	68 ee 36 81 00       	push   $0x8136ee
  810206:	e8 cb e2 ff ff       	call   80e4d6 <_panic>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  81020b:	68 c0 36 81 00       	push   $0x8136c0
  810210:	68 8b 23 81 00       	push   $0x81238b
  810215:	6a 7a                	push   $0x7a
  810217:	68 ee 36 81 00       	push   $0x8136ee
  81021c:	e8 b5 e2 ff ff       	call   80e4d6 <_panic>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  810221:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  810227:	83 e8 01             	sub    $0x1,%eax
  81022a:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  810230:	74 05                	je     810237 <free+0x9c>
		sys_page_unmap(0, c);
}
  810232:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810235:	c9                   	leave  
  810236:	c3                   	ret    
		sys_page_unmap(0, c);
  810237:	83 ec 08             	sub    $0x8,%esp
  81023a:	53                   	push   %ebx
  81023b:	6a 00                	push   $0x0
  81023d:	e8 ca ed ff ff       	call   80f00c <sys_page_unmap>
  810242:	83 c4 10             	add    $0x10,%esp
  810245:	eb eb                	jmp    810232 <free+0x97>

00810247 <malloc>:
{
  810247:	55                   	push   %ebp
  810248:	89 e5                	mov    %esp,%ebp
  81024a:	57                   	push   %edi
  81024b:	56                   	push   %esi
  81024c:	53                   	push   %ebx
  81024d:	83 ec 1c             	sub    $0x1c,%esp
	if (mptr == 0)
  810250:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
  810255:	85 c0                	test   %eax,%eax
  810257:	74 72                	je     8102cb <malloc+0x84>
	n = ROUNDUP(n, 4);
  810259:	8b 75 08             	mov    0x8(%ebp),%esi
  81025c:	8d 56 03             	lea    0x3(%esi),%edx
  81025f:	83 e2 fc             	and    $0xfffffffc,%edx
  810262:	89 d7                	mov    %edx,%edi
  810264:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (n >= MAXMALLOC)
  810267:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  81026d:	0f 87 3f 01 00 00    	ja     8103b2 <malloc+0x16b>
	if ((uintptr_t) mptr % PGSIZE){
  810273:	a9 ff 0f 00 00       	test   $0xfff,%eax
  810278:	74 30                	je     8102aa <malloc+0x63>
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  81027a:	89 c3                	mov    %eax,%ebx
  81027c:	c1 eb 0c             	shr    $0xc,%ebx
  81027f:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  810283:	c1 ea 0c             	shr    $0xc,%edx
  810286:	39 d3                	cmp    %edx,%ebx
  810288:	74 64                	je     8102ee <malloc+0xa7>
		free(mptr);	/* drop reference to this page */
  81028a:	83 ec 0c             	sub    $0xc,%esp
  81028d:	50                   	push   %eax
  81028e:	e8 08 ff ff ff       	call   81019b <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810293:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
  810298:	05 00 10 00 00       	add    $0x1000,%eax
  81029d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  8102a2:	a3 04 f0 b3 00       	mov    %eax,0xb3f004
  8102a7:	83 c4 10             	add    $0x10,%esp
  8102aa:	8b 0d 04 f0 b3 00    	mov    0xb3f004,%ecx
{
  8102b0:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
  8102b7:	be 00 00 00 00       	mov    $0x0,%esi
  8102bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8102bf:	8d 78 04             	lea    0x4(%eax),%edi
  8102c2:	89 cb                	mov    %ecx,%ebx
  8102c4:	01 f9                	add    %edi,%ecx
  8102c6:	e9 91 00 00 00       	jmp    81035c <malloc+0x115>
		mptr = mbegin;
  8102cb:	c7 05 04 f0 b3 00 00 	movl   $0x8000000,0xb3f004
  8102d2:	00 00 08 
	n = ROUNDUP(n, 4);
  8102d5:	8b 75 08             	mov    0x8(%ebp),%esi
  8102d8:	8d 56 03             	lea    0x3(%esi),%edx
  8102db:	83 e2 fc             	and    $0xfffffffc,%edx
  8102de:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (n >= MAXMALLOC)
  8102e1:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  8102e7:	76 c1                	jbe    8102aa <malloc+0x63>
  8102e9:	e9 31 01 00 00       	jmp    81041f <malloc+0x1d8>
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  8102ee:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
  8102f4:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
			(*ref)++;
  8102fa:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			mptr += n;
  8102fe:	89 fa                	mov    %edi,%edx
  810300:	01 c2                	add    %eax,%edx
  810302:	89 15 04 f0 b3 00    	mov    %edx,0xb3f004
			return v;
  810308:	e9 12 01 00 00       	jmp    81041f <malloc+0x1d8>
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81030d:	05 00 10 00 00       	add    $0x1000,%eax
  810312:	39 c8                	cmp    %ecx,%eax
  810314:	0f 83 9f 00 00 00    	jae    8103b9 <malloc+0x172>
		if (va >= (uintptr_t) mend
  81031a:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  81031f:	77 22                	ja     810343 <malloc+0xfc>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  810321:	89 c2                	mov    %eax,%edx
  810323:	c1 ea 16             	shr    $0x16,%edx
  810326:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  81032d:	f6 c2 01             	test   $0x1,%dl
  810330:	74 db                	je     81030d <malloc+0xc6>
  810332:	89 c2                	mov    %eax,%edx
  810334:	c1 ea 0c             	shr    $0xc,%edx
  810337:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  81033e:	f6 c2 01             	test   $0x1,%dl
  810341:	74 ca                	je     81030d <malloc+0xc6>
		if (mptr == mend) {
  810343:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  810349:	81 c1 00 10 00 00    	add    $0x1000,%ecx
  81034f:	be 01 00 00 00       	mov    $0x1,%esi
  810354:	81 fb 00 00 00 10    	cmp    $0x10000000,%ebx
  81035a:	74 07                	je     810363 <malloc+0x11c>
  81035c:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81035f:	89 d8                	mov    %ebx,%eax
  810361:	eb af                	jmp    810312 <malloc+0xcb>
			mptr = mbegin;
  810363:	b9 00 00 00 08       	mov    $0x8000000,%ecx
			if (++nwrap == 2)
  810368:	83 6d dc 01          	subl   $0x1,-0x24(%ebp)
  81036c:	0f 85 50 ff ff ff    	jne    8102c2 <malloc+0x7b>
  810372:	c7 05 04 f0 b3 00 00 	movl   $0x8000000,0xb3f004
  810379:	00 00 08 
				return 0;	/* out of address space */
  81037c:	b8 00 00 00 00       	mov    $0x0,%eax
  810381:	e9 99 00 00 00       	jmp    81041f <malloc+0x1d8>
  810386:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  810389:	eb 1c                	jmp    8103a7 <malloc+0x160>
				sys_page_unmap(0, mptr + i);
  81038b:	83 ec 08             	sub    $0x8,%esp
  81038e:	89 f0                	mov    %esi,%eax
  810390:	03 05 04 f0 b3 00    	add    0xb3f004,%eax
  810396:	50                   	push   %eax
  810397:	6a 00                	push   $0x0
  810399:	e8 6e ec ff ff       	call   80f00c <sys_page_unmap>
			for (; i >= 0; i -= PGSIZE)
  81039e:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  8103a4:	83 c4 10             	add    $0x10,%esp
  8103a7:	85 f6                	test   %esi,%esi
  8103a9:	79 e0                	jns    81038b <malloc+0x144>
			return 0;	/* out of physical memory */
  8103ab:	b8 00 00 00 00       	mov    $0x0,%eax
  8103b0:	eb 6d                	jmp    81041f <malloc+0x1d8>
		return 0;
  8103b2:	b8 00 00 00 00       	mov    $0x0,%eax
  8103b7:	eb 66                	jmp    81041f <malloc+0x1d8>
  8103b9:	89 f0                	mov    %esi,%eax
  8103bb:	84 c0                	test   %al,%al
  8103bd:	74 08                	je     8103c7 <malloc+0x180>
  8103bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8103c2:	a3 04 f0 b3 00       	mov    %eax,0xb3f004
	for (i = 0; i < n + 4; i += PGSIZE){
  8103c7:	bb 00 00 00 00       	mov    $0x0,%ebx
  8103cc:	89 de                	mov    %ebx,%esi
  8103ce:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8103d1:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  8103d7:	83 ec 04             	sub    $0x4,%esp
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8103da:	39 fb                	cmp    %edi,%ebx
  8103dc:	0f 92 c0             	setb   %al
  8103df:	0f b6 c0             	movzbl %al,%eax
  8103e2:	c1 e0 09             	shl    $0x9,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  8103e5:	83 c8 07             	or     $0x7,%eax
  8103e8:	50                   	push   %eax
  8103e9:	89 f0                	mov    %esi,%eax
  8103eb:	03 05 04 f0 b3 00    	add    0xb3f004,%eax
  8103f1:	50                   	push   %eax
  8103f2:	6a 00                	push   $0x0
  8103f4:	e8 8e eb ff ff       	call   80ef87 <sys_page_alloc>
  8103f9:	83 c4 10             	add    $0x10,%esp
  8103fc:	85 c0                	test   %eax,%eax
  8103fe:	78 86                	js     810386 <malloc+0x13f>
	for (i = 0; i < n + 4; i += PGSIZE){
  810400:	39 fb                	cmp    %edi,%ebx
  810402:	72 c8                	jb     8103cc <malloc+0x185>
	ref = (uint32_t*) (mptr + i - 4);
  810404:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810409:	c7 84 30 fc 0f 00 00 	movl   $0x2,0xffc(%eax,%esi,1)
  810410:	02 00 00 00 
	mptr += n;
  810414:	8b 55 e0             	mov    -0x20(%ebp),%edx
  810417:	01 c2                	add    %eax,%edx
  810419:	89 15 04 f0 b3 00    	mov    %edx,0xb3f004
}
  81041f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810422:	5b                   	pop    %ebx
  810423:	5e                   	pop    %esi
  810424:	5f                   	pop    %edi
  810425:	5d                   	pop    %ebp
  810426:	c3                   	ret    

00810427 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  810427:	55                   	push   %ebp
  810428:	89 e5                	mov    %esp,%ebp
  81042a:	56                   	push   %esi
  81042b:	53                   	push   %ebx
  81042c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  81042f:	83 ec 0c             	sub    $0xc,%esp
  810432:	ff 75 08             	push   0x8(%ebp)
  810435:	e8 21 f1 ff ff       	call   80f55b <fd2data>
  81043a:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  81043c:	83 c4 08             	add    $0x8,%esp
  81043f:	68 13 37 81 00       	push   $0x813713
  810444:	53                   	push   %ebx
  810445:	e8 41 e7 ff ff       	call   80eb8b <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  81044a:	8b 46 04             	mov    0x4(%esi),%eax
  81044d:	2b 06                	sub    (%esi),%eax
  81044f:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  810455:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  81045c:	00 00 00 
	stat->st_dev = &devpipe;
  81045f:	c7 83 88 00 00 00 24 	movl   $0x814324,0x88(%ebx)
  810466:	43 81 00 
	return 0;
}
  810469:	b8 00 00 00 00       	mov    $0x0,%eax
  81046e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810471:	5b                   	pop    %ebx
  810472:	5e                   	pop    %esi
  810473:	5d                   	pop    %ebp
  810474:	c3                   	ret    

00810475 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  810475:	55                   	push   %ebp
  810476:	89 e5                	mov    %esp,%ebp
  810478:	53                   	push   %ebx
  810479:	83 ec 0c             	sub    $0xc,%esp
  81047c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  81047f:	53                   	push   %ebx
  810480:	6a 00                	push   $0x0
  810482:	e8 85 eb ff ff       	call   80f00c <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  810487:	89 1c 24             	mov    %ebx,(%esp)
  81048a:	e8 cc f0 ff ff       	call   80f55b <fd2data>
  81048f:	83 c4 08             	add    $0x8,%esp
  810492:	50                   	push   %eax
  810493:	6a 00                	push   $0x0
  810495:	e8 72 eb ff ff       	call   80f00c <sys_page_unmap>
}
  81049a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81049d:	c9                   	leave  
  81049e:	c3                   	ret    

0081049f <_pipeisclosed>:
{
  81049f:	55                   	push   %ebp
  8104a0:	89 e5                	mov    %esp,%ebp
  8104a2:	57                   	push   %edi
  8104a3:	56                   	push   %esi
  8104a4:	53                   	push   %ebx
  8104a5:	83 ec 1c             	sub    $0x1c,%esp
  8104a8:	89 c7                	mov    %eax,%edi
  8104aa:	89 d6                	mov    %edx,%esi
		n = thisenv->env_runs;
  8104ac:	a1 30 b2 b3 00       	mov    0xb3b230,%eax
  8104b1:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  8104b4:	83 ec 0c             	sub    $0xc,%esp
  8104b7:	57                   	push   %edi
  8104b8:	e8 c4 04 00 00       	call   810981 <pageref>
  8104bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8104c0:	89 34 24             	mov    %esi,(%esp)
  8104c3:	e8 b9 04 00 00       	call   810981 <pageref>
		nn = thisenv->env_runs;
  8104c8:	8b 15 30 b2 b3 00    	mov    0xb3b230,%edx
  8104ce:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  8104d1:	83 c4 10             	add    $0x10,%esp
  8104d4:	39 cb                	cmp    %ecx,%ebx
  8104d6:	74 1b                	je     8104f3 <_pipeisclosed+0x54>
		if (n != nn && ret == 1)
  8104d8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  8104db:	75 cf                	jne    8104ac <_pipeisclosed+0xd>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  8104dd:	8b 42 58             	mov    0x58(%edx),%eax
  8104e0:	6a 01                	push   $0x1
  8104e2:	50                   	push   %eax
  8104e3:	53                   	push   %ebx
  8104e4:	68 1a 37 81 00       	push   $0x81371a
  8104e9:	e8 c3 e0 ff ff       	call   80e5b1 <cprintf>
  8104ee:	83 c4 10             	add    $0x10,%esp
  8104f1:	eb b9                	jmp    8104ac <_pipeisclosed+0xd>
		ret = pageref(fd) == pageref(p);
  8104f3:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  8104f6:	0f 94 c0             	sete   %al
  8104f9:	0f b6 c0             	movzbl %al,%eax
}
  8104fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8104ff:	5b                   	pop    %ebx
  810500:	5e                   	pop    %esi
  810501:	5f                   	pop    %edi
  810502:	5d                   	pop    %ebp
  810503:	c3                   	ret    

00810504 <devpipe_write>:
{
  810504:	55                   	push   %ebp
  810505:	89 e5                	mov    %esp,%ebp
  810507:	57                   	push   %edi
  810508:	56                   	push   %esi
  810509:	53                   	push   %ebx
  81050a:	83 ec 28             	sub    $0x28,%esp
  81050d:	8b 75 08             	mov    0x8(%ebp),%esi
	p = (struct Pipe*) fd2data(fd);
  810510:	56                   	push   %esi
  810511:	e8 45 f0 ff ff       	call   80f55b <fd2data>
  810516:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810518:	83 c4 10             	add    $0x10,%esp
  81051b:	bf 00 00 00 00       	mov    $0x0,%edi
  810520:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810523:	75 09                	jne    81052e <devpipe_write+0x2a>
	return i;
  810525:	89 f8                	mov    %edi,%eax
  810527:	eb 23                	jmp    81054c <devpipe_write+0x48>
			sys_yield();
  810529:	e8 3a ea ff ff       	call   80ef68 <sys_yield>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  81052e:	8b 43 04             	mov    0x4(%ebx),%eax
  810531:	8b 0b                	mov    (%ebx),%ecx
  810533:	8d 51 20             	lea    0x20(%ecx),%edx
  810536:	39 d0                	cmp    %edx,%eax
  810538:	72 1a                	jb     810554 <devpipe_write+0x50>
			if (_pipeisclosed(fd, p))
  81053a:	89 da                	mov    %ebx,%edx
  81053c:	89 f0                	mov    %esi,%eax
  81053e:	e8 5c ff ff ff       	call   81049f <_pipeisclosed>
  810543:	85 c0                	test   %eax,%eax
  810545:	74 e2                	je     810529 <devpipe_write+0x25>
				return 0;
  810547:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81054c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  81054f:	5b                   	pop    %ebx
  810550:	5e                   	pop    %esi
  810551:	5f                   	pop    %edi
  810552:	5d                   	pop    %ebp
  810553:	c3                   	ret    
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810554:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810557:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  81055b:	88 4d e7             	mov    %cl,-0x19(%ebp)
  81055e:	89 c2                	mov    %eax,%edx
  810560:	c1 fa 1f             	sar    $0x1f,%edx
  810563:	89 d1                	mov    %edx,%ecx
  810565:	c1 e9 1b             	shr    $0x1b,%ecx
  810568:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  81056b:	83 e2 1f             	and    $0x1f,%edx
  81056e:	29 ca                	sub    %ecx,%edx
  810570:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810574:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  810578:	83 c0 01             	add    $0x1,%eax
  81057b:	89 43 04             	mov    %eax,0x4(%ebx)
	for (i = 0; i < n; i++) {
  81057e:	83 c7 01             	add    $0x1,%edi
  810581:	eb 9d                	jmp    810520 <devpipe_write+0x1c>

00810583 <devpipe_read>:
{
  810583:	55                   	push   %ebp
  810584:	89 e5                	mov    %esp,%ebp
  810586:	57                   	push   %edi
  810587:	56                   	push   %esi
  810588:	53                   	push   %ebx
  810589:	83 ec 18             	sub    $0x18,%esp
  81058c:	8b 7d 08             	mov    0x8(%ebp),%edi
	p = (struct Pipe*)fd2data(fd);
  81058f:	57                   	push   %edi
  810590:	e8 c6 ef ff ff       	call   80f55b <fd2data>
  810595:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810597:	83 c4 10             	add    $0x10,%esp
  81059a:	be 00 00 00 00       	mov    $0x0,%esi
  81059f:	3b 75 10             	cmp    0x10(%ebp),%esi
  8105a2:	75 13                	jne    8105b7 <devpipe_read+0x34>
	return i;
  8105a4:	89 f0                	mov    %esi,%eax
  8105a6:	eb 02                	jmp    8105aa <devpipe_read+0x27>
				return i;
  8105a8:	89 f0                	mov    %esi,%eax
}
  8105aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8105ad:	5b                   	pop    %ebx
  8105ae:	5e                   	pop    %esi
  8105af:	5f                   	pop    %edi
  8105b0:	5d                   	pop    %ebp
  8105b1:	c3                   	ret    
			sys_yield();
  8105b2:	e8 b1 e9 ff ff       	call   80ef68 <sys_yield>
		while (p->p_rpos == p->p_wpos) {
  8105b7:	8b 03                	mov    (%ebx),%eax
  8105b9:	3b 43 04             	cmp    0x4(%ebx),%eax
  8105bc:	75 18                	jne    8105d6 <devpipe_read+0x53>
			if (i > 0)
  8105be:	85 f6                	test   %esi,%esi
  8105c0:	75 e6                	jne    8105a8 <devpipe_read+0x25>
			if (_pipeisclosed(fd, p))
  8105c2:	89 da                	mov    %ebx,%edx
  8105c4:	89 f8                	mov    %edi,%eax
  8105c6:	e8 d4 fe ff ff       	call   81049f <_pipeisclosed>
  8105cb:	85 c0                	test   %eax,%eax
  8105cd:	74 e3                	je     8105b2 <devpipe_read+0x2f>
				return 0;
  8105cf:	b8 00 00 00 00       	mov    $0x0,%eax
  8105d4:	eb d4                	jmp    8105aa <devpipe_read+0x27>
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  8105d6:	99                   	cltd   
  8105d7:	c1 ea 1b             	shr    $0x1b,%edx
  8105da:	01 d0                	add    %edx,%eax
  8105dc:	83 e0 1f             	and    $0x1f,%eax
  8105df:	29 d0                	sub    %edx,%eax
  8105e1:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  8105e6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8105e9:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  8105ec:	83 03 01             	addl   $0x1,(%ebx)
	for (i = 0; i < n; i++) {
  8105ef:	83 c6 01             	add    $0x1,%esi
  8105f2:	eb ab                	jmp    81059f <devpipe_read+0x1c>

008105f4 <pipe>:
{
  8105f4:	55                   	push   %ebp
  8105f5:	89 e5                	mov    %esp,%ebp
  8105f7:	56                   	push   %esi
  8105f8:	53                   	push   %ebx
  8105f9:	83 ec 1c             	sub    $0x1c,%esp
	if ((r = fd_alloc(&fd0)) < 0
  8105fc:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8105ff:	50                   	push   %eax
  810600:	e8 6d ef ff ff       	call   80f572 <fd_alloc>
  810605:	89 c3                	mov    %eax,%ebx
  810607:	83 c4 10             	add    $0x10,%esp
  81060a:	85 c0                	test   %eax,%eax
  81060c:	0f 88 23 01 00 00    	js     810735 <pipe+0x141>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810612:	83 ec 04             	sub    $0x4,%esp
  810615:	68 07 04 00 00       	push   $0x407
  81061a:	ff 75 f4             	push   -0xc(%ebp)
  81061d:	6a 00                	push   $0x0
  81061f:	e8 63 e9 ff ff       	call   80ef87 <sys_page_alloc>
  810624:	89 c3                	mov    %eax,%ebx
  810626:	83 c4 10             	add    $0x10,%esp
  810629:	85 c0                	test   %eax,%eax
  81062b:	0f 88 04 01 00 00    	js     810735 <pipe+0x141>
	if ((r = fd_alloc(&fd1)) < 0
  810631:	83 ec 0c             	sub    $0xc,%esp
  810634:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810637:	50                   	push   %eax
  810638:	e8 35 ef ff ff       	call   80f572 <fd_alloc>
  81063d:	89 c3                	mov    %eax,%ebx
  81063f:	83 c4 10             	add    $0x10,%esp
  810642:	85 c0                	test   %eax,%eax
  810644:	0f 88 db 00 00 00    	js     810725 <pipe+0x131>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  81064a:	83 ec 04             	sub    $0x4,%esp
  81064d:	68 07 04 00 00       	push   $0x407
  810652:	ff 75 f0             	push   -0x10(%ebp)
  810655:	6a 00                	push   $0x0
  810657:	e8 2b e9 ff ff       	call   80ef87 <sys_page_alloc>
  81065c:	89 c3                	mov    %eax,%ebx
  81065e:	83 c4 10             	add    $0x10,%esp
  810661:	85 c0                	test   %eax,%eax
  810663:	0f 88 bc 00 00 00    	js     810725 <pipe+0x131>
	va = fd2data(fd0);
  810669:	83 ec 0c             	sub    $0xc,%esp
  81066c:	ff 75 f4             	push   -0xc(%ebp)
  81066f:	e8 e7 ee ff ff       	call   80f55b <fd2data>
  810674:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810676:	83 c4 0c             	add    $0xc,%esp
  810679:	68 07 04 00 00       	push   $0x407
  81067e:	50                   	push   %eax
  81067f:	6a 00                	push   $0x0
  810681:	e8 01 e9 ff ff       	call   80ef87 <sys_page_alloc>
  810686:	89 c3                	mov    %eax,%ebx
  810688:	83 c4 10             	add    $0x10,%esp
  81068b:	85 c0                	test   %eax,%eax
  81068d:	0f 88 82 00 00 00    	js     810715 <pipe+0x121>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810693:	83 ec 0c             	sub    $0xc,%esp
  810696:	ff 75 f0             	push   -0x10(%ebp)
  810699:	e8 bd ee ff ff       	call   80f55b <fd2data>
  81069e:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  8106a5:	50                   	push   %eax
  8106a6:	6a 00                	push   $0x0
  8106a8:	56                   	push   %esi
  8106a9:	6a 00                	push   $0x0
  8106ab:	e8 1a e9 ff ff       	call   80efca <sys_page_map>
  8106b0:	89 c3                	mov    %eax,%ebx
  8106b2:	83 c4 20             	add    $0x20,%esp
  8106b5:	85 c0                	test   %eax,%eax
  8106b7:	78 4e                	js     810707 <pipe+0x113>
	fd0->fd_dev_id = devpipe.dev_id;
  8106b9:	a1 24 43 81 00       	mov    0x814324,%eax
  8106be:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8106c1:	89 02                	mov    %eax,(%edx)
	fd0->fd_omode = O_RDONLY;
  8106c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8106c6:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	fd1->fd_dev_id = devpipe.dev_id;
  8106cd:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8106d0:	89 02                	mov    %eax,(%edx)
	fd1->fd_omode = O_WRONLY;
  8106d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8106d5:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
	pfd[0] = fd2num(fd0);
  8106dc:	83 ec 0c             	sub    $0xc,%esp
  8106df:	ff 75 f4             	push   -0xc(%ebp)
  8106e2:	e8 64 ee ff ff       	call   80f54b <fd2num>
  8106e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8106ea:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  8106ec:	83 c4 04             	add    $0x4,%esp
  8106ef:	ff 75 f0             	push   -0x10(%ebp)
  8106f2:	e8 54 ee ff ff       	call   80f54b <fd2num>
  8106f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8106fa:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  8106fd:	83 c4 10             	add    $0x10,%esp
  810700:	bb 00 00 00 00       	mov    $0x0,%ebx
  810705:	eb 2e                	jmp    810735 <pipe+0x141>
	sys_page_unmap(0, va);
  810707:	83 ec 08             	sub    $0x8,%esp
  81070a:	56                   	push   %esi
  81070b:	6a 00                	push   $0x0
  81070d:	e8 fa e8 ff ff       	call   80f00c <sys_page_unmap>
  810712:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd1);
  810715:	83 ec 08             	sub    $0x8,%esp
  810718:	ff 75 f0             	push   -0x10(%ebp)
  81071b:	6a 00                	push   $0x0
  81071d:	e8 ea e8 ff ff       	call   80f00c <sys_page_unmap>
  810722:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd0);
  810725:	83 ec 08             	sub    $0x8,%esp
  810728:	ff 75 f4             	push   -0xc(%ebp)
  81072b:	6a 00                	push   $0x0
  81072d:	e8 da e8 ff ff       	call   80f00c <sys_page_unmap>
  810732:	83 c4 10             	add    $0x10,%esp
}
  810735:	89 d8                	mov    %ebx,%eax
  810737:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81073a:	5b                   	pop    %ebx
  81073b:	5e                   	pop    %esi
  81073c:	5d                   	pop    %ebp
  81073d:	c3                   	ret    

0081073e <pipeisclosed>:
{
  81073e:	55                   	push   %ebp
  81073f:	89 e5                	mov    %esp,%ebp
  810741:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810744:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810747:	50                   	push   %eax
  810748:	ff 75 08             	push   0x8(%ebp)
  81074b:	e8 72 ee ff ff       	call   80f5c2 <fd_lookup>
  810750:	83 c4 10             	add    $0x10,%esp
  810753:	85 c0                	test   %eax,%eax
  810755:	78 18                	js     81076f <pipeisclosed+0x31>
	p = (struct Pipe*) fd2data(fd);
  810757:	83 ec 0c             	sub    $0xc,%esp
  81075a:	ff 75 f4             	push   -0xc(%ebp)
  81075d:	e8 f9 ed ff ff       	call   80f55b <fd2data>
  810762:	89 c2                	mov    %eax,%edx
	return _pipeisclosed(fd, p);
  810764:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810767:	e8 33 fd ff ff       	call   81049f <_pipeisclosed>
  81076c:	83 c4 10             	add    $0x10,%esp
}
  81076f:	c9                   	leave  
  810770:	c3                   	ret    

00810771 <devcons_close>:
devcons_close(struct Fd *fd)
{
	USED(fd);

	return 0;
}
  810771:	b8 00 00 00 00       	mov    $0x0,%eax
  810776:	c3                   	ret    

00810777 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  810777:	55                   	push   %ebp
  810778:	89 e5                	mov    %esp,%ebp
  81077a:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  81077d:	68 32 37 81 00       	push   $0x813732
  810782:	ff 75 0c             	push   0xc(%ebp)
  810785:	e8 01 e4 ff ff       	call   80eb8b <strcpy>
	return 0;
}
  81078a:	b8 00 00 00 00       	mov    $0x0,%eax
  81078f:	c9                   	leave  
  810790:	c3                   	ret    

00810791 <devcons_write>:
{
  810791:	55                   	push   %ebp
  810792:	89 e5                	mov    %esp,%ebp
  810794:	57                   	push   %edi
  810795:	56                   	push   %esi
  810796:	53                   	push   %ebx
  810797:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	for (tot = 0; tot < n; tot += m) {
  81079d:	be 00 00 00 00       	mov    $0x0,%esi
		memmove(buf, (char*)vbuf + tot, m);
  8107a2:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	for (tot = 0; tot < n; tot += m) {
  8107a8:	eb 2e                	jmp    8107d8 <devcons_write+0x47>
		m = n - tot;
  8107aa:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8107ad:	29 f3                	sub    %esi,%ebx
  8107af:	b8 7f 00 00 00       	mov    $0x7f,%eax
  8107b4:	39 c3                	cmp    %eax,%ebx
  8107b6:	0f 47 d8             	cmova  %eax,%ebx
		memmove(buf, (char*)vbuf + tot, m);
  8107b9:	83 ec 04             	sub    $0x4,%esp
  8107bc:	53                   	push   %ebx
  8107bd:	89 f0                	mov    %esi,%eax
  8107bf:	03 45 0c             	add    0xc(%ebp),%eax
  8107c2:	50                   	push   %eax
  8107c3:	57                   	push   %edi
  8107c4:	e8 58 e5 ff ff       	call   80ed21 <memmove>
		sys_cputs(buf, m);
  8107c9:	83 c4 08             	add    $0x8,%esp
  8107cc:	53                   	push   %ebx
  8107cd:	57                   	push   %edi
  8107ce:	e8 f8 e6 ff ff       	call   80eecb <sys_cputs>
	for (tot = 0; tot < n; tot += m) {
  8107d3:	01 de                	add    %ebx,%esi
  8107d5:	83 c4 10             	add    $0x10,%esp
  8107d8:	3b 75 10             	cmp    0x10(%ebp),%esi
  8107db:	72 cd                	jb     8107aa <devcons_write+0x19>
}
  8107dd:	89 f0                	mov    %esi,%eax
  8107df:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8107e2:	5b                   	pop    %ebx
  8107e3:	5e                   	pop    %esi
  8107e4:	5f                   	pop    %edi
  8107e5:	5d                   	pop    %ebp
  8107e6:	c3                   	ret    

008107e7 <devcons_read>:
{
  8107e7:	55                   	push   %ebp
  8107e8:	89 e5                	mov    %esp,%ebp
  8107ea:	83 ec 08             	sub    $0x8,%esp
  8107ed:	b8 00 00 00 00       	mov    $0x0,%eax
	if (n == 0)
  8107f2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8107f6:	75 07                	jne    8107ff <devcons_read+0x18>
  8107f8:	eb 1f                	jmp    810819 <devcons_read+0x32>
		sys_yield();
  8107fa:	e8 69 e7 ff ff       	call   80ef68 <sys_yield>
	while ((c = sys_cgetc()) == 0)
  8107ff:	e8 e5 e6 ff ff       	call   80eee9 <sys_cgetc>
  810804:	85 c0                	test   %eax,%eax
  810806:	74 f2                	je     8107fa <devcons_read+0x13>
	if (c < 0)
  810808:	78 0f                	js     810819 <devcons_read+0x32>
	if (c == 0x04)	// ctl-d is eof
  81080a:	83 f8 04             	cmp    $0x4,%eax
  81080d:	74 0c                	je     81081b <devcons_read+0x34>
	*(char*)vbuf = c;
  81080f:	8b 55 0c             	mov    0xc(%ebp),%edx
  810812:	88 02                	mov    %al,(%edx)
	return 1;
  810814:	b8 01 00 00 00       	mov    $0x1,%eax
}
  810819:	c9                   	leave  
  81081a:	c3                   	ret    
		return 0;
  81081b:	b8 00 00 00 00       	mov    $0x0,%eax
  810820:	eb f7                	jmp    810819 <devcons_read+0x32>

00810822 <cputchar>:
{
  810822:	55                   	push   %ebp
  810823:	89 e5                	mov    %esp,%ebp
  810825:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  810828:	8b 45 08             	mov    0x8(%ebp),%eax
  81082b:	88 45 f7             	mov    %al,-0x9(%ebp)
	sys_cputs(&c, 1);
  81082e:	6a 01                	push   $0x1
  810830:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810833:	50                   	push   %eax
  810834:	e8 92 e6 ff ff       	call   80eecb <sys_cputs>
}
  810839:	83 c4 10             	add    $0x10,%esp
  81083c:	c9                   	leave  
  81083d:	c3                   	ret    

0081083e <getchar>:
{
  81083e:	55                   	push   %ebp
  81083f:	89 e5                	mov    %esp,%ebp
  810841:	83 ec 1c             	sub    $0x1c,%esp
	r = read(0, &c, 1);
  810844:	6a 01                	push   $0x1
  810846:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810849:	50                   	push   %eax
  81084a:	6a 00                	push   $0x0
  81084c:	e8 da ef ff ff       	call   80f82b <read>
	if (r < 0)
  810851:	83 c4 10             	add    $0x10,%esp
  810854:	85 c0                	test   %eax,%eax
  810856:	78 06                	js     81085e <getchar+0x20>
	if (r < 1)
  810858:	74 06                	je     810860 <getchar+0x22>
	return c;
  81085a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  81085e:	c9                   	leave  
  81085f:	c3                   	ret    
		return -E_EOF;
  810860:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  810865:	eb f7                	jmp    81085e <getchar+0x20>

00810867 <iscons>:
{
  810867:	55                   	push   %ebp
  810868:	89 e5                	mov    %esp,%ebp
  81086a:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  81086d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810870:	50                   	push   %eax
  810871:	ff 75 08             	push   0x8(%ebp)
  810874:	e8 49 ed ff ff       	call   80f5c2 <fd_lookup>
  810879:	83 c4 10             	add    $0x10,%esp
  81087c:	85 c0                	test   %eax,%eax
  81087e:	78 11                	js     810891 <iscons+0x2a>
	return fd->fd_dev_id == devcons.dev_id;
  810880:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810883:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810889:	39 10                	cmp    %edx,(%eax)
  81088b:	0f 94 c0             	sete   %al
  81088e:	0f b6 c0             	movzbl %al,%eax
}
  810891:	c9                   	leave  
  810892:	c3                   	ret    

00810893 <opencons>:
{
  810893:	55                   	push   %ebp
  810894:	89 e5                	mov    %esp,%ebp
  810896:	83 ec 24             	sub    $0x24,%esp
	if ((r = fd_alloc(&fd)) < 0)
  810899:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81089c:	50                   	push   %eax
  81089d:	e8 d0 ec ff ff       	call   80f572 <fd_alloc>
  8108a2:	83 c4 10             	add    $0x10,%esp
  8108a5:	85 c0                	test   %eax,%eax
  8108a7:	78 3a                	js     8108e3 <opencons+0x50>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  8108a9:	83 ec 04             	sub    $0x4,%esp
  8108ac:	68 07 04 00 00       	push   $0x407
  8108b1:	ff 75 f4             	push   -0xc(%ebp)
  8108b4:	6a 00                	push   $0x0
  8108b6:	e8 cc e6 ff ff       	call   80ef87 <sys_page_alloc>
  8108bb:	83 c4 10             	add    $0x10,%esp
  8108be:	85 c0                	test   %eax,%eax
  8108c0:	78 21                	js     8108e3 <opencons+0x50>
	fd->fd_dev_id = devcons.dev_id;
  8108c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8108c5:	8b 15 40 43 81 00    	mov    0x814340,%edx
  8108cb:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  8108cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8108d0:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  8108d7:	83 ec 0c             	sub    $0xc,%esp
  8108da:	50                   	push   %eax
  8108db:	e8 6b ec ff ff       	call   80f54b <fd2num>
  8108e0:	83 c4 10             	add    $0x10,%esp
}
  8108e3:	c9                   	leave  
  8108e4:	c3                   	ret    

008108e5 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  8108e5:	55                   	push   %ebp
  8108e6:	89 e5                	mov    %esp,%ebp
  8108e8:	83 ec 08             	sub    $0x8,%esp
	int r;

	if ( _pgfault_handler == 0) {
  8108eb:	83 3d 08 f0 b3 00 00 	cmpl   $0x0,0xb3f008
  8108f2:	74 0a                	je     8108fe <set_pgfault_handler+0x19>
			panic("set_pgfault_handler : fail to set _pgfault_upcall: %e",r);
		}
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  8108f4:	8b 45 08             	mov    0x8(%ebp),%eax
  8108f7:	a3 08 f0 b3 00       	mov    %eax,0xb3f008
}
  8108fc:	c9                   	leave  
  8108fd:	c3                   	ret    
		r = sys_page_alloc(sys_getenvid(), (void *)(UXSTACKTOP-PGSIZE), PTE_SYSCALL);
  8108fe:	e8 46 e6 ff ff       	call   80ef49 <sys_getenvid>
  810903:	83 ec 04             	sub    $0x4,%esp
  810906:	68 07 0e 00 00       	push   $0xe07
  81090b:	68 00 f0 bf ee       	push   $0xeebff000
  810910:	50                   	push   %eax
  810911:	e8 71 e6 ff ff       	call   80ef87 <sys_page_alloc>
		if (r < 0) {
  810916:	83 c4 10             	add    $0x10,%esp
  810919:	85 c0                	test   %eax,%eax
  81091b:	78 2c                	js     810949 <set_pgfault_handler+0x64>
		r = sys_env_set_pgfault_upcall(sys_getenvid(), _pgfault_upcall);
  81091d:	e8 27 e6 ff ff       	call   80ef49 <sys_getenvid>
  810922:	83 ec 08             	sub    $0x8,%esp
  810925:	68 5b 09 81 00       	push   $0x81095b
  81092a:	50                   	push   %eax
  81092b:	e8 a2 e7 ff ff       	call   80f0d2 <sys_env_set_pgfault_upcall>
		if (r < 0) {
  810930:	83 c4 10             	add    $0x10,%esp
  810933:	85 c0                	test   %eax,%eax
  810935:	79 bd                	jns    8108f4 <set_pgfault_handler+0xf>
			panic("set_pgfault_handler : fail to set _pgfault_upcall: %e",r);
  810937:	50                   	push   %eax
  810938:	68 80 37 81 00       	push   $0x813780
  81093d:	6a 28                	push   $0x28
  81093f:	68 b6 37 81 00       	push   $0x8137b6
  810944:	e8 8d db ff ff       	call   80e4d6 <_panic>
			panic("set_pgfault_handler : fail to alloc a page for UXSTACKTOP : %e",r);
  810949:	50                   	push   %eax
  81094a:	68 40 37 81 00       	push   $0x813740
  81094f:	6a 23                	push   $0x23
  810951:	68 b6 37 81 00       	push   $0x8137b6
  810956:	e8 7b db ff ff       	call   80e4d6 <_panic>

0081095b <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  81095b:	54                   	push   %esp
	movl _pgfault_handler, %eax
  81095c:	a1 08 f0 b3 00       	mov    0xb3f008,%eax
	call *%eax
  810961:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  810963:	83 c4 04             	add    $0x4,%esp
	//
	// LAB 4: Your code here. 
	//因为下一步之后就不能再操作常规寄存器了，所以要提前在栈中修改 utf_esp(减4)，以压入utf_eip。
	//struct PushRegs 32字节       EAX:累加器(Accumulator),  EDX：数据寄存器（Data Register） 其实选哪个寄存器应该都可以，
	//因为后面都会恢复重置，但我按照其功能说明选了这两个。
	movl 48(%esp), %eax// %eax中是utf_esp
  810966:	8b 44 24 30          	mov    0x30(%esp),%eax
	subl $4, %eax 
  81096a:	83 e8 04             	sub    $0x4,%eax
	movl %eax, 48(%esp)
  81096d:	89 44 24 30          	mov    %eax,0x30(%esp)
	//在新utf_esp 存入utf_eip。
	movl 40(%esp), %edx
  810971:	8b 54 24 28          	mov    0x28(%esp),%edx
	movl %edx, (%eax)
  810975:	89 10                	mov    %edx,(%eax)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.  
	addl $8, %esp
  810977:	83 c4 08             	add    $0x8,%esp
	popal  //弹出 utf_regs 此时 %esp 指向  utf_eip
  81097a:	61                   	popa   

	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.  
	addl $4, %esp
  81097b:	83 c4 04             	add    $0x4,%esp
	popfl//弹出utf_eflags
  81097e:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl %esp 
  81097f:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	// 别忘了！！ ret 指令相当于 popl %eip
	ret
  810980:	c3                   	ret    

00810981 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  810981:	55                   	push   %ebp
  810982:	89 e5                	mov    %esp,%ebp
  810984:	8b 45 08             	mov    0x8(%ebp),%eax
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  810987:	89 c2                	mov    %eax,%edx
  810989:	c1 ea 16             	shr    $0x16,%edx
  81098c:	8b 0c 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%ecx
		return 0;
  810993:	ba 00 00 00 00       	mov    $0x0,%edx
	if (!(uvpd[PDX(v)] & PTE_P))
  810998:	f6 c1 01             	test   $0x1,%cl
  81099b:	74 1c                	je     8109b9 <pageref+0x38>
	pte = uvpt[PGNUM(v)];
  81099d:	c1 e8 0c             	shr    $0xc,%eax
  8109a0:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if (!(pte & PTE_P))
  8109a7:	a8 01                	test   $0x1,%al
  8109a9:	74 0e                	je     8109b9 <pageref+0x38>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  8109ab:	c1 e8 0c             	shr    $0xc,%eax
  8109ae:	0f b7 14 c5 04 00 00 	movzwl -0x10fffffc(,%eax,8),%edx
  8109b5:	ef 
  8109b6:	0f b7 d2             	movzwl %dx,%edx
}
  8109b9:	89 d0                	mov    %edx,%eax
  8109bb:	5d                   	pop    %ebp
  8109bc:	c3                   	ret    
  8109bd:	66 90                	xchg   %ax,%ax
  8109bf:	90                   	nop

008109c0 <__udivdi3>:
  8109c0:	f3 0f 1e fb          	endbr32 
  8109c4:	55                   	push   %ebp
  8109c5:	57                   	push   %edi
  8109c6:	56                   	push   %esi
  8109c7:	53                   	push   %ebx
  8109c8:	83 ec 1c             	sub    $0x1c,%esp
  8109cb:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  8109cf:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  8109d3:	8b 74 24 34          	mov    0x34(%esp),%esi
  8109d7:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  8109db:	85 c0                	test   %eax,%eax
  8109dd:	75 19                	jne    8109f8 <__udivdi3+0x38>
  8109df:	39 f3                	cmp    %esi,%ebx
  8109e1:	76 4d                	jbe    810a30 <__udivdi3+0x70>
  8109e3:	31 ff                	xor    %edi,%edi
  8109e5:	89 e8                	mov    %ebp,%eax
  8109e7:	89 f2                	mov    %esi,%edx
  8109e9:	f7 f3                	div    %ebx
  8109eb:	89 fa                	mov    %edi,%edx
  8109ed:	83 c4 1c             	add    $0x1c,%esp
  8109f0:	5b                   	pop    %ebx
  8109f1:	5e                   	pop    %esi
  8109f2:	5f                   	pop    %edi
  8109f3:	5d                   	pop    %ebp
  8109f4:	c3                   	ret    
  8109f5:	8d 76 00             	lea    0x0(%esi),%esi
  8109f8:	39 f0                	cmp    %esi,%eax
  8109fa:	76 14                	jbe    810a10 <__udivdi3+0x50>
  8109fc:	31 ff                	xor    %edi,%edi
  8109fe:	31 c0                	xor    %eax,%eax
  810a00:	89 fa                	mov    %edi,%edx
  810a02:	83 c4 1c             	add    $0x1c,%esp
  810a05:	5b                   	pop    %ebx
  810a06:	5e                   	pop    %esi
  810a07:	5f                   	pop    %edi
  810a08:	5d                   	pop    %ebp
  810a09:	c3                   	ret    
  810a0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810a10:	0f bd f8             	bsr    %eax,%edi
  810a13:	83 f7 1f             	xor    $0x1f,%edi
  810a16:	75 48                	jne    810a60 <__udivdi3+0xa0>
  810a18:	39 f0                	cmp    %esi,%eax
  810a1a:	72 06                	jb     810a22 <__udivdi3+0x62>
  810a1c:	31 c0                	xor    %eax,%eax
  810a1e:	39 eb                	cmp    %ebp,%ebx
  810a20:	77 de                	ja     810a00 <__udivdi3+0x40>
  810a22:	b8 01 00 00 00       	mov    $0x1,%eax
  810a27:	eb d7                	jmp    810a00 <__udivdi3+0x40>
  810a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810a30:	89 d9                	mov    %ebx,%ecx
  810a32:	85 db                	test   %ebx,%ebx
  810a34:	75 0b                	jne    810a41 <__udivdi3+0x81>
  810a36:	b8 01 00 00 00       	mov    $0x1,%eax
  810a3b:	31 d2                	xor    %edx,%edx
  810a3d:	f7 f3                	div    %ebx
  810a3f:	89 c1                	mov    %eax,%ecx
  810a41:	31 d2                	xor    %edx,%edx
  810a43:	89 f0                	mov    %esi,%eax
  810a45:	f7 f1                	div    %ecx
  810a47:	89 c6                	mov    %eax,%esi
  810a49:	89 e8                	mov    %ebp,%eax
  810a4b:	89 f7                	mov    %esi,%edi
  810a4d:	f7 f1                	div    %ecx
  810a4f:	89 fa                	mov    %edi,%edx
  810a51:	83 c4 1c             	add    $0x1c,%esp
  810a54:	5b                   	pop    %ebx
  810a55:	5e                   	pop    %esi
  810a56:	5f                   	pop    %edi
  810a57:	5d                   	pop    %ebp
  810a58:	c3                   	ret    
  810a59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810a60:	89 f9                	mov    %edi,%ecx
  810a62:	ba 20 00 00 00       	mov    $0x20,%edx
  810a67:	29 fa                	sub    %edi,%edx
  810a69:	d3 e0                	shl    %cl,%eax
  810a6b:	89 44 24 08          	mov    %eax,0x8(%esp)
  810a6f:	89 d1                	mov    %edx,%ecx
  810a71:	89 d8                	mov    %ebx,%eax
  810a73:	d3 e8                	shr    %cl,%eax
  810a75:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  810a79:	09 c1                	or     %eax,%ecx
  810a7b:	89 f0                	mov    %esi,%eax
  810a7d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810a81:	89 f9                	mov    %edi,%ecx
  810a83:	d3 e3                	shl    %cl,%ebx
  810a85:	89 d1                	mov    %edx,%ecx
  810a87:	d3 e8                	shr    %cl,%eax
  810a89:	89 f9                	mov    %edi,%ecx
  810a8b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  810a8f:	89 eb                	mov    %ebp,%ebx
  810a91:	d3 e6                	shl    %cl,%esi
  810a93:	89 d1                	mov    %edx,%ecx
  810a95:	d3 eb                	shr    %cl,%ebx
  810a97:	09 f3                	or     %esi,%ebx
  810a99:	89 c6                	mov    %eax,%esi
  810a9b:	89 f2                	mov    %esi,%edx
  810a9d:	89 d8                	mov    %ebx,%eax
  810a9f:	f7 74 24 08          	divl   0x8(%esp)
  810aa3:	89 d6                	mov    %edx,%esi
  810aa5:	89 c3                	mov    %eax,%ebx
  810aa7:	f7 64 24 0c          	mull   0xc(%esp)
  810aab:	39 d6                	cmp    %edx,%esi
  810aad:	72 19                	jb     810ac8 <__udivdi3+0x108>
  810aaf:	89 f9                	mov    %edi,%ecx
  810ab1:	d3 e5                	shl    %cl,%ebp
  810ab3:	39 c5                	cmp    %eax,%ebp
  810ab5:	73 04                	jae    810abb <__udivdi3+0xfb>
  810ab7:	39 d6                	cmp    %edx,%esi
  810ab9:	74 0d                	je     810ac8 <__udivdi3+0x108>
  810abb:	89 d8                	mov    %ebx,%eax
  810abd:	31 ff                	xor    %edi,%edi
  810abf:	e9 3c ff ff ff       	jmp    810a00 <__udivdi3+0x40>
  810ac4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810ac8:	8d 43 ff             	lea    -0x1(%ebx),%eax
  810acb:	31 ff                	xor    %edi,%edi
  810acd:	e9 2e ff ff ff       	jmp    810a00 <__udivdi3+0x40>
  810ad2:	66 90                	xchg   %ax,%ax
  810ad4:	66 90                	xchg   %ax,%ax
  810ad6:	66 90                	xchg   %ax,%ax
  810ad8:	66 90                	xchg   %ax,%ax
  810ada:	66 90                	xchg   %ax,%ax
  810adc:	66 90                	xchg   %ax,%ax
  810ade:	66 90                	xchg   %ax,%ax

00810ae0 <__umoddi3>:
  810ae0:	f3 0f 1e fb          	endbr32 
  810ae4:	55                   	push   %ebp
  810ae5:	57                   	push   %edi
  810ae6:	56                   	push   %esi
  810ae7:	53                   	push   %ebx
  810ae8:	83 ec 1c             	sub    $0x1c,%esp
  810aeb:	8b 74 24 30          	mov    0x30(%esp),%esi
  810aef:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  810af3:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
  810af7:	8b 6c 24 38          	mov    0x38(%esp),%ebp
  810afb:	89 f0                	mov    %esi,%eax
  810afd:	89 da                	mov    %ebx,%edx
  810aff:	85 ff                	test   %edi,%edi
  810b01:	75 15                	jne    810b18 <__umoddi3+0x38>
  810b03:	39 dd                	cmp    %ebx,%ebp
  810b05:	76 39                	jbe    810b40 <__umoddi3+0x60>
  810b07:	f7 f5                	div    %ebp
  810b09:	89 d0                	mov    %edx,%eax
  810b0b:	31 d2                	xor    %edx,%edx
  810b0d:	83 c4 1c             	add    $0x1c,%esp
  810b10:	5b                   	pop    %ebx
  810b11:	5e                   	pop    %esi
  810b12:	5f                   	pop    %edi
  810b13:	5d                   	pop    %ebp
  810b14:	c3                   	ret    
  810b15:	8d 76 00             	lea    0x0(%esi),%esi
  810b18:	39 df                	cmp    %ebx,%edi
  810b1a:	77 f1                	ja     810b0d <__umoddi3+0x2d>
  810b1c:	0f bd cf             	bsr    %edi,%ecx
  810b1f:	83 f1 1f             	xor    $0x1f,%ecx
  810b22:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  810b26:	75 40                	jne    810b68 <__umoddi3+0x88>
  810b28:	39 df                	cmp    %ebx,%edi
  810b2a:	72 04                	jb     810b30 <__umoddi3+0x50>
  810b2c:	39 f5                	cmp    %esi,%ebp
  810b2e:	77 dd                	ja     810b0d <__umoddi3+0x2d>
  810b30:	89 da                	mov    %ebx,%edx
  810b32:	89 f0                	mov    %esi,%eax
  810b34:	29 e8                	sub    %ebp,%eax
  810b36:	19 fa                	sbb    %edi,%edx
  810b38:	eb d3                	jmp    810b0d <__umoddi3+0x2d>
  810b3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810b40:	89 e9                	mov    %ebp,%ecx
  810b42:	85 ed                	test   %ebp,%ebp
  810b44:	75 0b                	jne    810b51 <__umoddi3+0x71>
  810b46:	b8 01 00 00 00       	mov    $0x1,%eax
  810b4b:	31 d2                	xor    %edx,%edx
  810b4d:	f7 f5                	div    %ebp
  810b4f:	89 c1                	mov    %eax,%ecx
  810b51:	89 d8                	mov    %ebx,%eax
  810b53:	31 d2                	xor    %edx,%edx
  810b55:	f7 f1                	div    %ecx
  810b57:	89 f0                	mov    %esi,%eax
  810b59:	f7 f1                	div    %ecx
  810b5b:	89 d0                	mov    %edx,%eax
  810b5d:	31 d2                	xor    %edx,%edx
  810b5f:	eb ac                	jmp    810b0d <__umoddi3+0x2d>
  810b61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810b68:	8b 44 24 04          	mov    0x4(%esp),%eax
  810b6c:	ba 20 00 00 00       	mov    $0x20,%edx
  810b71:	29 c2                	sub    %eax,%edx
  810b73:	89 c1                	mov    %eax,%ecx
  810b75:	89 e8                	mov    %ebp,%eax
  810b77:	d3 e7                	shl    %cl,%edi
  810b79:	89 d1                	mov    %edx,%ecx
  810b7b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  810b7f:	d3 e8                	shr    %cl,%eax
  810b81:	89 c1                	mov    %eax,%ecx
  810b83:	8b 44 24 04          	mov    0x4(%esp),%eax
  810b87:	09 f9                	or     %edi,%ecx
  810b89:	89 df                	mov    %ebx,%edi
  810b8b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810b8f:	89 c1                	mov    %eax,%ecx
  810b91:	d3 e5                	shl    %cl,%ebp
  810b93:	89 d1                	mov    %edx,%ecx
  810b95:	d3 ef                	shr    %cl,%edi
  810b97:	89 c1                	mov    %eax,%ecx
  810b99:	89 f0                	mov    %esi,%eax
  810b9b:	d3 e3                	shl    %cl,%ebx
  810b9d:	89 d1                	mov    %edx,%ecx
  810b9f:	89 fa                	mov    %edi,%edx
  810ba1:	d3 e8                	shr    %cl,%eax
  810ba3:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  810ba8:	09 d8                	or     %ebx,%eax
  810baa:	f7 74 24 08          	divl   0x8(%esp)
  810bae:	89 d3                	mov    %edx,%ebx
  810bb0:	d3 e6                	shl    %cl,%esi
  810bb2:	f7 e5                	mul    %ebp
  810bb4:	89 c7                	mov    %eax,%edi
  810bb6:	89 d1                	mov    %edx,%ecx
  810bb8:	39 d3                	cmp    %edx,%ebx
  810bba:	72 06                	jb     810bc2 <__umoddi3+0xe2>
  810bbc:	75 0e                	jne    810bcc <__umoddi3+0xec>
  810bbe:	39 c6                	cmp    %eax,%esi
  810bc0:	73 0a                	jae    810bcc <__umoddi3+0xec>
  810bc2:	29 e8                	sub    %ebp,%eax
  810bc4:	1b 54 24 08          	sbb    0x8(%esp),%edx
  810bc8:	89 d1                	mov    %edx,%ecx
  810bca:	89 c7                	mov    %eax,%edi
  810bcc:	89 f5                	mov    %esi,%ebp
  810bce:	8b 74 24 04          	mov    0x4(%esp),%esi
  810bd2:	29 fd                	sub    %edi,%ebp
  810bd4:	19 cb                	sbb    %ecx,%ebx
  810bd6:	0f b6 4c 24 0c       	movzbl 0xc(%esp),%ecx
  810bdb:	89 d8                	mov    %ebx,%eax
  810bdd:	d3 e0                	shl    %cl,%eax
  810bdf:	89 f1                	mov    %esi,%ecx
  810be1:	d3 ed                	shr    %cl,%ebp
  810be3:	d3 eb                	shr    %cl,%ebx
  810be5:	09 e8                	or     %ebp,%eax
  810be7:	89 da                	mov    %ebx,%edx
  810be9:	83 c4 1c             	add    $0x1c,%esp
  810bec:	5b                   	pop    %ebx
  810bed:	5e                   	pop    %esi
  810bee:	5f                   	pop    %edi
  810bef:	5d                   	pop    %ebp
  810bf0:	c3                   	ret    
